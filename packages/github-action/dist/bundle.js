"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range2(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range2;
    function range2(a, b, str) {
      var begs, beg, left, right, result2;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result2) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result2 = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result2 = [left, right];
        }
      }
      return result2;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre)) return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,(?!,).*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch2;
    minimatch2.Minimatch = Minimatch2;
    var path10 = (function() {
      try {
        return require("path");
      } catch (e) {
      }
    })() || {
      sep: "/"
    };
    minimatch2.sep = path10.sep;
    var GLOBSTAR = minimatch2.GLOBSTAR = Minimatch2.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch2.filter = filter2;
    function filter2(pattern, options2) {
      options2 = options2 || {};
      return function(p, i, list) {
        return minimatch2(p, pattern, options2);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch2.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch2;
      }
      var orig = minimatch2;
      var m = function minimatch3(p, pattern, options2) {
        return orig(p, pattern, ext(def, options2));
      };
      m.Minimatch = function Minimatch3(pattern, options2) {
        return new orig.Minimatch(pattern, ext(def, options2));
      };
      m.Minimatch.defaults = function defaults(options2) {
        return orig.defaults(ext(def, options2)).Minimatch;
      };
      m.filter = function filter3(pattern, options2) {
        return orig.filter(pattern, ext(def, options2));
      };
      m.defaults = function defaults(options2) {
        return orig.defaults(ext(def, options2));
      };
      m.makeRe = function makeRe2(pattern, options2) {
        return orig.makeRe(pattern, ext(def, options2));
      };
      m.braceExpand = function braceExpand2(pattern, options2) {
        return orig.braceExpand(pattern, ext(def, options2));
      };
      m.match = function(list, pattern, options2) {
        return orig.match(list, pattern, ext(def, options2));
      };
      return m;
    };
    Minimatch2.defaults = function(def) {
      return minimatch2.defaults(def).Minimatch;
    };
    function minimatch2(p, pattern, options2) {
      assertValidPattern(pattern);
      if (!options2) options2 = {};
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch2(pattern, options2).match(p);
    }
    function Minimatch2(pattern, options2) {
      if (!(this instanceof Minimatch2)) {
        return new Minimatch2(pattern, options2);
      }
      assertValidPattern(pattern);
      if (!options2) options2 = {};
      pattern = pattern.trim();
      if (!options2.allowWindowsEscape && path10.sep !== "/") {
        pattern = pattern.split(path10.sep).join("/");
      }
      this.options = options2;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options2.partial;
      this.make();
    }
    Minimatch2.prototype.debug = function() {
    };
    Minimatch2.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options2.debug) this.debug = function debug5() {
        console.error.apply(console, arguments);
      };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch2.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate2 = false;
      var options2 = this.options;
      var negateOffset = 0;
      if (options2.nonegate) return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate2 = !negate2;
        negateOffset++;
      }
      if (negateOffset) this.pattern = pattern.substr(negateOffset);
      this.negate = negate2;
    }
    minimatch2.braceExpand = function(pattern, options2) {
      return braceExpand(pattern, options2);
    };
    Minimatch2.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options2) {
      if (!options2) {
        if (this instanceof Minimatch2) {
          options2 = this.options;
        } else {
          options2 = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch2.prototype.parse = parse2;
    var SUBPARSE = {};
    function parse2(pattern, isSub) {
      assertValidPattern(pattern);
      var options2 = this.options;
      if (pattern === "**") {
        if (!options2.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "") return "";
      var re = "";
      var hasMagic = !!options2.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          /* istanbul ignore next */
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1) c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options2.noext) clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          // these are mostly the same in regexp and glob
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_3, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options2.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch2.makeRe = function(pattern, options2) {
      return new Minimatch2(pattern, options2 || {}).makeRe();
    };
    Minimatch2.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false) return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options2 = this.options;
      var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      var flags = options2.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate) re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch2.match = function(list, pattern, options2) {
      options2 = options2 || {};
      var mm = new Minimatch2(pattern, options2);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch2.prototype.match = function match2(f, partial2) {
      if (typeof partial2 === "undefined") partial2 = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment) return false;
      if (this.empty) return f === "";
      if (f === "/" && partial2) return true;
      var options2 = this.options;
      if (path10.sep !== "/") {
        f = f.split(path10.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename) break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options2.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial2);
        if (hit) {
          if (options2.flipNegate) return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate) return false;
      return this.negate;
    };
    Minimatch2.prototype.matchOne = function(file, pattern, partial2) {
      var options2 = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false) return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".") return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial2)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial2) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl) return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit) return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial2;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// packages/core/dist/manifest-reader.js
var ManifestReader;
var init_manifest_reader = __esm({
  "packages/core/dist/manifest-reader.js"() {
    "use strict";
    ManifestReader = class {
      /**
       * Read all task manifests in the extension
       * Default implementation using findTaskPaths() and readTaskManifest()
       * Subclasses can override for optimization
       * @returns Array of task manifests with their paths
       */
      async readTaskManifests() {
        const taskPaths = await this.findTaskPaths();
        const results = [];
        for (const taskPath of taskPaths) {
          try {
            const manifest = await this.readTaskManifest(taskPath);
            results.push({ path: taskPath, manifest });
          } catch {
          }
        }
        return results;
      }
      /**
       * Get quick metadata about the extension
       * Default implementation using readExtensionManifest()
       * @returns Extension metadata
       */
      async getMetadata() {
        const manifest = await this.readExtensionManifest();
        return {
          publisher: manifest.publisher,
          extensionId: manifest.id,
          version: manifest.version,
          name: manifest.name,
          description: manifest.description
        };
      }
      /**
       * Get information about all tasks in the extension
       * Default implementation using readTaskManifests()
       * @returns Array of task information
       */
      async getTasksInfo() {
        const tasks = await this.readTaskManifests();
        return tasks.map(({ path: path10, manifest }) => ({
          name: manifest.name,
          friendlyName: manifest.friendlyName,
          version: `${manifest.version.Major}.${manifest.version.Minor}.${manifest.version.Patch}`,
          path: path10
        }));
      }
    };
  }
});

// node_modules/uuid/dist-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/uuid/dist-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist-node/validate.js"() {
    init_regex();
    validate_default = validate;
  }
});

// node_modules/uuid/dist-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// node_modules/uuid/dist-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var byteToHex;
var init_stringify = __esm({
  "node_modules/uuid/dist-node/stringify.js"() {
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
  }
});

// node_modules/uuid/dist-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
function v35(version, hash, value, namespace, buf, offset) {
  const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if (namespace?.length !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist-node/v35.js"() {
    init_parse();
    init_stringify();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/uuid/dist-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return (0, import_node_crypto.createHash)("sha1").update(bytes).digest();
}
var import_node_crypto, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist-node/sha1.js"() {
    import_node_crypto = require("node:crypto");
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist-node/v5.js
function v5(value, namespace, buf, offset) {
  return v35(80, sha1_default, value, namespace, buf, offset);
}
var v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist-node/v5.js"() {
    init_sha1();
    init_v35();
    v5.DNS = DNS;
    v5.URL = URL2;
    v5_default = v5;
  }
});

// node_modules/uuid/dist-node/index.js
var init_dist_node = __esm({
  "node_modules/uuid/dist-node/index.js"() {
    init_v5();
  }
});

// node_modules/buffer-crc32/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/buffer-crc32/dist/index.cjs"(exports2, module2) {
    "use strict";
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var CRC_TABLE = new Int32Array([
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ]);
    function ensureBuffer(input) {
      if (Buffer.isBuffer(input)) {
        return input;
      }
      if (typeof input === "number") {
        return Buffer.alloc(input);
      } else if (typeof input === "string") {
        return Buffer.from(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      const tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      let crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    var bufferCrc32 = crc32;
    var index = /* @__PURE__ */ getDefaultExportFromCjs(bufferCrc32);
    module2.exports = index;
  }
});

// node_modules/yazl/index.js
var require_yazl = __commonJS({
  "node_modules/yazl/index.js"(exports2) {
    var fs4 = require("fs");
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var zlib = require("zlib");
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var errorMonitor = require("events").errorMonitor;
    var crc32 = require_dist();
    exports2.ZipFile = ZipFile;
    exports2.dateToDosDateTime = dateToDosDateTime;
    util.inherits(ZipFile, EventEmitter);
    function ZipFile() {
      this.outputStream = new PassThrough();
      this.entries = [];
      this.outputStreamCursor = 0;
      this.ended = false;
      this.allDone = false;
      this.forceZip64Eocd = false;
      this.errored = false;
      this.on(errorMonitor, function() {
        this.errored = true;
      });
    }
    ZipFile.prototype.addFile = function(realPath, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options2 == null) options2 = {};
      if (shouldIgnoreAdding(self2)) return;
      var entry = new Entry(metadataPath, false, options2);
      self2.entries.push(entry);
      fs4.stat(realPath, function(err, stats) {
        if (err) return self2.emit("error", err);
        if (!stats.isFile()) return self2.emit("error", new Error("not a file: " + realPath));
        entry.uncompressedSize = stats.size;
        if (options2.mtime == null) entry.setLastModDate(stats.mtime);
        if (options2.mode == null) entry.setFileAttributesMode(stats.mode);
        entry.setFileDataPumpFunction(function() {
          var readStream = fs4.createReadStream(realPath);
          entry.state = Entry.FILE_DATA_IN_PROGRESS;
          readStream.on("error", function(err2) {
            self2.emit("error", err2);
          });
          pumpFileDataReadStream(self2, entry, readStream);
        });
        pumpEntries(self2);
      });
    };
    ZipFile.prototype.addReadStream = function(readStream, metadataPath, options2) {
      this.addReadStreamLazy(metadataPath, options2, function(cb2) {
        cb2(null, readStream);
      });
    };
    ZipFile.prototype.addReadStreamLazy = function(metadataPath, options2, getReadStreamFunction) {
      var self2 = this;
      if (typeof options2 === "function") {
        getReadStreamFunction = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      metadataPath = validateMetadataPath(metadataPath, false);
      if (shouldIgnoreAdding(self2)) return;
      var entry = new Entry(metadataPath, false, options2);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        getReadStreamFunction(function(err, readStream) {
          if (err) return self2.emit("error", err);
          pumpFileDataReadStream(self2, entry, readStream);
        });
      });
      pumpEntries(self2);
    };
    ZipFile.prototype.addBuffer = function(buffer, metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (buffer.length > 1073741823) throw new Error("buffer too large: " + buffer.length + " > 1073741823");
      if (options2 == null) options2 = {};
      if (options2.size != null) throw new Error("options.size not allowed");
      if (shouldIgnoreAdding(self2)) return;
      var entry = new Entry(metadataPath, false, options2);
      entry.uncompressedSize = buffer.length;
      entry.crc32 = crc32.unsigned(buffer);
      entry.crcAndFileSizeKnown = true;
      self2.entries.push(entry);
      if (entry.compressionLevel === 0) {
        setCompressedBuffer(buffer);
      } else {
        zlib.deflateRaw(buffer, { level: entry.compressionLevel }, function(err, compressedBuffer) {
          setCompressedBuffer(compressedBuffer);
        });
      }
      function setCompressedBuffer(compressedBuffer) {
        entry.compressedSize = compressedBuffer.length;
        entry.setFileDataPumpFunction(function() {
          writeToOutputStream(self2, compressedBuffer);
          writeToOutputStream(self2, entry.getDataDescriptor());
          entry.state = Entry.FILE_DATA_DONE;
          setImmediate(function() {
            pumpEntries(self2);
          });
        });
        pumpEntries(self2);
      }
    };
    ZipFile.prototype.addEmptyDirectory = function(metadataPath, options2) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, true);
      if (options2 == null) options2 = {};
      if (options2.size != null) throw new Error("options.size not allowed");
      if (options2.compress != null) throw new Error("options.compress not allowed");
      if (options2.compressionLevel != null) throw new Error("options.compressionLevel not allowed");
      if (shouldIgnoreAdding(self2)) return;
      var entry = new Entry(metadataPath, true, options2);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
      pumpEntries(self2);
    };
    var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
    ZipFile.prototype.end = function(options2, calculatedTotalSizeCallback) {
      if (typeof options2 === "function") {
        calculatedTotalSizeCallback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (this.ended) return;
      this.ended = true;
      if (this.errored) return;
      this.calculatedTotalSizeCallback = calculatedTotalSizeCallback;
      this.forceZip64Eocd = !!options2.forceZip64Format;
      if (options2.comment) {
        if (typeof options2.comment === "string") {
          this.comment = encodeCp437(options2.comment);
        } else {
          this.comment = options2.comment;
        }
        if (this.comment.length > 65535) throw new Error("comment is too large");
        if (bufferIncludes(this.comment, eocdrSignatureBuffer)) throw new Error("comment contains end of central directory record signature");
      } else {
        this.comment = EMPTY_BUFFER;
      }
      pumpEntries(this);
    };
    function writeToOutputStream(self2, buffer) {
      self2.outputStream.write(buffer);
      self2.outputStreamCursor += buffer.length;
    }
    function pumpFileDataReadStream(self2, entry, readStream) {
      var crc32Watcher = new Crc32Watcher();
      var uncompressedSizeCounter = new ByteCounter();
      var compressor = entry.compressionLevel !== 0 ? new zlib.DeflateRaw({ level: entry.compressionLevel }) : new PassThrough();
      var compressedSizeCounter = new ByteCounter();
      readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
      compressedSizeCounter.on("end", function() {
        entry.crc32 = crc32Watcher.crc32;
        if (entry.uncompressedSize == null) {
          entry.uncompressedSize = uncompressedSizeCounter.byteCount;
        } else {
          if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount) return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
        }
        entry.compressedSize = compressedSizeCounter.byteCount;
        self2.outputStreamCursor += entry.compressedSize;
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
    }
    function determineCompressionLevel(options2) {
      if (options2.compress != null && options2.compressionLevel != null) {
        if (!!options2.compress !== !!options2.compressionLevel) throw new Error("conflicting settings for compress and compressionLevel");
      }
      if (options2.compressionLevel != null) return options2.compressionLevel;
      if (options2.compress === false) return 0;
      return 6;
    }
    function pumpEntries(self2) {
      if (self2.allDone || self2.errored) return;
      if (self2.ended && self2.calculatedTotalSizeCallback != null) {
        var calculatedTotalSize = calculateTotalSize(self2);
        if (calculatedTotalSize != null) {
          self2.calculatedTotalSizeCallback(calculatedTotalSize);
          self2.calculatedTotalSizeCallback = null;
        }
      }
      var entry = getFirstNotDoneEntry();
      function getFirstNotDoneEntry() {
        for (var i = 0; i < self2.entries.length; i++) {
          var entry2 = self2.entries[i];
          if (entry2.state < Entry.FILE_DATA_DONE) return entry2;
        }
        return null;
      }
      if (entry != null) {
        if (entry.state < Entry.READY_TO_PUMP_FILE_DATA) return;
        if (entry.state === Entry.FILE_DATA_IN_PROGRESS) return;
        entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
        var localFileHeader = entry.getLocalFileHeader();
        writeToOutputStream(self2, localFileHeader);
        entry.doFileDataPump();
      } else {
        if (self2.ended) {
          self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
          self2.entries.forEach(function(entry2) {
            var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
            writeToOutputStream(self2, centralDirectoryRecord);
          });
          writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
          self2.outputStream.end();
          self2.allDone = true;
        }
      }
    }
    function calculateTotalSize(self2) {
      var pretendOutputCursor = 0;
      var centralDirectorySize = 0;
      for (var i = 0; i < self2.entries.length; i++) {
        var entry = self2.entries[i];
        if (entry.compressionLevel !== 0) return -1;
        if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
          if (entry.uncompressedSize == null) return -1;
        } else {
          if (entry.uncompressedSize == null) return null;
        }
        entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
        var useZip64Format = entry.useZip64Format();
        pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
        pretendOutputCursor += entry.uncompressedSize;
        if (!entry.crcAndFileSizeKnown) {
          if (useZip64Format) {
            pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
          } else {
            pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
          }
        }
        centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
        if (!entry.forceDosTimestamp) {
          centralDirectorySize += INFO_ZIP_UNIVERSAL_TIMESTAMP_EXTRA_FIELD_SIZE;
        }
        if (useZip64Format) {
          centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
        }
      }
      var endOfCentralDirectorySize = 0;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
        endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
      }
      endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
      return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
    }
    function shouldIgnoreAdding(self2) {
      if (self2.ended) throw new Error("cannot add entries after calling end()");
      if (self2.errored) return true;
      return false;
    }
    var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
    var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
    var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
    function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
      var needZip64Format = false;
      var normalEntriesLength = self2.entries.length;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
        normalEntriesLength = 65535;
        needZip64Format = true;
      }
      var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
      var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
      if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
        normalSizeOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
      if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
        normalOffsetOfStartOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      if (actuallyJustTellMeHowLongItWouldBe) {
        if (needZip64Format) {
          return ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE + END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        } else {
          return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        }
      }
      var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
      eocdrBuffer.writeUInt32LE(101010256, 0);
      eocdrBuffer.writeUInt16LE(0, 4);
      eocdrBuffer.writeUInt16LE(0, 6);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
      eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
      eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
      eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
      self2.comment.copy(eocdrBuffer, 22);
      if (!needZip64Format) return eocdrBuffer;
      var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
      zip64EocdrBuffer.writeUInt32LE(101075792, 0);
      writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
      zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
      zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
      zip64EocdrBuffer.writeUInt32LE(0, 16);
      zip64EocdrBuffer.writeUInt32LE(0, 20);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
      writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
      writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
      var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
      zip64EocdlBuffer.writeUInt32LE(117853008, 0);
      zip64EocdlBuffer.writeUInt32LE(0, 4);
      writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
      zip64EocdlBuffer.writeUInt32LE(1, 16);
      return Buffer.concat([
        zip64EocdrBuffer,
        zip64EocdlBuffer,
        eocdrBuffer
      ]);
    }
    function validateMetadataPath(metadataPath, isDirectory) {
      if (metadataPath === "") throw new Error("empty metadataPath");
      metadataPath = metadataPath.replace(/\\/g, "/");
      if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath)) throw new Error("absolute path: " + metadataPath);
      if (metadataPath.split("/").indexOf("..") !== -1) throw new Error("invalid relative path: " + metadataPath);
      var looksLikeDirectory = /\/$/.test(metadataPath);
      if (isDirectory) {
        if (!looksLikeDirectory) metadataPath += "/";
      } else {
        if (looksLikeDirectory) throw new Error("file path cannot end with '/': " + metadataPath);
      }
      return metadataPath;
    }
    var EMPTY_BUFFER = bufferAlloc(0);
    function Entry(metadataPath, isDirectory, options2) {
      this.utf8FileName = bufferFrom(metadataPath);
      if (this.utf8FileName.length > 65535) throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
      this.isDirectory = isDirectory;
      this.state = Entry.WAITING_FOR_METADATA;
      this.setLastModDate(options2.mtime != null ? options2.mtime : /* @__PURE__ */ new Date());
      this.forceDosTimestamp = !!options2.forceDosTimestamp;
      if (options2.mode != null) {
        this.setFileAttributesMode(options2.mode);
      } else {
        this.setFileAttributesMode(isDirectory ? 16893 : 33204);
      }
      if (isDirectory) {
        this.crcAndFileSizeKnown = true;
        this.crc32 = 0;
        this.uncompressedSize = 0;
        this.compressedSize = 0;
      } else {
        this.crcAndFileSizeKnown = false;
        this.crc32 = null;
        this.uncompressedSize = null;
        this.compressedSize = null;
        if (options2.size != null) this.uncompressedSize = options2.size;
      }
      if (isDirectory) {
        this.compressionLevel = 0;
      } else {
        this.compressionLevel = determineCompressionLevel(options2);
      }
      this.forceZip64Format = !!options2.forceZip64Format;
      if (options2.fileComment) {
        if (typeof options2.fileComment === "string") {
          this.fileComment = bufferFrom(options2.fileComment, "utf-8");
        } else {
          this.fileComment = options2.fileComment;
        }
        if (this.fileComment.length > 65535) throw new Error("fileComment is too large");
      } else {
        this.fileComment = EMPTY_BUFFER;
      }
    }
    Entry.WAITING_FOR_METADATA = 0;
    Entry.READY_TO_PUMP_FILE_DATA = 1;
    Entry.FILE_DATA_IN_PROGRESS = 2;
    Entry.FILE_DATA_DONE = 3;
    Entry.prototype.setLastModDate = function(date) {
      this.mtime = date;
      var dosDateTime = dateToDosDateTime(date);
      this.lastModFileTime = dosDateTime.time;
      this.lastModFileDate = dosDateTime.date;
    };
    Entry.prototype.setFileAttributesMode = function(mode) {
      if ((mode & 65535) !== mode) throw new Error("invalid mode. expected: 0 <= " + mode + " <= 65535");
      this.externalFileAttributes = mode << 16 >>> 0;
    };
    Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
      this.doFileDataPump = doFileDataPump;
      this.state = Entry.READY_TO_PUMP_FILE_DATA;
    };
    Entry.prototype.useZip64Format = function() {
      return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
    };
    var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
    var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
    var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
    var VERSION_MADE_BY = 3 << 8 | 63;
    var FILE_NAME_IS_UTF8 = 1 << 11;
    var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
    Entry.prototype.getLocalFileHeader = function() {
      var crc322 = 0;
      var compressedSize = 0;
      var uncompressedSize = 0;
      if (this.crcAndFileSizeKnown) {
        crc322 = this.crc32;
        compressedSize = this.compressedSize;
        uncompressedSize = this.uncompressedSize;
      }
      var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      fixedSizeStuff.writeUInt32LE(67324752, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
      fixedSizeStuff.writeUInt32LE(crc322, 14);
      fixedSizeStuff.writeUInt32LE(compressedSize, 18);
      fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
      fixedSizeStuff.writeUInt16LE(0, 28);
      return Buffer.concat([
        fixedSizeStuff,
        // file name (variable size)
        this.utf8FileName
        // extra field (variable size)
        // no extra fields
      ]);
    };
    var DATA_DESCRIPTOR_SIZE = 16;
    var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
    Entry.prototype.getDataDescriptor = function() {
      if (this.crcAndFileSizeKnown) {
        return EMPTY_BUFFER;
      }
      if (!this.useZip64Format()) {
        var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        buffer.writeUInt32LE(this.compressedSize, 8);
        buffer.writeUInt32LE(this.uncompressedSize, 12);
        return buffer;
      } else {
        var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        writeUInt64LE(buffer, this.compressedSize, 8);
        writeUInt64LE(buffer, this.uncompressedSize, 16);
        return buffer;
      }
    };
    var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
    var INFO_ZIP_UNIVERSAL_TIMESTAMP_EXTRA_FIELD_SIZE = 9;
    var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
    Entry.prototype.getCentralDirectoryRecord = function() {
      var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown) generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      var izutefBuffer = EMPTY_BUFFER;
      if (!this.forceDosTimestamp) {
        izutefBuffer = bufferAlloc(INFO_ZIP_UNIVERSAL_TIMESTAMP_EXTRA_FIELD_SIZE);
        izutefBuffer.writeUInt16LE(21589, 0);
        izutefBuffer.writeUInt16LE(INFO_ZIP_UNIVERSAL_TIMESTAMP_EXTRA_FIELD_SIZE - 4, 2);
        var EB_UT_FL_MTIME = 1 << 0;
        var EB_UT_FL_ATIME = 1 << 1;
        izutefBuffer.writeUInt8(EB_UT_FL_MTIME | EB_UT_FL_ATIME, 4);
        var timestamp = Math.floor(this.mtime.getTime() / 1e3);
        if (timestamp < -2147483648) timestamp = -2147483648;
        if (timestamp > 2147483647) timestamp = 2147483647;
        izutefBuffer.writeUInt32LE(timestamp, 5);
      }
      var normalCompressedSize = this.compressedSize;
      var normalUncompressedSize = this.uncompressedSize;
      var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
      var versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
      var zeiefBuffer = EMPTY_BUFFER;
      if (this.useZip64Format()) {
        normalCompressedSize = 4294967295;
        normalUncompressedSize = 4294967295;
        normalRelativeOffsetOfLocalHeader = 4294967295;
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
        zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
        zeiefBuffer.writeUInt16LE(1, 0);
        zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
        writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
        writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
        writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
      }
      fixedSizeStuff.writeUInt32LE(33639248, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
      fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
      fixedSizeStuff.writeUInt32LE(this.crc32, 16);
      fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
      fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
      fixedSizeStuff.writeUInt16LE(izutefBuffer.length + zeiefBuffer.length, 30);
      fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
      fixedSizeStuff.writeUInt16LE(0, 34);
      fixedSizeStuff.writeUInt16LE(0, 36);
      fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
      fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
      return Buffer.concat([
        fixedSizeStuff,
        // file name (variable size)
        this.utf8FileName,
        // extra field (variable size)
        izutefBuffer,
        zeiefBuffer,
        // file comment (variable size)
        this.fileComment
      ]);
    };
    Entry.prototype.getCompressionMethod = function() {
      var NO_COMPRESSION = 0;
      var DEFLATE_COMPRESSION = 8;
      return this.compressionLevel === 0 ? NO_COMPRESSION : DEFLATE_COMPRESSION;
    };
    var minDosDate = new Date(1980, 0, 1);
    var maxDosDate = new Date(2107, 11, 31, 23, 59, 58);
    function dateToDosDateTime(jsDate) {
      if (jsDate < minDosDate) jsDate = minDosDate;
      else if (jsDate > maxDosDate) jsDate = maxDosDate;
      var date = 0;
      date |= jsDate.getDate() & 31;
      date |= (jsDate.getMonth() + 1 & 15) << 5;
      date |= (jsDate.getFullYear() - 1980 & 127) << 9;
      var time = 0;
      time |= Math.floor(jsDate.getSeconds() / 2);
      time |= (jsDate.getMinutes() & 63) << 5;
      time |= (jsDate.getHours() & 31) << 11;
      return { date, time };
    }
    function writeUInt64LE(buffer, n, offset) {
      var high = Math.floor(n / 4294967296);
      var low = n % 4294967296;
      buffer.writeUInt32LE(low, offset);
      buffer.writeUInt32LE(high, offset + 4);
    }
    util.inherits(ByteCounter, Transform);
    function ByteCounter(options2) {
      Transform.call(this, options2);
      this.byteCount = 0;
    }
    ByteCounter.prototype._transform = function(chunk2, encoding, cb2) {
      this.byteCount += chunk2.length;
      cb2(null, chunk2);
    };
    util.inherits(Crc32Watcher, Transform);
    function Crc32Watcher(options2) {
      Transform.call(this, options2);
      this.crc32 = 0;
    }
    Crc32Watcher.prototype._transform = function(chunk2, encoding, cb2) {
      this.crc32 = crc32.unsigned(chunk2, this.crc32);
      cb2(null, chunk2);
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    if (cp437.length !== 256) throw new Error("assertion failure");
    var reverseCp437 = null;
    function encodeCp437(string) {
      if (/^[\x20-\x7e]*$/.test(string)) {
        return bufferFrom(string, "utf-8");
      }
      if (reverseCp437 == null) {
        reverseCp437 = {};
        for (var i = 0; i < cp437.length; i++) {
          reverseCp437[cp437[i]] = i;
        }
      }
      var result2 = bufferAlloc(string.length);
      for (var i = 0; i < string.length; i++) {
        var b = reverseCp437[string[i]];
        if (b == null) throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
        result2[i] = b;
      }
      return result2;
    }
    function bufferAlloc(size2) {
      bufferAlloc = modern;
      try {
        return bufferAlloc(size2);
      } catch (e) {
        bufferAlloc = legacy;
        return bufferAlloc(size2);
      }
      function modern(size3) {
        return Buffer.allocUnsafe(size3);
      }
      function legacy(size3) {
        return new Buffer(size3);
      }
    }
    function bufferFrom(something, encoding) {
      bufferFrom = modern;
      try {
        return bufferFrom(something, encoding);
      } catch (e) {
        bufferFrom = legacy;
        return bufferFrom(something, encoding);
      }
      function modern(something2, encoding2) {
        return Buffer.from(something2, encoding2);
      }
      function legacy(something2, encoding2) {
        return new Buffer(something2, encoding2);
      }
    }
    function bufferIncludes(buffer, content) {
      bufferIncludes = modern;
      try {
        return bufferIncludes(buffer, content);
      } catch (e) {
        bufferIncludes = legacy;
        return bufferIncludes(buffer, content);
      }
      function modern(buffer2, content2) {
        return buffer2.includes(content2);
      }
      function legacy(buffer2, content2) {
        for (var i = 0; i <= buffer2.length - content2.length; i++) {
          for (var j = 0; ; j++) {
            if (j === content2.length) return true;
            if (buffer2[i + j] !== content2[j]) break;
          }
        }
        return false;
      }
    }
  }
});

// packages/core/dist/vsix-writer.js
var vsix_writer_exports = {};
__export(vsix_writer_exports, {
  VsixWriter: () => VsixWriter
});
function validateZipPath(filePath) {
  const normalizedPath = filePath.replace(/\\/g, "/");
  if (normalizedPath.startsWith("/") || /^[A-Z]:/i.test(normalizedPath)) {
    throw new Error(`Security: Absolute paths are not allowed: ${filePath}`);
  }
  if (normalizedPath.includes("../") || normalizedPath.startsWith("..")) {
    throw new Error(`Security: Path traversal detected: ${filePath}`);
  }
  if (normalizedPath.includes("\0")) {
    throw new Error(`Security: Null byte detected in path: ${filePath}`);
  }
}
var import_yazl, import_buffer, import_fs, VsixWriter;
var init_vsix_writer = __esm({
  "packages/core/dist/vsix-writer.js"() {
    "use strict";
    import_yazl = __toESM(require_yazl(), 1);
    import_buffer = require("buffer");
    import_fs = require("fs");
    VsixWriter = class _VsixWriter {
      editor;
      zipFile = null;
      constructor(editor) {
        this.editor = editor;
      }
      /**
       * Create a writer from an editor
       * @param editor The ManifestEditor with modifications
       * @returns VsixWriter instance
       */
      static fromEditor(editor) {
        return new _VsixWriter(editor);
      }
      /**
       * Write the modified VSIX to a file
       *
       * This method efficiently copies unchanged entries from the source VSIX
       * without recompression, significantly improving performance for large files.
       *
       * @param outputPath Path where the new VSIX should be written
       * @returns Promise that resolves when writing is complete
       */
      async writeToFile(outputPath) {
        const reader = this.editor.getReader();
        const modifications = this.editor.getModifications();
        const manifestMods = this.editor.getManifestModifications();
        const taskManifestMods = this.editor.getTaskManifestModifications();
        this.zipFile = new import_yazl.default.ZipFile();
        const addedFiles = /* @__PURE__ */ new Set();
        const manifestPath = await this.determineManifestPath(reader);
        if (Object.keys(manifestMods).length > 0 || taskManifestMods.size > 0) {
          await this.applyManifestModifications(reader, manifestPath, manifestMods, taskManifestMods, addedFiles);
        }
        for (const [path10, mod] of modifications) {
          validateZipPath(path10);
          if (mod.type === "remove") {
            addedFiles.add(path10);
          } else if (mod.type === "modify" && mod.content) {
            this.zipFile.addBuffer(mod.content, path10);
            addedFiles.add(path10);
          }
        }
        await this.copyUnchangedFiles(reader, addedFiles);
        await this.finalizeZip(outputPath);
      }
      /**
       * Write the modified VSIX to a buffer in memory
       * @returns Promise<Buffer> containing the complete VSIX
       */
      async writeToBuffer() {
        const reader = this.editor.getReader();
        const modifications = this.editor.getModifications();
        const manifestMods = this.editor.getManifestModifications();
        const taskManifestMods = this.editor.getTaskManifestModifications();
        this.zipFile = new import_yazl.default.ZipFile();
        const addedFiles = /* @__PURE__ */ new Set();
        const manifestPath = await this.determineManifestPath(reader);
        if (Object.keys(manifestMods).length > 0 || taskManifestMods.size > 0) {
          await this.applyManifestModifications(reader, manifestPath, manifestMods, taskManifestMods, addedFiles);
        }
        for (const [path10, mod] of modifications) {
          validateZipPath(path10);
          if (mod.type === "remove") {
            addedFiles.add(path10);
          } else if (mod.type === "modify" && mod.content) {
            this.zipFile.addBuffer(mod.content, path10);
            addedFiles.add(path10);
          }
        }
        await this.copyUnchangedFiles(reader, addedFiles);
        return this.finalizeZipToBuffer();
      }
      /**
       * Determine which manifest file to use
       */
      async determineManifestPath(reader) {
        if (await reader.fileExists("extension.vsomanifest")) {
          return "extension.vsomanifest";
        }
        if (await reader.fileExists("vss-extension.json")) {
          return "vss-extension.json";
        }
        throw new Error("No extension manifest found in source VSIX");
      }
      /**
       * Apply modifications to manifests
       */
      async applyManifestModifications(reader, manifestPath, manifestMods, taskManifestMods, addedFiles) {
        const manifest = await reader.readExtensionManifest();
        Object.assign(manifest, manifestMods);
        const manifestJson = JSON.stringify(manifest, null, 2);
        this.zipFile.addBuffer(import_buffer.Buffer.from(manifestJson, "utf-8"), manifestPath);
        addedFiles.add(manifestPath);
        if (taskManifestMods.size > 0) {
          const taskManifests = await reader.readTaskManifests();
          for (const taskManifest of taskManifests) {
            const mods = taskManifestMods.get(taskManifest.manifest.name);
            if (mods) {
              Object.assign(taskManifest.manifest, mods);
              const taskJson = JSON.stringify(taskManifest.manifest, null, 2);
              const taskPath = `${taskManifest.path}/task.json`;
              this.zipFile.addBuffer(import_buffer.Buffer.from(taskJson, "utf-8"), taskPath);
              addedFiles.add(taskPath);
            }
          }
        }
      }
      /**
       * Copy unchanged files from source VSIX
       *
       * This is the key optimization: files are copied directly from the source
       * ZIP without decompression/recompression, preserving original compression.
       */
      async copyUnchangedFiles(reader, addedFiles) {
        const allFiles = await reader.listFiles();
        for (const file of allFiles) {
          if (!addedFiles.has(file.path)) {
            try {
              const content = await reader.readFile(file.path);
              this.zipFile.addBuffer(content, file.path);
            } catch (err) {
              console.warn(`Warning: Could not copy file ${file.path}: ${err.message}`);
            }
          }
        }
      }
      /**
       * Finalize ZIP and write to file
       */
      async finalizeZip(outputPath) {
        if (!this.zipFile) {
          throw new Error("ZIP file not initialized");
        }
        return new Promise((resolve, reject2) => {
          const outputStream = (0, import_fs.createWriteStream)(outputPath);
          outputStream.on("error", (err) => {
            reject2(new Error(`Failed to write VSIX file: ${err.message}`));
          });
          outputStream.on("finish", () => {
            resolve();
          });
          this.zipFile.outputStream.pipe(outputStream).on("error", (err) => {
            reject2(new Error(`Failed to write VSIX stream: ${err.message}`));
          });
          this.zipFile.end();
        });
      }
      /**
       * Finalize ZIP to buffer
       */
      async finalizeZipToBuffer() {
        if (!this.zipFile) {
          throw new Error("ZIP file not initialized");
        }
        return new Promise((resolve, reject2) => {
          const chunks = [];
          this.zipFile.outputStream.on("data", (chunk2) => {
            chunks.push(chunk2);
          });
          this.zipFile.outputStream.on("end", () => {
            resolve(import_buffer.Buffer.concat(chunks));
          });
          this.zipFile.outputStream.on("error", (err) => {
            reject2(new Error(`Failed to create VSIX buffer: ${err.message}`));
          });
          this.zipFile.end();
        });
      }
      /**
       * Close and cleanup resources
       */
      async close() {
        this.zipFile = null;
      }
    };
  }
});

// packages/core/dist/filesystem-manifest-writer.js
var filesystem_manifest_writer_exports = {};
__export(filesystem_manifest_writer_exports, {
  FilesystemManifestWriter: () => FilesystemManifestWriter
});
var import_promises2, import_path3, FilesystemManifestWriter;
var init_filesystem_manifest_writer = __esm({
  "packages/core/dist/filesystem-manifest-writer.js"() {
    "use strict";
    import_promises2 = require("fs/promises");
    import_path3 = __toESM(require("path"), 1);
    FilesystemManifestWriter = class _FilesystemManifestWriter {
      editor;
      platform;
      overridesPath = null;
      constructor(editor, platform) {
        this.editor = editor;
        this.platform = platform;
      }
      /**
       * Create a writer from an editor
       * @param editor The editor with modifications
       * @returns FilesystemManifestWriter instance
       */
      static fromEditor(editor) {
        const reader = editor.getReader();
        if (reader.constructor.name !== "FilesystemManifestReader") {
          throw new Error("FilesystemManifestWriter can only be used with FilesystemManifestReader");
        }
        const fsReader = reader;
        const platform = fsReader.platform;
        return new _FilesystemManifestWriter(editor, platform);
      }
      /**
       * Write modified manifests to the filesystem
       *
       * This updates task.json files directly and writes extension manifest changes.
       * It also generates an overrides.json in the temp directory that can be passed
       * to tfx with --overrides-file.
       *
       * @returns Promise that resolves when writing is complete
       */
      async writeToFilesystem() {
        const reader = this.editor.getReader();
        const rootFolder = reader.getRootFolder();
        const manifestMods = this.editor.getManifestModifications();
        const taskManifestMods = this.editor.getTaskManifestModifications();
        const fileMods = this.editor.getModifications();
        this.platform.debug("Writing manifests to filesystem...");
        if (taskManifestMods.size > 0) {
          await this.writeTaskManifests(reader, rootFolder, taskManifestMods);
        }
        if (Object.keys(manifestMods).length > 0) {
          await this.writeExtensionManifest(reader, manifestMods);
        }
        for (const [filePath, mod] of fileMods) {
          if (mod.type === "modify" && mod.content) {
            const absolutePath = import_path3.default.isAbsolute(filePath) ? filePath : import_path3.default.join(rootFolder, filePath);
            this.platform.debug(`Writing file: ${absolutePath}`);
            await (0, import_promises2.writeFile)(absolutePath, mod.content);
          }
        }
        await this.generateOverridesFile(manifestMods);
        this.platform.info("Manifests written to filesystem successfully");
      }
      /**
       * Write task manifest modifications to filesystem
       */
      async writeTaskManifests(reader, rootFolder, taskManifestMods) {
        const tasks = await reader.readTaskManifests();
        const appliedTaskNames = /* @__PURE__ */ new Set();
        const packagePathMap = await reader.buildPackagePathMap();
        for (const { path: taskPath, manifest } of tasks) {
          const mods = taskManifestMods.get(manifest.name);
          if (mods) {
            appliedTaskNames.add(manifest.name);
            Object.assign(manifest, mods);
            let actualPath = taskPath;
            const normalizedTaskPath = taskPath.replace(/\\/g, "/");
            for (const [pkgPath, sourcePath] of packagePathMap.entries()) {
              const normalizedPkgPath = pkgPath.replace(/\\/g, "/");
              if (normalizedTaskPath === normalizedPkgPath) {
                actualPath = sourcePath;
                break;
              } else if (normalizedTaskPath.startsWith(normalizedPkgPath + "/")) {
                const remainder = normalizedTaskPath.substring(normalizedPkgPath.length + 1);
                actualPath = import_path3.default.join(sourcePath, remainder);
                break;
              }
            }
            this.platform.debug(`Writing task manifest: taskPath='${taskPath}', actualPath='${actualPath}'`);
            const absoluteTaskPath = import_path3.default.isAbsolute(actualPath) ? actualPath : import_path3.default.join(rootFolder, actualPath);
            const taskJsonPath = import_path3.default.join(absoluteTaskPath, "task.json");
            this.platform.debug(`Writing to file: ${taskJsonPath}`);
            const manifestJson = JSON.stringify(manifest, null, 2) + "\n";
            await (0, import_promises2.writeFile)(taskJsonPath, manifestJson, "utf-8");
          }
        }
        for (const [taskName, mods] of taskManifestMods.entries()) {
          if (appliedTaskNames.has(taskName)) {
            continue;
          }
          const fallbackTaskDir = await this.findTaskDirectoryByName(rootFolder, taskName);
          if (!fallbackTaskDir) {
            this.platform.debug(`No task.json found for task '${taskName}' during fallback write`);
            continue;
          }
          const taskJsonPath = import_path3.default.join(fallbackTaskDir, "task.json");
          const content = await (0, import_promises2.readFile)(taskJsonPath, "utf-8");
          const manifest = JSON.parse(content);
          Object.assign(manifest, mods);
          this.platform.debug(`Fallback writing task manifest: ${taskJsonPath}`);
          await (0, import_promises2.writeFile)(taskJsonPath, JSON.stringify(manifest, null, 2) + "\n", "utf-8");
        }
      }
      /**
       * Recursively find a task directory by task manifest name
       */
      async findTaskDirectoryByName(rootFolder, taskName) {
        const stack = [rootFolder];
        while (stack.length > 0) {
          const current = stack.pop();
          let entries;
          try {
            entries = await (0, import_promises2.readdir)(current, { withFileTypes: true });
          } catch {
            continue;
          }
          for (const entry of entries) {
            const absolutePath = import_path3.default.join(current, entry.name);
            if (entry.isDirectory()) {
              stack.push(absolutePath);
              continue;
            }
            if (!entry.isFile() || entry.name !== "task.json") {
              continue;
            }
            try {
              const content = await (0, import_promises2.readFile)(absolutePath, "utf-8");
              const manifest = JSON.parse(content);
              if (manifest.name === taskName) {
                return import_path3.default.dirname(absolutePath);
              }
            } catch {
            }
          }
        }
        return null;
      }
      /**
       * Write extension manifest modifications to filesystem
       */
      async writeExtensionManifest(reader, manifestMods) {
        const manifest = await reader.readExtensionManifest();
        Object.assign(manifest, manifestMods);
        const manifestPath = reader.getManifestPath();
        if (!manifestPath) {
          throw new Error("Extension manifest path not resolved");
        }
        this.platform.debug(`Writing extension manifest: ${manifestPath}`);
        const manifestJson = JSON.stringify(manifest, null, 2) + "\n";
        await (0, import_promises2.writeFile)(manifestPath, manifestJson, "utf-8");
      }
      /**
       * Generate overrides.json file in temp directory
       *
       * This file can be passed to tfx with --overrides-file to override
       * extension manifest values during packaging without modifying source files.
       */
      async generateOverridesFile(manifestMods) {
        if (Object.keys(manifestMods).length === 0) {
          this.platform.debug("No manifest modifications, skipping overrides.json generation");
          return;
        }
        const overrides = {};
        if (manifestMods.publisher) {
          overrides.publisher = manifestMods.publisher;
        }
        if (manifestMods.id) {
          overrides.id = manifestMods.id;
        }
        if (manifestMods.version) {
          overrides.version = manifestMods.version;
        }
        if (manifestMods.name) {
          overrides.name = manifestMods.name;
        }
        if (manifestMods.description) {
          overrides.description = manifestMods.description;
        }
        if (manifestMods.galleryFlags) {
          overrides.galleryFlags = manifestMods.galleryFlags;
        }
        const tempDir = this.platform.getTempDir();
        await (0, import_promises2.mkdir)(tempDir, { recursive: true });
        this.overridesPath = import_path3.default.join(tempDir, `overrides-${Date.now()}.json`);
        this.platform.debug(`Writing overrides file: ${this.overridesPath}`);
        const overridesJson = JSON.stringify(overrides, null, 2) + "\n";
        await (0, import_promises2.writeFile)(this.overridesPath, overridesJson, "utf-8");
        this.platform.info(`Generated overrides file: ${this.overridesPath}`);
      }
      /**
       * Get the path to the generated overrides.json file
       * This can be passed to tfx with --overrides-file
       * @returns Path to overrides.json or null if not generated
       */
      getOverridesPath() {
        return this.overridesPath;
      }
      /**
       * Close and cleanup resources
       */
      async close() {
      }
    };
  }
});

// packages/core/dist/manifest-editor.js
var manifest_editor_exports = {};
__export(manifest_editor_exports, {
  ManifestEditor: () => ManifestEditor
});
var import_buffer2, ManifestEditor;
var init_manifest_editor = __esm({
  "packages/core/dist/manifest-editor.js"() {
    "use strict";
    init_dist_node();
    import_buffer2 = require("buffer");
    ManifestEditor = class _ManifestEditor {
      reader;
      modifications = /* @__PURE__ */ new Map();
      manifestModifications = {};
      taskManifestModifications = /* @__PURE__ */ new Map();
      // Track original task IDs for updating extension manifest references
      taskIdUpdates = /* @__PURE__ */ new Map();
      constructor(options2) {
        this.reader = options2.reader;
      }
      /**
       * Create an editor from a reader
       * @param reader The manifest reader (VSIX or filesystem)
       * @returns ManifestEditor instance
       */
      static fromReader(reader) {
        return new _ManifestEditor({ reader });
      }
      /**
       * Apply a set of options to the manifest
       * This is the main entry point for batch modifications
       * All conditional logic for applying changes is contained here
       *
       * @param options Options to apply
       * @returns Promise<this> for async chaining
       */
      async applyOptions(options2) {
        if (options2.publisherId) {
          this.setPublisher(options2.publisherId);
        }
        if (options2.extensionId) {
          this.setExtensionId(options2.extensionId);
        }
        if (options2.extensionVersion) {
          this.setVersion(options2.extensionVersion);
        }
        if (options2.extensionName) {
          this.setName(options2.extensionName);
        }
        if (options2.extensionVisibility) {
          this.setVisibility(options2.extensionVisibility);
        }
        if (options2.extensionPricing) {
          this.setPricing(options2.extensionPricing);
        }
        if (options2.updateTasksVersion && options2.extensionVersion) {
          const versionType = options2.updateTasksVersionType || "major";
          await this.updateAllTaskVersions(options2.extensionVersion, versionType);
        }
        if (options2.updateTasksId) {
          await this.updateAllTaskIds();
        }
        return this;
      }
      /**
       * Set the publisher ID
       * @param publisher New publisher ID
       * @returns This editor for chaining
       */
      setPublisher(publisher) {
        this.manifestModifications.publisher = publisher;
        return this;
      }
      /**
       * Set the extension ID
       * @param id New extension ID
       * @returns This editor for chaining
       */
      setExtensionId(id) {
        this.manifestModifications.id = id;
        return this;
      }
      /**
       * Set the extension version
       * @param version New version (e.g., "1.2.3")
       * @returns This editor for chaining
       */
      setVersion(version) {
        this.manifestModifications.version = version;
        return this;
      }
      /**
       * Set the extension name
       * @param name New display name
       * @returns This editor for chaining
       */
      setName(name) {
        this.manifestModifications.name = name;
        return this;
      }
      /**
       * Set the extension description
       * @param description New description
       * @returns This editor for chaining
       */
      setDescription(description) {
        this.manifestModifications.description = description;
        return this;
      }
      /**
       * Set extension visibility in gallery
       * @param visibility 'public', 'private', 'public_preview', or 'private_preview'
       * @returns This editor for chaining
       */
      setVisibility(visibility) {
        if (!this.manifestModifications.galleryFlags) {
          this.manifestModifications.galleryFlags = [];
        }
        const flags = this.manifestModifications.galleryFlags;
        const visibilityFlags = ["Public", "Private", "Preview"];
        for (const flag of visibilityFlags) {
          const index = flags.indexOf(flag);
          if (index >= 0) {
            flags.splice(index, 1);
          }
        }
        if (visibility === "public") {
          flags.push("Public");
        } else if (visibility === "private") {
          flags.push("Private");
        } else if (visibility === "public_preview") {
          flags.push("Public", "Preview");
        } else if (visibility === "private_preview") {
          flags.push("Private", "Preview");
        }
        return this;
      }
      /**
       * Set extension pricing model
       * @param pricing 'free', 'paid', or 'trial'
       * @returns This editor for chaining
       */
      setPricing(pricing) {
        if (!this.manifestModifications.galleryFlags) {
          this.manifestModifications.galleryFlags = [];
        }
        const flags = this.manifestModifications.galleryFlags;
        const pricingFlags = ["Free", "Paid", "Trial"];
        for (const flag of pricingFlags) {
          const index = flags.indexOf(flag);
          if (index >= 0) {
            flags.splice(index, 1);
          }
        }
        const flagMap = { free: "Free", paid: "Paid", trial: "Trial" };
        flags.push(flagMap[pricing]);
        return this;
      }
      /**
       * Update a specific task's version
       * @param taskName Name of the task
       * @param extensionVersion Extension version to apply (e.g., "1.2.3")
       * @param versionType How to apply the version: 'major', 'minor', or 'patch'
       * @returns This editor for chaining
       */
      updateTaskVersion(taskName, extensionVersion, versionType = "major") {
        const versionParts = extensionVersion.split(".");
        if (versionParts.length > 3) {
        }
        const newVersion = {
          major: parseInt(versionParts[0], 10) || 0,
          minor: parseInt(versionParts[1], 10) || 0,
          patch: parseInt(versionParts[2], 10) || 0
        };
        if (!this.taskManifestModifications.has(taskName)) {
          this.taskManifestModifications.set(taskName, {});
        }
        const taskMods = this.taskManifestModifications.get(taskName);
        const existingVersion = taskMods.version || { Major: 0, Minor: 0, Patch: 0 };
        switch (versionType) {
          case "major":
            taskMods.version = {
              Major: newVersion.major,
              Minor: newVersion.minor,
              Patch: newVersion.patch
            };
            break;
          case "minor":
            taskMods.version = {
              Major: existingVersion.Major,
              Minor: newVersion.minor,
              Patch: newVersion.patch
            };
            break;
          case "patch":
            taskMods.version = {
              Major: existingVersion.Major,
              Minor: existingVersion.Minor,
              Patch: newVersion.patch
            };
            break;
        }
        return this;
      }
      /**
       * Update a specific task's ID (UUID) using v5 namespacing
       * @param taskName Name of the task
       * @param publisherId Publisher ID (for UUID generation)
       * @param extensionId Extension ID (for UUID generation)
       * @returns This editor for chaining
       */
      updateTaskId(taskName, publisherId, extensionId) {
        const marketplaceNamespace = v5_default("https://marketplace.visualstudio.com/vsts", v5_default.URL);
        const taskNamespace = `${publisherId}.${extensionId}.${taskName}`;
        const newId = v5_default(taskNamespace, marketplaceNamespace);
        if (!this.taskManifestModifications.has(taskName)) {
          this.taskManifestModifications.set(taskName, {});
        }
        const taskMods = this.taskManifestModifications.get(taskName);
        taskMods.id = newId;
        return this;
      }
      /**
       * Update all tasks' versions in the extension
       * Reads all tasks from the reader and updates their versions
       * @param extensionVersion Extension version to apply
       * @param versionType How to apply the version: 'major', 'minor', or 'patch'
       * @returns Promise<this> for async chaining
       */
      async updateAllTaskVersions(extensionVersion, versionType = "major") {
        const tasks = await this.reader.getTasksInfo();
        const versionParts = extensionVersion.split(".");
        const parsedVersion = {
          major: parseInt(versionParts[0], 10) || 0,
          minor: parseInt(versionParts[1], 10) || 0,
          patch: parseInt(versionParts[2], 10) || 0
        };
        for (const task of tasks) {
          const existingParts = (task.version || "0.0.0").split(".");
          const existingVersion = {
            Major: parseInt(existingParts[0], 10) || 0,
            Minor: parseInt(existingParts[1], 10) || 0,
            Patch: parseInt(existingParts[2], 10) || 0
          };
          if (!this.taskManifestModifications.has(task.name)) {
            this.taskManifestModifications.set(task.name, {});
          }
          const taskMods = this.taskManifestModifications.get(task.name);
          switch (versionType) {
            case "major":
              taskMods.version = {
                Major: parsedVersion.major,
                Minor: parsedVersion.minor,
                Patch: parsedVersion.patch
              };
              break;
            case "minor":
              taskMods.version = {
                Major: existingVersion.Major,
                Minor: parsedVersion.minor,
                Patch: parsedVersion.patch
              };
              break;
            case "patch":
              taskMods.version = {
                Major: existingVersion.Major,
                Minor: existingVersion.Minor,
                Patch: parsedVersion.patch
              };
              break;
          }
        }
        return this;
      }
      /**
       * Update all tasks' IDs in the extension using v5 namespacing
       * Reads extension manifest for publisher/ID and all tasks from reader
       * @returns Promise<this> for async chaining
       */
      async updateAllTaskIds() {
        const manifest = await this.reader.readExtensionManifest();
        const publisherId = this.manifestModifications.publisher || manifest.publisher;
        const extensionId = this.manifestModifications.id || manifest.id;
        const tasks = await this.reader.getTasksInfo();
        for (const task of tasks) {
          this.updateTaskId(task.name, publisherId, extensionId);
        }
        return this;
      }
      /**
       * Add or modify a file
       * @param path Path to the file
       * @param content File content
       * @returns This editor for chaining
       */
      setFile(path10, content) {
        const buffer = import_buffer2.Buffer.isBuffer(content) ? content : import_buffer2.Buffer.from(content, "utf-8");
        const normalizedPath = path10.replace(/\\/g, "/");
        this.modifications.set(normalizedPath, {
          type: "modify",
          path: normalizedPath,
          content: buffer
        });
        return this;
      }
      /**
       * Remove a file
       * @param path Path to the file
       * @returns This editor for chaining
       */
      removeFile(path10) {
        const normalizedPath = path10.replace(/\\/g, "/");
        this.modifications.set(normalizedPath, {
          type: "remove",
          path: normalizedPath
        });
        return this;
      }
      /**
       * Convert to a writer for output
       * The writer type depends on the reader type
       * @returns Promise<Writer> ready to write (VsixWriter or FilesystemManifestWriter)
       */
      async toWriter() {
        const readerConstructorName = this.reader.constructor.name;
        if (readerConstructorName === "VsixReader") {
          const { VsixWriter: VsixWriter2 } = await Promise.resolve().then(() => (init_vsix_writer(), vsix_writer_exports));
          return VsixWriter2.fromEditor(this);
        } else if (readerConstructorName === "FilesystemManifestReader") {
          const { FilesystemManifestWriter: FilesystemManifestWriter2 } = await Promise.resolve().then(() => (init_filesystem_manifest_writer(), filesystem_manifest_writer_exports));
          return FilesystemManifestWriter2.fromEditor(this);
        } else {
          throw new Error(`Unsupported reader type: ${readerConstructorName}`);
        }
      }
      /**
       * Get the source reader
       * @internal
       */
      getReader() {
        return this.reader;
      }
      /**
       * Get all file modifications
       * @internal
       */
      getModifications() {
        return this.modifications;
      }
      /**
       * Get manifest modifications
       * @internal
       */
      getManifestModifications() {
        return this.manifestModifications;
      }
      /**
       * Get task manifest modifications
       * @internal
       */
      getTaskManifestModifications() {
        return this.taskManifestModifications;
      }
      /**
       * Get task ID updates (for updating extension manifest references)
       * @internal
       */
      getTaskIdUpdates() {
        return this.taskIdUpdates;
      }
    };
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb2) {
      if (this.pending === 0) {
        cb2(this.error);
      } else {
        this.listeners.push(cb2);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called) throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/yauzl/fd-slicer.js
var require_fd_slicer = __commonJS({
  "node_modules/yauzl/fd-slicer.js"(exports2) {
    var fs4 = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable2 = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options2) {
      options2 = options2 || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options2.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb2) {
        fs4.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb2();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb2) {
        fs4.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb2();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options2) {
      return new ReadStream(this, options2);
    };
    FdSlicer.prototype.createWriteStream = function(options2) {
      return new WriteStream(this, options2);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0) return;
      if (self2.refCount < 0) throw new Error("invalid unref");
      if (self2.autoClose) {
        fs4.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options2) {
      options2 = options2 || {};
      Readable.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed) return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb2) {
        if (self2.destroyed) return cb2();
        var buffer = Buffer.allocUnsafe(toRead);
        fs4.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb2();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed) return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable2);
    function WriteStream(context, options2) {
      options2 = options2 || {};
      Writable2.call(this, options2);
      this.context = context;
      this.context.ref();
      this.start = options2.start || 0;
      this.endOffset = options2.end == null ? Infinity : +options2.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed) return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb2) {
        if (self2.destroyed) return cb2();
        fs4.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb2();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb2();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed) return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options2) {
      EventEmitter.call(this);
      options2 = options2 || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options2.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      if (!(0 <= offset && offset <= buffer.length)) throw new RangeError("offset outside buffer: 0 <= " + offset + " <= " + buffer.length);
      if (position < 0) throw new RangeError("position is negative: " + position);
      if (offset + length > buffer.length) {
        length = buffer.length - offset;
      }
      if (position + length > this.buffer.length) {
        length = this.buffer.length - position;
      }
      if (length <= 0) {
        setImmediate(function() {
          callback(null, 0);
        });
        return;
      }
      this.buffer.copy(buffer, offset, position, position + length);
      setImmediate(function() {
        callback(null, length);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options2) {
      options2 = options2 || {};
      var readStream = new PassThrough(options2);
      readStream.destroyed = false;
      readStream.start = options2.start || 0;
      readStream.endOffset = options2.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options2) {
      var bufferSlicer = this;
      options2 = options2 || {};
      var writeStream = new Writable2(options2);
      writeStream.start = options2.start || 0;
      writeStream.endOffset = options2.end == null ? this.buffer.length : +options2.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed) return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options2) {
      return new BufferSlicer(buffer, options2);
    }
    function createFromFd(fd, options2) {
      return new FdSlicer(fd, options2);
    }
  }
});

// node_modules/yauzl/node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/yauzl/node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer5 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer5.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer5.alloc === "function" && typeof Buffer5.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer5.alloc(input) : new Buffer5(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer5.from(input) : new Buffer5(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer5.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    var fs4 = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable2 = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.getFileNameLowLevel = getFileNameLowLevel;
    exports2.validateFileName = validateFileName;
    exports2.parseExtraFields = parseExtraFields;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.LocalFileHeader = LocalFileHeader;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path10, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = true;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs4.open(path10, "r", function(err, fd) {
        if (err) return callback(err);
        fromFd(fd, options2, function(err2, zipfile) {
          if (err2) fs4.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = false;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      fs4.fstat(fd, function(err, stats) {
        if (err) return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options2, callback);
      });
    }
    function fromBuffer(buffer, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      options2.autoClose = false;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options2, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      if (options2.autoClose == null) options2.autoClose = true;
      if (options2.lazyEntries == null) options2.lazyEntries = false;
      if (options2.decodeStrings == null) options2.decodeStrings = true;
      var decodeStrings = !!options2.decodeStrings;
      if (options2.validateEntrySizes == null) options2.validateEntrySizes = true;
      if (options2.strictFileNames == null) options2.strictFileNames = false;
      if (callback == null) callback = defaultCallback;
      if (typeof totalSize !== "number") throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var zip64EocdlSize = 20;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(zip64EocdlSize + eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err) return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256) continue;
          var eocdrBuffer = buffer.subarray(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("Invalid comment length. Expected: " + expectedCommentLength + ". Found: " + commentLength + ". Are there extra bytes at the end of the file? Or is the end of central dir signature `PK\u263A\u263B` in the comment?"));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer.subarray(22), false) : eocdrBuffer.subarray(22);
          if (i - zip64EocdlSize >= 0 && buffer.readUInt32LE(i - zip64EocdlSize) === 117853008) {
            var zip64EocdlBuffer = buffer.subarray(i - zip64EocdlSize, i - zip64EocdlSize + zip64EocdlSize);
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            return readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err2) {
              if (err2) return callback(err2);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              diskNumber = zip64EocdrBuffer.readUInt32LE(16);
              if (diskNumber !== 0) {
                return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
            });
          }
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options2.autoClose, options2.lazyEntries, decodeStrings, options2.validateEntrySizes, options2.strictFileNames));
        }
        callback(new Error("End of central directory record signature not found. Either not a zip file, or file is truncated."));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries) self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen) return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose) self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError) return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries) throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose) self2.close();
          if (self2.emittedError) return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError) return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err) return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError) return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248) return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64) return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2) return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError) return;
          entry.fileNameRaw = buffer.subarray(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          entry.extraFieldRaw = buffer.subarray(entry.fileNameLength, fileCommentStart);
          entry.fileCommentRaw = buffer.subarray(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          try {
            entry.extraFields = parseExtraFields(entry.extraFieldRaw);
          } catch (err3) {
            return emitErrorAndAutoClose(self2, err3);
          }
          if (self2.decodeStrings) {
            var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
            entry.fileComment = decodeBuffer(entry.fileCommentRaw, isUtf8);
            entry.fileName = getFileNameLowLevel(entry.generalPurposeBitFlag, entry.fileNameRaw, entry.extraFields, self2.strictFileNames);
            var errorMessage = validateFileName(entry.fileName);
            if (errorMessage != null) return emitErrorAndAutoClose(self2, new Error(errorMessage));
          } else {
            entry.fileComment = entry.fileCommentRaw;
            entry.fileName = entry.fileNameRaw;
          }
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          for (var i = 0; i < entry.extraFields.length; i++) {
            var extraField = entry.extraFields[i];
            if (extraField.id !== 1) continue;
            var zip64EiefBuffer = extraField.data;
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            break;
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries) self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options2, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) {
        options2 = {};
      } else {
        if (options2.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options2.decrypt !== false) throw new Error("invalid options.decrypt value: " + options2.decrypt);
          if (entry.isCompressed()) {
            if (options2.decompress !== false) throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options2.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options2.decompress === false || options2.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options2.decompress);
          }
        }
        if (options2.start != null || options2.end != null) {
          if (entry.isCompressed() && options2.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options2.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options2.start != null) {
          relativeStart = options2.start;
          if (relativeStart < 0) throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize) throw new Error("options.start > entry.compressedSize");
        }
        if (options2.end != null) {
          relativeEnd = options2.end;
          if (relativeEnd < 0) throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize) throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart) throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen) return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options2.decrypt !== false) return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      var decompress;
      if (entry.compressionMethod === 0) {
        decompress = false;
      } else if (entry.compressionMethod === 8) {
        decompress = options2.decompress != null ? options2.decompress : true;
      } else {
        return callback(new Error("unsupported compression method: " + entry.compressionMethod));
      }
      self2.readLocalFileHeader(entry, { minimal: true }, function(err, localFileHeader) {
        if (err) return callback(err);
        self2.openReadStreamLowLevel(
          localFileHeader.fileDataStart,
          entry.compressedSize,
          relativeStart,
          relativeEnd,
          decompress,
          entry.uncompressedSize,
          callback
        );
      });
    };
    ZipFile.prototype.openReadStreamLowLevel = function(fileDataStart, compressedSize, relativeStart, relativeEnd, decompress, uncompressedSize, callback) {
      var self2 = this;
      var fileDataEnd = fileDataStart + compressedSize;
      var readStream = self2.reader.createReadStream({
        start: fileDataStart + relativeStart,
        end: fileDataStart + relativeEnd
      });
      var endpointStream = readStream;
      if (decompress) {
        var destroyed = false;
        var inflateFilter = zlib.createInflateRaw();
        readStream.on("error", function(err) {
          setImmediate(function() {
            if (!destroyed) inflateFilter.emit("error", err);
          });
        });
        readStream.pipe(inflateFilter);
        if (self2.validateEntrySizes) {
          endpointStream = new AssertByteCountStream(uncompressedSize);
          inflateFilter.on("error", function(err) {
            setImmediate(function() {
              if (!destroyed) endpointStream.emit("error", err);
            });
          });
          inflateFilter.pipe(endpointStream);
        } else {
          endpointStream = inflateFilter;
        }
        installDestroyFn(endpointStream, function() {
          destroyed = true;
          if (inflateFilter !== endpointStream) inflateFilter.unpipe(endpointStream);
          readStream.unpipe(inflateFilter);
          readStream.destroy();
        });
      }
      callback(null, endpointStream);
    };
    ZipFile.prototype.readLocalFileHeader = function(entry, options2, callback) {
      var self2 = this;
      if (callback == null) {
        callback = options2;
        options2 = null;
      }
      if (options2 == null) options2 = {};
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err) return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var fileDataStart = entry.relativeOffsetOfLocalHeader + 30 + fileNameLength + extraFieldLength;
          if (fileDataStart + entry.compressedSize > self2.fileSize) {
            return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
          }
          if (options2.minimal) {
            return callback(null, { fileDataStart });
          }
          var localFileHeader = new LocalFileHeader();
          localFileHeader.fileDataStart = fileDataStart;
          localFileHeader.versionNeededToExtract = buffer.readUInt16LE(4);
          localFileHeader.generalPurposeBitFlag = buffer.readUInt16LE(6);
          localFileHeader.compressionMethod = buffer.readUInt16LE(8);
          localFileHeader.lastModFileTime = buffer.readUInt16LE(10);
          localFileHeader.lastModFileDate = buffer.readUInt16LE(12);
          localFileHeader.crc32 = buffer.readUInt32LE(14);
          localFileHeader.compressedSize = buffer.readUInt32LE(18);
          localFileHeader.uncompressedSize = buffer.readUInt32LE(22);
          localFileHeader.fileNameLength = fileNameLength;
          localFileHeader.extraFieldLength = extraFieldLength;
          buffer = newBuffer(fileNameLength + extraFieldLength);
          self2.reader.ref();
          readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader + 30, function(err2) {
            try {
              if (err2) return callback(err2);
              localFileHeader.fileName = buffer.subarray(0, fileNameLength);
              localFileHeader.extraField = buffer.subarray(fileNameLength);
              return callback(null, localFileHeader);
            } finally {
              self2.reader.unref();
            }
          });
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function(options2) {
      if (options2 == null) options2 = {};
      if (!options2.forceDosFormat) {
        for (var i = 0; i < this.extraFields.length; i++) {
          var extraField = this.extraFields[i];
          if (extraField.id === 21589) {
            var data = extraField.data;
            if (data.length < 5) continue;
            var flags = data[0];
            var HAS_MTIME = 1;
            if (!(flags & HAS_MTIME)) continue;
            var posixTimestamp = data.readInt32LE(1);
            return new Date(posixTimestamp * 1e3);
          } else if (extraField.id === 10) {
            var data = extraField.data;
            var cursor = 4;
            while (cursor < data.length + 4) {
              var tag = data.readUInt16LE(cursor);
              cursor += 2;
              var size2 = data.readUInt16LE(cursor);
              cursor += 2;
              if (tag !== 1) {
                cursor += size2;
                continue;
              }
              if (size2 < 8 || cursor + size2 > data.length) break;
              var hundredNanoSecondsSince1601 = 4294967296 * data.readInt32LE(cursor + 4) + data.readUInt32LE(cursor);
              var millisecondsSince1970 = hundredNanoSecondsSince1601 / 1e4 - 116444736e5;
              return new Date(millisecondsSince1970);
            }
          }
        }
      }
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime, options2.timezone);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function LocalFileHeader() {
    }
    function dosDateTimeToDate(date, time, timezone) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      if (timezone == null || timezone === "local") {
        return new Date(year, month, day, hour, minute, second, millisecond);
      } else if (timezone === "UTC") {
        return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      } else {
        throw new Error("unrecognized options.timezone: " + options.timezone);
      }
    }
    function getFileNameLowLevel(generalPurposeBitFlag, fileNameBuffer, extraFields, strictFileNames) {
      var fileName = null;
      for (var i = 0; i < extraFields.length; i++) {
        var extraField = extraFields[i];
        if (extraField.id === 28789) {
          if (extraField.data.length < 6) {
            continue;
          }
          if (extraField.data.readUInt8(0) !== 1) {
            continue;
          }
          var oldNameCrc32 = extraField.data.readUInt32LE(1);
          if (crc32.unsigned(fileNameBuffer) !== oldNameCrc32) {
            continue;
          }
          fileName = decodeBuffer(extraField.data.subarray(5), true);
          break;
        }
      }
      if (fileName == null) {
        var isUtf8 = (generalPurposeBitFlag & 2048) !== 0;
        fileName = decodeBuffer(fileNameBuffer, isUtf8);
      }
      if (!strictFileNames) {
        fileName = fileName.replace(/\\/g, "/");
      }
      return fileName;
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function parseExtraFields(extraFieldBuffer) {
      var extraFields = [];
      var i = 0;
      while (i < extraFieldBuffer.length - 3) {
        var headerId = extraFieldBuffer.readUInt16LE(i + 0);
        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
        var dataStart = i + 4;
        var dataEnd = dataStart + dataSize;
        if (dataEnd > extraFieldBuffer.length) throw new Error("extra field length exceeds extra field buffer size");
        var dataBuffer = extraFieldBuffer.subarray(dataStart, dataEnd);
        extraFields.push({
          id: headerId,
          data: dataBuffer
        });
        i = dataEnd;
      }
      return extraFields;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err) return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk2, encoding, cb2) {
      this.actualByteCount += chunk2.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb2(new Error(msg));
      }
      cb2(null, chunk2);
    };
    AssertByteCountStream.prototype._flush = function(cb2) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb2(new Error(msg));
      }
      cb2();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0) return;
      if (self2.refCount < 0) throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err) return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options2) {
      if (options2 == null) options2 = {};
      var start = options2.start;
      var end = options2.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) refUnrefFilter.emit("error", err);
        });
      });
      installDestroyFn(refUnrefFilter, function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      });
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed) byteCounter.emit("error", err);
        });
      });
      installDestroyFn(byteCounter, function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      });
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable2();
      var written = 0;
      writeStream._write = function(chunk2, encoding, cb2) {
        chunk2.copy(buffer, offset + written, 0, chunk2.length);
        written += chunk2.length;
        cb2();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error2) {
        callback(error2);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb2) {
      this.unref();
      cb2();
    };
    RefUnrefFilter.prototype.unref = function(cb2) {
      if (this.unreffedYet) return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      } else {
        var result2 = "";
        for (var i = 0; i < buffer.length; i++) {
          result2 += cp437[buffer[i]];
        }
        return result2;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function installDestroyFn(stream, fn) {
      if (typeof stream.destroy === "function") {
        stream._destroy = function(err, cb2) {
          fn();
          if (cb2 != null) cb2(err);
        };
      } else {
        stream.destroy = fn;
      }
    }
    function defaultCallback(err) {
      if (err) throw err;
    }
  }
});

// packages/core/dist/filesystem-manifest-reader.js
var filesystem_manifest_reader_exports = {};
__export(filesystem_manifest_reader_exports, {
  FilesystemManifestReader: () => FilesystemManifestReader
});
var import_promises3, import_path5, FilesystemManifestReader;
var init_filesystem_manifest_reader = __esm({
  "packages/core/dist/filesystem-manifest-reader.js"() {
    "use strict";
    import_promises3 = require("fs/promises");
    import_path5 = __toESM(require("path"), 1);
    init_manifest_reader();
    FilesystemManifestReader = class extends ManifestReader {
      rootFolder;
      manifestGlobs;
      platform;
      manifestPath = null;
      extensionManifest = null;
      // Map of packagePath (task name) to actual source path
      packagePathMap = null;
      constructor(options2) {
        super();
        this.rootFolder = options2.rootFolder;
        this.manifestGlobs = options2.manifestGlobs || ["vss-extension.json"];
        this.platform = options2.platform;
      }
      /**
       * Find and resolve the extension manifest file path
       */
      async resolveManifestPath() {
        if (this.manifestPath) {
          return this.manifestPath;
        }
        const matches = await this.platform.findMatch(this.rootFolder, this.manifestGlobs);
        if (matches.length === 0) {
          const commonNames = ["vss-extension.json", "extension.vsomanifest"];
          for (const name of commonNames) {
            const candidate = import_path5.default.join(this.rootFolder, name);
            if (await this.platform.fileExists(candidate)) {
              this.manifestPath = candidate;
              return candidate;
            }
          }
          throw new Error(`Extension manifest not found in ${this.rootFolder}. Tried patterns: ${this.manifestGlobs.join(", ")}`);
        }
        if (matches.length > 1) {
          this.platform.warning(`Multiple manifest files found: ${matches.join(", ")}. Using first match.`);
        }
        this.manifestPath = matches[0];
        return this.manifestPath;
      }
      /**
       * Read the extension manifest from filesystem
       * @returns Parsed extension manifest
       */
      async readExtensionManifest() {
        if (this.extensionManifest) {
          return this.extensionManifest;
        }
        const manifestPath = await this.resolveManifestPath();
        const content = await (0, import_promises3.readFile)(manifestPath, "utf-8");
        this.extensionManifest = JSON.parse(content);
        return this.extensionManifest;
      }
      /**
       * Build a map of packagePath to actual source path from files array
       * This handles cases where task.json is in a different directory than the final package path
       * @returns Map of packagePath to source path
       */
      async buildPackagePathMap() {
        if (this.packagePathMap) {
          return this.packagePathMap;
        }
        this.packagePathMap = /* @__PURE__ */ new Map();
        const manifest = await this.readExtensionManifest();
        if (manifest.files) {
          for (const file of manifest.files) {
            if (file.packagePath) {
              this.packagePathMap.set(file.packagePath, file.path);
              this.platform.debug(`Mapped packagePath '${file.packagePath}' to source path '${file.path}'`);
            }
          }
        }
        return this.packagePathMap;
      }
      /**
       * Find task paths from the extension manifest
       * @returns Array of task directory paths (relative to rootFolder)
       */
      async findTaskPaths() {
        const manifest = await this.readExtensionManifest();
        const taskPaths = [];
        if (manifest.contributions) {
          for (const contribution of manifest.contributions) {
            if (contribution.type === "ms.vss-distributed-task.task" && contribution.properties) {
              const name = contribution.properties.name;
              if (name) {
                taskPaths.push(name);
              }
            }
          }
        }
        if (taskPaths.length === 0 && manifest.files) {
          for (const file of manifest.files) {
            const taskJsonPath = import_path5.default.join(this.rootFolder, file.path, "task.json");
            if (await this.platform.fileExists(taskJsonPath)) {
              taskPaths.push(file.path);
            }
          }
        }
        return taskPaths;
      }
      /**
       * Read a task manifest from filesystem
       * @param taskPath Path to the task directory (relative to rootFolder) or packagePath
       * @returns Parsed task manifest
       */
      async readTaskManifest(taskPath) {
        const packagePathMap = await this.buildPackagePathMap();
        let actualPath = taskPath;
        const normalizedTaskPath = taskPath.replace(/\\/g, "/");
        for (const [pkgPath, sourcePath] of packagePathMap.entries()) {
          const normalizedPkgPath = pkgPath.replace(/\\/g, "/");
          if (normalizedTaskPath === normalizedPkgPath) {
            actualPath = sourcePath;
            break;
          } else if (normalizedTaskPath.startsWith(normalizedPkgPath + "/")) {
            const remainder = normalizedTaskPath.substring(normalizedPkgPath.length + 1);
            actualPath = import_path5.default.join(sourcePath, remainder);
            break;
          }
        }
        this.platform.debug(`Reading task manifest: taskPath='${taskPath}', actualPath='${actualPath}'`);
        const absoluteTaskPath = import_path5.default.isAbsolute(actualPath) ? actualPath : import_path5.default.join(this.rootFolder, actualPath);
        const taskJsonPath = import_path5.default.join(absoluteTaskPath, "task.json");
        if (!await this.platform.fileExists(taskJsonPath)) {
          throw new Error(`Task manifest not found: ${taskJsonPath}`);
        }
        const content = await (0, import_promises3.readFile)(taskJsonPath, "utf-8");
        return JSON.parse(content);
      }
      /**
       * Close and clean up resources
       * No-op for filesystem reader as there are no persistent resources
       */
      async close() {
        this.extensionManifest = null;
        this.manifestPath = null;
        this.packagePathMap = null;
      }
      /**
       * Get the root folder path
       */
      getRootFolder() {
        return this.rootFolder;
      }
      /**
       * Get the resolved manifest path (if already resolved)
       */
      getManifestPath() {
        return this.manifestPath;
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/VsoClient.js
var require_VsoClient = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/VsoClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VsoClient = exports2.InvalidApiResourceVersionError = void 0;
    var url = require("url");
    var path10 = require("path");
    var InvalidApiResourceVersionError = class {
      constructor(message) {
        this.name = "Invalid resource version";
        this.message = message;
      }
    };
    exports2.InvalidApiResourceVersionError = InvalidApiResourceVersionError;
    var VsoClient = class _VsoClient {
      constructor(baseUrl, restClient) {
        this.baseUrl = baseUrl;
        this.basePath = url.parse(baseUrl).pathname;
        this.restClient = restClient;
        this._locationsByAreaPromises = {};
        this._initializationPromise = Promise.resolve(true);
      }
      autoNegotiateApiVersion(location, requestedVersion) {
        let negotiatedVersion;
        let apiVersion;
        let apiVersionString;
        if (requestedVersion) {
          let apiVersionRegEx = new RegExp("(\\d+(\\.\\d+)?)(-preview(\\.(\\d+))?)?");
          let isPreview = false;
          let resourceVersion;
          let regExExecArray = apiVersionRegEx.exec(requestedVersion);
          if (regExExecArray) {
            if (regExExecArray[1]) {
              apiVersion = +regExExecArray[1];
              apiVersionString = regExExecArray[1];
              if (regExExecArray[3]) {
                isPreview = true;
                if (regExExecArray[5]) {
                  resourceVersion = +regExExecArray[5];
                }
              }
              if (apiVersion <= +location.releasedVersion || !resourceVersion && apiVersion <= +location.maxVersion && isPreview || resourceVersion && apiVersion <= +location.maxVersion && resourceVersion <= +location.resourceVersion) {
                negotiatedVersion = requestedVersion;
              }
            }
          }
        }
        if (!negotiatedVersion) {
          if (apiVersion < +location.maxVersion) {
            negotiatedVersion = apiVersionString + "-preview";
          } else if (location.maxVersion === location.releasedVersion) {
            negotiatedVersion = location.maxVersion;
          } else {
            negotiatedVersion = location.maxVersion + "-preview." + location.resourceVersion;
          }
        }
        return negotiatedVersion;
      }
      /**
       * Gets the route template for a resource based on its location ID and negotiates the api version
       */
      getVersioningData(apiVersion, area, locationId, routeValues, queryParams) {
        let requestUrl;
        return this.beginGetLocation(area, locationId).then((location) => {
          if (!location) {
            throw new Error("Failed to find api location for area: " + area + " id: " + locationId);
          }
          apiVersion = this.autoNegotiateApiVersion(location, apiVersion);
          requestUrl = this.getRequestUrl(location.routeTemplate, location.area, location.resourceName, routeValues, queryParams);
          return {
            apiVersion,
            requestUrl
          };
        });
      }
      /**
       * Sets a promise that is waited on before any requests are issued. Can be used to asynchronously
       * set the request url and auth token manager.
       */
      _setInitializationPromise(promise) {
        if (promise) {
          this._initializationPromise = promise;
        }
      }
      /**
       * Gets information about an API resource location (route template, supported versions, etc.)
       *
       * @param area resource area name
       * @param locationId Guid of the location to get
       */
      beginGetLocation(area, locationId) {
        return this._initializationPromise.then(() => {
          return this.beginGetAreaLocations(area);
        }).then((areaLocations) => {
          return areaLocations[(locationId || "").toLowerCase()];
        });
      }
      beginGetAreaLocations(area) {
        let areaLocationsPromise = this._locationsByAreaPromises[area];
        if (!areaLocationsPromise) {
          let requestUrl = this.resolveUrl(_VsoClient.APIS_RELATIVE_PATH + "/" + area);
          areaLocationsPromise = this.restClient.options(requestUrl).then((res) => {
            if (!res.result) {
              return {};
            }
            let locationsLookup = {};
            let resourceLocations = res.result.value;
            let i;
            for (i = 0; i < resourceLocations.length; i++) {
              let resourceLocation = resourceLocations[i];
              locationsLookup[resourceLocation.id.toLowerCase()] = resourceLocation;
            }
            this._locationsByAreaPromises[area] = areaLocationsPromise;
            return locationsLookup;
          });
        }
        return areaLocationsPromise;
      }
      resolveUrl(relativeUrl) {
        return url.resolve(this.baseUrl, path10.join(this.basePath, relativeUrl));
      }
      queryParamsToStringHelper(queryParams, prefix) {
        if (queryParams == null || queryParams.length === 0) {
          return "";
        }
        let queryString = "";
        if (Array.isArray(queryParams)) {
          const paramName = prefix.endsWith(".") ? prefix.slice(0, -1) : prefix;
          const values2 = queryParams.map((value) => value.toString()).join(",");
          queryString += paramName + "=" + encodeURIComponent(values2) + "&";
          return queryString;
        }
        if (typeof queryParams !== "string") {
          for (let property2 in queryParams) {
            if (queryParams.hasOwnProperty(property2)) {
              const prop = queryParams[property2];
              const newPrefix = prefix + encodeURIComponent(property2.toString()) + ".";
              queryString += this.queryParamsToStringHelper(prop, newPrefix);
            }
          }
        }
        if (queryString === "" && prefix.length > 0) {
          const queryValue = typeof queryParams === "object" && "toUTCString" in queryParams ? queryParams.toUTCString() : queryParams.toString();
          const paramName = prefix.endsWith(".") ? prefix.slice(0, -1) : prefix;
          queryString = paramName + "=" + encodeURIComponent(queryValue) + "&";
        }
        return queryString;
      }
      queryParamsToString(queryParams) {
        const queryString = "?" + this.queryParamsToStringHelper(queryParams, "");
        return queryString.slice(0, -1);
      }
      getRequestUrl(routeTemplate, area, resource, routeValues, queryParams) {
        routeValues = routeValues || {};
        if (!routeValues.area) {
          routeValues.area = area;
        }
        if (!routeValues.resource) {
          routeValues.resource = resource;
        }
        let relativeUrl = this.replaceRouteValues(routeTemplate, routeValues);
        if (queryParams) {
          relativeUrl += this.queryParamsToString(queryParams);
        }
        return url.resolve(this.baseUrl, path10.join(this.basePath, relativeUrl));
      }
      // helper method copied directly from VSS\WebAPI\restclient.ts
      replaceRouteValues(routeTemplate, routeValues) {
        let result2 = "", currentPathPart = "", paramName = "", insideParam = false, charIndex, routeTemplateLength = routeTemplate.length, c;
        for (charIndex = 0; charIndex < routeTemplateLength; charIndex++) {
          c = routeTemplate[charIndex];
          if (insideParam) {
            if (c == "}") {
              insideParam = false;
              if (routeValues[paramName]) {
                currentPathPart += encodeURIComponent(routeValues[paramName]);
              } else {
                let strippedParamName = paramName.replace(/[^a-z0-9]/ig, "");
                if (routeValues[strippedParamName]) {
                  currentPathPart += encodeURIComponent(routeValues[strippedParamName]);
                }
              }
              paramName = "";
            } else {
              paramName += c;
            }
          } else {
            if (c == "/") {
              if (currentPathPart) {
                if (result2) {
                  result2 += "/";
                }
                result2 += currentPathPart;
                currentPathPart = "";
              }
            } else if (c == "{") {
              if (charIndex + 1 < routeTemplateLength && routeTemplate[charIndex + 1] == "{") {
                currentPathPart += c;
                charIndex++;
              } else {
                insideParam = true;
              }
            } else if (c == "}") {
              currentPathPart += c;
              if (charIndex + 1 < routeTemplateLength && routeTemplate[charIndex + 1] == "}") {
                charIndex++;
              }
            } else {
              currentPathPart += c;
            }
          }
        }
        if (currentPathPart) {
          if (result2) {
            result2 += "/";
          }
          result2 += currentPathPart;
        }
        return result2;
      }
    };
    exports2.VsoClient = VsoClient;
    VsoClient.APIS_RELATIVE_PATH = "_apis";
    VsoClient.PREVIEW_INDICATOR = "-preview.";
  }
});

// packages/core/node_modules/azure-devops-node-api/Serialization.js
var require_Serialization = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/Serialization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractSerializer = void 0;
    var ContractSerializer;
    (function(ContractSerializer2) {
      var _legacyDateRegExp;
      function serialize(data, contractMetadata, preserveOriginal) {
        if (data && contractMetadata) {
          if (Array.isArray(data)) {
            return _getTranslatedArray(data, contractMetadata, true, preserveOriginal);
          } else {
            return _getTranslatedObject(data, contractMetadata, true, preserveOriginal);
          }
        } else {
          return data;
        }
      }
      ContractSerializer2.serialize = serialize;
      function deserialize(data, contractMetadata, preserveOriginal, unwrapWrappedCollections) {
        if (data) {
          if (unwrapWrappedCollections && Array.isArray(data.value)) {
            data = data.value;
          }
          if (contractMetadata) {
            if (Array.isArray(data)) {
              data = _getTranslatedArray(data, contractMetadata, false, preserveOriginal);
            } else {
              data = _getTranslatedObject(data, contractMetadata, false, preserveOriginal);
            }
          }
        }
        return data;
      }
      ContractSerializer2.deserialize = deserialize;
      function _getTranslatedArray(array, typeMetadata, serialize2, preserveOriginal) {
        var resultArray = array;
        var arrayCopy = [];
        var i;
        for (i = 0; i < array.length; i++) {
          var item = array[i];
          var processedItem;
          if (Array.isArray(item)) {
            processedItem = _getTranslatedArray(item, typeMetadata, serialize2, preserveOriginal);
          } else {
            processedItem = _getTranslatedObject(item, typeMetadata, serialize2, preserveOriginal);
          }
          if (preserveOriginal) {
            arrayCopy.push(processedItem);
            if (processedItem !== item) {
              resultArray = arrayCopy;
            }
          } else {
            array[i] = processedItem;
          }
        }
        return resultArray;
      }
      function _getTranslatedObject(typeObject, typeMetadata, serialize2, preserveOriginal) {
        var processedItem = typeObject, copiedItem = false;
        if (typeObject && typeMetadata.fields) {
          for (var fieldName in typeMetadata.fields) {
            var fieldMetadata = typeMetadata.fields[fieldName];
            var fieldValue = typeObject[fieldName];
            var translatedValue = _getTranslatedField(fieldValue, fieldMetadata, serialize2, preserveOriginal);
            if (fieldValue !== translatedValue) {
              if (preserveOriginal && !copiedItem) {
                processedItem = this._extend({}, typeObject);
                copiedItem = true;
              }
              processedItem[fieldName] = translatedValue;
            }
          }
        }
        return processedItem;
      }
      function _getTranslatedField(fieldValue, fieldMetadata, serialize2, preserveOriginal) {
        if (!fieldValue) {
          return fieldValue;
        }
        if (fieldMetadata.isArray) {
          if (Array.isArray(fieldValue)) {
            var newArray = [], processedArray = fieldValue;
            for (var index = 0; index < fieldValue.length; index++) {
              var arrayValue = fieldValue[index];
              var processedValue = arrayValue;
              if (fieldMetadata.isDate) {
                processedValue = _getTranslatedDateValue(arrayValue, serialize2);
              } else if (fieldMetadata.enumType) {
                processedValue = _getTranslatedEnumValue(fieldMetadata.enumType, arrayValue, serialize2);
              } else if (fieldMetadata.typeInfo) {
                if (Array.isArray(arrayValue)) {
                  processedValue = _getTranslatedArray(arrayValue, fieldMetadata.typeInfo, serialize2, preserveOriginal);
                } else {
                  processedValue = _getTranslatedObject(arrayValue, fieldMetadata.typeInfo, serialize2, preserveOriginal);
                }
              }
              if (preserveOriginal) {
                newArray.push(processedValue);
                if (processedValue !== arrayValue) {
                  processedArray = newArray;
                }
              } else {
                fieldValue[index] = processedValue;
              }
            }
            return processedArray;
          } else {
            return fieldValue;
          }
        } else if (fieldMetadata.isDictionary) {
          var dictionaryModified = false;
          var newDictionary = {};
          for (var key in fieldValue) {
            var dictionaryValue = fieldValue[key];
            var newKey = key, newValue = dictionaryValue;
            if (fieldMetadata.dictionaryKeyIsDate) {
              newKey = _getTranslatedDateValue(key, serialize2);
            } else if (fieldMetadata.dictionaryKeyEnumType) {
              newKey = _getTranslatedEnumValue(fieldMetadata.dictionaryKeyEnumType, key, serialize2);
            }
            if (fieldMetadata.dictionaryValueIsDate) {
              newValue = _getTranslatedDateValue(dictionaryValue, serialize2);
            } else if (fieldMetadata.dictionaryValueEnumType) {
              newValue = _getTranslatedEnumValue(fieldMetadata.dictionaryValueEnumType, dictionaryValue, serialize2);
            } else if (fieldMetadata.dictionaryValueTypeInfo) {
              newValue = _getTranslatedObject(newValue, fieldMetadata.dictionaryValueTypeInfo, serialize2, preserveOriginal);
            } else if (fieldMetadata.dictionaryValueFieldInfo) {
              newValue = _getTranslatedField(dictionaryValue, fieldMetadata.dictionaryValueFieldInfo, serialize2, preserveOriginal);
            }
            newDictionary[newKey] = newValue;
            if (key !== newKey || dictionaryValue !== newValue) {
              dictionaryModified = true;
            }
          }
          return dictionaryModified ? newDictionary : fieldValue;
        } else {
          if (fieldMetadata.isDate) {
            return _getTranslatedDateValue(fieldValue, serialize2);
          } else if (fieldMetadata.enumType) {
            return _getTranslatedEnumValue(fieldMetadata.enumType, fieldValue, serialize2);
          } else if (fieldMetadata.typeInfo) {
            return _getTranslatedObject(fieldValue, fieldMetadata.typeInfo, serialize2, preserveOriginal);
          } else {
            return fieldValue;
          }
        }
      }
      function _getTranslatedEnumValue(enumType, valueToConvert, serialize2) {
        if (serialize2 && typeof valueToConvert === "number") {
        } else if (!serialize2 && typeof valueToConvert === "string") {
          var result2 = 0;
          if (valueToConvert) {
            var splitValue = valueToConvert.split(",");
            for (var i = 0; i < splitValue.length; i++) {
              var valuePart = splitValue[i];
              var enumName = valuePart.replace(/^\s+|\s+$/g, "") || "";
              if (enumName) {
                var resultPart = enumType.enumValues[enumName];
                if (!resultPart) {
                  var lowerCaseEnumName = enumName.toLowerCase();
                  if (lowerCaseEnumName !== enumName) {
                    for (var name in enumType.enumValues) {
                      var value = enumType.enumValues[name];
                      if (name.toLowerCase() === lowerCaseEnumName) {
                        resultPart = value;
                        break;
                      }
                    }
                  }
                }
                if (resultPart) {
                  result2 |= resultPart;
                }
              }
            }
          }
          return result2;
        }
        return valueToConvert;
      }
      function _getTranslatedDateValue(valueToConvert, serialize2) {
        if (!serialize2 && typeof valueToConvert === "string") {
          var dateValue = new Date(valueToConvert);
          if (isNaN(dateValue) && navigator.userAgent && /msie/i.test(navigator.userAgent)) {
            dateValue = _convertLegacyIEDate(valueToConvert);
          }
          return dateValue;
        }
        return valueToConvert;
      }
      function _convertLegacyIEDate(dateStringValue) {
        var match2;
        if (!_legacyDateRegExp) {
          _legacyDateRegExp = new RegExp("(\\d+)-(\\d+)-(\\d+)T(\\d+):(\\d+):(\\d+).(\\d+)Z");
        }
        match2 = _legacyDateRegExp.exec(dateStringValue);
        if (match2) {
          return new Date(Date.UTC(parseInt(match2[1]), parseInt(match2[2]) - 1, parseInt(match2[3]), parseInt(match2[4]), parseInt(match2[5]), parseInt(match2[6]), parseInt(match2[7])));
        } else {
          return null;
        }
      }
      var _extend = function(out) {
        out = out || {};
        for (var i = 1; i < arguments.length; i++) {
          if (!arguments[i])
            continue;
          for (var key in arguments[i]) {
            if (arguments[i].hasOwnProperty(key))
              out[key] = arguments[i][key];
          }
        }
        return out;
      };
    })(ContractSerializer = exports2.ContractSerializer || (exports2.ContractSerializer = {}));
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    module2.exports = require("util").inspect;
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    var quotes = {
      __proto__: null,
      "double": '"',
      single: "'"
    };
    var quoteREs = {
      __proto__: null,
      "double": /(["\\])/g,
      single: /(['\\])/g
    };
    module2.exports = function inspect_(obj, options2, depth, seen) {
      var opts = options2 || {};
      if (has3(opts, "quoteStyle") && !has3(quotes, opts.quoteStyle)) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has3(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has3(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement2(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var style = opts.quoteStyle || defaultStyle;
      var quoteChar = quotes[style];
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has3(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement2(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var quoteRE = quoteREs[opts.quoteStyle || "single"];
      quoteRE.lastIndex = 0;
      var s = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size2, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size2 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has3(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has3(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel-list/index.js
var require_side_channel_list = __commonJS({
  "node_modules/side-channel-list/index.js"(exports2, module2) {
    "use strict";
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var listGetNode = function(list, key, isDelete) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) != null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          if (!isDelete) {
            curr.next = /** @type {NonNullable<typeof list.next>} */
            list.next;
            list.next = curr;
          }
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      if (!objects) {
        return void 0;
      }
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      if (!objects) {
        return false;
      }
      return !!listGetNode(objects, key);
    };
    var listDelete = function(objects, key) {
      if (objects) {
        return listGetNode(objects, key, true);
      }
    };
    module2.exports = function getSideChannelList() {
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          var root2 = $o && $o.next;
          var deletedNode = listDelete($o, key);
          if (deletedNode && root2 && root2 === deletedNode) {
            $o = void 0;
          }
          return !!deletedNode;
        },
        get: function(key) {
          return listGet($o, key);
        },
        has: function(key) {
          return listHas($o, key);
        },
        set: function(key, value) {
          if (!$o) {
            $o = {
              next: void 0
            };
          }
          listSet(
            /** @type {NonNullable<typeof $o>} */
            $o,
            key,
            value
          );
        }
      };
      return channel;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN3(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _3 in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max2 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max2(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max2 = require_max();
    var min2 = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max2,
      "%Math.min%": min2,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first2 = $strSlice(string, 0, 1);
      var last2 = $strSlice(string, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result2 = [];
      $replace(string, rePropName, function(match2, number, quote, subString) {
        result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
      });
      return result2;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {Parameters<typeof callBindBasic>[0][0]} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic([intrinsic]);
      }
      return intrinsic;
    };
  }
});

// node_modules/side-channel-map/index.js
var require_side_channel_map = __commonJS({
  "node_modules/side-channel-map/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $Map = GetIntrinsic("%Map%", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var $mapDelete = callBound("Map.prototype.delete", true);
    var $mapSize = callBound("Map.prototype.size", true);
    module2.exports = !!$Map && /** @type {Exclude<import('.'), false>} */
    function getSideChannelMap() {
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          if ($m) {
            var result2 = $mapDelete($m, key);
            if ($mapSize($m) === 0) {
              $m = void 0;
            }
            return result2;
          }
          return false;
        },
        get: function(key) {
          if ($m) {
            return $mapGet($m, key);
          }
        },
        has: function(key) {
          if ($m) {
            return $mapHas($m, key);
          }
          return false;
        },
        set: function(key, value) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/side-channel-weakmap/index.js
var require_side_channel_weakmap = __commonJS({
  "node_modules/side-channel-weakmap/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_call_bound();
    var inspect = require_object_inspect();
    var getSideChannelMap = require_side_channel_map();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $weakMapDelete = callBound("WeakMap.prototype.delete", true);
    module2.exports = $WeakMap ? (
      /** @type {Exclude<import('.'), false>} */
      function getSideChannelWeakMap() {
        var $wm;
        var $m;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          "delete": function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapDelete($wm, key);
              }
            } else if (getSideChannelMap) {
              if ($m) {
                return $m["delete"](key);
              }
            }
            return false;
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            }
            return $m && $m.get(key);
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            }
            return !!$m && $m.has(key);
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if (getSideChannelMap) {
              if (!$m) {
                $m = getSideChannelMap();
              }
              $m.set(key, value);
            }
          }
        };
        return channel;
      }
    ) : getSideChannelMap;
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var getSideChannelList = require_side_channel_list();
    var getSideChannelMap = require_side_channel_map();
    var getSideChannelWeakMap = require_side_channel_weakmap();
    var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
    module2.exports = function getSideChannel() {
      var $channelData;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        "delete": function(key) {
          return !!$channelData && $channelData["delete"](key);
        },
        get: function(key) {
          return $channelData && $channelData.get(key);
        },
        has: function(key) {
          return !!$channelData && $channelData.has(key);
        },
        set: function(key, value) {
          if (!$channelData) {
            $channelData = makeChannel();
          }
          $channelData.set(key, value);
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var getSideChannel = require_side_channel();
    var has3 = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var overflowChannel = getSideChannel();
    var markOverflow = function markOverflow2(obj, maxIndex) {
      overflowChannel.set(obj, maxIndex);
      return obj;
    };
    var isOverflow = function isOverflow2(obj) {
      return overflowChannel.has(obj);
    };
    var getMaxIndex = function getMaxIndex2(obj) {
      return overflowChannel.get(obj);
    };
    var setMaxIndex = function setMaxIndex2(obj, maxIndex) {
      overflowChannel.set(obj, maxIndex);
    };
    var hexTable = (function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array[array.length] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
      }
      return array;
    })();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted[compacted.length] = obj[j];
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options2) {
      var obj = options2 && options2.plainObjects ? { __proto__: null } : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options2) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object" && typeof source !== "function") {
        if (isArray(target)) {
          var nextIndex = target.length;
          if (options2 && typeof options2.arrayLimit === "number" && nextIndex > options2.arrayLimit) {
            return markOverflow(arrayToObject(target.concat(source), options2), nextIndex);
          }
          target[nextIndex] = source;
        } else if (target && typeof target === "object") {
          if (isOverflow(target)) {
            var newIndex = getMaxIndex(target) + 1;
            target[newIndex] = source;
            setMaxIndex(target, newIndex);
          } else if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has3.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        if (isOverflow(source)) {
          var sourceKeys = Object.keys(source);
          var result2 = options2 && options2.plainObjects ? { __proto__: null, 0: target } : { 0: target };
          for (var m = 0; m < sourceKeys.length; m++) {
            var oldKey = parseInt(sourceKeys[m], 10);
            result2[oldKey + 1] = source[sourceKeys[m]];
          }
          return markOverflow(result2, getMaxIndex(source) + 1);
        }
        var combined = [target].concat(source);
        if (options2 && typeof options2.arrayLimit === "number" && combined.length > options2.arrayLimit) {
          return markOverflow(arrayToObject(combined, options2), combined.length - 1);
        }
        return combined;
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options2);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has3.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options2);
            } else {
              target[target.length] = item;
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has3.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options2);
        } else {
          acc[key] = value;
        }
        if (isOverflow(source) && !isOverflow(acc)) {
          markOverflow(acc, getMaxIndex(source));
        }
        if (isOverflow(acc)) {
          var keyNum = parseInt(key, 10);
          if (String(keyNum) === key && keyNum >= 0 && keyNum > getMaxIndex(acc)) {
            setMaxIndex(acc, keyNum);
          }
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, defaultDecoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact2 = function compact3(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys2 = Object.keys(obj);
        for (var j = 0; j < keys2.length; ++j) {
          var key = keys2[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue[queue.length] = { obj, prop: key };
            refs[refs.length] = val;
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b, arrayLimit, plainObjects) {
      if (isOverflow(a)) {
        var newIndex = getMaxIndex(a) + 1;
        a[newIndex] = b;
        setMaxIndex(a, newIndex);
        return a;
      }
      var result2 = [].concat(a, b);
      if (result2.length > arrayLimit) {
        return markOverflow(arrayToObject(result2, { plainObjects }), result2.length - 1);
      }
      return result2;
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped[mapped.length] = fn(val[i]);
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact: compact2,
      decode,
      encode,
      isBuffer,
      isOverflow,
      isRegExp,
      markOverflow,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has3 = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push2 = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push2.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      commaRoundTrip: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      filter: void 0,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object2;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object2);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values2 = [];
      if (typeof obj === "undefined") {
        return values2;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter2)) {
        objKeys = filter2;
      } else {
        var keys2 = Object.keys(obj);
        objKeys = sort ? keys2.sort(sort) : keys2;
      }
      var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object2, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values2, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values2;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has3.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter2 = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: !!opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object2, opts) {
      var obj = object2;
      var options2 = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options2.filter === "function") {
        filter2 = options2.filter;
        obj = filter2("", obj);
      } else if (isArray(options2.filter)) {
        filter2 = options2.filter;
        objKeys = filter2;
      }
      var keys2 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options2.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options2.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options2.sort) {
        objKeys.sort(options2.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = obj[key];
        if (options2.skipNulls && value === null) {
          continue;
        }
        pushToArray(keys2, stringify(
          value,
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options2.allowEmptyArrays,
          options2.strictNullHandling,
          options2.skipNulls,
          options2.encodeDotInKeys,
          options2.encode ? options2.encoder : null,
          options2.filter,
          options2.sort,
          options2.allowDots,
          options2.serializeDate,
          options2.format,
          options2.formatter,
          options2.encodeValuesOnly,
          options2.charset,
          sideChannel
        ));
      }
      var joined = keys2.join(options2.delimiter);
      var prefix = options2.addQueryPrefix === true ? "?" : "";
      if (options2.charsetSentinel) {
        if (options2.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var has3 = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false,
      throwOnLimitExceeded: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options2, currentArrayLength) {
      if (val && typeof val === "string" && options2.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      if (options2.throwOnLimitExceeded && currentArrayLength >= options2.arrayLimit) {
        throw new RangeError("Array limit exceeded. Only " + options2.arrayLimit + " element" + (options2.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options2) {
      var obj = { __proto__: null };
      var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
      var parts = cleanStr.split(
        options2.delimiter,
        options2.throwOnLimitExceeded ? limit + 1 : limit
      );
      if (options2.throwOnLimitExceeded && parts.length > limit) {
        throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
      }
      var skipIndex = -1;
      var i;
      var charset = options2.charset;
      if (options2.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key;
        var val;
        if (pos === -1) {
          key = options2.decoder(part, defaults.decoder, charset, "key");
          val = options2.strictNullHandling ? null : "";
        } else {
          key = options2.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          if (key !== null) {
            val = utils.maybeMap(
              parseArrayValue(
                part.slice(pos + 1),
                options2,
                isArray(obj[key]) ? obj[key].length : 0
              ),
              function(encodedVal) {
                return options2.decoder(encodedVal, defaults.decoder, charset, "value");
              }
            );
          }
        }
        if (val && options2.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(String(val));
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        if (options2.comma && isArray(val) && val.length > options2.arrayLimit) {
          if (options2.throwOnLimitExceeded) {
            throw new RangeError("Array limit exceeded. Only " + options2.arrayLimit + " element" + (options2.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
          }
          val = utils.combine([], val, options2.arrayLimit, options2.plainObjects);
        }
        if (key !== null) {
          var existing = has3.call(obj, key);
          if (existing && options2.duplicates === "combine") {
            obj[key] = utils.combine(
              obj[key],
              val,
              options2.arrayLimit,
              options2.plainObjects
            );
          } else if (!existing || options2.duplicates === "last") {
            obj[key] = val;
          }
        }
      }
      return obj;
    };
    var parseObject = function(chain2, val, options2, valuesParsed) {
      var currentArrayLength = 0;
      if (chain2.length > 0 && chain2[chain2.length - 1] === "[]") {
        var parentKey = chain2.slice(0, -1).join("");
        currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
      }
      var leaf = valuesParsed ? val : parseArrayValue(val, options2, currentArrayLength);
      for (var i = chain2.length - 1; i >= 0; --i) {
        var obj;
        var root2 = chain2[i];
        if (root2 === "[]" && options2.parseArrays) {
          if (utils.isOverflow(leaf)) {
            obj = leaf;
          } else {
            obj = options2.allowEmptyArrays && (leaf === "" || options2.strictNullHandling && leaf === null) ? [] : utils.combine(
              [],
              leaf,
              options2.arrayLimit,
              options2.plainObjects
            );
          }
        } else {
          obj = options2.plainObjects ? { __proto__: null } : {};
          var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
          var decodedRoot = options2.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          var isValidArrayIndex = !isNaN(index) && root2 !== decodedRoot && String(index) === decodedRoot && index >= 0 && options2.parseArrays;
          if (!options2.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (isValidArrayIndex && index < options2.arrayLimit) {
            obj = [];
            obj[index] = leaf;
          } else if (isValidArrayIndex && options2.throwOnLimitExceeded) {
            throw new RangeError("Array limit exceeded. Only " + options2.arrayLimit + " element" + (options2.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
          } else if (isValidArrayIndex) {
            obj[index] = leaf;
            utils.markOverflow(obj, index);
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var splitKeyIntoSegments = function splitKeyIntoSegments2(givenKey, options2) {
      var key = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      if (options2.depth <= 0) {
        if (!options2.plainObjects && has3.call(Object.prototype, key)) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        return [key];
      }
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys2 = [];
      if (parent) {
        if (!options2.plainObjects && has3.call(Object.prototype, parent)) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys2[keys2.length] = parent;
      }
      var i = 0;
      while ((segment = child.exec(key)) !== null && i < options2.depth) {
        i += 1;
        var segmentContent = segment[1].slice(1, -1);
        if (!options2.plainObjects && has3.call(Object.prototype, segmentContent)) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys2[keys2.length] = segment[1];
      }
      if (segment) {
        if (options2.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options2.depth + " and strictDepth is true");
        }
        keys2[keys2.length] = "[" + key.slice(segment.index) + "]";
      }
      return keys2;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options2, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var keys2 = splitKeyIntoSegments(givenKey, options2);
      if (!keys2) {
        return;
      }
      return parseObject(keys2, val, options2, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
        throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
      };
    };
    module2.exports = function(str, opts) {
      var options2 = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options2.plainObjects ? { __proto__: null } : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
      var obj = options2.plainObjects ? { __proto__: null } : {};
      var keys2 = Object.keys(tempObj);
      for (var i = 0; i < keys2.length; ++i) {
        var key = keys2[i];
        var newObj = parseKeys(key, tempObj[key], options2, typeof str === "string");
        obj = utils.merge(obj, newObj, options2);
      }
      if (options2.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// node_modules/typed-rest-client/Util.js
var require_Util = __commonJS({
  "node_modules/typed-rest-client/Util.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUrl = getUrl;
    exports2.decompressGzippedContent = decompressGzippedContent;
    exports2.buildProxyBypassRegexFromEnv = buildProxyBypassRegexFromEnv;
    exports2.obtainContentCharset = obtainContentCharset;
    var qs = require_lib();
    var url = require("url");
    var path10 = require("path");
    var zlib = require("zlib");
    function getUrl(resource, baseUrl, queryParams) {
      const pathApi = path10.posix || path10;
      let requestUrl = "";
      if (!baseUrl) {
        requestUrl = resource;
      } else if (!resource) {
        requestUrl = baseUrl;
      } else {
        const base = url.parse(baseUrl);
        const resultantUrl = url.parse(resource);
        resultantUrl.protocol = resultantUrl.protocol || base.protocol;
        resultantUrl.auth = resultantUrl.auth || base.auth;
        resultantUrl.host = resultantUrl.host || base.host;
        resultantUrl.pathname = pathApi.resolve(base.pathname, resultantUrl.pathname);
        if (!resultantUrl.pathname.endsWith("/") && resource.endsWith("/")) {
          resultantUrl.pathname += "/";
        }
        requestUrl = url.format(resultantUrl);
      }
      return queryParams ? getUrlWithParsedQueryParams(requestUrl, queryParams) : requestUrl;
    }
    function getUrlWithParsedQueryParams(requestUrl, queryParams) {
      const url2 = requestUrl.replace(/\?$/g, "");
      const parsedQueryParams = qs.stringify(queryParams.params, buildParamsStringifyOptions(queryParams));
      return `${url2}${parsedQueryParams}`;
    }
    function buildParamsStringifyOptions(queryParams) {
      let options2 = {
        addQueryPrefix: true,
        delimiter: (queryParams.options || {}).separator || "&",
        allowDots: (queryParams.options || {}).shouldAllowDots || false,
        arrayFormat: (queryParams.options || {}).arrayFormat || "repeat",
        encodeValuesOnly: (queryParams.options || {}).shouldOnlyEncodeValues || true
      };
      return options2;
    }
    function decompressGzippedContent(buffer, charset) {
      return __awaiter3(this, void 0, void 0, function* () {
        return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
          zlib.gunzip(buffer, function(error2, buffer2) {
            if (error2) {
              reject2(error2);
            } else {
              resolve(buffer2.toString(charset || "utf-8"));
            }
          });
        }));
      });
    }
    function buildProxyBypassRegexFromEnv(bypass) {
      try {
        return new RegExp(bypass, "i");
      } catch (err) {
        if (err instanceof SyntaxError && (bypass || "").startsWith("*")) {
          let wildcardEscaped = bypass.replace("*", "(.*)");
          return new RegExp(wildcardEscaped, "i");
        }
        throw err;
      }
    }
    function obtainContentCharset(response) {
      const nodeSupportedEncodings = ["ascii", "utf8", "utf16le", "ucs2", "base64", "binary", "hex"];
      const contentType = response.message.headers["content-type"] || "";
      const matches = contentType.match(/charset=([^;,\r\n]+)/i);
      if (matches && matches[1] && nodeSupportedEncodings.indexOf(matches[1]) != -1) {
        return matches[1];
      }
      return "utf-8";
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert4 = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options2) {
      var agent = new TunnelingAgent(options2);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options2) {
      var agent = new TunnelingAgent(options2);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options2) {
      var agent = new TunnelingAgent(options2);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options2) {
      var agent = new TunnelingAgent(options2);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options2) {
      var self2 = this;
      self2.options = options2 || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options3 = toOptions(host, port, localAddress);
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === options3.host && pending.port === options3.port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options2 = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options2);
        return;
      }
      self2.createSocket(options2, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options2);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options2, cb2) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options2.host + ":" + options2.port,
        agent: false,
        headers: {
          host: options2.host + ":" + options2.port
        }
      });
      if (options2.localAddress) {
        connectOptions.localAddress = options2.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug5("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug5(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error2 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error2.code = "ECONNRESET";
          options2.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug5("got illegal response body from proxy");
          socket.destroy();
          var error2 = new Error("got illegal response body from proxy");
          error2.code = "ECONNRESET";
          options2.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        debug5("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb2(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug5(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
        error2.code = "ECONNRESET";
        options2.request.emit("error", error2);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options2, cb2) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options2, function(socket) {
        var hostHeader = options2.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options2.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb2(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys2 = Object.keys(overrides);
          for (var j = 0, keyLen = keys2.length; j < keyLen; ++j) {
            var k = keys2[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug5;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug5 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug5 = function() {
      };
    }
    exports2.debug = debug5;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// node_modules/typed-rest-client/HttpClient.js
var require_HttpClient = __commonJS({
  "node_modules/typed-rest-client/HttpClient.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.HttpClientResponse = exports2.HttpCodes = void 0;
    exports2.isHttps = isHttps;
    var url = require("url");
    var http = require("http");
    var https = require("https");
    var util = require_Util();
    var fs4;
    var tunnel;
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var HttpRedirectCodes = [HttpCodes.MovedPermanently, HttpCodes.ResourceMoved, HttpCodes.SeeOther, HttpCodes.TemporaryRedirect, HttpCodes.PermanentRedirect];
    var HttpResponseRetryCodes = [HttpCodes.BadGateway, HttpCodes.ServiceUnavailable, HttpCodes.GatewayTimeout];
    var NetworkRetryErrors = ["ECONNRESET", "ENOTFOUND", "ESOCKETTIMEDOUT", "ETIMEDOUT", "ECONNREFUSED", "EHOSTUNREACH"];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
          const chunks = [];
          const encodingCharset = util.obtainContentCharset(this);
          const contentEncoding = this.message.headers["content-encoding"] || "";
          const isGzippedEncoded = new RegExp("(gzip$)|(gzip, *deflate)").test(contentEncoding);
          this.message.on("data", function(data) {
            const chunk2 = typeof data === "string" ? Buffer.from(data, encodingCharset) : data;
            chunks.push(chunk2);
          }).on("end", function() {
            return __awaiter3(this, void 0, void 0, function* () {
              const buffer = Buffer.concat(chunks);
              if (isGzippedEncoded) {
                const gunzippedBody = yield util.decompressGzippedContent(buffer, encodingCharset);
                resolve(gunzippedBody);
              } else {
                resolve(buffer.toString(encodingCharset));
              }
            });
          }).on("error", function(err) {
            reject2(err);
          });
        }));
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      let parsedUrl = url.parse(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    var EnvironmentVariables;
    (function(EnvironmentVariables2) {
      EnvironmentVariables2["HTTP_PROXY"] = "HTTP_PROXY";
      EnvironmentVariables2["HTTPS_PROXY"] = "HTTPS_PROXY";
      EnvironmentVariables2["NO_PROXY"] = "NO_PROXY";
    })(EnvironmentVariables || (EnvironmentVariables = {}));
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this._httpGlobalAgentOptions = {
          keepAlive: false,
          timeout: 3e4
        };
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        let no_proxy = process.env[EnvironmentVariables.NO_PROXY];
        if (no_proxy) {
          this._httpProxyBypassHosts = [];
          no_proxy.split(",").forEach((bypass) => {
            this._httpProxyBypassHosts.push(util.buildProxyBypassRegexFromEnv(bypass));
          });
        }
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          this._httpProxy = requestOptions.proxy;
          if (requestOptions.proxy && requestOptions.proxy.proxyBypassHosts) {
            this._httpProxyBypassHosts = [];
            requestOptions.proxy.proxyBypassHosts.forEach((bypass) => {
              this._httpProxyBypassHosts.push(new RegExp(bypass, "i"));
            });
          }
          if (requestOptions.globalAgentOptions) {
            this._httpGlobalAgentOptions = requestOptions.globalAgentOptions;
          }
          this._certConfig = requestOptions.cert;
          if (this._certConfig) {
            fs4 = require("fs");
            if (this._certConfig.caFile && fs4.existsSync(this._certConfig.caFile)) {
              this._ca = fs4.readFileSync(this._certConfig.caFile, "utf8");
            }
            if (this._certConfig.certFile && fs4.existsSync(this._certConfig.certFile)) {
              this._cert = fs4.readFileSync(this._certConfig.certFile, "utf8");
            }
            if (this._certConfig.keyFile && fs4.existsSync(this._certConfig.keyFile)) {
              this._key = fs4.readFileSync(this._certConfig.keyFile, "utf8");
            }
          }
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      }
      get(requestUrl, additionalHeaders) {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      }
      del(requestUrl, additionalHeaders) {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      }
      post(requestUrl, data, additionalHeaders) {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      }
      patch(requestUrl, data, additionalHeaders) {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      }
      put(requestUrl, data, additionalHeaders) {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      }
      head(requestUrl, additionalHeaders) {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          let parsedUrl = url.parse(requestUrl);
          let info4 = this._prepareRequest(verb, parsedUrl, headers);
          let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          while (numTries < maxTries) {
            try {
              response = yield this.requestRaw(info4, data);
            } catch (err) {
              numTries++;
              if (err && err.code && NetworkRetryErrors.indexOf(err.code) > -1 && numTries < maxTries) {
                yield this._performExponentialBackoff(numTries);
                continue;
              }
              throw err;
            }
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (let i = 0; i < this.handlers.length; i++) {
                if (this.handlers[i].canHandleAuthentication(response)) {
                  authenticationHandler = this.handlers[i];
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info4, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              let parsedRedirectUrl = url.parse(redirectUrl);
              if (parsedUrl.protocol == "https:" && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              info4 = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info4, data);
              redirectsRemaining--;
            }
            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          }
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info4, data) {
        return new Promise((resolve, reject2) => {
          let callbackForResult = function(err, res) {
            if (err) {
              reject2(err);
            }
            resolve(res);
          };
          this.requestRawWithCallback(info4, data, callbackForResult);
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info4, data, onResult) {
        let socket;
        if (typeof data === "string") {
          info4.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        };
        let req = info4.httpModule.request(info4.options, (msg) => {
          let res = new HttpClientResponse(msg);
          handleResult(null, res);
        });
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.destroy();
          }
          handleResult(new Error("Request timeout: " + info4.options.path), null);
        });
        req.on("error", function(err) {
          handleResult(err, null);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      _prepareRequest(method, requestUrl, headers) {
        const info4 = {};
        info4.parsedUrl = requestUrl;
        const usingSsl = info4.parsedUrl.protocol === "https:";
        info4.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info4.options = {};
        info4.options.host = info4.parsedUrl.hostname;
        info4.options.port = info4.parsedUrl.port ? parseInt(info4.parsedUrl.port) : defaultPort;
        info4.options.path = (info4.parsedUrl.pathname || "") + (info4.parsedUrl.search || "");
        info4.options.method = method;
        info4.options.timeout = this.requestOptions && this.requestOptions.socketTimeout || this._socketTimeout;
        this._socketTimeout = info4.options.timeout;
        info4.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info4.options.headers["user-agent"] = this.userAgent;
        }
        info4.options.agent = this._getAgent(info4.parsedUrl);
        if (this.handlers && !this._isPresigned(url.format(requestUrl))) {
          this.handlers.forEach((handler) => {
            handler.prepareRequest(info4.options);
          });
        }
        return info4;
      }
      _isPresigned(requestUrl) {
        if (this.requestOptions && this.requestOptions.presignedUrlPatterns) {
          const patterns = this.requestOptions.presignedUrlPatterns;
          for (let i = 0; i < patterns.length; i++) {
            if (requestUrl.match(patterns[i])) {
              return true;
            }
          }
        }
        return false;
      }
      _mergeHeaders(headers) {
        const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
      }
      _getAgent(parsedUrl) {
        let agent;
        let proxy = this._getProxy(parsedUrl);
        let useProxy = proxy.proxyUrl && proxy.proxyUrl.hostname && !this._isMatchInBypassProxyList(parsedUrl);
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (!!agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (!!this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (useProxy) {
          if (!tunnel) {
            tunnel = require_tunnel2();
          }
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: {
              proxyAuth: proxy.proxyAuth,
              host: proxy.proxyUrl.hostname,
              port: proxy.proxyUrl.port
            }
          };
          let tunnelAgent;
          const overHttps = proxy.proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options2 = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options2) : new http.Agent(options2);
          this._agent = agent;
        }
        if (!agent) {
          const globalAgentOptions = {
            keepAlive: this._httpGlobalAgentOptions.keepAlive,
            timeout: this._httpGlobalAgentOptions.timeout
          };
          agent = usingSsl ? new https.Agent(globalAgentOptions) : new http.Agent(globalAgentOptions);
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
        }
        if (usingSsl && this._certConfig) {
          agent.options = Object.assign(agent.options || {}, { ca: this._ca, cert: this._cert, key: this._key, passphrase: this._certConfig.passphrase });
        }
        return agent;
      }
      _getProxy(parsedUrl) {
        let usingSsl = parsedUrl.protocol === "https:";
        let proxyConfig = this._httpProxy;
        let https_proxy = process.env[EnvironmentVariables.HTTPS_PROXY];
        let http_proxy = process.env[EnvironmentVariables.HTTP_PROXY];
        if (!proxyConfig) {
          if (https_proxy && usingSsl) {
            proxyConfig = {
              proxyUrl: https_proxy
            };
          } else if (http_proxy) {
            proxyConfig = {
              proxyUrl: http_proxy
            };
          }
        }
        let proxyUrl;
        let proxyAuth;
        if (proxyConfig) {
          if (proxyConfig.proxyUrl.length > 0) {
            proxyUrl = url.parse(proxyConfig.proxyUrl);
          }
          if (proxyConfig.proxyUsername || proxyConfig.proxyPassword) {
            proxyAuth = proxyConfig.proxyUsername + ":" + proxyConfig.proxyPassword;
          }
        }
        return { proxyUrl, proxyAuth };
      }
      _isMatchInBypassProxyList(parsedUrl) {
        if (!this._httpProxyBypassHosts) {
          return false;
        }
        let bypass = false;
        this._httpProxyBypassHosts.forEach((bypassHost) => {
          if (bypassHost.test(parsedUrl.href)) {
            bypass = true;
          }
        });
        return bypass;
      }
      _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      }
    };
    exports2.HttpClient = HttpClient;
  }
});

// node_modules/typed-rest-client/RestClient.js
var require_RestClient = __commonJS({
  "node_modules/typed-rest-client/RestClient.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestClient = void 0;
    var httpm = require_HttpClient();
    var util = require_Util();
    var RestClient = class _RestClient {
      /**
       * Creates an instance of the RestClient
       * @constructor
       * @param {string} userAgent - userAgent for requests
       * @param {string} baseUrl - (Optional) If not specified, use full urls per request.  If supplied and a function passes a relative url, it will be appended to this
       * @param {ifm.IRequestHandler[]} handlers - handlers are typically auth handlers (basic, bearer, ntlm supplied)
       * @param {ifm.IRequestOptions} requestOptions - options for each http requests (http proxy setting, socket timeout)
       */
      constructor(userAgent, baseUrl, handlers, requestOptions) {
        this.client = new httpm.HttpClient(userAgent, handlers, requestOptions);
        if (baseUrl) {
          this._baseUrl = baseUrl;
        }
      }
      /**
       * Gets a resource from an endpoint
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} requestUrl - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      options(requestUrl, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          let url = util.getUrl(requestUrl, this._baseUrl);
          let res = yield this.client.options(url, this._headersFromOptions(options2));
          return this.processResponse(res, options2);
        });
      }
      /**
       * Gets a resource from an endpoint
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified url or relative path
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      get(resource, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl, (options2 || {}).queryParameters);
          let res = yield this.client.get(url, this._headersFromOptions(options2));
          return this.processResponse(res, options2);
        });
      }
      /**
       * Deletes a resource from an endpoint
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      del(resource, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl, (options2 || {}).queryParameters);
          let res = yield this.client.del(url, this._headersFromOptions(options2));
          return this.processResponse(res, options2);
        });
      }
      /**
       * Creates resource(s) from an endpoint
       * T type of object returned.
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      create(resource, resources, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl);
          let headers = this._headersFromOptions(options2, true);
          let data = JSON.stringify(resources, null, 2);
          let res = yield this.client.post(url, data, headers);
          return this.processResponse(res, options2);
        });
      }
      /**
       * Updates resource(s) from an endpoint
       * T type of object returned.
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      update(resource, resources, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl);
          let headers = this._headersFromOptions(options2, true);
          let data = JSON.stringify(resources, null, 2);
          let res = yield this.client.patch(url, data, headers);
          return this.processResponse(res, options2);
        });
      }
      /**
       * Replaces resource(s) from an endpoint
       * T type of object returned.
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      replace(resource, resources, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl);
          let headers = this._headersFromOptions(options2, true);
          let data = JSON.stringify(resources, null, 2);
          let res = yield this.client.put(url, data, headers);
          return this.processResponse(res, options2);
        });
      }
      uploadStream(verb, requestUrl, stream, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          let url = util.getUrl(requestUrl, this._baseUrl);
          let headers = this._headersFromOptions(options2, true);
          let res = yield this.client.sendStream(verb, url, stream, headers);
          return this.processResponse(res, options2);
        });
      }
      _headersFromOptions(options2, contentType) {
        options2 = options2 || {};
        let headers = options2.additionalHeaders || {};
        headers["Accept"] = options2.acceptHeader || "application/json";
        if (contentType) {
          let found = false;
          for (let header in headers) {
            if (header.toLowerCase() == "content-type") {
              found = true;
            }
          }
          if (!found) {
            headers["Content-Type"] = "application/json; charset=utf-8";
          }
        }
        return headers;
      }
      static dateTimeDeserializer(key, value) {
        if (typeof value === "string") {
          let a = new Date(value);
          if (!isNaN(a.valueOf())) {
            return a;
          }
        }
        return value;
      }
      processResponse(res, options2) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode == httpm.HttpCodes.NotFound) {
              resolve(response);
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options2 && options2.deserializeDates) {
                  obj = JSON.parse(contents, _RestClient.dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                if (options2 && options2.responseProcessor) {
                  response.result = options2.responseProcessor(obj);
                } else {
                  response.result = obj;
                }
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = "Failed request: (" + statusCode + ")";
              }
              let err = new Error(msg);
              err["statusCode"] = statusCode;
              if (response.result) {
                err["result"] = response.result;
              }
              if (response.headers) {
                err["responseHeaders"] = response.headers;
              }
              reject2(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports2.RestClient = RestClient;
  }
});

// packages/core/node_modules/azure-devops-node-api/ClientApiBases.js
var require_ClientApiBases = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/ClientApiBases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientApiBase = void 0;
    var vsom = require_VsoClient();
    var serm = require_Serialization();
    var rm = require_RestClient();
    var hm = require_HttpClient();
    var ClientApiBase = class {
      constructor(baseUrl, handlers, userAgent, options2) {
        this.baseUrl = baseUrl;
        this.http = new hm.HttpClient(userAgent, handlers, options2);
        this.rest = new rm.RestClient(userAgent, null, handlers, options2);
        this.vsoClient = new vsom.VsoClient(baseUrl, this.rest);
        this.userAgent = userAgent;
      }
      createAcceptHeader(type, apiVersion) {
        return type + (apiVersion ? ";api-version=" + apiVersion : "");
      }
      createRequestOptions(type, apiVersion) {
        let options2 = {};
        options2.acceptHeader = this.createAcceptHeader(type, apiVersion);
        return options2;
      }
      formatResponse(data, responseTypeMetadata, isCollection) {
        let serializationData = {
          responseTypeMetadata,
          responseIsCollection: isCollection
        };
        let deserializedResult = serm.ContractSerializer.deserialize(data, serializationData.responseTypeMetadata, false, serializationData.responseIsCollection);
        return deserializedResult;
      }
      extractRateLimitHeaders(headers, target) {
        if (!headers || !target) {
          return;
        }
        const rateLimit = {};
        if (headers["x-ratelimit-resource"]) {
          rateLimit.resource = headers["x-ratelimit-resource"];
        }
        if (headers["x-ratelimit-delay"]) {
          rateLimit.delay = parseFloat(headers["x-ratelimit-delay"]);
        }
        if (headers["x-ratelimit-limit"]) {
          rateLimit.limit = parseInt(headers["x-ratelimit-limit"], 10);
        }
        if (headers["x-ratelimit-remaining"]) {
          rateLimit.remaining = parseInt(headers["x-ratelimit-remaining"], 10);
        }
        if (headers["x-ratelimit-reset"]) {
          rateLimit.reset = parseInt(headers["x-ratelimit-reset"], 10);
        }
        if (headers["retry-after"]) {
          rateLimit.retryAfter = parseInt(headers["retry-after"], 10);
        }
        target.rateLimit = rateLimit;
      }
    };
    exports2.ClientApiBase = ClientApiBase;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/AlertInterfaces.js
var require_AlertInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/AlertInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ValidationResult = exports2.State = exports2.Severity = exports2.SarifJobStatus = exports2.ResultType = exports2.MetadataOperation = exports2.MetadataChangeType = exports2.LicenseState = exports2.ExpandOption = exports2.DismissalType = exports2.DependencyKind = exports2.Confidence = exports2.ComponentType = exports2.AnalysisConfigurationType = exports2.AlertValidityStatus = exports2.AlertValidationRequestStatus = exports2.AlertType = exports2.AlertListExpandOption = void 0;
    var AlertListExpandOption;
    (function(AlertListExpandOption2) {
      AlertListExpandOption2[AlertListExpandOption2["None"] = 0] = "None";
      AlertListExpandOption2[AlertListExpandOption2["Minimal"] = 1] = "Minimal";
    })(AlertListExpandOption = exports2.AlertListExpandOption || (exports2.AlertListExpandOption = {}));
    var AlertType;
    (function(AlertType2) {
      AlertType2[AlertType2["Unknown"] = 0] = "Unknown";
      AlertType2[AlertType2["Dependency"] = 1] = "Dependency";
      AlertType2[AlertType2["Secret"] = 2] = "Secret";
      AlertType2[AlertType2["Code"] = 3] = "Code";
      AlertType2[AlertType2["License"] = 4] = "License";
    })(AlertType = exports2.AlertType || (exports2.AlertType = {}));
    var AlertValidationRequestStatus;
    (function(AlertValidationRequestStatus2) {
      AlertValidationRequestStatus2[AlertValidationRequestStatus2["None"] = 0] = "None";
      AlertValidationRequestStatus2[AlertValidationRequestStatus2["Created"] = 1] = "Created";
      AlertValidationRequestStatus2[AlertValidationRequestStatus2["InProgress"] = 2] = "InProgress";
      AlertValidationRequestStatus2[AlertValidationRequestStatus2["Completed"] = 3] = "Completed";
      AlertValidationRequestStatus2[AlertValidationRequestStatus2["Failed"] = 4] = "Failed";
    })(AlertValidationRequestStatus = exports2.AlertValidationRequestStatus || (exports2.AlertValidationRequestStatus = {}));
    var AlertValidityStatus;
    (function(AlertValidityStatus2) {
      AlertValidityStatus2[AlertValidityStatus2["None"] = 0] = "None";
      AlertValidityStatus2[AlertValidityStatus2["Unknown"] = 1] = "Unknown";
      AlertValidityStatus2[AlertValidityStatus2["Active"] = 2] = "Active";
      AlertValidityStatus2[AlertValidityStatus2["Inactive"] = 3] = "Inactive";
    })(AlertValidityStatus = exports2.AlertValidityStatus || (exports2.AlertValidityStatus = {}));
    var AnalysisConfigurationType;
    (function(AnalysisConfigurationType2) {
      AnalysisConfigurationType2[AnalysisConfigurationType2["Default"] = 0] = "Default";
      AnalysisConfigurationType2[AnalysisConfigurationType2["AdoPipeline"] = 1] = "AdoPipeline";
    })(AnalysisConfigurationType = exports2.AnalysisConfigurationType || (exports2.AnalysisConfigurationType = {}));
    var ComponentType;
    (function(ComponentType2) {
      ComponentType2[ComponentType2["Unknown"] = 0] = "Unknown";
      ComponentType2[ComponentType2["NuGet"] = 1] = "NuGet";
      ComponentType2[ComponentType2["Npm"] = 2] = "Npm";
      ComponentType2[ComponentType2["Maven"] = 3] = "Maven";
      ComponentType2[ComponentType2["Git"] = 4] = "Git";
      ComponentType2[ComponentType2["Other"] = 5] = "Other";
      ComponentType2[ComponentType2["RubyGems"] = 6] = "RubyGems";
      ComponentType2[ComponentType2["Cargo"] = 7] = "Cargo";
      ComponentType2[ComponentType2["Pip"] = 8] = "Pip";
      ComponentType2[ComponentType2["File"] = 9] = "File";
      ComponentType2[ComponentType2["Go"] = 10] = "Go";
      ComponentType2[ComponentType2["DockerImage"] = 11] = "DockerImage";
      ComponentType2[ComponentType2["Pod"] = 12] = "Pod";
      ComponentType2[ComponentType2["Linux"] = 13] = "Linux";
      ComponentType2[ComponentType2["Conda"] = 14] = "Conda";
      ComponentType2[ComponentType2["DockerReference"] = 15] = "DockerReference";
      ComponentType2[ComponentType2["Vcpkg"] = 16] = "Vcpkg";
    })(ComponentType = exports2.ComponentType || (exports2.ComponentType = {}));
    var Confidence;
    (function(Confidence2) {
      Confidence2[Confidence2["High"] = 0] = "High";
      Confidence2[Confidence2["Other"] = 1] = "Other";
    })(Confidence = exports2.Confidence || (exports2.Confidence = {}));
    var DependencyKind;
    (function(DependencyKind2) {
      DependencyKind2[DependencyKind2["Unknown"] = 0] = "Unknown";
      DependencyKind2[DependencyKind2["RootDependency"] = 1] = "RootDependency";
      DependencyKind2[DependencyKind2["Component"] = 2] = "Component";
      DependencyKind2[DependencyKind2["VulnerableDependency"] = 3] = "VulnerableDependency";
    })(DependencyKind = exports2.DependencyKind || (exports2.DependencyKind = {}));
    var DismissalType;
    (function(DismissalType2) {
      DismissalType2[DismissalType2["Unknown"] = 0] = "Unknown";
      DismissalType2[DismissalType2["Fixed"] = 1] = "Fixed";
      DismissalType2[DismissalType2["AcceptedRisk"] = 2] = "AcceptedRisk";
      DismissalType2[DismissalType2["FalsePositive"] = 3] = "FalsePositive";
      DismissalType2[DismissalType2["AgreedToGuidance"] = 4] = "AgreedToGuidance";
      DismissalType2[DismissalType2["ToolUpgrade"] = 5] = "ToolUpgrade";
    })(DismissalType = exports2.DismissalType || (exports2.DismissalType = {}));
    var ExpandOption;
    (function(ExpandOption2) {
      ExpandOption2[ExpandOption2["None"] = 0] = "None";
      ExpandOption2[ExpandOption2["ValidationFingerprint"] = 1] = "ValidationFingerprint";
    })(ExpandOption = exports2.ExpandOption || (exports2.ExpandOption = {}));
    var LicenseState;
    (function(LicenseState2) {
      LicenseState2[LicenseState2["Unknown"] = 0] = "Unknown";
      LicenseState2[LicenseState2["NotHarvested"] = 1] = "NotHarvested";
      LicenseState2[LicenseState2["Harvested"] = 2] = "Harvested";
    })(LicenseState = exports2.LicenseState || (exports2.LicenseState = {}));
    var MetadataChangeType;
    (function(MetadataChangeType2) {
      MetadataChangeType2[MetadataChangeType2["None"] = 0] = "None";
      MetadataChangeType2[MetadataChangeType2["Created"] = 1] = "Created";
      MetadataChangeType2[MetadataChangeType2["Updated"] = 2] = "Updated";
      MetadataChangeType2[MetadataChangeType2["Deleted"] = 3] = "Deleted";
    })(MetadataChangeType = exports2.MetadataChangeType || (exports2.MetadataChangeType = {}));
    var MetadataOperation;
    (function(MetadataOperation2) {
      MetadataOperation2[MetadataOperation2["None"] = 0] = "None";
      MetadataOperation2[MetadataOperation2["Add"] = 1] = "Add";
      MetadataOperation2[MetadataOperation2["Remove"] = 2] = "Remove";
    })(MetadataOperation = exports2.MetadataOperation || (exports2.MetadataOperation = {}));
    var ResultType;
    (function(ResultType2) {
      ResultType2[ResultType2["Unknown"] = 0] = "Unknown";
      ResultType2[ResultType2["Dependency"] = 1] = "Dependency";
      ResultType2[ResultType2["VersionControl"] = 2] = "VersionControl";
    })(ResultType = exports2.ResultType || (exports2.ResultType = {}));
    var SarifJobStatus;
    (function(SarifJobStatus2) {
      SarifJobStatus2[SarifJobStatus2["New"] = 0] = "New";
      SarifJobStatus2[SarifJobStatus2["Queued"] = 1] = "Queued";
      SarifJobStatus2[SarifJobStatus2["Completed"] = 2] = "Completed";
      SarifJobStatus2[SarifJobStatus2["Failed"] = 3] = "Failed";
      SarifJobStatus2[SarifJobStatus2["Requeued"] = 4] = "Requeued";
    })(SarifJobStatus = exports2.SarifJobStatus || (exports2.SarifJobStatus = {}));
    var Severity;
    (function(Severity2) {
      Severity2[Severity2["Low"] = 0] = "Low";
      Severity2[Severity2["Medium"] = 1] = "Medium";
      Severity2[Severity2["High"] = 2] = "High";
      Severity2[Severity2["Critical"] = 3] = "Critical";
      Severity2[Severity2["Note"] = 4] = "Note";
      Severity2[Severity2["Warning"] = 5] = "Warning";
      Severity2[Severity2["Error"] = 6] = "Error";
      Severity2[Severity2["Undefined"] = 7] = "Undefined";
    })(Severity = exports2.Severity || (exports2.Severity = {}));
    var State;
    (function(State2) {
      State2[State2["Unknown"] = 0] = "Unknown";
      State2[State2["Active"] = 1] = "Active";
      State2[State2["Dismissed"] = 2] = "Dismissed";
      State2[State2["Fixed"] = 4] = "Fixed";
      State2[State2["AutoDismissed"] = 8] = "AutoDismissed";
    })(State = exports2.State || (exports2.State = {}));
    var ValidationResult;
    (function(ValidationResult2) {
      ValidationResult2[ValidationResult2["None"] = 0] = "None";
      ValidationResult2[ValidationResult2["Exploitable"] = 1] = "Exploitable";
      ValidationResult2[ValidationResult2["NotExploitable"] = 2] = "NotExploitable";
      ValidationResult2[ValidationResult2["Inconclusive"] = 3] = "Inconclusive";
    })(ValidationResult = exports2.ValidationResult || (exports2.ValidationResult = {}));
    exports2.TypeInfo = {
      Alert: {},
      AlertAnalysisInstance: {},
      AlertListExpandOption: {
        enumValues: {
          "none": 0,
          "minimal": 1
        }
      },
      AlertMetadata: {},
      AlertMetadataChange: {},
      AlertStateUpdate: {},
      AlertType: {
        enumValues: {
          "unknown": 0,
          "dependency": 1,
          "secret": 2,
          "code": 3,
          "license": 4
        }
      },
      AlertValidationRequestStatus: {
        enumValues: {
          "none": 0,
          "created": 1,
          "inProgress": 2,
          "completed": 3,
          "failed": 4
        }
      },
      AlertValidityInfo: {},
      AlertValidityStatus: {
        enumValues: {
          "none": 0,
          "unknown": 1,
          "active": 2,
          "inactive": 3
        }
      },
      AnalysisConfiguration: {},
      AnalysisConfigurationType: {
        enumValues: {
          "default": 0,
          "adoPipeline": 1
        }
      },
      AnalysisInstance: {},
      AnalysisResult: {},
      Branch: {},
      ComponentType: {
        enumValues: {
          "unknown": 0,
          "nuGet": 1,
          "npm": 2,
          "maven": 3,
          "git": 4,
          "other": 5,
          "rubyGems": 6,
          "cargo": 7,
          "pip": 8,
          "file": 9,
          "go": 10,
          "dockerImage": 11,
          "pod": 12,
          "linux": 13,
          "conda": 14,
          "dockerReference": 15,
          "vcpkg": 16
        }
      },
      Confidence: {
        enumValues: {
          "high": 0,
          "other": 1
        }
      },
      Dependency: {},
      DependencyKind: {
        enumValues: {
          "unknown": 0,
          "rootDependency": 1,
          "component": 2,
          "vulnerableDependency": 3
        }
      },
      DependencyResult: {},
      Dismissal: {},
      DismissalType: {
        enumValues: {
          "unknown": 0,
          "fixed": 1,
          "acceptedRisk": 2,
          "falsePositive": 3,
          "agreedToGuidance": 4,
          "toolUpgrade": 5
        }
      },
      ExpandOption: {
        enumValues: {
          "none": 0,
          "validationFingerprint": 1
        }
      },
      License: {},
      LicenseState: {
        enumValues: {
          "unknown": 0,
          "notHarvested": 1,
          "harvested": 2
        }
      },
      LogicalLocation: {},
      Metadata: {},
      MetadataChange: {},
      MetadataChangeType: {
        enumValues: {
          "none": 0,
          "created": 1,
          "updated": 2,
          "deleted": 3
        }
      },
      MetadataOperation: {
        enumValues: {
          "none": 0,
          "add": 1,
          "remove": 2
        }
      },
      Result: {},
      ResultType: {
        enumValues: {
          "unknown": 0,
          "dependency": 1,
          "versionControl": 2
        }
      },
      SarifJobStatus: {
        enumValues: {
          "new": 0,
          "queued": 1,
          "completed": 2,
          "failed": 3,
          "requeued": 4
        }
      },
      SarifUploadStatus: {},
      SearchCriteria: {},
      Severity: {
        enumValues: {
          "low": 0,
          "medium": 1,
          "high": 2,
          "critical": 3,
          "note": 4,
          "warning": 5,
          "error": 6,
          "undefined": 7
        }
      },
      State: {
        enumValues: {
          "unknown": 0,
          "active": 1,
          "dismissed": 2,
          "fixed": 4,
          "autoDismissed": 8
        }
      },
      UxFilters: {},
      ValidationFingerprint: {},
      ValidationRequestInfo: {},
      ValidationResult: {
        enumValues: {
          "none": 0,
          "exploitable": 1,
          "notExploitable": 2,
          "inconclusive": 3
        }
      }
    };
    exports2.TypeInfo.Alert.fields = {
      alertType: {
        enumType: exports2.TypeInfo.AlertType
      },
      confidence: {
        enumType: exports2.TypeInfo.Confidence
      },
      dismissal: {
        typeInfo: exports2.TypeInfo.Dismissal
      },
      firstSeenDate: {
        isDate: true
      },
      fixedDate: {
        isDate: true
      },
      introducedDate: {
        isDate: true
      },
      lastSeenDate: {
        isDate: true
      },
      logicalLocations: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LogicalLocation
      },
      severity: {
        enumType: exports2.TypeInfo.Severity
      },
      state: {
        enumType: exports2.TypeInfo.State
      },
      validationFingerprints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ValidationFingerprint
      },
      validityDetails: {
        typeInfo: exports2.TypeInfo.AlertValidityInfo
      }
    };
    exports2.TypeInfo.AlertAnalysisInstance.fields = {
      analysisConfiguration: {
        typeInfo: exports2.TypeInfo.AnalysisConfiguration
      },
      firstSeen: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      fixedIn: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      lastSeen: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      recentAnalysisInstance: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      state: {
        enumType: exports2.TypeInfo.State
      }
    };
    exports2.TypeInfo.AlertMetadata.fields = {
      metadata: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Metadata
      }
    };
    exports2.TypeInfo.AlertMetadataChange.fields = {
      metadataChange: {
        typeInfo: exports2.TypeInfo.MetadataChange
      }
    };
    exports2.TypeInfo.AlertStateUpdate.fields = {
      dismissedReason: {
        enumType: exports2.TypeInfo.DismissalType
      },
      state: {
        enumType: exports2.TypeInfo.State
      }
    };
    exports2.TypeInfo.AlertValidityInfo.fields = {
      validityLastCheckedDate: {
        isDate: true
      },
      validityStatus: {
        enumType: exports2.TypeInfo.AlertValidityStatus
      }
    };
    exports2.TypeInfo.AnalysisConfiguration.fields = {
      alertType: {
        enumType: exports2.TypeInfo.AlertType
      },
      analysisConfigurationType: {
        enumType: exports2.TypeInfo.AnalysisConfigurationType
      }
    };
    exports2.TypeInfo.AnalysisInstance.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.AnalysisConfiguration
      },
      createdDate: {
        isDate: true
      },
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AnalysisResult
      }
    };
    exports2.TypeInfo.AnalysisResult.fields = {
      result: {
        typeInfo: exports2.TypeInfo.Result
      },
      state: {
        enumType: exports2.TypeInfo.State
      }
    };
    exports2.TypeInfo.Branch.fields = {
      deletedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Dependency.fields = {
      componentType: {
        enumType: exports2.TypeInfo.ComponentType
      },
      license: {
        typeInfo: exports2.TypeInfo.License
      }
    };
    exports2.TypeInfo.DependencyResult.fields = {
      dependency: {
        typeInfo: exports2.TypeInfo.Dependency
      }
    };
    exports2.TypeInfo.Dismissal.fields = {
      dismissalType: {
        enumType: exports2.TypeInfo.DismissalType
      },
      requestedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.License.fields = {
      state: {
        enumType: exports2.TypeInfo.LicenseState
      }
    };
    exports2.TypeInfo.LogicalLocation.fields = {
      kind: {
        enumType: exports2.TypeInfo.DependencyKind
      },
      license: {
        typeInfo: exports2.TypeInfo.License
      }
    };
    exports2.TypeInfo.Metadata.fields = {
      op: {
        enumType: exports2.TypeInfo.MetadataOperation
      }
    };
    exports2.TypeInfo.MetadataChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.MetadataChangeType
      }
    };
    exports2.TypeInfo.Result.fields = {
      dependencyResult: {
        typeInfo: exports2.TypeInfo.DependencyResult
      },
      resultType: {
        enumType: exports2.TypeInfo.ResultType
      },
      severity: {
        enumType: exports2.TypeInfo.Severity
      }
    };
    exports2.TypeInfo.SarifUploadStatus.fields = {
      processingStatus: {
        enumType: exports2.TypeInfo.SarifJobStatus
      }
    };
    exports2.TypeInfo.SearchCriteria.fields = {
      alertType: {
        enumType: exports2.TypeInfo.AlertType
      },
      confidenceLevels: {
        isArray: true,
        enumType: exports2.TypeInfo.Confidence
      },
      fromDate: {
        isDate: true
      },
      modifiedSince: {
        isDate: true
      },
      severities: {
        isArray: true,
        enumType: exports2.TypeInfo.Severity
      },
      states: {
        isArray: true,
        enumType: exports2.TypeInfo.State
      },
      toDate: {
        isDate: true
      },
      validity: {
        isArray: true,
        enumType: exports2.TypeInfo.AlertValidityStatus
      }
    };
    exports2.TypeInfo.UxFilters.fields = {
      branches: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Branch
      },
      confidenceLevels: {
        isArray: true,
        enumType: exports2.TypeInfo.Confidence
      },
      licenses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.License
      },
      packages: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Dependency
      },
      severities: {
        isArray: true,
        enumType: exports2.TypeInfo.Severity
      },
      states: {
        isArray: true,
        enumType: exports2.TypeInfo.State
      },
      validity: {
        isArray: true,
        enumType: exports2.TypeInfo.AlertValidityStatus
      }
    };
    exports2.TypeInfo.ValidationFingerprint.fields = {
      validityLastUpdatedDate: {
        isDate: true
      },
      validityResult: {
        enumType: exports2.TypeInfo.ValidationResult
      }
    };
    exports2.TypeInfo.ValidationRequestInfo.fields = {
      alertValidationRequestStatus: {
        enumType: exports2.TypeInfo.AlertValidationRequestStatus
      },
      validityLastCheckedDate: {
        isDate: true
      },
      validityStatus: {
        enumType: exports2.TypeInfo.AlertValidityStatus
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/AlertApi.js
var require_AlertApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/AlertApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlertApi = void 0;
    var basem = require_ClientApiBases();
    var AlertInterfaces = require_AlertInterfaces();
    var AlertApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Alert-api", options2);
      }
      /**
       * Get an alert.
       *
       * @param {string} project - Project ID or project name
       * @param {number} alertId - ID of alert to retrieve
       * @param {string} repository - Name or id  of a repository that alert is part of
       * @param {string} ref
       * @param {AlertInterfaces.ExpandOption} expand - Expand alert attributes. Possible options are {ValidationFingerprint, None}
       */
      getAlert(project, alertId, repository, ref, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            let queryValues = {
              ref,
              expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.Alert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get alerts for a repository
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       * @param {number} top - The maximum number of alerts to return
       * @param {string} orderBy - Must be "id" "firstSeen" "lastSeen" "fixedOn" or "severity"  Defaults to "id"
       * @param {AlertInterfaces.SearchCriteria} criteria - Options to limit the alerts returned
       * @param {AlertInterfaces.AlertListExpandOption} expand
       * @param {string} continuationToken - If there are more alerts than can be returned, a continuation token is placed in the "x-ms-continuationtoken" header.  Use that token here to get the next page of alerts
       */
      getAlerts(project, repository, top, orderBy, criteria, expand, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            let queryValues = {
              top,
              orderBy,
              criteria,
              expand,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.Alert, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an alert.
       *
       * @param {string} project - Project ID or project name
       * @param {number} alertId - ID of alert to retrieve
       * @param {string} repository - Name or id  of a repository that alert is part of
       * @param {string} ref
       * @param {AlertInterfaces.ExpandOption} expand - Expand alert attributes. Possible options are {ValidationFingerprint, None}
       */
      getAlertSarif(project, alertId, repository, ref, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            let queryValues = {
              ref,
              expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of an alert
       *
       * @param {AlertInterfaces.AlertStateUpdate} stateUpdate - The new status of the alert
       * @param {string} project - Project ID or project name
       * @param {number} alertId - The ID of the alert
       * @param {string} repository - The name or ID of the repository
       */
      updateAlert(stateUpdate, project, alertId, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, stateUpdate, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.Alert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the branches for which analysis results were submitted.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository
       * @param {AlertInterfaces.AlertType} alertType - The type of alert: Dependency Scanning (1), Secret (2), Code QL (3), etc.
       * @param {string} continuationToken - A string variable that represents the branch name and is used to fetch branches that follow it in alphabetical order.
       * @param {string} branchNameContains - A string variable used to fetch branches that contain this string anywhere in the branch name, case insensitive.
       * @param {number} top - An int variable used to return the top k branches that satisfy the search criteria.
       * @param {boolean} includePullRequestBranches - A bool variable indicating whether or not to include pull request branches.
       */
      getBranches(project, repository, alertType, continuationToken, branchNameContains, top, includePullRequestBranches) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (alertType == null) {
            throw new TypeError("alertType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Branches",
              project,
              repository
            };
            let queryValues = {
              alertType,
              continuationToken,
              branchNameContains,
              top,
              includePullRequestBranches
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "8f90675b-f794-434d-8f2c-cfae0a11c02a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.Branch, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} repository
       * @param {AlertInterfaces.AlertType} alertType
       */
      getUxFilters(project, repository, alertType) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (alertType == null) {
            throw new TypeError("alertType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              project,
              repository
            };
            let queryValues = {
              alertType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "8f90675b-f794-434d-8f2c-cfae0a11c02a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.UxFilters, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get instances of an alert on a branch specified with @ref. If @ref is not provided, return instances of an alert on default branch(if the alert exist in default branch) or latest affected branch.
       *
       * @param {string} project - Project ID or project name
       * @param {number} alertId - ID of alert to retrieve
       * @param {string} repository - Name or id of a repository that alert is part of
       * @param {string} ref
       */
      getAlertInstances(project, alertId, repository, ref) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            let queryValues = {
              ref
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "f451ba96-0e95-458a-8dd5-3df894770a49", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.AlertAnalysisInstance, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create legal review. This creates the legal review associated with the alert. It include the review work item url.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - Name or id  of a repository for the legal alert
       * @param {number} alertId - Advance Security alert id of the legal alert to get the legal review
       * @param {string} ref
       */
      createLegalReview(project, repository, alertId, ref) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (alertId == null) {
            throw new TypeError("alertId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            let queryValues = {
              alertId,
              ref
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "65de4b84-7519-4ae8-8623-175f79b49b80", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update alert metadata associations.
       *
       * @param {AlertInterfaces.AlertMetadata[]} alertsMetadata - A list of metadata to associate with alerts.
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository.
       */
      updateAlertsMetadata(alertsMetadata, project, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "65de4b84-7519-4ae8-8623-175f79b49b80", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, alertsMetadata, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.AlertMetadataChange, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Upload a Sarif containing security alerts
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of a repository
       * @param {String} notificationFlag - Header to signal that this is a progress notification
       */
      uploadSarif(customHeaders, contentStream, project, repository, notificationFlag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-AdvSec-NotificationSarif"] = "notificationFlag";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "2a141cae-a50d-4c22-b41b-13f77748d035", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the status of the Sarif processing job
       *
       * @param {number} sarifId - Sarif ID returned when the Sarif was uploaded
       */
      getSarif(sarifId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              sarifId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Alert", "a04689e7-0f81-48a2-8d18-40654c47494c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.SarifUploadStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the validity details for an alert.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of a repository
       * @param {number} alertId - The ID of the alert
       */
      getValidityData(project, repository, alertId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository,
              alertId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "2e022520-3508-4b5f-9855-acb954d673ba", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.ValidationRequestInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Initiate the validation process for a given alert
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of a repository
       * @param {number} alertId - The ID of the alert
       */
      initiateValidation(project, repository, alertId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository,
              alertId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "2e022520-3508-4b5f-9855-acb954d673ba", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.AlertValidationRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.AlertApi = AlertApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/common/SystemDataInterfaces.js
var require_SystemDataInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/common/SystemDataInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.SqlDbType = void 0;
    var SqlDbType;
    (function(SqlDbType2) {
      SqlDbType2[SqlDbType2["BigInt"] = 0] = "BigInt";
      SqlDbType2[SqlDbType2["Binary"] = 1] = "Binary";
      SqlDbType2[SqlDbType2["Bit"] = 2] = "Bit";
      SqlDbType2[SqlDbType2["Char"] = 3] = "Char";
      SqlDbType2[SqlDbType2["DateTime"] = 4] = "DateTime";
      SqlDbType2[SqlDbType2["Decimal"] = 5] = "Decimal";
      SqlDbType2[SqlDbType2["Float"] = 6] = "Float";
      SqlDbType2[SqlDbType2["Image"] = 7] = "Image";
      SqlDbType2[SqlDbType2["Int"] = 8] = "Int";
      SqlDbType2[SqlDbType2["Money"] = 9] = "Money";
      SqlDbType2[SqlDbType2["NChar"] = 10] = "NChar";
      SqlDbType2[SqlDbType2["NText"] = 11] = "NText";
      SqlDbType2[SqlDbType2["NVarChar"] = 12] = "NVarChar";
      SqlDbType2[SqlDbType2["Real"] = 13] = "Real";
      SqlDbType2[SqlDbType2["UniqueIdentifier"] = 14] = "UniqueIdentifier";
      SqlDbType2[SqlDbType2["SmallDateTime"] = 15] = "SmallDateTime";
      SqlDbType2[SqlDbType2["SmallInt"] = 16] = "SmallInt";
      SqlDbType2[SqlDbType2["SmallMoney"] = 17] = "SmallMoney";
      SqlDbType2[SqlDbType2["Text"] = 18] = "Text";
      SqlDbType2[SqlDbType2["Timestamp"] = 19] = "Timestamp";
      SqlDbType2[SqlDbType2["TinyInt"] = 20] = "TinyInt";
      SqlDbType2[SqlDbType2["VarBinary"] = 21] = "VarBinary";
      SqlDbType2[SqlDbType2["VarChar"] = 22] = "VarChar";
      SqlDbType2[SqlDbType2["Variant"] = 23] = "Variant";
      SqlDbType2[SqlDbType2["Xml"] = 25] = "Xml";
      SqlDbType2[SqlDbType2["Udt"] = 29] = "Udt";
      SqlDbType2[SqlDbType2["Structured"] = 30] = "Structured";
      SqlDbType2[SqlDbType2["Date"] = 31] = "Date";
      SqlDbType2[SqlDbType2["Time"] = 32] = "Time";
      SqlDbType2[SqlDbType2["DateTime2"] = 33] = "DateTime2";
      SqlDbType2[SqlDbType2["DateTimeOffset"] = 34] = "DateTimeOffset";
    })(SqlDbType = exports2.SqlDbType || (exports2.SqlDbType = {}));
    exports2.TypeInfo = {
      SqlDbType: {
        enumValues: {
          "BigInt": 0,
          "Binary": 1,
          "Bit": 2,
          "Char": 3,
          "DateTime": 4,
          "Decimal": 5,
          "Float": 6,
          "Image": 7,
          "Int": 8,
          "Money": 9,
          "NChar": 10,
          "NText": 11,
          "NVarChar": 12,
          "Real": 13,
          "UniqueIdentifier": 14,
          "SmallDateTime": 15,
          "SmallInt": 16,
          "SmallMoney": 17,
          "Text": 18,
          "Timestamp": 19,
          "TinyInt": 20,
          "VarBinary": 21,
          "VarChar": 22,
          "Variant": 23,
          "Xml": 25,
          "Udt": 29,
          "Structured": 30,
          "Date": 31,
          "Time": 32,
          "DateTime2": 33,
          "DateTimeOffset": 34
        }
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/CoreInterfaces.js
var require_CoreInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/CoreInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.SourceControlTypes = exports2.ProjectVisibility = exports2.ProjectChangeType = exports2.ProcessType = exports2.ProcessCustomizationType = exports2.ConnectedServiceKind = void 0;
    var ConnectedServiceKind;
    (function(ConnectedServiceKind2) {
      ConnectedServiceKind2[ConnectedServiceKind2["Custom"] = 0] = "Custom";
      ConnectedServiceKind2[ConnectedServiceKind2["AzureSubscription"] = 1] = "AzureSubscription";
      ConnectedServiceKind2[ConnectedServiceKind2["Chef"] = 2] = "Chef";
      ConnectedServiceKind2[ConnectedServiceKind2["Generic"] = 3] = "Generic";
    })(ConnectedServiceKind = exports2.ConnectedServiceKind || (exports2.ConnectedServiceKind = {}));
    var ProcessCustomizationType;
    (function(ProcessCustomizationType2) {
      ProcessCustomizationType2[ProcessCustomizationType2["Unknown"] = -1] = "Unknown";
      ProcessCustomizationType2[ProcessCustomizationType2["Xml"] = 0] = "Xml";
      ProcessCustomizationType2[ProcessCustomizationType2["Inherited"] = 1] = "Inherited";
    })(ProcessCustomizationType = exports2.ProcessCustomizationType || (exports2.ProcessCustomizationType = {}));
    var ProcessType;
    (function(ProcessType2) {
      ProcessType2[ProcessType2["System"] = 0] = "System";
      ProcessType2[ProcessType2["Custom"] = 1] = "Custom";
      ProcessType2[ProcessType2["Inherited"] = 2] = "Inherited";
    })(ProcessType = exports2.ProcessType || (exports2.ProcessType = {}));
    var ProjectChangeType;
    (function(ProjectChangeType2) {
      ProjectChangeType2[ProjectChangeType2["Modified"] = 0] = "Modified";
      ProjectChangeType2[ProjectChangeType2["Deleted"] = 1] = "Deleted";
      ProjectChangeType2[ProjectChangeType2["Added"] = 2] = "Added";
    })(ProjectChangeType = exports2.ProjectChangeType || (exports2.ProjectChangeType = {}));
    var ProjectVisibility;
    (function(ProjectVisibility2) {
      ProjectVisibility2[ProjectVisibility2["Unchanged"] = -1] = "Unchanged";
      ProjectVisibility2[ProjectVisibility2["Private"] = 0] = "Private";
      ProjectVisibility2[ProjectVisibility2["Organization"] = 1] = "Organization";
      ProjectVisibility2[ProjectVisibility2["Public"] = 2] = "Public";
      ProjectVisibility2[ProjectVisibility2["SystemPrivate"] = 3] = "SystemPrivate";
    })(ProjectVisibility = exports2.ProjectVisibility || (exports2.ProjectVisibility = {}));
    var SourceControlTypes;
    (function(SourceControlTypes2) {
      SourceControlTypes2[SourceControlTypes2["Tfvc"] = 1] = "Tfvc";
      SourceControlTypes2[SourceControlTypes2["Git"] = 2] = "Git";
    })(SourceControlTypes = exports2.SourceControlTypes || (exports2.SourceControlTypes = {}));
    exports2.TypeInfo = {
      ConnectedServiceKind: {
        enumValues: {
          "custom": 0,
          "azureSubscription": 1,
          "chef": 2,
          "generic": 3
        }
      },
      Process: {},
      ProcessCustomizationType: {
        enumValues: {
          "unknown": -1,
          "xml": 0,
          "inherited": 1
        }
      },
      ProcessType: {
        enumValues: {
          "system": 0,
          "custom": 1,
          "inherited": 2
        }
      },
      ProjectChangeType: {
        enumValues: {
          "modified": 0,
          "deleted": 1,
          "added": 2
        }
      },
      ProjectInfo: {},
      ProjectMessage: {},
      ProjectVisibility: {
        enumValues: {
          "private": 0,
          "organization": 1,
          "public": 2
        }
      },
      SourceControlTypes: {
        enumValues: {
          "tfvc": 1,
          "git": 2
        }
      },
      TeamProject: {},
      TeamProjectCollection: {},
      TeamProjectReference: {},
      TemporaryDataCreatedDTO: {},
      WebApiConnectedService: {},
      WebApiConnectedServiceDetails: {},
      WebApiProject: {}
    };
    exports2.TypeInfo.Process.fields = {
      type: {
        enumType: exports2.TypeInfo.ProcessType
      }
    };
    exports2.TypeInfo.ProjectInfo.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.ProjectMessage.fields = {
      project: {
        typeInfo: exports2.TypeInfo.ProjectInfo
      },
      projectChangeType: {
        enumType: exports2.TypeInfo.ProjectChangeType
      }
    };
    exports2.TypeInfo.TeamProject.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.TeamProjectCollection.fields = {
      processCustomizationType: {
        enumType: exports2.TypeInfo.ProcessCustomizationType
      }
    };
    exports2.TypeInfo.TeamProjectReference.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.TemporaryDataCreatedDTO.fields = {
      expirationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.WebApiConnectedService.fields = {
      project: {
        typeInfo: exports2.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.WebApiConnectedServiceDetails.fields = {
      connectedServiceMetaData: {
        typeInfo: exports2.TypeInfo.WebApiConnectedService
      }
    };
    exports2.TypeInfo.WebApiProject.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/TestInterfaces.js
var require_TestInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/TestInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.TestSessionState = exports2.TestSessionSource = exports2.TestRunSubstate = exports2.TestRunState = exports2.TestRunPublishContext = exports2.TestRunOutcome = exports2.TestResultsSettingsType = exports2.TestResultsSessionState = exports2.TestResultsContextType = exports2.TestResultGroupBy = exports2.TestPointState = exports2.TestOutcome = exports2.TestLogType = exports2.TestLogStoreOperationType = exports2.TestLogStoreEndpointType = exports2.TestLogStatusCode = exports2.TestLogScope = exports2.TestConfigurationState = exports2.TCMServiceDataMigrationStatus = exports2.SuiteExpand = exports2.SessionResult = exports2.Service = exports2.RunType = exports2.ResultObjectType = exports2.ResultMetaDataDetails = exports2.ResultMetadata = exports2.ResultGroupType = exports2.ResultDetails = exports2.OperationType = exports2.Metrics = exports2.FlakyDetectionType = exports2.CustomTestFieldType = exports2.CustomTestFieldScope = exports2.CoverageSummaryStatus = exports2.CoverageStatus = exports2.CoverageQueryFlags = exports2.CoverageDetailedSummaryStatus = exports2.CloneOperationState = exports2.AttachmentType = void 0;
    var SystemData = require_SystemDataInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var AttachmentType;
    (function(AttachmentType2) {
      AttachmentType2[AttachmentType2["GeneralAttachment"] = 0] = "GeneralAttachment";
      AttachmentType2[AttachmentType2["AfnStrip"] = 1] = "AfnStrip";
      AttachmentType2[AttachmentType2["BugFilingData"] = 2] = "BugFilingData";
      AttachmentType2[AttachmentType2["CodeCoverage"] = 3] = "CodeCoverage";
      AttachmentType2[AttachmentType2["IntermediateCollectorData"] = 4] = "IntermediateCollectorData";
      AttachmentType2[AttachmentType2["RunConfig"] = 5] = "RunConfig";
      AttachmentType2[AttachmentType2["TestImpactDetails"] = 6] = "TestImpactDetails";
      AttachmentType2[AttachmentType2["TmiTestRunDeploymentFiles"] = 7] = "TmiTestRunDeploymentFiles";
      AttachmentType2[AttachmentType2["TmiTestRunReverseDeploymentFiles"] = 8] = "TmiTestRunReverseDeploymentFiles";
      AttachmentType2[AttachmentType2["TmiTestResultDetail"] = 9] = "TmiTestResultDetail";
      AttachmentType2[AttachmentType2["TmiTestRunSummary"] = 10] = "TmiTestRunSummary";
      AttachmentType2[AttachmentType2["ConsoleLog"] = 11] = "ConsoleLog";
    })(AttachmentType = exports2.AttachmentType || (exports2.AttachmentType = {}));
    var CloneOperationState;
    (function(CloneOperationState2) {
      CloneOperationState2[CloneOperationState2["Failed"] = 2] = "Failed";
      CloneOperationState2[CloneOperationState2["InProgress"] = 1] = "InProgress";
      CloneOperationState2[CloneOperationState2["Queued"] = 0] = "Queued";
      CloneOperationState2[CloneOperationState2["Succeeded"] = 3] = "Succeeded";
    })(CloneOperationState = exports2.CloneOperationState || (exports2.CloneOperationState = {}));
    var CoverageDetailedSummaryStatus;
    (function(CoverageDetailedSummaryStatus2) {
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["None"] = 0] = "None";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["InProgress"] = 1] = "InProgress";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["Finalized"] = 2] = "Finalized";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["Pending"] = 3] = "Pending";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["UpdateRequestQueued"] = 4] = "UpdateRequestQueued";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NoModulesFound"] = 5] = "NoModulesFound";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NumberOfFilesExceeded"] = 6] = "NumberOfFilesExceeded";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NoInputFiles"] = 7] = "NoInputFiles";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["BuildCancelled"] = 8] = "BuildCancelled";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["FailedJobs"] = 9] = "FailedJobs";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["ModuleMergeJobTimeout"] = 10] = "ModuleMergeJobTimeout";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["CodeCoverageSuccess"] = 11] = "CodeCoverageSuccess";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["InvalidBuildConfiguration"] = 12] = "InvalidBuildConfiguration";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["CoverageAnalyzerBuildNotFound"] = 13] = "CoverageAnalyzerBuildNotFound";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["FailedToRequeue"] = 14] = "FailedToRequeue";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["BuildBailedOut"] = 15] = "BuildBailedOut";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NoCodeCoverageTask"] = 16] = "NoCodeCoverageTask";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MergeJobFailed"] = 17] = "MergeJobFailed";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MergeInvokerJobFailed"] = 18] = "MergeInvokerJobFailed";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MonitorJobFailed"] = 19] = "MonitorJobFailed";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["ModuleMergeInvokerJobTimeout"] = 20] = "ModuleMergeInvokerJobTimeout";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MonitorJobTimeout"] = 21] = "MonitorJobTimeout";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["InvalidCoverageInput"] = 22] = "InvalidCoverageInput";
    })(CoverageDetailedSummaryStatus = exports2.CoverageDetailedSummaryStatus || (exports2.CoverageDetailedSummaryStatus = {}));
    var CoverageQueryFlags;
    (function(CoverageQueryFlags2) {
      CoverageQueryFlags2[CoverageQueryFlags2["Modules"] = 1] = "Modules";
      CoverageQueryFlags2[CoverageQueryFlags2["Functions"] = 2] = "Functions";
      CoverageQueryFlags2[CoverageQueryFlags2["BlockData"] = 4] = "BlockData";
    })(CoverageQueryFlags = exports2.CoverageQueryFlags || (exports2.CoverageQueryFlags = {}));
    var CoverageStatus;
    (function(CoverageStatus2) {
      CoverageStatus2[CoverageStatus2["Covered"] = 0] = "Covered";
      CoverageStatus2[CoverageStatus2["NotCovered"] = 1] = "NotCovered";
      CoverageStatus2[CoverageStatus2["PartiallyCovered"] = 2] = "PartiallyCovered";
    })(CoverageStatus = exports2.CoverageStatus || (exports2.CoverageStatus = {}));
    var CoverageSummaryStatus;
    (function(CoverageSummaryStatus2) {
      CoverageSummaryStatus2[CoverageSummaryStatus2["None"] = 0] = "None";
      CoverageSummaryStatus2[CoverageSummaryStatus2["InProgress"] = 1] = "InProgress";
      CoverageSummaryStatus2[CoverageSummaryStatus2["Completed"] = 2] = "Completed";
      CoverageSummaryStatus2[CoverageSummaryStatus2["Finalized"] = 3] = "Finalized";
      CoverageSummaryStatus2[CoverageSummaryStatus2["Pending"] = 4] = "Pending";
      CoverageSummaryStatus2[CoverageSummaryStatus2["UpdateRequestQueued"] = 5] = "UpdateRequestQueued";
    })(CoverageSummaryStatus = exports2.CoverageSummaryStatus || (exports2.CoverageSummaryStatus = {}));
    var CustomTestFieldScope;
    (function(CustomTestFieldScope2) {
      CustomTestFieldScope2[CustomTestFieldScope2["None"] = 0] = "None";
      CustomTestFieldScope2[CustomTestFieldScope2["TestRun"] = 1] = "TestRun";
      CustomTestFieldScope2[CustomTestFieldScope2["TestResult"] = 2] = "TestResult";
      CustomTestFieldScope2[CustomTestFieldScope2["TestRunAndTestResult"] = 3] = "TestRunAndTestResult";
      CustomTestFieldScope2[CustomTestFieldScope2["System"] = 4] = "System";
      CustomTestFieldScope2[CustomTestFieldScope2["All"] = 7] = "All";
    })(CustomTestFieldScope = exports2.CustomTestFieldScope || (exports2.CustomTestFieldScope = {}));
    var CustomTestFieldType;
    (function(CustomTestFieldType2) {
      CustomTestFieldType2[CustomTestFieldType2["Bit"] = 2] = "Bit";
      CustomTestFieldType2[CustomTestFieldType2["DateTime"] = 4] = "DateTime";
      CustomTestFieldType2[CustomTestFieldType2["Int"] = 8] = "Int";
      CustomTestFieldType2[CustomTestFieldType2["Float"] = 6] = "Float";
      CustomTestFieldType2[CustomTestFieldType2["String"] = 12] = "String";
      CustomTestFieldType2[CustomTestFieldType2["Guid"] = 14] = "Guid";
    })(CustomTestFieldType = exports2.CustomTestFieldType || (exports2.CustomTestFieldType = {}));
    var FlakyDetectionType;
    (function(FlakyDetectionType2) {
      FlakyDetectionType2[FlakyDetectionType2["Custom"] = 1] = "Custom";
      FlakyDetectionType2[FlakyDetectionType2["System"] = 2] = "System";
    })(FlakyDetectionType = exports2.FlakyDetectionType || (exports2.FlakyDetectionType = {}));
    var Metrics;
    (function(Metrics2) {
      Metrics2[Metrics2["All"] = 1] = "All";
      Metrics2[Metrics2["ResultSummary"] = 2] = "ResultSummary";
      Metrics2[Metrics2["ResultsAnalysis"] = 3] = "ResultsAnalysis";
      Metrics2[Metrics2["RunSummary"] = 4] = "RunSummary";
    })(Metrics = exports2.Metrics || (exports2.Metrics = {}));
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["Add"] = 1] = "Add";
      OperationType2[OperationType2["Delete"] = 2] = "Delete";
    })(OperationType = exports2.OperationType || (exports2.OperationType = {}));
    var ResultDetails;
    (function(ResultDetails2) {
      ResultDetails2[ResultDetails2["None"] = 0] = "None";
      ResultDetails2[ResultDetails2["Iterations"] = 1] = "Iterations";
      ResultDetails2[ResultDetails2["WorkItems"] = 2] = "WorkItems";
      ResultDetails2[ResultDetails2["SubResults"] = 4] = "SubResults";
      ResultDetails2[ResultDetails2["Point"] = 8] = "Point";
    })(ResultDetails = exports2.ResultDetails || (exports2.ResultDetails = {}));
    var ResultGroupType;
    (function(ResultGroupType2) {
      ResultGroupType2[ResultGroupType2["None"] = 0] = "None";
      ResultGroupType2[ResultGroupType2["Rerun"] = 1] = "Rerun";
      ResultGroupType2[ResultGroupType2["DataDriven"] = 2] = "DataDriven";
      ResultGroupType2[ResultGroupType2["OrderedTest"] = 3] = "OrderedTest";
      ResultGroupType2[ResultGroupType2["Generic"] = 4] = "Generic";
    })(ResultGroupType = exports2.ResultGroupType || (exports2.ResultGroupType = {}));
    var ResultMetadata;
    (function(ResultMetadata2) {
      ResultMetadata2[ResultMetadata2["Rerun"] = 1] = "Rerun";
      ResultMetadata2[ResultMetadata2["Flaky"] = 2] = "Flaky";
    })(ResultMetadata = exports2.ResultMetadata || (exports2.ResultMetadata = {}));
    var ResultMetaDataDetails;
    (function(ResultMetaDataDetails2) {
      ResultMetaDataDetails2[ResultMetaDataDetails2["None"] = 0] = "None";
      ResultMetaDataDetails2[ResultMetaDataDetails2["FlakyIdentifiers"] = 1] = "FlakyIdentifiers";
    })(ResultMetaDataDetails = exports2.ResultMetaDataDetails || (exports2.ResultMetaDataDetails = {}));
    var ResultObjectType;
    (function(ResultObjectType2) {
      ResultObjectType2[ResultObjectType2["TestSuite"] = 0] = "TestSuite";
      ResultObjectType2[ResultObjectType2["TestPlan"] = 1] = "TestPlan";
    })(ResultObjectType = exports2.ResultObjectType || (exports2.ResultObjectType = {}));
    var RunType;
    (function(RunType2) {
      RunType2[RunType2["Unspecified"] = 0] = "Unspecified";
      RunType2[RunType2["Normal"] = 1] = "Normal";
      RunType2[RunType2["Blocking"] = 2] = "Blocking";
      RunType2[RunType2["Web"] = 4] = "Web";
      RunType2[RunType2["MtrRunInitiatedFromWeb"] = 8] = "MtrRunInitiatedFromWeb";
      RunType2[RunType2["RunWithDtlEnv"] = 16] = "RunWithDtlEnv";
      RunType2[RunType2["NoConfigRun"] = 32] = "NoConfigRun";
    })(RunType = exports2.RunType || (exports2.RunType = {}));
    var Service;
    (function(Service2) {
      Service2[Service2["Any"] = 0] = "Any";
      Service2[Service2["Tcm"] = 1] = "Tcm";
      Service2[Service2["Tfs"] = 2] = "Tfs";
    })(Service = exports2.Service || (exports2.Service = {}));
    var SessionResult;
    (function(SessionResult2) {
      SessionResult2[SessionResult2["None"] = 0] = "None";
      SessionResult2[SessionResult2["Passed"] = 1] = "Passed";
      SessionResult2[SessionResult2["Failed"] = 2] = "Failed";
      SessionResult2[SessionResult2["Pending"] = 3] = "Pending";
    })(SessionResult = exports2.SessionResult || (exports2.SessionResult = {}));
    var SuiteExpand;
    (function(SuiteExpand2) {
      SuiteExpand2[SuiteExpand2["Children"] = 1] = "Children";
      SuiteExpand2[SuiteExpand2["DefaultTesters"] = 2] = "DefaultTesters";
    })(SuiteExpand = exports2.SuiteExpand || (exports2.SuiteExpand = {}));
    var TCMServiceDataMigrationStatus;
    (function(TCMServiceDataMigrationStatus2) {
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["NotStarted"] = 0] = "NotStarted";
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["InProgress"] = 1] = "InProgress";
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["Completed"] = 2] = "Completed";
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["Failed"] = 3] = "Failed";
    })(TCMServiceDataMigrationStatus = exports2.TCMServiceDataMigrationStatus || (exports2.TCMServiceDataMigrationStatus = {}));
    var TestConfigurationState;
    (function(TestConfigurationState2) {
      TestConfigurationState2[TestConfigurationState2["Active"] = 1] = "Active";
      TestConfigurationState2[TestConfigurationState2["Inactive"] = 2] = "Inactive";
    })(TestConfigurationState = exports2.TestConfigurationState || (exports2.TestConfigurationState = {}));
    var TestLogScope;
    (function(TestLogScope2) {
      TestLogScope2[TestLogScope2["Run"] = 0] = "Run";
      TestLogScope2[TestLogScope2["Build"] = 1] = "Build";
      TestLogScope2[TestLogScope2["Release"] = 2] = "Release";
    })(TestLogScope = exports2.TestLogScope || (exports2.TestLogScope = {}));
    var TestLogStatusCode;
    (function(TestLogStatusCode2) {
      TestLogStatusCode2[TestLogStatusCode2["Success"] = 0] = "Success";
      TestLogStatusCode2[TestLogStatusCode2["Failed"] = 1] = "Failed";
      TestLogStatusCode2[TestLogStatusCode2["FileAlreadyExists"] = 2] = "FileAlreadyExists";
      TestLogStatusCode2[TestLogStatusCode2["InvalidInput"] = 3] = "InvalidInput";
      TestLogStatusCode2[TestLogStatusCode2["InvalidFileName"] = 4] = "InvalidFileName";
      TestLogStatusCode2[TestLogStatusCode2["InvalidContainer"] = 5] = "InvalidContainer";
      TestLogStatusCode2[TestLogStatusCode2["TransferFailed"] = 6] = "TransferFailed";
      TestLogStatusCode2[TestLogStatusCode2["FeatureDisabled"] = 7] = "FeatureDisabled";
      TestLogStatusCode2[TestLogStatusCode2["BuildDoesNotExist"] = 8] = "BuildDoesNotExist";
      TestLogStatusCode2[TestLogStatusCode2["RunDoesNotExist"] = 9] = "RunDoesNotExist";
      TestLogStatusCode2[TestLogStatusCode2["ContainerNotCreated"] = 10] = "ContainerNotCreated";
      TestLogStatusCode2[TestLogStatusCode2["APINotSupported"] = 11] = "APINotSupported";
      TestLogStatusCode2[TestLogStatusCode2["FileSizeExceeds"] = 12] = "FileSizeExceeds";
      TestLogStatusCode2[TestLogStatusCode2["ContainerNotFound"] = 13] = "ContainerNotFound";
      TestLogStatusCode2[TestLogStatusCode2["FileNotFound"] = 14] = "FileNotFound";
      TestLogStatusCode2[TestLogStatusCode2["DirectoryNotFound"] = 15] = "DirectoryNotFound";
      TestLogStatusCode2[TestLogStatusCode2["StorageCapacityExceeded"] = 16] = "StorageCapacityExceeded";
    })(TestLogStatusCode = exports2.TestLogStatusCode || (exports2.TestLogStatusCode = {}));
    var TestLogStoreEndpointType;
    (function(TestLogStoreEndpointType2) {
      TestLogStoreEndpointType2[TestLogStoreEndpointType2["Root"] = 1] = "Root";
      TestLogStoreEndpointType2[TestLogStoreEndpointType2["File"] = 2] = "File";
    })(TestLogStoreEndpointType = exports2.TestLogStoreEndpointType || (exports2.TestLogStoreEndpointType = {}));
    var TestLogStoreOperationType;
    (function(TestLogStoreOperationType2) {
      TestLogStoreOperationType2[TestLogStoreOperationType2["Read"] = 1] = "Read";
      TestLogStoreOperationType2[TestLogStoreOperationType2["Create"] = 2] = "Create";
      TestLogStoreOperationType2[TestLogStoreOperationType2["ReadAndCreate"] = 3] = "ReadAndCreate";
    })(TestLogStoreOperationType = exports2.TestLogStoreOperationType || (exports2.TestLogStoreOperationType = {}));
    var TestLogType;
    (function(TestLogType2) {
      TestLogType2[TestLogType2["GeneralAttachment"] = 1] = "GeneralAttachment";
      TestLogType2[TestLogType2["CodeCoverage"] = 2] = "CodeCoverage";
      TestLogType2[TestLogType2["TestImpact"] = 3] = "TestImpact";
      TestLogType2[TestLogType2["Intermediate"] = 4] = "Intermediate";
      TestLogType2[TestLogType2["System"] = 5] = "System";
      TestLogType2[TestLogType2["MergedCoverageFile"] = 6] = "MergedCoverageFile";
    })(TestLogType = exports2.TestLogType || (exports2.TestLogType = {}));
    var TestOutcome;
    (function(TestOutcome2) {
      TestOutcome2[TestOutcome2["Unspecified"] = 0] = "Unspecified";
      TestOutcome2[TestOutcome2["None"] = 1] = "None";
      TestOutcome2[TestOutcome2["Passed"] = 2] = "Passed";
      TestOutcome2[TestOutcome2["Failed"] = 3] = "Failed";
      TestOutcome2[TestOutcome2["Inconclusive"] = 4] = "Inconclusive";
      TestOutcome2[TestOutcome2["Timeout"] = 5] = "Timeout";
      TestOutcome2[TestOutcome2["Aborted"] = 6] = "Aborted";
      TestOutcome2[TestOutcome2["Blocked"] = 7] = "Blocked";
      TestOutcome2[TestOutcome2["NotExecuted"] = 8] = "NotExecuted";
      TestOutcome2[TestOutcome2["Warning"] = 9] = "Warning";
      TestOutcome2[TestOutcome2["Error"] = 10] = "Error";
      TestOutcome2[TestOutcome2["NotApplicable"] = 11] = "NotApplicable";
      TestOutcome2[TestOutcome2["Paused"] = 12] = "Paused";
      TestOutcome2[TestOutcome2["InProgress"] = 13] = "InProgress";
      TestOutcome2[TestOutcome2["NotImpacted"] = 14] = "NotImpacted";
      TestOutcome2[TestOutcome2["MaxValue"] = 14] = "MaxValue";
    })(TestOutcome = exports2.TestOutcome || (exports2.TestOutcome = {}));
    var TestPointState;
    (function(TestPointState2) {
      TestPointState2[TestPointState2["None"] = 0] = "None";
      TestPointState2[TestPointState2["Ready"] = 1] = "Ready";
      TestPointState2[TestPointState2["Completed"] = 2] = "Completed";
      TestPointState2[TestPointState2["NotReady"] = 3] = "NotReady";
      TestPointState2[TestPointState2["InProgress"] = 4] = "InProgress";
      TestPointState2[TestPointState2["MaxValue"] = 4] = "MaxValue";
    })(TestPointState = exports2.TestPointState || (exports2.TestPointState = {}));
    var TestResultGroupBy;
    (function(TestResultGroupBy2) {
      TestResultGroupBy2[TestResultGroupBy2["Branch"] = 1] = "Branch";
      TestResultGroupBy2[TestResultGroupBy2["Environment"] = 2] = "Environment";
    })(TestResultGroupBy = exports2.TestResultGroupBy || (exports2.TestResultGroupBy = {}));
    var TestResultsContextType;
    (function(TestResultsContextType2) {
      TestResultsContextType2[TestResultsContextType2["Build"] = 1] = "Build";
      TestResultsContextType2[TestResultsContextType2["Release"] = 2] = "Release";
      TestResultsContextType2[TestResultsContextType2["Pipeline"] = 3] = "Pipeline";
    })(TestResultsContextType = exports2.TestResultsContextType || (exports2.TestResultsContextType = {}));
    var TestResultsSessionState;
    (function(TestResultsSessionState2) {
      TestResultsSessionState2[TestResultsSessionState2["None"] = 0] = "None";
      TestResultsSessionState2[TestResultsSessionState2["Running"] = 1] = "Running";
      TestResultsSessionState2[TestResultsSessionState2["Completed"] = 2] = "Completed";
      TestResultsSessionState2[TestResultsSessionState2["Waiting"] = 3] = "Waiting";
      TestResultsSessionState2[TestResultsSessionState2["Cancelled"] = 4] = "Cancelled";
    })(TestResultsSessionState = exports2.TestResultsSessionState || (exports2.TestResultsSessionState = {}));
    var TestResultsSettingsType;
    (function(TestResultsSettingsType2) {
      TestResultsSettingsType2[TestResultsSettingsType2["All"] = 1] = "All";
      TestResultsSettingsType2[TestResultsSettingsType2["Flaky"] = 2] = "Flaky";
      TestResultsSettingsType2[TestResultsSettingsType2["NewTestLogging"] = 3] = "NewTestLogging";
    })(TestResultsSettingsType = exports2.TestResultsSettingsType || (exports2.TestResultsSettingsType = {}));
    var TestRunOutcome;
    (function(TestRunOutcome2) {
      TestRunOutcome2[TestRunOutcome2["Passed"] = 0] = "Passed";
      TestRunOutcome2[TestRunOutcome2["Failed"] = 1] = "Failed";
      TestRunOutcome2[TestRunOutcome2["NotImpacted"] = 2] = "NotImpacted";
      TestRunOutcome2[TestRunOutcome2["Others"] = 3] = "Others";
    })(TestRunOutcome = exports2.TestRunOutcome || (exports2.TestRunOutcome = {}));
    var TestRunPublishContext;
    (function(TestRunPublishContext2) {
      TestRunPublishContext2[TestRunPublishContext2["Build"] = 1] = "Build";
      TestRunPublishContext2[TestRunPublishContext2["Release"] = 2] = "Release";
      TestRunPublishContext2[TestRunPublishContext2["All"] = 3] = "All";
    })(TestRunPublishContext = exports2.TestRunPublishContext || (exports2.TestRunPublishContext = {}));
    var TestRunState;
    (function(TestRunState2) {
      TestRunState2[TestRunState2["Unspecified"] = 0] = "Unspecified";
      TestRunState2[TestRunState2["NotStarted"] = 1] = "NotStarted";
      TestRunState2[TestRunState2["InProgress"] = 2] = "InProgress";
      TestRunState2[TestRunState2["Completed"] = 3] = "Completed";
      TestRunState2[TestRunState2["Aborted"] = 4] = "Aborted";
      TestRunState2[TestRunState2["Waiting"] = 5] = "Waiting";
      TestRunState2[TestRunState2["NeedsInvestigation"] = 6] = "NeedsInvestigation";
    })(TestRunState = exports2.TestRunState || (exports2.TestRunState = {}));
    var TestRunSubstate;
    (function(TestRunSubstate2) {
      TestRunSubstate2[TestRunSubstate2["None"] = 0] = "None";
      TestRunSubstate2[TestRunSubstate2["CreatingEnvironment"] = 1] = "CreatingEnvironment";
      TestRunSubstate2[TestRunSubstate2["RunningTests"] = 2] = "RunningTests";
      TestRunSubstate2[TestRunSubstate2["CanceledByUser"] = 3] = "CanceledByUser";
      TestRunSubstate2[TestRunSubstate2["AbortedBySystem"] = 4] = "AbortedBySystem";
      TestRunSubstate2[TestRunSubstate2["TimedOut"] = 5] = "TimedOut";
      TestRunSubstate2[TestRunSubstate2["PendingAnalysis"] = 6] = "PendingAnalysis";
      TestRunSubstate2[TestRunSubstate2["Analyzed"] = 7] = "Analyzed";
      TestRunSubstate2[TestRunSubstate2["CancellationInProgress"] = 8] = "CancellationInProgress";
    })(TestRunSubstate = exports2.TestRunSubstate || (exports2.TestRunSubstate = {}));
    var TestSessionSource;
    (function(TestSessionSource2) {
      TestSessionSource2[TestSessionSource2["Unknown"] = 0] = "Unknown";
      TestSessionSource2[TestSessionSource2["XTDesktop"] = 1] = "XTDesktop";
      TestSessionSource2[TestSessionSource2["FeedbackDesktop"] = 2] = "FeedbackDesktop";
      TestSessionSource2[TestSessionSource2["XTWeb"] = 3] = "XTWeb";
      TestSessionSource2[TestSessionSource2["FeedbackWeb"] = 4] = "FeedbackWeb";
      TestSessionSource2[TestSessionSource2["XTDesktop2"] = 5] = "XTDesktop2";
      TestSessionSource2[TestSessionSource2["SessionInsightsForAll"] = 6] = "SessionInsightsForAll";
    })(TestSessionSource = exports2.TestSessionSource || (exports2.TestSessionSource = {}));
    var TestSessionState;
    (function(TestSessionState2) {
      TestSessionState2[TestSessionState2["Unspecified"] = 0] = "Unspecified";
      TestSessionState2[TestSessionState2["NotStarted"] = 1] = "NotStarted";
      TestSessionState2[TestSessionState2["InProgress"] = 2] = "InProgress";
      TestSessionState2[TestSessionState2["Paused"] = 3] = "Paused";
      TestSessionState2[TestSessionState2["Completed"] = 4] = "Completed";
      TestSessionState2[TestSessionState2["Declined"] = 5] = "Declined";
    })(TestSessionState = exports2.TestSessionState || (exports2.TestSessionState = {}));
    exports2.TypeInfo = {
      AfnStrip: {},
      AggregatedDataForResultTrend: {},
      AggregatedResultDetailsByOutcome: {},
      AggregatedResultsAnalysis: {},
      AggregatedResultsByOutcome: {},
      AggregatedRunsByOutcome: {},
      AggregatedRunsByState: {},
      AttachmentType: {
        enumValues: {
          "generalAttachment": 0,
          "afnStrip": 1,
          "bugFilingData": 2,
          "codeCoverage": 3,
          "intermediateCollectorData": 4,
          "runConfig": 5,
          "testImpactDetails": 6,
          "tmiTestRunDeploymentFiles": 7,
          "tmiTestRunReverseDeploymentFiles": 8,
          "tmiTestResultDetail": 9,
          "tmiTestRunSummary": 10,
          "consoleLog": 11
        }
      },
      BatchResponse: {},
      BuildConfiguration: {},
      BuildCoverage: {},
      BuildReference2: {},
      BulkResultUpdateRequest: {},
      CloneOperationInformation: {},
      CloneOperationState: {
        enumValues: {
          "failed": 2,
          "inProgress": 1,
          "queued": 0,
          "succeeded": 3
        }
      },
      CodeCoverageSummary: {},
      Coverage2: {},
      CoverageDetailedSummaryStatus: {
        enumValues: {
          "none": 0,
          "inProgress": 1,
          "finalized": 2,
          "pending": 3,
          "updateRequestQueued": 4,
          "noModulesFound": 5,
          "numberOfFilesExceeded": 6,
          "noInputFiles": 7,
          "buildCancelled": 8,
          "failedJobs": 9,
          "moduleMergeJobTimeout": 10,
          "codeCoverageSuccess": 11,
          "invalidBuildConfiguration": 12,
          "coverageAnalyzerBuildNotFound": 13,
          "failedToRequeue": 14,
          "buildBailedOut": 15,
          "noCodeCoverageTask": 16,
          "mergeJobFailed": 17,
          "mergeInvokerJobFailed": 18,
          "monitorJobFailed": 19,
          "moduleMergeInvokerJobTimeout": 20,
          "monitorJobTimeout": 21,
          "invalidCoverageInput": 22
        }
      },
      CoverageQueryFlags: {
        enumValues: {
          "modules": 1,
          "functions": 2,
          "blockData": 4
        }
      },
      CoverageStatus: {
        enumValues: {
          "covered": 0,
          "notCovered": 1,
          "partiallyCovered": 2
        }
      },
      CoverageSummaryStatus: {
        enumValues: {
          "none": 0,
          "inProgress": 1,
          "completed": 2,
          "finalized": 3,
          "pending": 4,
          "updateRequestQueued": 5
        }
      },
      CreateTestMessageLogEntryRequest: {},
      CreateTestResultsRequest: {},
      CreateTestRunRequest: {},
      CustomTestFieldDefinition: {},
      CustomTestFieldScope: {
        enumValues: {
          "none": 0,
          "testRun": 1,
          "testResult": 2,
          "testRunAndTestResult": 3,
          "system": 4,
          "all": 7
        }
      },
      CustomTestFieldType: {
        enumValues: {
          "bit": 2,
          "dateTime": 4,
          "int": 8,
          "float": 6,
          "string": 12,
          "guid": 14
        }
      },
      DatedTestFieldData: {},
      FailingSince: {},
      FetchTestResultsResponse: {},
      FlakyDetection: {},
      FlakyDetectionType: {
        enumValues: {
          "custom": 1,
          "system": 2
        }
      },
      FlakySettings: {},
      LastResultDetails: {},
      LegacyBuildConfiguration: {},
      LegacyReleaseReference: {},
      LegacyTestCaseResult: {},
      LegacyTestRun: {},
      LegacyTestSettings: {},
      Machine: {},
      Metrics: {
        enumValues: {
          "all": 1,
          "resultSummary": 2,
          "resultsAnalysis": 3,
          "runSummary": 4
        }
      },
      OperationType: {
        enumValues: {
          "add": 1,
          "delete": 2
        }
      },
      PipelineTestMetrics: {},
      PointLastResult: {},
      PointsResults2: {},
      QueryTestActionResultResponse: {},
      ReleaseReference: {},
      ReleaseReference2: {},
      RequirementsToTestsMapping2: {},
      Response: {},
      ResultDetails: {
        enumValues: {
          "none": 0,
          "iterations": 1,
          "workItems": 2,
          "subResults": 4,
          "point": 8
        }
      },
      ResultGroupType: {
        enumValues: {
          "none": 0,
          "rerun": 1,
          "dataDriven": 2,
          "orderedTest": 3,
          "generic": 4
        }
      },
      ResultMetadata: {
        enumValues: {
          "rerun": 1,
          "flaky": 2
        }
      },
      ResultMetaDataDetails: {
        enumValues: {
          "none": 0,
          "flakyIdentifiers": 1
        }
      },
      ResultObjectType: {
        enumValues: {
          "testSuite": 0,
          "testPlan": 1
        }
      },
      ResultRetentionSettings: {},
      ResultsByQueryResponse: {},
      ResultsFilter: {},
      ResultsSummaryByOutcome: {},
      ResultSummary: {},
      ResultUpdateRequest: {},
      ResultUpdateRequestModel: {},
      ResultUpdateResponse: {},
      RunCreateModel: {},
      RunStatistic: {},
      RunSummary: {},
      RunSummaryModel: {},
      RunType: {
        enumValues: {
          "unspecified": 0,
          "normal": 1,
          "blocking": 2,
          "web": 4,
          "mtrRunInitiatedFromWeb": 8,
          "runWithDtlEnv": 16,
          "noConfigRun": 32
        }
      },
      RunUpdateModel: {},
      Service: {
        enumValues: {
          "any": 0,
          "tcm": 1,
          "tfs": 2
        }
      },
      SessionEnvironmentAndMachine: {},
      SessionResult: {
        enumValues: {
          "none": 0,
          "passed": 1,
          "failed": 2,
          "pending": 3
        }
      },
      SourceViewBuildCoverage: {},
      SuiteExpand: {
        enumValues: {
          "children": 1,
          "defaultTesters": 2
        }
      },
      TCMServiceDataMigrationStatus: {
        enumValues: {
          "notStarted": 0,
          "inProgress": 1,
          "completed": 2,
          "failed": 3
        }
      },
      TestActionResult: {},
      TestActionResult2: {},
      TestActionResultModel: {},
      TestAttachment: {},
      TestAuthoringDetails: {},
      TestCaseReference2: {},
      TestCaseResult: {},
      TestConfiguration: {},
      TestConfigurationState: {
        enumValues: {
          "active": 1,
          "inactive": 2
        }
      },
      TestExecutionReportData: {},
      TestExtensionField: {},
      TestExtensionFieldDetails: {},
      TestFailuresAnalysis: {},
      TestHistoryQuery: {},
      TestIterationDetailsModel: {},
      TestLog: {},
      TestLogReference: {},
      TestLogScope: {
        enumValues: {
          "run": 0,
          "build": 1,
          "release": 2
        }
      },
      TestLogStatus: {},
      TestLogStatusCode: {
        enumValues: {
          "success": 0,
          "failed": 1,
          "fileAlreadyExists": 2,
          "invalidInput": 3,
          "invalidFileName": 4,
          "invalidContainer": 5,
          "transferFailed": 6,
          "featureDisabled": 7,
          "buildDoesNotExist": 8,
          "runDoesNotExist": 9,
          "containerNotCreated": 10,
          "apiNotSupported": 11,
          "fileSizeExceeds": 12,
          "containerNotFound": 13,
          "fileNotFound": 14,
          "directoryNotFound": 15,
          "storageCapacityExceeded": 16
        }
      },
      TestLogStoreAttachment: {},
      TestLogStoreEndpointDetails: {},
      TestLogStoreEndpointType: {
        enumValues: {
          "root": 1,
          "file": 2
        }
      },
      TestLogStoreOperationType: {
        enumValues: {
          "read": 1,
          "create": 2,
          "readAndCreate": 3
        }
      },
      TestLogType: {
        enumValues: {
          "generalAttachment": 1,
          "codeCoverage": 2,
          "testImpact": 3,
          "intermediate": 4,
          "system": 5,
          "mergedCoverageFile": 6
        }
      },
      TestMessageLogDetails: {},
      TestMessageLogEntry: {},
      TestMessageLogEntry2: {},
      TestMethod: {},
      TestOutcome: {
        enumValues: {
          "unspecified": 0,
          "none": 1,
          "passed": 2,
          "failed": 3,
          "inconclusive": 4,
          "timeout": 5,
          "aborted": 6,
          "blocked": 7,
          "notExecuted": 8,
          "warning": 9,
          "error": 10,
          "notApplicable": 11,
          "paused": 12,
          "inProgress": 13,
          "notImpacted": 14,
          "maxValue": 14
        }
      },
      TestParameter2: {},
      TestPlan: {},
      TestPlanCloneRequest: {},
      TestPlanHubData: {},
      TestPlansWithSelection: {},
      TestPoint: {},
      TestPointReference: {},
      TestPointsEvent: {},
      TestPointsQuery: {},
      TestPointState: {
        enumValues: {
          "none": 0,
          "ready": 1,
          "completed": 2,
          "notReady": 3,
          "inProgress": 4,
          "maxValue": 4
        }
      },
      TestPointsUpdatedEvent: {},
      TestResult2: {},
      TestResultAcrossProjectResponse: {},
      TestResultAttachment: {},
      TestResultGroupBy: {
        enumValues: {
          "branch": 1,
          "environment": 2
        }
      },
      TestResultHistory: {},
      TestResultHistoryDetailsForGroup: {},
      TestResultHistoryForGroup: {},
      TestResultModelBase: {},
      TestResultReset2: {},
      TestResultsContext: {},
      TestResultsContextType: {
        enumValues: {
          "build": 1,
          "release": 2,
          "pipeline": 3
        }
      },
      TestResultsDetails: {},
      TestResultsDetailsForGroup: {},
      TestResultsEx2: {},
      TestResultsQuery: {},
      TestResultsSession: {},
      TestResultsSessionState: {
        enumValues: {
          "none": 0,
          "running": 1,
          "completed": 2,
          "waiting": 3,
          "cancelled": 4
        }
      },
      TestResultsSettings: {},
      TestResultsSettingsType: {
        enumValues: {
          "all": 1,
          "flaky": 2,
          "newTestLogging": 3
        }
      },
      TestResultSummary: {},
      TestResultsUpdateSettings: {},
      TestResultsWithWatermark: {},
      TestResultTrendFilter: {},
      TestRun: {},
      TestRun2: {},
      TestRunCanceledEvent: {},
      TestRunCreatedEvent: {},
      TestRunEvent: {},
      TestRunEx2: {},
      TestRunOutcome: {
        enumValues: {
          "passed": 0,
          "failed": 1,
          "notImpacted": 2,
          "others": 3
        }
      },
      TestRunPublishContext: {
        enumValues: {
          "build": 1,
          "release": 2,
          "all": 3
        }
      },
      TestRunStartedEvent: {},
      TestRunState: {
        enumValues: {
          "unspecified": 0,
          "notStarted": 1,
          "inProgress": 2,
          "completed": 3,
          "aborted": 4,
          "waiting": 5,
          "needsInvestigation": 6
        }
      },
      TestRunStatistic: {},
      TestRunSubstate: {
        enumValues: {
          "none": 0,
          "creatingEnvironment": 1,
          "runningTests": 2,
          "canceledByUser": 3,
          "abortedBySystem": 4,
          "timedOut": 5,
          "pendingAnalysis": 6,
          "analyzed": 7,
          "cancellationInProgress": 8
        }
      },
      TestRunSummary2: {},
      TestRunWithDtlEnvEvent: {},
      TestSession: {},
      TestSessionExploredWorkItemReference: {},
      TestSessionSource: {
        enumValues: {
          "unknown": 0,
          "xtDesktop": 1,
          "feedbackDesktop": 2,
          "xtWeb": 3,
          "feedbackWeb": 4,
          "xtDesktop2": 5,
          "sessionInsightsForAll": 6
        }
      },
      TestSessionState: {
        enumValues: {
          "unspecified": 0,
          "notStarted": 1,
          "inProgress": 2,
          "paused": 3,
          "completed": 4,
          "declined": 5
        }
      },
      TestSettings2: {},
      TestSubResult: {},
      TestSuite: {},
      TestSummaryForWorkItem: {},
      TestToWorkItemLinks: {},
      Timeline: {},
      UpdatedProperties: {},
      UpdateTestRunRequest: {},
      UpdateTestRunResponse: {},
      WorkItemToTestLinks: {}
    };
    exports2.TypeInfo.AfnStrip.fields = {
      creationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AggregatedDataForResultTrend.fields = {
      resultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      runSummaryByState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedRunsByState
      },
      testResultsContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.AggregatedResultDetailsByOutcome.fields = {
      outcome: {
        enumType: exports2.TypeInfo.TestOutcome
      }
    };
    exports2.TypeInfo.AggregatedResultsAnalysis.fields = {
      notReportedResultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      previousContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      },
      resultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      runSummaryByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedRunsByOutcome
      },
      runSummaryByState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedRunsByState
      }
    };
    exports2.TypeInfo.AggregatedResultsByOutcome.fields = {
      outcome: {
        enumType: exports2.TypeInfo.TestOutcome
      }
    };
    exports2.TypeInfo.AggregatedRunsByOutcome.fields = {
      outcome: {
        enumType: exports2.TypeInfo.TestRunOutcome
      }
    };
    exports2.TypeInfo.AggregatedRunsByState.fields = {
      resultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      state: {
        enumType: exports2.TypeInfo.TestRunState
      }
    };
    exports2.TypeInfo.BatchResponse.fields = {
      responses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Response
      }
    };
    exports2.TypeInfo.BuildConfiguration.fields = {
      creationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildCoverage.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      }
    };
    exports2.TypeInfo.BuildReference2.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BulkResultUpdateRequest.fields = {
      requests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ResultUpdateRequest
      }
    };
    exports2.TypeInfo.CloneOperationInformation.fields = {
      completionDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      resultObjectType: {
        enumType: exports2.TypeInfo.ResultObjectType
      },
      state: {
        enumType: exports2.TypeInfo.CloneOperationState
      }
    };
    exports2.TypeInfo.CodeCoverageSummary.fields = {
      coverageDetailedSummaryStatus: {
        enumType: exports2.TypeInfo.CoverageDetailedSummaryStatus
      },
      status: {
        enumType: exports2.TypeInfo.CoverageSummaryStatus
      }
    };
    exports2.TypeInfo.Coverage2.fields = {
      dateCreated: {
        isDate: true
      },
      dateModified: {
        isDate: true
      }
    };
    exports2.TypeInfo.CreateTestMessageLogEntryRequest.fields = {
      testMessageLogEntry: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestMessageLogEntry
      }
    };
    exports2.TypeInfo.CreateTestResultsRequest.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.CreateTestRunRequest.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      },
      testRun: {
        typeInfo: exports2.TypeInfo.LegacyTestRun
      },
      testSettings: {
        typeInfo: exports2.TypeInfo.LegacyTestSettings
      }
    };
    exports2.TypeInfo.CustomTestFieldDefinition.fields = {
      fieldType: {
        enumType: exports2.TypeInfo.CustomTestFieldType
      },
      scope: {
        enumType: exports2.TypeInfo.CustomTestFieldScope
      }
    };
    exports2.TypeInfo.DatedTestFieldData.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.FailingSince.fields = {
      date: {
        isDate: true
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      }
    };
    exports2.TypeInfo.FetchTestResultsResponse.fields = {
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      attachments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      },
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.FlakyDetection.fields = {
      flakyDetectionType: {
        enumType: exports2.TypeInfo.FlakyDetectionType
      }
    };
    exports2.TypeInfo.FlakySettings.fields = {
      flakyDetection: {
        typeInfo: exports2.TypeInfo.FlakyDetection
      }
    };
    exports2.TypeInfo.LastResultDetails.fields = {
      dateCompleted: {
        isDate: true
      }
    };
    exports2.TypeInfo.LegacyBuildConfiguration.fields = {
      completedDate: {
        isDate: true
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.LegacyReleaseReference.fields = {
      environmentCreationDate: {
        isDate: true
      },
      releaseCreationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.LegacyTestCaseResult.fields = {
      buildReference: {
        typeInfo: exports2.TypeInfo.LegacyBuildConfiguration
      },
      creationDate: {
        isDate: true
      },
      customFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestExtensionField
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      failingSince: {
        typeInfo: exports2.TypeInfo.FailingSince
      },
      lastUpdated: {
        isDate: true
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.LegacyReleaseReference
      },
      resultGroupType: {
        enumType: exports2.TypeInfo.ResultGroupType
      },
      stackTrace: {
        typeInfo: exports2.TypeInfo.TestExtensionField
      }
    };
    exports2.TypeInfo.LegacyTestRun.fields = {
      buildReference: {
        typeInfo: exports2.TypeInfo.LegacyBuildConfiguration
      },
      completeDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      customFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestExtensionField
      },
      dueDate: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.LegacyReleaseReference
      },
      startDate: {
        isDate: true
      },
      testMessageLogEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestMessageLogDetails
      }
    };
    exports2.TypeInfo.LegacyTestSettings.fields = {
      createdDate: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.Machine.fields = {
      timeline: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Timeline
      }
    };
    exports2.TypeInfo.PipelineTestMetrics.fields = {
      resultSummary: {
        typeInfo: exports2.TypeInfo.ResultSummary
      },
      runSummary: {
        typeInfo: exports2.TypeInfo.RunSummary
      },
      summaryAtChild: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PipelineTestMetrics
      }
    };
    exports2.TypeInfo.PointLastResult.fields = {
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.PointsResults2.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.QueryTestActionResultResponse.fields = {
      testActionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      testAttachments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      }
    };
    exports2.TypeInfo.ReleaseReference.fields = {
      creationDate: {
        isDate: true
      },
      environmentCreationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseReference2.fields = {
      environmentCreationDate: {
        isDate: true
      },
      releaseCreationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.RequirementsToTestsMapping2.fields = {
      creationDate: {
        isDate: true
      },
      deletionDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Response.fields = {};
    exports2.TypeInfo.ResultRetentionSettings.fields = {
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ResultsByQueryResponse.fields = {
      testResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.ResultsFilter.fields = {
      executedIn: {
        enumType: exports2.TypeInfo.Service
      },
      maxCompleteDate: {
        isDate: true
      },
      testResultsContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.ResultsSummaryByOutcome.fields = {
      aggregatedResultDetailsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultDetailsByOutcome
      }
    };
    exports2.TypeInfo.ResultSummary.fields = {
      resultSummaryByRunState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState,
        dictionaryValueTypeInfo: exports2.TypeInfo.ResultsSummaryByOutcome
      }
    };
    exports2.TypeInfo.ResultUpdateRequest.fields = {
      actionResultDeletes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      attachments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      },
      testCaseResult: {
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.ResultUpdateRequestModel.fields = {
      actionResultDeletes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResultModel
      },
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResultModel
      }
    };
    exports2.TypeInfo.ResultUpdateResponse.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.RunCreateModel.fields = {
      buildReference: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      runSummary: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunSummaryModel
      }
    };
    exports2.TypeInfo.RunStatistic.fields = {
      resultMetadata: {
        enumType: exports2.TypeInfo.ResultMetadata
      }
    };
    exports2.TypeInfo.RunSummary.fields = {
      runSummaryByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunOutcome
      },
      runSummaryByState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState
      }
    };
    exports2.TypeInfo.RunSummaryModel.fields = {
      testOutcome: {
        enumType: exports2.TypeInfo.TestOutcome
      }
    };
    exports2.TypeInfo.RunUpdateModel.fields = {
      logEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestMessageLogDetails
      },
      runSummary: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunSummaryModel
      },
      substate: {
        enumType: exports2.TypeInfo.TestRunSubstate
      }
    };
    exports2.TypeInfo.SessionEnvironmentAndMachine.fields = {
      machines: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Machine
      }
    };
    exports2.TypeInfo.SourceViewBuildCoverage.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      }
    };
    exports2.TypeInfo.TestActionResult.fields = {
      creationDate: {
        isDate: true
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestActionResult2.fields = {
      creationDate: {
        isDate: true
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestActionResultModel.fields = {
      completedDate: {
        isDate: true
      },
      startedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestAttachment.fields = {
      attachmentType: {
        enumType: exports2.TypeInfo.AttachmentType
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestAuthoringDetails.fields = {
      lastUpdated: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestPointState
      }
    };
    exports2.TypeInfo.TestCaseReference2.fields = {
      creationDate: {
        isDate: true
      },
      lastRefTestRunDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestCaseResult.fields = {
      completedDate: {
        isDate: true
      },
      createdDate: {
        isDate: true
      },
      failingSince: {
        typeInfo: exports2.TypeInfo.FailingSince
      },
      iterationDetails: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestIterationDetailsModel
      },
      lastUpdatedDate: {
        isDate: true
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      resultGroupType: {
        enumType: exports2.TypeInfo.ResultGroupType
      },
      startedDate: {
        isDate: true
      },
      subResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSubResult
      }
    };
    exports2.TypeInfo.TestConfiguration.fields = {
      lastUpdatedDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestConfigurationState
      }
    };
    exports2.TypeInfo.TestExecutionReportData.fields = {
      reportData: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DatedTestFieldData
      }
    };
    exports2.TypeInfo.TestExtensionField.fields = {
      field: {
        typeInfo: exports2.TypeInfo.TestExtensionFieldDetails
      }
    };
    exports2.TypeInfo.TestExtensionFieldDetails.fields = {
      type: {
        enumType: SystemData.TypeInfo.SqlDbType
      }
    };
    exports2.TypeInfo.TestFailuresAnalysis.fields = {
      previousContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.TestHistoryQuery.fields = {
      groupBy: {
        enumType: exports2.TypeInfo.TestResultGroupBy
      },
      maxCompleteDate: {
        isDate: true
      },
      resultsForGroup: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultHistoryForGroup
      }
    };
    exports2.TypeInfo.TestIterationDetailsModel.fields = {
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResultModel
      },
      completedDate: {
        isDate: true
      },
      startedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestLog.fields = {
      logReference: {
        typeInfo: exports2.TypeInfo.TestLogReference
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestLogReference.fields = {
      scope: {
        enumType: exports2.TypeInfo.TestLogScope
      },
      type: {
        enumType: exports2.TypeInfo.TestLogType
      }
    };
    exports2.TypeInfo.TestLogStatus.fields = {
      status: {
        enumType: exports2.TypeInfo.TestLogStatusCode
      }
    };
    exports2.TypeInfo.TestLogStoreAttachment.fields = {
      attachmentType: {
        enumType: exports2.TypeInfo.AttachmentType
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestLogStoreEndpointDetails.fields = {
      endpointType: {
        enumType: exports2.TypeInfo.TestLogStoreEndpointType
      },
      status: {
        enumType: exports2.TypeInfo.TestLogStatusCode
      }
    };
    exports2.TypeInfo.TestMessageLogDetails.fields = {
      dateCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestMessageLogEntry.fields = {
      dateCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestMessageLogEntry2.fields = {
      dateCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestMethod.fields = {
      testResult: {
        typeInfo: exports2.TypeInfo.TestCaseResult
      }
    };
    exports2.TypeInfo.TestParameter2.fields = {
      creationDate: {
        isDate: true
      },
      dateModified: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlan.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlanCloneRequest.fields = {
      destinationTestPlan: {
        typeInfo: exports2.TypeInfo.TestPlan
      }
    };
    exports2.TypeInfo.TestPlanHubData.fields = {
      testPlan: {
        typeInfo: exports2.TypeInfo.TestPlan
      },
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPoint
      },
      testSuites: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      }
    };
    exports2.TypeInfo.TestPlansWithSelection.fields = {
      plans: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPlan
      }
    };
    exports2.TypeInfo.TestPoint.fields = {
      lastResetToActive: {
        isDate: true
      },
      lastResultDetails: {
        typeInfo: exports2.TypeInfo.LastResultDetails
      },
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPointReference.fields = {
      state: {
        enumType: exports2.TypeInfo.TestPointState
      }
    };
    exports2.TypeInfo.TestPointsEvent.fields = {
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPointReference
      }
    };
    exports2.TypeInfo.TestPointsQuery.fields = {
      points: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPoint
      }
    };
    exports2.TypeInfo.TestPointsUpdatedEvent.fields = {
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPointReference
      }
    };
    exports2.TypeInfo.TestResult2.fields = {
      creationDate: {
        isDate: true
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultAcrossProjectResponse.fields = {
      testResult: {
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.TestResultAttachment.fields = {
      attachmentType: {
        enumType: exports2.TypeInfo.AttachmentType
      },
      creationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultHistory.fields = {
      resultsForGroup: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultHistoryDetailsForGroup
      }
    };
    exports2.TypeInfo.TestResultHistoryDetailsForGroup.fields = {
      latestResult: {
        typeInfo: exports2.TypeInfo.TestCaseResult
      }
    };
    exports2.TypeInfo.TestResultHistoryForGroup.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseResult
      }
    };
    exports2.TypeInfo.TestResultModelBase.fields = {
      completedDate: {
        isDate: true
      },
      startedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultReset2.fields = {
      dateModified: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultsContext.fields = {
      contextType: {
        enumType: exports2.TypeInfo.TestResultsContextType
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      }
    };
    exports2.TypeInfo.TestResultsDetails.fields = {
      resultsForGroup: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultsDetailsForGroup
      }
    };
    exports2.TypeInfo.TestResultsDetailsForGroup.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseResult
      },
      resultsCountByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      }
    };
    exports2.TypeInfo.TestResultsEx2.fields = {
      creationDate: {
        isDate: true
      },
      dateTimeValue: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultsQuery.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseResult
      },
      resultsFilter: {
        typeInfo: exports2.TypeInfo.ResultsFilter
      }
    };
    exports2.TypeInfo.TestResultsSession.fields = {
      endTimeUTC: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.SessionResult
      },
      startTimeUTC: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestResultsSessionState
      },
      timeline: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Timeline
      }
    };
    exports2.TypeInfo.TestResultsSettings.fields = {
      flakySettings: {
        typeInfo: exports2.TypeInfo.FlakySettings
      }
    };
    exports2.TypeInfo.TestResultSummary.fields = {
      aggregatedResultsAnalysis: {
        typeInfo: exports2.TypeInfo.AggregatedResultsAnalysis
      },
      teamProject: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      testFailures: {
        typeInfo: exports2.TypeInfo.TestFailuresAnalysis
      },
      testResultsContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.TestResultsUpdateSettings.fields = {
      flakySettings: {
        typeInfo: exports2.TypeInfo.FlakySettings
      }
    };
    exports2.TypeInfo.TestResultsWithWatermark.fields = {
      changedDate: {
        isDate: true
      },
      pointsResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PointsResults2
      }
    };
    exports2.TypeInfo.TestResultTrendFilter.fields = {
      maxCompleteDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRun.fields = {
      buildConfiguration: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      },
      completedDate: {
        isDate: true
      },
      createdDate: {
        isDate: true
      },
      dueDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      runStatistics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunStatistic
      },
      startedDate: {
        isDate: true
      },
      substate: {
        enumType: exports2.TypeInfo.TestRunSubstate
      }
    };
    exports2.TypeInfo.TestRun2.fields = {
      completeDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      deletedOn: {
        isDate: true
      },
      dueDate: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRunCanceledEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunCreatedEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunEx2.fields = {
      createdDate: {
        isDate: true
      },
      dateTimeValue: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRunStartedEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunStatistic.fields = {
      runStatistics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunStatistic
      }
    };
    exports2.TypeInfo.TestRunSummary2.fields = {
      testRunCompletedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRunWithDtlEnvEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestSession.fields = {
      endDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      source: {
        enumType: exports2.TypeInfo.TestSessionSource
      },
      startDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestSessionState
      }
    };
    exports2.TypeInfo.TestSessionExploredWorkItemReference.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestSettings2.fields = {
      createdDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestSubResult.fields = {
      completedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      resultGroupType: {
        enumType: exports2.TypeInfo.ResultGroupType
      },
      startedDate: {
        isDate: true
      },
      subResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSubResult
      }
    };
    exports2.TypeInfo.TestSuite.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      },
      lastPopulatedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestSummaryForWorkItem.fields = {
      summary: {
        typeInfo: exports2.TypeInfo.AggregatedDataForResultTrend
      }
    };
    exports2.TypeInfo.TestToWorkItemLinks.fields = {
      test: {
        typeInfo: exports2.TypeInfo.TestMethod
      }
    };
    exports2.TypeInfo.Timeline.fields = {
      timestampUTC: {
        isDate: true
      }
    };
    exports2.TypeInfo.UpdatedProperties.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.UpdateTestRunRequest.fields = {
      attachmentsToAdd: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      },
      testRun: {
        typeInfo: exports2.TypeInfo.LegacyTestRun
      }
    };
    exports2.TypeInfo.UpdateTestRunResponse.fields = {
      updatedProperties: {
        typeInfo: exports2.TypeInfo.UpdatedProperties
      }
    };
    exports2.TypeInfo.WorkItemToTestLinks.fields = {
      executedIn: {
        enumType: exports2.TypeInfo.Service
      },
      tests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestMethod
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/BuildInterfaces.js
var require_BuildInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/BuildInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkspaceMappingType = exports2.ValidationResult = exports2.TimelineRecordState = exports2.TaskResult = exports2.SupportLevel = exports2.StageUpdateType = exports2.SourceProviderAvailability = exports2.ServiceHostStatus = exports2.ScheduleDays = exports2.ResultSet = exports2.RepositoryCleanOptions = exports2.QueuePriority = exports2.QueueOptions = exports2.QueryDeletedOption = exports2.ProcessTemplateType = exports2.IssueType = exports2.GetOption = exports2.FolderQueryOrder = exports2.DeleteOptions = exports2.DefinitionType = exports2.DefinitionTriggerType = exports2.DefinitionQueueStatus = exports2.DefinitionQueryOrder = exports2.DefinitionQuality = exports2.ControllerStatus = exports2.BuildStatus = exports2.BuildResult = exports2.BuildReason = exports2.BuildQueryOrder = exports2.BuildPhaseStatus = exports2.BuildOptionInputType = exports2.BuildAuthorizationScope = exports2.AuditAction = exports2.AgentStatus = void 0;
    var TFS_TestManagement_Contracts = require_TestInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var AgentStatus;
    (function(AgentStatus2) {
      AgentStatus2[AgentStatus2["Unavailable"] = 0] = "Unavailable";
      AgentStatus2[AgentStatus2["Available"] = 1] = "Available";
      AgentStatus2[AgentStatus2["Offline"] = 2] = "Offline";
    })(AgentStatus = exports2.AgentStatus || (exports2.AgentStatus = {}));
    var AuditAction;
    (function(AuditAction2) {
      AuditAction2[AuditAction2["Add"] = 1] = "Add";
      AuditAction2[AuditAction2["Update"] = 2] = "Update";
      AuditAction2[AuditAction2["Delete"] = 3] = "Delete";
    })(AuditAction = exports2.AuditAction || (exports2.AuditAction = {}));
    var BuildAuthorizationScope;
    (function(BuildAuthorizationScope2) {
      BuildAuthorizationScope2[BuildAuthorizationScope2["ProjectCollection"] = 1] = "ProjectCollection";
      BuildAuthorizationScope2[BuildAuthorizationScope2["Project"] = 2] = "Project";
    })(BuildAuthorizationScope = exports2.BuildAuthorizationScope || (exports2.BuildAuthorizationScope = {}));
    var BuildOptionInputType;
    (function(BuildOptionInputType2) {
      BuildOptionInputType2[BuildOptionInputType2["String"] = 0] = "String";
      BuildOptionInputType2[BuildOptionInputType2["Boolean"] = 1] = "Boolean";
      BuildOptionInputType2[BuildOptionInputType2["StringList"] = 2] = "StringList";
      BuildOptionInputType2[BuildOptionInputType2["Radio"] = 3] = "Radio";
      BuildOptionInputType2[BuildOptionInputType2["PickList"] = 4] = "PickList";
      BuildOptionInputType2[BuildOptionInputType2["MultiLine"] = 5] = "MultiLine";
      BuildOptionInputType2[BuildOptionInputType2["BranchFilter"] = 6] = "BranchFilter";
    })(BuildOptionInputType = exports2.BuildOptionInputType || (exports2.BuildOptionInputType = {}));
    var BuildPhaseStatus;
    (function(BuildPhaseStatus2) {
      BuildPhaseStatus2[BuildPhaseStatus2["Unknown"] = 0] = "Unknown";
      BuildPhaseStatus2[BuildPhaseStatus2["Failed"] = 1] = "Failed";
      BuildPhaseStatus2[BuildPhaseStatus2["Succeeded"] = 2] = "Succeeded";
    })(BuildPhaseStatus = exports2.BuildPhaseStatus || (exports2.BuildPhaseStatus = {}));
    var BuildQueryOrder;
    (function(BuildQueryOrder2) {
      BuildQueryOrder2[BuildQueryOrder2["FinishTimeAscending"] = 2] = "FinishTimeAscending";
      BuildQueryOrder2[BuildQueryOrder2["FinishTimeDescending"] = 3] = "FinishTimeDescending";
      BuildQueryOrder2[BuildQueryOrder2["QueueTimeDescending"] = 4] = "QueueTimeDescending";
      BuildQueryOrder2[BuildQueryOrder2["QueueTimeAscending"] = 5] = "QueueTimeAscending";
      BuildQueryOrder2[BuildQueryOrder2["StartTimeDescending"] = 6] = "StartTimeDescending";
      BuildQueryOrder2[BuildQueryOrder2["StartTimeAscending"] = 7] = "StartTimeAscending";
    })(BuildQueryOrder = exports2.BuildQueryOrder || (exports2.BuildQueryOrder = {}));
    var BuildReason;
    (function(BuildReason2) {
      BuildReason2[BuildReason2["None"] = 0] = "None";
      BuildReason2[BuildReason2["Manual"] = 1] = "Manual";
      BuildReason2[BuildReason2["IndividualCI"] = 2] = "IndividualCI";
      BuildReason2[BuildReason2["BatchedCI"] = 4] = "BatchedCI";
      BuildReason2[BuildReason2["Schedule"] = 8] = "Schedule";
      BuildReason2[BuildReason2["ScheduleForced"] = 16] = "ScheduleForced";
      BuildReason2[BuildReason2["UserCreated"] = 32] = "UserCreated";
      BuildReason2[BuildReason2["ValidateShelveset"] = 64] = "ValidateShelveset";
      BuildReason2[BuildReason2["CheckInShelveset"] = 128] = "CheckInShelveset";
      BuildReason2[BuildReason2["PullRequest"] = 256] = "PullRequest";
      BuildReason2[BuildReason2["BuildCompletion"] = 512] = "BuildCompletion";
      BuildReason2[BuildReason2["ResourceTrigger"] = 1024] = "ResourceTrigger";
      BuildReason2[BuildReason2["Triggered"] = 1967] = "Triggered";
      BuildReason2[BuildReason2["All"] = 2031] = "All";
    })(BuildReason = exports2.BuildReason || (exports2.BuildReason = {}));
    var BuildResult;
    (function(BuildResult2) {
      BuildResult2[BuildResult2["None"] = 0] = "None";
      BuildResult2[BuildResult2["Succeeded"] = 2] = "Succeeded";
      BuildResult2[BuildResult2["PartiallySucceeded"] = 4] = "PartiallySucceeded";
      BuildResult2[BuildResult2["Failed"] = 8] = "Failed";
      BuildResult2[BuildResult2["Canceled"] = 32] = "Canceled";
    })(BuildResult = exports2.BuildResult || (exports2.BuildResult = {}));
    var BuildStatus;
    (function(BuildStatus2) {
      BuildStatus2[BuildStatus2["None"] = 0] = "None";
      BuildStatus2[BuildStatus2["InProgress"] = 1] = "InProgress";
      BuildStatus2[BuildStatus2["Completed"] = 2] = "Completed";
      BuildStatus2[BuildStatus2["Cancelling"] = 4] = "Cancelling";
      BuildStatus2[BuildStatus2["Postponed"] = 8] = "Postponed";
      BuildStatus2[BuildStatus2["NotStarted"] = 32] = "NotStarted";
      BuildStatus2[BuildStatus2["All"] = 47] = "All";
    })(BuildStatus = exports2.BuildStatus || (exports2.BuildStatus = {}));
    var ControllerStatus;
    (function(ControllerStatus2) {
      ControllerStatus2[ControllerStatus2["Unavailable"] = 0] = "Unavailable";
      ControllerStatus2[ControllerStatus2["Available"] = 1] = "Available";
      ControllerStatus2[ControllerStatus2["Offline"] = 2] = "Offline";
    })(ControllerStatus = exports2.ControllerStatus || (exports2.ControllerStatus = {}));
    var DefinitionQuality;
    (function(DefinitionQuality2) {
      DefinitionQuality2[DefinitionQuality2["Definition"] = 1] = "Definition";
      DefinitionQuality2[DefinitionQuality2["Draft"] = 2] = "Draft";
    })(DefinitionQuality = exports2.DefinitionQuality || (exports2.DefinitionQuality = {}));
    var DefinitionQueryOrder;
    (function(DefinitionQueryOrder2) {
      DefinitionQueryOrder2[DefinitionQueryOrder2["None"] = 0] = "None";
      DefinitionQueryOrder2[DefinitionQueryOrder2["LastModifiedAscending"] = 1] = "LastModifiedAscending";
      DefinitionQueryOrder2[DefinitionQueryOrder2["LastModifiedDescending"] = 2] = "LastModifiedDescending";
      DefinitionQueryOrder2[DefinitionQueryOrder2["DefinitionNameAscending"] = 3] = "DefinitionNameAscending";
      DefinitionQueryOrder2[DefinitionQueryOrder2["DefinitionNameDescending"] = 4] = "DefinitionNameDescending";
    })(DefinitionQueryOrder = exports2.DefinitionQueryOrder || (exports2.DefinitionQueryOrder = {}));
    var DefinitionQueueStatus;
    (function(DefinitionQueueStatus2) {
      DefinitionQueueStatus2[DefinitionQueueStatus2["Enabled"] = 0] = "Enabled";
      DefinitionQueueStatus2[DefinitionQueueStatus2["Paused"] = 1] = "Paused";
      DefinitionQueueStatus2[DefinitionQueueStatus2["Disabled"] = 2] = "Disabled";
    })(DefinitionQueueStatus = exports2.DefinitionQueueStatus || (exports2.DefinitionQueueStatus = {}));
    var DefinitionTriggerType;
    (function(DefinitionTriggerType2) {
      DefinitionTriggerType2[DefinitionTriggerType2["None"] = 1] = "None";
      DefinitionTriggerType2[DefinitionTriggerType2["ContinuousIntegration"] = 2] = "ContinuousIntegration";
      DefinitionTriggerType2[DefinitionTriggerType2["BatchedContinuousIntegration"] = 4] = "BatchedContinuousIntegration";
      DefinitionTriggerType2[DefinitionTriggerType2["Schedule"] = 8] = "Schedule";
      DefinitionTriggerType2[DefinitionTriggerType2["GatedCheckIn"] = 16] = "GatedCheckIn";
      DefinitionTriggerType2[DefinitionTriggerType2["BatchedGatedCheckIn"] = 32] = "BatchedGatedCheckIn";
      DefinitionTriggerType2[DefinitionTriggerType2["PullRequest"] = 64] = "PullRequest";
      DefinitionTriggerType2[DefinitionTriggerType2["BuildCompletion"] = 128] = "BuildCompletion";
      DefinitionTriggerType2[DefinitionTriggerType2["All"] = 255] = "All";
    })(DefinitionTriggerType = exports2.DefinitionTriggerType || (exports2.DefinitionTriggerType = {}));
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2[DefinitionType2["Xaml"] = 1] = "Xaml";
      DefinitionType2[DefinitionType2["Build"] = 2] = "Build";
    })(DefinitionType = exports2.DefinitionType || (exports2.DefinitionType = {}));
    var DeleteOptions;
    (function(DeleteOptions2) {
      DeleteOptions2[DeleteOptions2["None"] = 0] = "None";
      DeleteOptions2[DeleteOptions2["DropLocation"] = 1] = "DropLocation";
      DeleteOptions2[DeleteOptions2["TestResults"] = 2] = "TestResults";
      DeleteOptions2[DeleteOptions2["Label"] = 4] = "Label";
      DeleteOptions2[DeleteOptions2["Details"] = 8] = "Details";
      DeleteOptions2[DeleteOptions2["Symbols"] = 16] = "Symbols";
      DeleteOptions2[DeleteOptions2["All"] = 31] = "All";
    })(DeleteOptions = exports2.DeleteOptions || (exports2.DeleteOptions = {}));
    var FolderQueryOrder;
    (function(FolderQueryOrder2) {
      FolderQueryOrder2[FolderQueryOrder2["None"] = 0] = "None";
      FolderQueryOrder2[FolderQueryOrder2["FolderAscending"] = 1] = "FolderAscending";
      FolderQueryOrder2[FolderQueryOrder2["FolderDescending"] = 2] = "FolderDescending";
    })(FolderQueryOrder = exports2.FolderQueryOrder || (exports2.FolderQueryOrder = {}));
    var GetOption;
    (function(GetOption2) {
      GetOption2[GetOption2["LatestOnQueue"] = 0] = "LatestOnQueue";
      GetOption2[GetOption2["LatestOnBuild"] = 1] = "LatestOnBuild";
      GetOption2[GetOption2["Custom"] = 2] = "Custom";
    })(GetOption = exports2.GetOption || (exports2.GetOption = {}));
    var IssueType;
    (function(IssueType2) {
      IssueType2[IssueType2["Error"] = 1] = "Error";
      IssueType2[IssueType2["Warning"] = 2] = "Warning";
    })(IssueType = exports2.IssueType || (exports2.IssueType = {}));
    var ProcessTemplateType;
    (function(ProcessTemplateType2) {
      ProcessTemplateType2[ProcessTemplateType2["Custom"] = 0] = "Custom";
      ProcessTemplateType2[ProcessTemplateType2["Default"] = 1] = "Default";
      ProcessTemplateType2[ProcessTemplateType2["Upgrade"] = 2] = "Upgrade";
    })(ProcessTemplateType = exports2.ProcessTemplateType || (exports2.ProcessTemplateType = {}));
    var QueryDeletedOption;
    (function(QueryDeletedOption2) {
      QueryDeletedOption2[QueryDeletedOption2["ExcludeDeleted"] = 0] = "ExcludeDeleted";
      QueryDeletedOption2[QueryDeletedOption2["IncludeDeleted"] = 1] = "IncludeDeleted";
      QueryDeletedOption2[QueryDeletedOption2["OnlyDeleted"] = 2] = "OnlyDeleted";
    })(QueryDeletedOption = exports2.QueryDeletedOption || (exports2.QueryDeletedOption = {}));
    var QueueOptions;
    (function(QueueOptions2) {
      QueueOptions2[QueueOptions2["None"] = 0] = "None";
      QueueOptions2[QueueOptions2["DoNotRun"] = 1] = "DoNotRun";
    })(QueueOptions = exports2.QueueOptions || (exports2.QueueOptions = {}));
    var QueuePriority;
    (function(QueuePriority2) {
      QueuePriority2[QueuePriority2["Low"] = 5] = "Low";
      QueuePriority2[QueuePriority2["BelowNormal"] = 4] = "BelowNormal";
      QueuePriority2[QueuePriority2["Normal"] = 3] = "Normal";
      QueuePriority2[QueuePriority2["AboveNormal"] = 2] = "AboveNormal";
      QueuePriority2[QueuePriority2["High"] = 1] = "High";
    })(QueuePriority = exports2.QueuePriority || (exports2.QueuePriority = {}));
    var RepositoryCleanOptions;
    (function(RepositoryCleanOptions2) {
      RepositoryCleanOptions2[RepositoryCleanOptions2["Source"] = 0] = "Source";
      RepositoryCleanOptions2[RepositoryCleanOptions2["SourceAndOutputDir"] = 1] = "SourceAndOutputDir";
      RepositoryCleanOptions2[RepositoryCleanOptions2["SourceDir"] = 2] = "SourceDir";
      RepositoryCleanOptions2[RepositoryCleanOptions2["AllBuildDir"] = 3] = "AllBuildDir";
    })(RepositoryCleanOptions = exports2.RepositoryCleanOptions || (exports2.RepositoryCleanOptions = {}));
    var ResultSet;
    (function(ResultSet2) {
      ResultSet2[ResultSet2["All"] = 0] = "All";
      ResultSet2[ResultSet2["Top"] = 1] = "Top";
    })(ResultSet = exports2.ResultSet || (exports2.ResultSet = {}));
    var ScheduleDays;
    (function(ScheduleDays2) {
      ScheduleDays2[ScheduleDays2["None"] = 0] = "None";
      ScheduleDays2[ScheduleDays2["Monday"] = 1] = "Monday";
      ScheduleDays2[ScheduleDays2["Tuesday"] = 2] = "Tuesday";
      ScheduleDays2[ScheduleDays2["Wednesday"] = 4] = "Wednesday";
      ScheduleDays2[ScheduleDays2["Thursday"] = 8] = "Thursday";
      ScheduleDays2[ScheduleDays2["Friday"] = 16] = "Friday";
      ScheduleDays2[ScheduleDays2["Saturday"] = 32] = "Saturday";
      ScheduleDays2[ScheduleDays2["Sunday"] = 64] = "Sunday";
      ScheduleDays2[ScheduleDays2["All"] = 127] = "All";
    })(ScheduleDays = exports2.ScheduleDays || (exports2.ScheduleDays = {}));
    var ServiceHostStatus;
    (function(ServiceHostStatus2) {
      ServiceHostStatus2[ServiceHostStatus2["Online"] = 1] = "Online";
      ServiceHostStatus2[ServiceHostStatus2["Offline"] = 2] = "Offline";
    })(ServiceHostStatus = exports2.ServiceHostStatus || (exports2.ServiceHostStatus = {}));
    var SourceProviderAvailability;
    (function(SourceProviderAvailability2) {
      SourceProviderAvailability2[SourceProviderAvailability2["Hosted"] = 1] = "Hosted";
      SourceProviderAvailability2[SourceProviderAvailability2["OnPremises"] = 2] = "OnPremises";
      SourceProviderAvailability2[SourceProviderAvailability2["All"] = 3] = "All";
    })(SourceProviderAvailability = exports2.SourceProviderAvailability || (exports2.SourceProviderAvailability = {}));
    var StageUpdateType;
    (function(StageUpdateType2) {
      StageUpdateType2[StageUpdateType2["Cancel"] = 0] = "Cancel";
      StageUpdateType2[StageUpdateType2["Retry"] = 1] = "Retry";
      StageUpdateType2[StageUpdateType2["Run"] = 2] = "Run";
    })(StageUpdateType = exports2.StageUpdateType || (exports2.StageUpdateType = {}));
    var SupportLevel;
    (function(SupportLevel2) {
      SupportLevel2[SupportLevel2["Unsupported"] = 0] = "Unsupported";
      SupportLevel2[SupportLevel2["Supported"] = 1] = "Supported";
      SupportLevel2[SupportLevel2["Required"] = 2] = "Required";
    })(SupportLevel = exports2.SupportLevel || (exports2.SupportLevel = {}));
    var TaskResult2;
    (function(TaskResult3) {
      TaskResult3[TaskResult3["Succeeded"] = 0] = "Succeeded";
      TaskResult3[TaskResult3["SucceededWithIssues"] = 1] = "SucceededWithIssues";
      TaskResult3[TaskResult3["Failed"] = 2] = "Failed";
      TaskResult3[TaskResult3["Canceled"] = 3] = "Canceled";
      TaskResult3[TaskResult3["Skipped"] = 4] = "Skipped";
      TaskResult3[TaskResult3["Abandoned"] = 5] = "Abandoned";
      TaskResult3[TaskResult3["ManuallyQueued"] = 6] = "ManuallyQueued";
      TaskResult3[TaskResult3["DependentOnManualQueue"] = 7] = "DependentOnManualQueue";
    })(TaskResult2 = exports2.TaskResult || (exports2.TaskResult = {}));
    var TimelineRecordState;
    (function(TimelineRecordState2) {
      TimelineRecordState2[TimelineRecordState2["Pending"] = 0] = "Pending";
      TimelineRecordState2[TimelineRecordState2["InProgress"] = 1] = "InProgress";
      TimelineRecordState2[TimelineRecordState2["Completed"] = 2] = "Completed";
    })(TimelineRecordState = exports2.TimelineRecordState || (exports2.TimelineRecordState = {}));
    var ValidationResult;
    (function(ValidationResult2) {
      ValidationResult2[ValidationResult2["OK"] = 0] = "OK";
      ValidationResult2[ValidationResult2["Warning"] = 1] = "Warning";
      ValidationResult2[ValidationResult2["Error"] = 2] = "Error";
    })(ValidationResult = exports2.ValidationResult || (exports2.ValidationResult = {}));
    var WorkspaceMappingType;
    (function(WorkspaceMappingType2) {
      WorkspaceMappingType2[WorkspaceMappingType2["Map"] = 0] = "Map";
      WorkspaceMappingType2[WorkspaceMappingType2["Cloak"] = 1] = "Cloak";
    })(WorkspaceMappingType = exports2.WorkspaceMappingType || (exports2.WorkspaceMappingType = {}));
    exports2.TypeInfo = {
      AgentStatus: {
        enumValues: {
          "unavailable": 0,
          "available": 1,
          "offline": 2
        }
      },
      AuditAction: {
        enumValues: {
          "add": 1,
          "update": 2,
          "delete": 3
        }
      },
      Build: {},
      BuildAgent: {},
      BuildAuthorizationScope: {
        enumValues: {
          "projectCollection": 1,
          "project": 2
        }
      },
      BuildCompletedEvent: {},
      BuildCompletionTrigger: {},
      BuildController: {},
      BuildDefinition: {},
      BuildDefinition3_2: {},
      BuildDefinitionReference: {},
      BuildDefinitionReference3_2: {},
      BuildDefinitionRevision: {},
      BuildDefinitionSourceProvider: {},
      BuildDefinitionTemplate: {},
      BuildDefinitionTemplate3_2: {},
      BuildDeletedEvent: {},
      BuildDeployment: {},
      BuildLog: {},
      BuildMetric: {},
      BuildOptionDefinition: {},
      BuildOptionInputDefinition: {},
      BuildOptionInputType: {
        enumValues: {
          "string": 0,
          "boolean": 1,
          "stringList": 2,
          "radio": 3,
          "pickList": 4,
          "multiLine": 5,
          "branchFilter": 6
        }
      },
      BuildPhaseStatus: {
        enumValues: {
          "unknown": 0,
          "failed": 1,
          "succeeded": 2
        }
      },
      BuildProcessTemplate: {},
      BuildQueryOrder: {
        enumValues: {
          "finishTimeAscending": 2,
          "finishTimeDescending": 3,
          "queueTimeDescending": 4,
          "queueTimeAscending": 5,
          "startTimeDescending": 6,
          "startTimeAscending": 7
        }
      },
      BuildQueuedEvent: {},
      BuildReason: {
        enumValues: {
          "none": 0,
          "manual": 1,
          "individualCI": 2,
          "batchedCI": 4,
          "schedule": 8,
          "scheduleForced": 16,
          "userCreated": 32,
          "validateShelveset": 64,
          "checkInShelveset": 128,
          "pullRequest": 256,
          "buildCompletion": 512,
          "resourceTrigger": 1024,
          "triggered": 1967,
          "all": 2031
        }
      },
      BuildReference: {},
      BuildRequestValidationResult: {},
      BuildResult: {
        enumValues: {
          "none": 0,
          "succeeded": 2,
          "partiallySucceeded": 4,
          "failed": 8,
          "canceled": 32
        }
      },
      BuildRetentionHistory: {},
      BuildRetentionSample: {},
      BuildServer: {},
      BuildStatus: {
        enumValues: {
          "none": 0,
          "inProgress": 1,
          "completed": 2,
          "cancelling": 4,
          "postponed": 8,
          "notStarted": 32,
          "all": 47
        }
      },
      BuildSummary: {},
      BuildTagsAddedEvent: {},
      BuildTrigger: {},
      BuildUpdatedEvent: {},
      Change: {},
      ContinuousDeploymentDefinition: {},
      ContinuousIntegrationTrigger: {},
      ControllerStatus: {
        enumValues: {
          "unavailable": 0,
          "available": 1,
          "offline": 2
        }
      },
      DefinitionQuality: {
        enumValues: {
          "definition": 1,
          "draft": 2
        }
      },
      DefinitionQueryOrder: {
        enumValues: {
          "none": 0,
          "lastModifiedAscending": 1,
          "lastModifiedDescending": 2,
          "definitionNameAscending": 3,
          "definitionNameDescending": 4
        }
      },
      DefinitionQueueStatus: {
        enumValues: {
          "enabled": 0,
          "paused": 1,
          "disabled": 2
        }
      },
      DefinitionReference: {},
      DefinitionTriggerType: {
        enumValues: {
          "none": 1,
          "continuousIntegration": 2,
          "batchedContinuousIntegration": 4,
          "schedule": 8,
          "gatedCheckIn": 16,
          "batchedGatedCheckIn": 32,
          "pullRequest": 64,
          "buildCompletion": 128,
          "all": 255
        }
      },
      DefinitionType: {
        enumValues: {
          "xaml": 1,
          "build": 2
        }
      },
      DeleteOptions: {
        enumValues: {
          "none": 0,
          "dropLocation": 1,
          "testResults": 2,
          "label": 4,
          "details": 8,
          "symbols": 16,
          "all": 31
        }
      },
      DesignerProcess: {},
      Folder: {},
      FolderQueryOrder: {
        enumValues: {
          "none": 0,
          "folderAscending": 1,
          "folderDescending": 2
        }
      },
      GatedCheckInTrigger: {},
      GetOption: {
        enumValues: {
          "latestOnQueue": 0,
          "latestOnBuild": 1,
          "custom": 2
        }
      },
      InformationNode: {},
      Issue: {},
      IssueType: {
        enumValues: {
          "error": 1,
          "warning": 2
        }
      },
      Phase: {},
      ProcessTemplateType: {
        enumValues: {
          "custom": 0,
          "default": 1,
          "upgrade": 2
        }
      },
      PullRequestTrigger: {},
      QueryDeletedOption: {
        enumValues: {
          "excludeDeleted": 0,
          "includeDeleted": 1,
          "onlyDeleted": 2
        }
      },
      QueueOptions: {
        enumValues: {
          "none": 0,
          "doNotRun": 1
        }
      },
      QueuePriority: {
        enumValues: {
          "low": 5,
          "belowNormal": 4,
          "normal": 3,
          "aboveNormal": 2,
          "high": 1
        }
      },
      RepositoryCleanOptions: {
        enumValues: {
          "source": 0,
          "sourceAndOutputDir": 1,
          "sourceDir": 2,
          "allBuildDir": 3
        }
      },
      RepositoryWebhook: {},
      ResultSet: {
        enumValues: {
          "all": 0,
          "top": 1
        }
      },
      RetentionLease: {},
      Schedule: {},
      ScheduleDays: {
        enumValues: {
          "none": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 4,
          "thursday": 8,
          "friday": 16,
          "saturday": 32,
          "sunday": 64,
          "all": 127
        }
      },
      ScheduleTrigger: {},
      ServiceHostStatus: {
        enumValues: {
          "online": 1,
          "offline": 2
        }
      },
      SourceProviderAttributes: {},
      SourceProviderAvailability: {
        enumValues: {
          "hosted": 1,
          "onPremises": 2,
          "all": 3
        }
      },
      StageUpdateType: {
        enumValues: {
          "cancel": 0,
          "retry": 1,
          "run": 2
        }
      },
      SupportedTrigger: {},
      SupportLevel: {
        enumValues: {
          "unsupported": 0,
          "supported": 1,
          "required": 2
        }
      },
      TaskResult: {
        enumValues: {
          "succeeded": 0,
          "succeededWithIssues": 1,
          "failed": 2,
          "canceled": 3,
          "skipped": 4,
          "abandoned": 5,
          "manuallyQueued": 6,
          "dependentOnManualQueue": 7
        }
      },
      Timeline: {},
      TimelineRecord: {},
      TimelineRecordState: {
        enumValues: {
          "pending": 0,
          "inProgress": 1,
          "completed": 2
        }
      },
      TimelineRecordsUpdatedEvent: {},
      UpdateStageParameters: {},
      ValidationResult: {
        enumValues: {
          "ok": 0,
          "warning": 1,
          "error": 2
        }
      },
      WorkspaceMapping: {},
      WorkspaceMappingType: {
        enumValues: {
          "map": 0,
          "cloak": 1
        }
      },
      WorkspaceTemplate: {},
      XamlBuildDefinition: {}
    };
    exports2.TypeInfo.Build.fields = {
      controller: {
        typeInfo: exports2.TypeInfo.BuildController
      },
      definition: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      deletedDate: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      lastChangedDate: {
        isDate: true
      },
      priority: {
        enumType: exports2.TypeInfo.QueuePriority
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      queueOptions: {
        enumType: exports2.TypeInfo.QueueOptions
      },
      queueTime: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.BuildReason
      },
      result: {
        enumType: exports2.TypeInfo.BuildResult
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.BuildStatus
      },
      triggeredByBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      validationResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildRequestValidationResult
      }
    };
    exports2.TypeInfo.BuildAgent.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.AgentStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildCompletedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Change
      },
      testResults: {
        typeInfo: TFS_TestManagement_Contracts.TypeInfo.AggregatedResultsAnalysis
      },
      timelineRecords: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.BuildCompletionTrigger.fields = {
      definition: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.BuildController.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ControllerStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildDefinition.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      jobAuthorizationScope: {
        enumType: exports2.TypeInfo.BuildAuthorizationScope
      },
      latestBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      latestCompletedBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      triggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildTrigger
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinition3_2.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      jobAuthorizationScope: {
        enumType: exports2.TypeInfo.BuildAuthorizationScope
      },
      latestBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      latestCompletedBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      triggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildTrigger
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinitionReference.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      latestBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      latestCompletedBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinitionReference3_2.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinitionRevision.fields = {
      changedDate: {
        isDate: true
      },
      changeType: {
        enumType: exports2.TypeInfo.AuditAction
      }
    };
    exports2.TypeInfo.BuildDefinitionSourceProvider.fields = {
      lastModified: {
        isDate: true
      },
      supportedTriggerTypes: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.BuildDefinitionTemplate.fields = {
      template: {
        typeInfo: exports2.TypeInfo.BuildDefinition
      }
    };
    exports2.TypeInfo.BuildDefinitionTemplate3_2.fields = {
      template: {
        typeInfo: exports2.TypeInfo.BuildDefinition3_2
      }
    };
    exports2.TypeInfo.BuildDeletedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.BuildDeployment.fields = {
      deployment: {
        typeInfo: exports2.TypeInfo.BuildSummary
      }
    };
    exports2.TypeInfo.BuildLog.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildMetric.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildOptionDefinition.fields = {
      inputs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildOptionInputDefinition
      }
    };
    exports2.TypeInfo.BuildOptionInputDefinition.fields = {
      type: {
        enumType: exports2.TypeInfo.BuildOptionInputType
      }
    };
    exports2.TypeInfo.BuildProcessTemplate.fields = {
      supportedReasons: {
        enumType: exports2.TypeInfo.BuildReason
      },
      templateType: {
        enumType: exports2.TypeInfo.ProcessTemplateType
      }
    };
    exports2.TypeInfo.BuildQueuedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.BuildReference.fields = {
      finishTime: {
        isDate: true
      },
      queueTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.BuildResult
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.BuildStatus
      }
    };
    exports2.TypeInfo.BuildRequestValidationResult.fields = {
      result: {
        enumType: exports2.TypeInfo.ValidationResult
      }
    };
    exports2.TypeInfo.BuildRetentionHistory.fields = {
      buildRetentionSamples: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildRetentionSample
      }
    };
    exports2.TypeInfo.BuildRetentionSample.fields = {
      sampleTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildServer.fields = {
      status: {
        enumType: exports2.TypeInfo.ServiceHostStatus
      },
      statusChangedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildSummary.fields = {
      finishTime: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.BuildReason
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.BuildStatus
      }
    };
    exports2.TypeInfo.BuildTagsAddedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.BuildTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.BuildUpdatedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.Change.fields = {
      timestamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ContinuousDeploymentDefinition.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.ContinuousIntegrationTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.DefinitionReference.fields = {
      createdDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.DesignerProcess.fields = {
      phases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Phase
      }
    };
    exports2.TypeInfo.Folder.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GatedCheckInTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.InformationNode.fields = {
      lastModifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Issue.fields = {
      type: {
        enumType: exports2.TypeInfo.IssueType
      }
    };
    exports2.TypeInfo.Phase.fields = {
      jobAuthorizationScope: {
        enumType: exports2.TypeInfo.BuildAuthorizationScope
      }
    };
    exports2.TypeInfo.PullRequestTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.RepositoryWebhook.fields = {
      types: {
        isArray: true,
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.RetentionLease.fields = {
      createdOn: {
        isDate: true
      },
      validUntil: {
        isDate: true
      }
    };
    exports2.TypeInfo.Schedule.fields = {
      daysToBuild: {
        enumType: exports2.TypeInfo.ScheduleDays
      }
    };
    exports2.TypeInfo.ScheduleTrigger.fields = {
      schedules: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Schedule
      },
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.SourceProviderAttributes.fields = {
      supportedTriggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SupportedTrigger
      }
    };
    exports2.TypeInfo.SupportedTrigger.fields = {
      supportedCapabilities: {
        isDictionary: true,
        dictionaryValueEnumType: exports2.TypeInfo.SupportLevel
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.Timeline.fields = {
      lastChangedOn: {
        isDate: true
      },
      records: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.TimelineRecord.fields = {
      finishTime: {
        isDate: true
      },
      issues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Issue
      },
      lastModified: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TimelineRecordState
      }
    };
    exports2.TypeInfo.TimelineRecordsUpdatedEvent.fields = {
      timelineRecords: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.UpdateStageParameters.fields = {
      state: {
        enumType: exports2.TypeInfo.StageUpdateType
      }
    };
    exports2.TypeInfo.WorkspaceMapping.fields = {
      mappingType: {
        enumType: exports2.TypeInfo.WorkspaceMappingType
      }
    };
    exports2.TypeInfo.WorkspaceTemplate.fields = {
      lastModifiedDate: {
        isDate: true
      },
      mappings: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkspaceMapping
      }
    };
    exports2.TypeInfo.XamlBuildDefinition.fields = {
      controller: {
        typeInfo: exports2.TypeInfo.BuildController
      },
      createdDate: {
        isDate: true
      },
      createdOn: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      supportedReasons: {
        enumType: exports2.TypeInfo.BuildReason
      },
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/BuildApi.js
var require_BuildApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/BuildApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildApi = void 0;
    var basem = require_ClientApiBases();
    var BuildInterfaces = require_BuildInterfaces();
    var BuildApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Build-api", options2);
      }
      /**
       * Associates an artifact with a build.
       *
       * @param {BuildInterfaces.BuildArtifact} artifact - The artifact.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      createArtifact(artifact, project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, artifact, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific artifact for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} artifactName - The name of the artifact.
       */
      getArtifact(project, buildId, artifactName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              artifactName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific artifact for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} artifactName - The name of the artifact.
       */
      getArtifactContentZip(project, buildId, artifactName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              artifactName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all artifacts for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getArtifacts(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a file from the build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} artifactName - The name of the artifact.
       * @param {string} fileId - The primary key for the file.
       * @param {string} fileName - The name that the file will be set to.
       */
      getFile(project, buildId, artifactName, fileId, fileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          if (fileId == null) {
            throw new TypeError("fileId can not be null or undefined");
          }
          if (fileName == null) {
            throw new TypeError("fileName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              artifactName,
              fileId,
              fileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the list of attachments of a specific type that are associated with a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} type - The type of attachment.
       */
      getAttachments(project, buildId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "f2192269-89fa-4f94-baf6-8fb128c55159", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific attachment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} timelineId - The ID of the timeline.
       * @param {string} recordId - The ID of the timeline record.
       * @param {string} type - The type of the attachment.
       * @param {string} name - The name of the attachment.
       */
      getAttachment(project, buildId, timelineId, recordId, type, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "af5122d3-3438-485e-a25a-2dbbfde84ee6", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {BuildInterfaces.DefinitionResourceReference[]} resources
       * @param {string} project - Project ID or project name
       */
      authorizeProjectResources(resources, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "398c85bc-81aa-4822-947c-a194a05f0fef", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, resources, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} type
       * @param {string} id
       */
      getProjectResources(project, type, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              type,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "398c85bc-81aa-4822-947c-a194a05f0fef", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent build for a definition. Note that this API is deprecated. Prefer StatusBadgeController.GetStatusBadge.
       *
       * @param {string} project - The project ID or name.
       * @param {number} definitionId - The ID of the definition.
       * @param {string} branchName - The name of the branch.
       */
      getBadge(project, definitionId, branchName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "de6a4df8-22cd-44ee-af2d-39f6aa7a4261", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of branches for the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - The vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
       * @param {string} branchName - If supplied, the name of the branch to check for specifically.
       */
      listBranches(project, providerName, serviceEndpointId, repository, branchName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "e05d4403-9b81-4244-8763-20fde28d1976", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent build for the specified branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repoType - The repository type.
       * @param {string} repoId - The repository ID.
       * @param {string} branchName - The branch name.
       */
      getBuildBadge(project, repoType, repoId, branchName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repoType
            };
            let queryValues = {
              repoId,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "21b3b9ce-fad5-4567-9ad0-80679794e003", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent build for the specified branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repoType - The repository type.
       * @param {string} repoId - The repository ID.
       * @param {string} branchName - The branch name.
       */
      getBuildBadgeData(project, repoType, repoId, branchName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repoType
            };
            let queryValues = {
              repoId,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "21b3b9ce-fad5-4567-9ad0-80679794e003", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all retention leases that apply to a specific build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getRetentionLeasesForBuild(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "3da19a6a-f088-45c4-83ce-2ad3a87be6c4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      deleteBuild(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a build
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} propertyFilters
       */
      getBuild(project, buildId, propertyFilters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              propertyFilters
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} definitions - A comma-delimited list of definition IDs. If specified, filters to builds for these definitions.
       * @param {number[]} queues - A comma-delimited list of queue IDs. If specified, filters to builds that ran against these queues.
       * @param {string} buildNumber - If specified, filters to builds that match this build number. Append * to do a prefix search.
       * @param {Date} minTime - If specified, filters to builds that finished/started/queued after this date based on the queryOrder specified.
       * @param {Date} maxTime - If specified, filters to builds that finished/started/queued before this date based on the queryOrder specified.
       * @param {string} requestedFor - If specified, filters to builds requested for the specified user.
       * @param {BuildInterfaces.BuildReason} reasonFilter - If specified, filters to builds that match this reason.
       * @param {BuildInterfaces.BuildStatus} statusFilter - If specified, filters to builds that match this status.
       * @param {BuildInterfaces.BuildResult} resultFilter - If specified, filters to builds that match this result.
       * @param {string[]} tagFilters - A comma-delimited list of tags. If specified, filters to builds that have the specified tags.
       * @param {string[]} properties - A comma-delimited list of properties to retrieve.
       * @param {number} top - The maximum number of builds to return.
       * @param {string} continuationToken - A continuation token, returned by a previous call to this method, that can be used to return the next set of builds.
       * @param {number} maxBuildsPerDefinition - The maximum number of builds to return per definition.
       * @param {BuildInterfaces.QueryDeletedOption} deletedFilter - Indicates whether to exclude, include, or only return deleted builds.
       * @param {BuildInterfaces.BuildQueryOrder} queryOrder - The order in which builds should be returned.
       * @param {string} branchName - If specified, filters to builds that built branches that built this branch.
       * @param {number[]} buildIds - A comma-delimited list that specifies the IDs of builds to retrieve.
       * @param {string} repositoryId - If specified, filters to builds that built from this repository.
       * @param {string} repositoryType - If specified, filters to builds that built from repositories of this type.
       */
      getBuilds(project, definitions, queues, buildNumber, minTime, maxTime, requestedFor, reasonFilter, statusFilter, resultFilter, tagFilters, properties, top, continuationToken, maxBuildsPerDefinition, deletedFilter, queryOrder, branchName, buildIds, repositoryId, repositoryType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitions: definitions && definitions.join(","),
              queues: queues && queues.join(","),
              buildNumber,
              minTime,
              maxTime,
              requestedFor,
              reasonFilter,
              statusFilter,
              resultFilter,
              tagFilters: tagFilters && tagFilters.join(","),
              properties: properties && properties.join(","),
              "$top": top,
              continuationToken,
              maxBuildsPerDefinition,
              deletedFilter,
              queryOrder,
              branchName,
              buildIds: buildIds && buildIds.join(","),
              repositoryId,
              repositoryType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a build
       *
       * @param {BuildInterfaces.Build} build
       * @param {string} project - Project ID or project name
       * @param {boolean} ignoreWarnings
       * @param {string} checkInTicket
       * @param {number} sourceBuildId
       * @param {number} definitionId - Optional definition id to queue a build without a body. Ignored if there's a valid body
       */
      queueBuild(build, project, ignoreWarnings, checkInTicket, sourceBuildId, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ignoreWarnings,
              checkInTicket,
              sourceBuildId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, build, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a build.
       *
       * @param {BuildInterfaces.Build} build - The build.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {boolean} retry
       */
      updateBuild(build, project, buildId, retry) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              retry
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, build, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates multiple builds.
       *
       * @param {BuildInterfaces.Build[]} builds - The builds to update.
       * @param {string} project - Project ID or project name
       */
      updateBuilds(builds, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, builds, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the changes associated with a build
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} continuationToken
       * @param {number} top - The maximum number of changes to return
       * @param {boolean} includeSourceChange
       */
      getBuildChanges(project, buildId, continuationToken, top, includeSourceChange) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              continuationToken,
              "$top": top,
              includeSourceChange
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "54572c7b-bbd3-45d4-80dc-28be08941620", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Change, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the changes made to the repository between two given builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number} fromBuildId - The ID of the first build.
       * @param {number} toBuildId - The ID of the last build.
       * @param {number} top - The maximum number of changes to return.
       */
      getChangesBetweenBuilds(project, fromBuildId, toBuildId, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromBuildId,
              toBuildId,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "f10f0ea5-18a1-43ec-a8fb-2042c7be9b43", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Change, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a controller
       *
       * @param {number} controllerId
       */
      getBuildController(controllerId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              controllerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "fcac1932-2ee1-437f-9b6f-7f696be858f6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildController, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets controller, optionally filtered by name
       *
       * @param {string} name
       */
      getBuildControllers(name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "fcac1932-2ee1-437f-9b6f-7f696be858f6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildController, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new definition.
       *
       * @param {BuildInterfaces.BuildDefinition} definition - The definition.
       * @param {string} project - Project ID or project name
       * @param {number} definitionToCloneId
       * @param {number} definitionToCloneRevision
       */
      createDefinition(definition, project, definitionToCloneId, definitionToCloneRevision) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionToCloneId,
              definitionToCloneRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, definition, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a definition and all associated builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      deleteDefinition(project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a definition, optionally at a specific revision.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} revision - The revision number to retrieve. If this is not specified, the latest version will be returned.
       * @param {Date} minMetricsTime - If specified, indicates the date from which metrics should be included.
       * @param {string[]} propertyFilters - A comma-delimited list of properties to include in the results.
       * @param {boolean} includeLatestBuilds
       */
      getDefinition(project, definitionId, revision, minMetricsTime, propertyFilters, includeLatestBuilds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision,
              minMetricsTime,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              includeLatestBuilds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of definitions.
       *
       * @param {string} project - Project ID or project name
       * @param {string} name - If specified, filters to definitions whose names match this pattern.
       * @param {string} repositoryId - A repository ID. If specified, filters to definitions that use this repository.
       * @param {string} repositoryType - If specified, filters to definitions that have a repository of this type.
       * @param {BuildInterfaces.DefinitionQueryOrder} queryOrder - Indicates the order in which definitions should be returned.
       * @param {number} top - The maximum number of definitions to return.
       * @param {string} continuationToken - A continuation token, returned by a previous call to this method, that can be used to return the next set of definitions.
       * @param {Date} minMetricsTime - If specified, indicates the date from which metrics should be included.
       * @param {number[]} definitionIds - A comma-delimited list that specifies the IDs of definitions to retrieve.
       * @param {string} path - If specified, filters to definitions under this folder.
       * @param {Date} builtAfter - If specified, filters to definitions that have builds after this date.
       * @param {Date} notBuiltAfter - If specified, filters to definitions that do not have builds after this date.
       * @param {boolean} includeAllProperties - Indicates whether the full definitions should be returned. By default, shallow representations of the definitions are returned.
       * @param {boolean} includeLatestBuilds - Indicates whether to return the latest and latest completed builds for this definition.
       * @param {string} taskIdFilter - If specified, filters to definitions that use the specified task.
       * @param {number} processType - If specified, filters to definitions with the given process type.
       * @param {string} yamlFilename - If specified, filters to YAML definitions that match the given filename. To use this filter includeAllProperties should be set to true
       */
      getDefinitions(project, name, repositoryId, repositoryType, queryOrder, top, continuationToken, minMetricsTime, definitionIds, path10, builtAfter, notBuiltAfter, includeAllProperties, includeLatestBuilds, taskIdFilter, processType, yamlFilename) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              repositoryId,
              repositoryType,
              queryOrder,
              "$top": top,
              continuationToken,
              minMetricsTime,
              definitionIds: definitionIds && definitionIds.join(","),
              path: path10,
              builtAfter,
              notBuiltAfter,
              includeAllProperties,
              includeLatestBuilds,
              taskIdFilter,
              processType,
              yamlFilename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionReference, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Restores a deleted definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The identifier of the definition to restore.
       * @param {boolean} deleted - When false, restores a deleted definition.
       */
      restoreDefinition(project, definitionId, deleted) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (deleted == null) {
            throw new TypeError("deleted can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              deleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing build definition.  In order for this operation to succeed, the value of the "Revision" property of the request body must match the existing build definition's. It is recommended that you obtain the existing build definition by using GET, modify the build definition as necessary, and then submit the modified definition with PUT.
       *
       * @param {BuildInterfaces.BuildDefinition} definition - The new version of the definition. Its "Revision" property must match the existing definition for the update to be accepted.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} secretsSourceDefinitionId
       * @param {number} secretsSourceDefinitionRevision
       */
      updateDefinition(definition, project, definitionId, secretsSourceDefinitionId, secretsSourceDefinitionRevision) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              secretsSourceDefinitionId,
              secretsSourceDefinitionRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, definition, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the contents of a file in the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
       * @param {string} commitOrBranch - The identifier of the commit or branch from which a file's contents are retrieved.
       * @param {string} path - The path to the file to retrieve, relative to the root of the repository.
       */
      getFileContents(project, providerName, serviceEndpointId, repository, commitOrBranch, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              commitOrBranch,
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "29d12225-b1d9-425f-b668-6c594a981313", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new folder.
       *
       * @param {BuildInterfaces.Folder} folder - The folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - The full path of the folder.
       */
      createFolder(folder, project, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, folder, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a definition folder. Definitions and their corresponding builds will also be deleted.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - The full path to the folder.
       */
      deleteFolder(project, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of build definition folders.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - The path to start with.
       * @param {BuildInterfaces.FolderQueryOrder} queryOrder - The order in which folders should be returned.
       */
      getFolders(project, path10, queryOrder) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path10
            };
            let queryValues = {
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Folder, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing folder at given  existing path
       *
       * @param {BuildInterfaces.Folder} folder - The new version of the folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - The full path to the folder.
       */
      updateFolder(folder, project, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, folder, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets pipeline general settings.
       *
       * @param {string} project - Project ID or project name
       */
      getBuildGeneralSettings(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "c4aefd19-30ff-405b-80ad-aca021e7242a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates pipeline general settings.
       *
       * @param {BuildInterfaces.PipelineGeneralSettings} newSettings
       * @param {string} project - Project ID or project name
       */
      updateBuildGeneralSettings(newSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "c4aefd19-30ff-405b-80ad-aca021e7242a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the retention history for the project collection. This includes pipelines that have custom retention rules that may prevent the retention job from cleaning them up, runs per pipeline with retention type, files associated with pipelines owned by the collection with retention type, and the number of files per pipeline.
       *
       * @param {number} daysToLookback
       */
      getRetentionHistory(daysToLookback) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              daysToLookback
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "1a9c48be-0ef5-4ec2-b94f-f053bdd2d3bf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildRetentionHistory, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the latest build for a definition, optionally scoped to a specific branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} definition - definition name with optional leading folder path, or the definition id
       * @param {string} branchName - optional parameter that indicates the specific branch to use. If not specified, the default branch is used.
       */
      getLatestBuild(project, definition, branchName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definition
            };
            let queryValues = {
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "54481611-01f4-47f3-998f-160da0f0c229", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds new leases for pipeline runs.
       *
       * @param {BuildInterfaces.NewRetentionLease[]} newLeases
       * @param {string} project - Project ID or project name
       */
      addRetentionLeases(newLeases, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newLeases, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes specific retention leases.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} ids
       */
      deleteRetentionLeasesById(project, ids) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the details of the retention lease given a lease id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} leaseId
       */
      getRetentionLease(project, leaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              leaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns any leases matching the specified MinimalRetentionLeases
       *
       * @param {string} project - Project ID or project name
       * @param {BuildInterfaces.MinimalRetentionLease[]} leasesToFetch - List of JSON-serialized MinimalRetentionLeases separated by '|'
       */
      getRetentionLeasesByMinimalRetentionLeases(project, leasesToFetch) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (leasesToFetch == null) {
            throw new TypeError("leasesToFetch can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              leasesToFetch: leasesToFetch && leasesToFetch.join("|")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns any leases owned by the specified entity, optionally scoped to a single pipeline definition and run.
       *
       * @param {string} project - Project ID or project name
       * @param {string} ownerId
       * @param {number} definitionId - An optional parameter to limit the search to a specific pipeline definition.
       * @param {number} runId - An optional parameter to limit the search to a single pipeline run. Requires definitionId.
       */
      getRetentionLeasesByOwnerId(project, ownerId, definitionId, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ownerId,
              definitionId,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns any leases owned by the specified user, optionally scoped to a single pipeline definition and run.
       *
       * @param {string} project - Project ID or project name
       * @param {string} userOwnerId - The user id to search for.
       * @param {number} definitionId - An optional parameter to limit the search to a specific pipeline definition.
       * @param {number} runId - An optional parameter to limit the search to a single pipeline run. Requires definitionId.
       */
      getRetentionLeasesByUserId(project, userOwnerId, definitionId, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (userOwnerId == null) {
            throw new TypeError("userOwnerId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              userOwnerId,
              definitionId,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the duration or pipeline protection status of a retention lease.
       *
       * @param {BuildInterfaces.RetentionLeaseUpdate} leaseUpdate - The new data for the retention lease.
       * @param {string} project - Project ID or project name
       * @param {number} leaseId - The ID of the lease to update.
       */
      updateRetentionLease(leaseUpdate, project, leaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              leaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, leaseUpdate, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets an individual log file for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} logId - The ID of the log file.
       * @param {number} startLine - The start line.
       * @param {number} endLine - The end line.
       */
      getBuildLog(project, buildId, logId, startLine, endLine) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets an individual log file for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} logId - The ID of the log file.
       * @param {number} startLine - The start line.
       * @param {number} endLine - The end line.
       */
      getBuildLogLines(project, buildId, logId, startLine, endLine) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the logs for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getBuildLogs(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the logs for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getBuildLogsZip(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets an individual log file for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} logId - The ID of the log file.
       * @param {number} startLine - The start line.
       * @param {number} endLine - The end line.
       */
      getBuildLogZip(project, buildId, logId, startLine, endLine) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets build metrics for a project.
       *
       * @param {string} project - Project ID or project name
       * @param {string} metricAggregationType - The aggregation type to use (hourly, daily).
       * @param {Date} minMetricsTime - The date from which to calculate metrics.
       */
      getProjectMetrics(project, metricAggregationType, minMetricsTime) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              metricAggregationType
            };
            let queryValues = {
              minMetricsTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "7433fae7-a6bc-41dc-a6e2-eef9005ce41a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildMetric, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets build metrics for a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {Date} minMetricsTime - The date from which to calculate metrics.
       */
      getDefinitionMetrics(project, definitionId, minMetricsTime) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              minMetricsTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d973b939-0ce0-4fec-91d8-da3940fa1827", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildMetric, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all build definition options supported by the system.
       *
       * @param {string} project - Project ID or project name
       */
      getBuildOptionDefinitions(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "591cb5a4-2d46-4f3a-a697-5cd42b6bd332", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildOptionDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the contents of a directory in the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
       * @param {string} commitOrBranch - The identifier of the commit or branch from which a file's contents are retrieved.
       * @param {string} path - The path contents to list, relative to the root of the repository.
       */
      getPathContents(project, providerName, serviceEndpointId, repository, commitOrBranch, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              commitOrBranch,
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "7944d6fb-df01-4709-920a-7a189aa34037", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets properties for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string[]} filter - A comma-delimited list of properties. If specified, filters to these specific properties.
       */
      getBuildProperties(project, buildId, filter2) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              filter: filter2 && filter2.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "0a6312e9-0627-49b7-8083-7d74a64849c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates properties for a build.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - A json-patch document describing the properties to update.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      updateBuildProperties(customHeaders, document, project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "0a6312e9-0627-49b7-8083-7d74a64849c9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, document, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets properties for a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {string[]} filter - A comma-delimited list of properties. If specified, filters to these specific properties.
       */
      getDefinitionProperties(project, definitionId, filter2) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              filter: filter2 && filter2.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d9826ad7-2a68-46a9-a6e9-677698777895", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates properties for a definition.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - A json-patch document describing the properties to update.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      updateDefinitionProperties(customHeaders, document, project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d9826ad7-2a68-46a9-a6e9-677698777895", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, document, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a pull request object from source provider.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} pullRequestId - Vendor-specific id of the pull request.
       * @param {string} repositoryId - Vendor-specific identifier or the name of the repository that contains the pull request.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       */
      getPullRequest(project, providerName, pullRequestId, repositoryId, serviceEndpointId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName,
              pullRequestId
            };
            let queryValues = {
              repositoryId,
              serviceEndpointId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d8763ec7-9ff0-4fb4-b2b2-9d757906ff14", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a build report.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} type
       */
      getBuildReport(project, buildId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "45bcaa88-67e1-4042-a035-56d3b4a7d44c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a build report.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} type
       */
      getBuildReportHtmlContent(project, buildId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "45bcaa88-67e1-4042-a035-56d3b4a7d44c", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/html", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of source code repositories.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of a single repository to get.
       * @param {BuildInterfaces.ResultSet} resultSet - 'top' for the repositories most relevant for the endpoint. If not set, all repositories are returned. Ignored if 'repository' is set.
       * @param {boolean} pageResults - If set to true, this will limit the set of results and will return a continuation token to continue the query.
       * @param {string} continuationToken - When paging results, this is a continuation token, returned by a previous call to this method, that can be used to return the next set of repositories.
       */
      listRepositories(project, providerName, serviceEndpointId, repository, resultSet, pageResults, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              resultSet,
              pageResults,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d44d1680-f978-4834-9b93-8c6e132329c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {BuildInterfaces.DefinitionResourceReference[]} resources
       * @param {string} project - Project ID or project name
       * @param {number} definitionId
       */
      authorizeDefinitionResources(resources, project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "ea623316-1967-45eb-89ab-e9e6110cf2d6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, resources, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} definitionId
       */
      getDefinitionResources(project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "ea623316-1967-45eb-89ab-e9e6110cf2d6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets information about build resources in the system.
       *
       */
      getResourceUsage() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "3813d06c-9e36-4ea1-aac3-61a485d60e3d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the project's retention settings.
       *
       * @param {string} project - Project ID or project name
       */
      getRetentionSettings(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "dadb46e7-5851-4c72-820e-ae8abb82f59f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the project's retention settings.
       *
       * @param {BuildInterfaces.UpdateProjectRetentionSettingModel} updateModel
       * @param {string} project - Project ID or project name
       */
      updateRetentionSettings(updateModel, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "dadb46e7-5851-4c72-820e-ae8abb82f59f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all revisions of a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      getDefinitionRevisions(project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "7c116775-52e5-453e-8c5d-914d9762d8c4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the build settings.
       *
       * @param {string} project - Project ID or project name
       */
      getBuildSettings(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "aa8c1c9c-ef8b-474a-b8c4-785c7b191d0d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the build settings.
       *
       * @param {BuildInterfaces.BuildSettings} settings - The new settings.
       * @param {string} project - Project ID or project name
       */
      updateBuildSettings(settings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "aa8c1c9c-ef8b-474a-b8c4-785c7b191d0d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, settings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of source providers and their capabilities.
       *
       * @param {string} project - Project ID or project name
       */
      listSourceProviders(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "3ce81729-954f-423d-a581-9fea01d25186", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.SourceProviderAttributes, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a build stage
       *
       * @param {BuildInterfaces.UpdateStageParameters} updateParameters
       * @param {number} buildId
       * @param {string} stageRefName
       * @param {string} project - Project ID or project name
       */
      updateStage(updateParameters, buildId, stageRefName, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              stageRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "b8aac6c9-744b-46e1-88fc-3550969f9313", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * <p>Gets the build status for a definition, optionally scoped to a specific branch, stage, job, and configuration.</p> <p>If there are more than one, then it is required to pass in a stageName value when specifying a jobName, and the same rule then applies for both if passing a configuration parameter.</p>
       *
       * @param {string} project - Project ID or project name
       * @param {string} definition - Either the definition name with optional leading folder path, or the definition id.
       * @param {string} branchName - Only consider the most recent build for this branch. If not specified, the default branch is used.
       * @param {string} stageName - Use this stage within the pipeline to render the status.
       * @param {string} jobName - Use this job within a stage of the pipeline to render the status.
       * @param {string} configuration - Use this job configuration to render the status
       * @param {string} label - Replaces the default text on the left side of the badge.
       */
      getStatusBadge(project, definition, branchName, stageName, jobName, configuration, label) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definition
            };
            let queryValues = {
              branchName,
              stageName,
              jobName,
              configuration,
              label
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "07acfdce-4757-4439-b422-ddd13a2fcc10", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} tag - The tag to add.
       */
      addBuildTag(project, buildId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds tags to a build.
       *
       * @param {string[]} tags - The tags to add. Request body is composed directly from listed tags.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      addBuildTags(tags, project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a tag from a build. NOTE: This API will not work for tags with special characters. To remove tags with special characters, use the PATCH method instead (in 6.0+)
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} tag - The tag to remove.
       */
      deleteBuildTag(project, buildId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getBuildTags(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds/Removes tags from a build.
       *
       * @param {BuildInterfaces.UpdateTagParameters} updateParameters - The tags to add/remove.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      updateBuildTags(updateParameters, project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {string} tag - The tag to add.
       */
      addDefinitionTag(project, definitionId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds multiple tags to a definition.
       *
       * @param {string[]} tags - The tags to add.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      addDefinitionTags(tags, project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a tag from a definition. NOTE: This API will not work for tags with special characters. To remove tags with special characters, use the PATCH method instead (in 6.0+)
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {string} tag - The tag to remove.
       */
      deleteDefinitionTag(project, definitionId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} revision - The definition revision number. If not specified, uses the latest revision of the definition.
       */
      getDefinitionTags(project, definitionId, revision) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds/Removes tags from a definition.
       *
       * @param {BuildInterfaces.UpdateTagParameters} updateParameters - The tags to add/remove.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      updateDefinitionTags(updateParameters, project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a tag from builds, definitions, and from the tag store
       *
       * @param {string} project - Project ID or project name
       * @param {string} tag - The tag to remove.
       */
      deleteTag(project, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "d84ac5c6-edc7-43d5-adc9-1b34be5dea09", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of all build tags in the project.
       *
       * @param {string} project - Project ID or project name
       */
      getTags(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "d84ac5c6-edc7-43d5-adc9-1b34be5dea09", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a build definition template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - The ID of the template.
       */
      deleteTemplate(project, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific build definition template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - The ID of the requested template.
       */
      getTemplate(project, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all definition templates.
       *
       * @param {string} project - Project ID or project name
       */
      getTemplates(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionTemplate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing build definition template.
       *
       * @param {BuildInterfaces.BuildDefinitionTemplate} template - The new version of the template.
       * @param {string} project - Project ID or project name
       * @param {string} templateId - The ID of the template.
       */
      saveTemplate(template2, project, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, template2, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets details for a build
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} timelineId
       * @param {number} changeId
       * @param {string} planId
       */
      getBuildTimeline(project, buildId, timelineId, changeId, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              timelineId
            };
            let queryValues = {
              changeId,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "8baac422-4c6e-4de5-8532-db96d92acffa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Timeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Recreates the webhooks for the specified triggers in the given source code repository.
       *
       * @param {BuildInterfaces.DefinitionTriggerType[]} triggerTypes - The types of triggers to restore webhooks for.
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.
       */
      restoreWebhooks(triggerTypes, project, providerName, serviceEndpointId, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "793bceb8-9736-4030-bd2f-fb3ce6d6b478", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, triggerTypes, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of webhooks installed in the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.
       */
      listWebhooks(project, providerName, serviceEndpointId, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "8f20ff82-9498-4812-9f6e-9c01bdc50e99", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RepositoryWebhook, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work items associated with a build. Only work items in the same project are returned.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} top - The maximum number of work items to return.
       */
      getBuildWorkItemsRefs(project, buildId, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "5a21f5d2-5642-47e4-a0bd-1356e6731bee", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work items associated with a build, filtered to specific commits.
       *
       * @param {string[]} commitIds - A comma-delimited list of commit IDs.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} top - The maximum number of work items to return, or the number of commits to consider if no commit IDs are specified.
       */
      getBuildWorkItemsRefsFromCommits(commitIds, project, buildId, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "5a21f5d2-5642-47e4-a0bd-1356e6731bee", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, commitIds, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all the work items between two builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number} fromBuildId - The ID of the first build.
       * @param {number} toBuildId - The ID of the last build.
       * @param {number} top - The maximum number of work items to return.
       */
      getWorkItemsBetweenBuilds(project, fromBuildId, toBuildId, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (fromBuildId == null) {
            throw new TypeError("fromBuildId can not be null or undefined");
          }
          if (toBuildId == null) {
            throw new TypeError("toBuildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromBuildId,
              toBuildId,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "52ba8915-5518-42e3-a4bb-b0182d159e2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Converts a definition to YAML, optionally at a specific revision.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} revision - The revision number to retrieve. If this is not specified, the latest version will be returned.
       * @param {Date} minMetricsTime - If specified, indicates the date from which metrics should be included.
       * @param {string[]} propertyFilters - A comma-delimited list of properties to include in the results.
       * @param {boolean} includeLatestBuilds
       */
      getDefinitionYaml(project, definitionId, revision, minMetricsTime, propertyFilters, includeLatestBuilds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision,
              minMetricsTime,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              includeLatestBuilds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "7c3df3a1-7e51-4150-8cf7-540347f8697f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.BuildApi = BuildApi;
    BuildApi.RESOURCE_AREA_ID = "965220d5-5bb9-42cf-8d67-9b146df2a5a4";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/common/OperationsInterfaces.js
var require_OperationsInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/common/OperationsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.OperationStatus = void 0;
    var OperationStatus;
    (function(OperationStatus2) {
      OperationStatus2[OperationStatus2["NotSet"] = 0] = "NotSet";
      OperationStatus2[OperationStatus2["Queued"] = 1] = "Queued";
      OperationStatus2[OperationStatus2["InProgress"] = 2] = "InProgress";
      OperationStatus2[OperationStatus2["Cancelled"] = 3] = "Cancelled";
      OperationStatus2[OperationStatus2["Succeeded"] = 4] = "Succeeded";
      OperationStatus2[OperationStatus2["Failed"] = 5] = "Failed";
    })(OperationStatus = exports2.OperationStatus || (exports2.OperationStatus = {}));
    exports2.TypeInfo = {
      Operation: {},
      OperationReference: {},
      OperationStatus: {
        enumValues: {
          "notSet": 0,
          "queued": 1,
          "inProgress": 2,
          "cancelled": 3,
          "succeeded": 4,
          "failed": 5
        }
      }
    };
    exports2.TypeInfo.Operation.fields = {
      status: {
        enumType: exports2.TypeInfo.OperationStatus
      }
    };
    exports2.TypeInfo.OperationReference.fields = {
      status: {
        enumType: exports2.TypeInfo.OperationStatus
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/CoreApi.js
var require_CoreApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/CoreApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoreApi = void 0;
    var basem = require_ClientApiBases();
    var CoreInterfaces = require_CoreInterfaces();
    var OperationsInterfaces = require_OperationsInterfaces();
    var CoreApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Core-api", options2);
      }
      /**
       * Removes the avatar for the project.
       *
       * @param {string} projectId - The ID or name of the project.
       */
      removeProjectAvatar(projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "54b2a2a0-859b-4d05-827c-ec4c862f641a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Sets the avatar for the project.
       *
       * @param {CoreInterfaces.ProjectAvatar} avatarBlob - The avatar blob data object to upload.
       * @param {string} projectId - The ID or name of the project.
       */
      setProjectAvatar(avatarBlob, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "54b2a2a0-859b-4d05-827c-ec4c862f641a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, avatarBlob, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets list of user readable teams in a project and teams user is member of (excluded from readable list).
       *
       * @param {string} projectId - The name or ID (GUID) of the team project containing the teams to retrieve.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       * @param {number} top - Maximum number of teams to return.
       * @param {number} skip - Number of teams to skip.
       */
      getProjectTeamsByCategory(projectId, expandIdentity, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              "$expandIdentity": expandIdentity,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "6f9619ff-8b86-d011-b42d-00c04fc964ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.WebApiConnectedServiceDetails} connectedServiceCreationData
       * @param {string} projectId
       */
      createConnectedService(connectedServiceCreationData, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "b4f70219-e18b-42c5-abe3-98b07d35525e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, connectedServiceCreationData, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.WebApiConnectedService, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} projectId
       * @param {string} name
       */
      getConnectedServiceDetails(projectId, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "b4f70219-e18b-42c5-abe3-98b07d35525e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.WebApiConnectedServiceDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} projectId
       * @param {CoreInterfaces.ConnectedServiceKind} kind
       */
      getConnectedServices(projectId, kind) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              kind
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "b4f70219-e18b-42c5-abe3-98b07d35525e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.WebApiConnectedService, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.IdentityData} mruData
       * @param {string} mruName
       */
      createIdentityMru(mruData, mruName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, mruData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.IdentityData} mruData
       * @param {string} mruName
       */
      deleteIdentityMru(mruData, mruName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} mruName
       */
      getIdentityMru(mruName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.IdentityData} mruData
       * @param {string} mruName
       */
      updateIdentityMru(mruData, mruName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, mruData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of members for a specific team.
       *
       * @param {string} projectId - The name or ID (GUID) of the team project the team belongs to.
       * @param {string} teamId - The name or ID (GUID) of the team .
       * @param {number} top
       * @param {number} skip
       */
      getTeamMembersWithExtendedProperties(projectId, teamId, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "294c494c-2600-4d7e-b76c-3dd50c3c95be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a process by ID.
       *
       * @param {string} processId - ID for a process.
       */
      getProcessById(processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "93878975-88c5-4e6a-8abb-7ddd77a8a7d8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.Process, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of processes.
       *
       */
      getProcesses() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "93878975-88c5-4e6a-8abb-7ddd77a8a7d8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.Process, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get project collection with the specified id or name.
       *
       * @param {string} collectionId
       */
      getProjectCollection(collectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              collectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "8031090f-ef1d-4af6-85fc-698cd75d42bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.TeamProjectCollection, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get project collection references for this application.
       *
       * @param {number} top
       * @param {number} skip
       */
      getProjectCollections(top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "8031090f-ef1d-4af6-85fc-698cd75d42bf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the history of changes to the project.
       *
       * @param {number} minRevision - The minimum revision number to return in the history.
       */
      getProjectHistoryEntries(minRevision) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              minRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "6488a877-4749-4954-82ea-7340d36be9f2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.ProjectInfo, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get project with the specified id or name, optionally including capabilities.
       *
       * @param {string} projectId
       * @param {boolean} includeCapabilities - Include capabilities (such as source control) in the team project result (default: false).
       * @param {boolean} includeHistory - Search within renamed projects (that had such name in the past).
       */
      getProject(projectId, includeCapabilities, includeHistory) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              includeCapabilities,
              includeHistory
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.TeamProject, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all projects in the organization that the authenticated user has access to.
       *
       * @param {any} stateFilter - Filter on team projects in a specific team project state (default: WellFormed).
       * @param {number} top
       * @param {number} skip
       * @param {number} continuationToken - Pointer that shows how many projects already been fetched.
       * @param {boolean} getDefaultTeamImageUrl
       */
      getProjects(stateFilter, top, skip, continuationToken, getDefaultTeamImageUrl) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              stateFilter,
              "$top": top,
              "$skip": skip,
              continuationToken,
              getDefaultTeamImageUrl
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.TeamProjectReference, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a project to be created. Use the [GetOperation](../../operations/operations/get) to periodically check for create project status.
       *
       * @param {CoreInterfaces.TeamProject} projectToCreate - The project to create.
       */
      queueCreateProject(projectToCreate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectToCreate, options2);
              let ret = this.formatResponse(res.result, OperationsInterfaces.TypeInfo.OperationReference, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a project to be deleted. Use the [GetOperation](../../operations/operations/get) to periodically check for delete project status.
       *
       * @param {string} projectId - The project id of the project to delete.
       */
      queueDeleteProject(projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, OperationsInterfaces.TypeInfo.OperationReference, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an existing project's name, abbreviation, description, or restore a project.
       *
       * @param {CoreInterfaces.TeamProject} projectUpdate - The updates for the project. The state must be set to wellFormed to restore the project.
       * @param {string} projectId - The project id of the project to update.
       */
      updateProject(projectUpdate, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, projectUpdate, options2);
              let ret = this.formatResponse(res.result, OperationsInterfaces.TypeInfo.OperationReference, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of team project properties for multiple projects.
       *
       * @param {string[]} projectIds - A comma-delimited string of team project IDs
       * @param {string[]} properties
       */
      getProjectsProperties(projectIds, properties) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (projectIds == null) {
            throw new TypeError("projectIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              projectIds: projectIds && projectIds.join(","),
              properties: properties && properties.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "0a3ffdfc-fe94-47a6-bb27-79bf3f762eac", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of team project properties.
       *
       * @param {string} projectId - The team project ID.
       * @param {string[]} keys - A comma-delimited string of team project property names. Wildcard characters ("?" and "*") are supported. If no key is specified, all properties will be returned.
       */
      getProjectProperties(projectId, keys2) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              keys: keys2 && keys2.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "4976a71a-4487-49aa-8aab-a1eda469037a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create, update, and delete team project properties.
       *
       * @param {string} projectId - The team project ID.
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - A JSON Patch document that represents an array of property operations. See RFC 6902 for more details on JSON Patch. The accepted operation verbs are Add and Remove, where Add is used for both creating and updating properties. The path consists of a forward slash and a property name.
       */
      setProjectProperties(customHeaders, projectId, patchDocument) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "4976a71a-4487-49aa-8aab-a1eda469037a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.Proxy} proxy
       */
      createOrUpdateProxy(proxy) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "ec1f4311-f2b4-4c15-b2b8-8990b80d2908", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, proxy, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} proxyUrl
       * @param {string} site
       */
      deleteProxy(proxyUrl, site) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (proxyUrl == null) {
            throw new TypeError("proxyUrl can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              proxyUrl,
              site
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "ec1f4311-f2b4-4c15-b2b8-8990b80d2908", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} proxyUrl
       */
      getProxies(proxyUrl) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              proxyUrl
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "ec1f4311-f2b4-4c15-b2b8-8990b80d2908", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of all teams.
       *
       * @param {boolean} mine - If true, then return all teams requesting user is member. Otherwise return all teams user has read access.
       * @param {number} top - Maximum number of teams to return.
       * @param {number} skip - Number of teams to skip.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       */
      getAllTeams(mine, top, skip, expandIdentity) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$mine": mine,
              "$top": top,
              "$skip": skip,
              "$expandIdentity": expandIdentity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "7a4d9ee9-3433-4347-b47a-7a80f1cf307e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a team in a team project.
       *
       * @param {CoreInterfaces.WebApiTeam} team - The team data used to create the team.
       * @param {string} projectId - The name or ID (GUID) of the team project in which to create the team.
       */
      createTeam(team, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, team, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a team.
       *
       * @param {string} projectId - The name or ID (GUID) of the team project containing the team to delete.
       * @param {string} teamId - The name or ID of the team to delete.
       */
      deleteTeam(projectId, teamId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific team.
       *
       * @param {string} projectId - The name or ID (GUID) of the team project containing the team.
       * @param {string} teamId - The name or ID (GUID) of the team.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       */
      getTeam(projectId, teamId, expandIdentity) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            let queryValues = {
              "$expandIdentity": expandIdentity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of teams.
       *
       * @param {string} projectId
       * @param {boolean} mine - If true return all the teams requesting user is member, otherwise return all the teams user has read access.
       * @param {number} top - Maximum number of teams to return.
       * @param {number} skip - Number of teams to skip.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       */
      getTeams(projectId, mine, top, skip, expandIdentity) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              "$mine": mine,
              "$top": top,
              "$skip": skip,
              "$expandIdentity": expandIdentity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a team's name and/or description.
       *
       * @param {CoreInterfaces.WebApiTeam} teamData
       * @param {string} projectId - The name or ID (GUID) of the team project containing the team to update.
       * @param {string} teamId - The name of ID of the team to update.
       */
      updateTeam(teamData, projectId, teamId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, teamData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.CoreApi = CoreApi;
    CoreApi.RESOURCE_AREA_ID = "79134c72-4a58-4b42-976c-04e7115f32bf";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/DashboardInterfaces.js
var require_DashboardInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/DashboardInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WidgetScope = exports2.TeamDashboardPermission = exports2.GroupMemberPermission = exports2.DashboardScope = void 0;
    var DashboardScope;
    (function(DashboardScope2) {
      DashboardScope2[DashboardScope2["Collection_User"] = 0] = "Collection_User";
      DashboardScope2[DashboardScope2["Project_Team"] = 1] = "Project_Team";
      DashboardScope2[DashboardScope2["Project"] = 2] = "Project";
    })(DashboardScope = exports2.DashboardScope || (exports2.DashboardScope = {}));
    var GroupMemberPermission;
    (function(GroupMemberPermission2) {
      GroupMemberPermission2[GroupMemberPermission2["None"] = 0] = "None";
      GroupMemberPermission2[GroupMemberPermission2["Edit"] = 1] = "Edit";
      GroupMemberPermission2[GroupMemberPermission2["Manage"] = 2] = "Manage";
      GroupMemberPermission2[GroupMemberPermission2["ManagePermissions"] = 3] = "ManagePermissions";
    })(GroupMemberPermission = exports2.GroupMemberPermission || (exports2.GroupMemberPermission = {}));
    var TeamDashboardPermission;
    (function(TeamDashboardPermission2) {
      TeamDashboardPermission2[TeamDashboardPermission2["None"] = 0] = "None";
      TeamDashboardPermission2[TeamDashboardPermission2["Read"] = 1] = "Read";
      TeamDashboardPermission2[TeamDashboardPermission2["Create"] = 2] = "Create";
      TeamDashboardPermission2[TeamDashboardPermission2["Edit"] = 4] = "Edit";
      TeamDashboardPermission2[TeamDashboardPermission2["Delete"] = 8] = "Delete";
      TeamDashboardPermission2[TeamDashboardPermission2["ManagePermissions"] = 16] = "ManagePermissions";
    })(TeamDashboardPermission = exports2.TeamDashboardPermission || (exports2.TeamDashboardPermission = {}));
    var WidgetScope;
    (function(WidgetScope2) {
      WidgetScope2[WidgetScope2["Collection_User"] = 0] = "Collection_User";
      WidgetScope2[WidgetScope2["Project_Team"] = 1] = "Project_Team";
    })(WidgetScope = exports2.WidgetScope || (exports2.WidgetScope = {}));
    exports2.TypeInfo = {
      CopyDashboardOptions: {},
      CopyDashboardResponse: {},
      Dashboard: {},
      DashboardGroup: {},
      DashboardGroupEntry: {},
      DashboardGroupEntryResponse: {},
      DashboardResponse: {},
      DashboardScope: {
        enumValues: {
          "collection_User": 0,
          "project_Team": 1,
          "project": 2
        }
      },
      GroupMemberPermission: {
        enumValues: {
          "none": 0,
          "edit": 1,
          "manage": 2,
          "managePermissions": 3
        }
      },
      TeamDashboardPermission: {
        enumValues: {
          "none": 0,
          "read": 1,
          "create": 2,
          "edit": 4,
          "delete": 8,
          "managePermissions": 16
        }
      },
      Widget: {},
      WidgetMetadata: {},
      WidgetMetadataResponse: {},
      WidgetResponse: {},
      WidgetScope: {
        enumValues: {
          "collection_User": 0,
          "project_Team": 1
        }
      },
      WidgetsVersionedList: {},
      WidgetTypesResponse: {}
    };
    exports2.TypeInfo.CopyDashboardOptions.fields = {
      copyDashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      }
    };
    exports2.TypeInfo.CopyDashboardResponse.fields = {
      copiedDashboard: {
        typeInfo: exports2.TypeInfo.Dashboard
      },
      copyDashboardOptions: {
        typeInfo: exports2.TypeInfo.CopyDashboardOptions
      }
    };
    exports2.TypeInfo.Dashboard.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.DashboardGroup.fields = {
      dashboardEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DashboardGroupEntry
      },
      permission: {
        enumType: exports2.TypeInfo.GroupMemberPermission
      },
      teamDashboardPermission: {
        enumType: exports2.TypeInfo.TeamDashboardPermission
      }
    };
    exports2.TypeInfo.DashboardGroupEntry.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.DashboardGroupEntryResponse.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.DashboardResponse.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.Widget.fields = {
      dashboard: {
        typeInfo: exports2.TypeInfo.Dashboard
      }
    };
    exports2.TypeInfo.WidgetMetadata.fields = {
      supportedScopes: {
        isArray: true,
        enumType: exports2.TypeInfo.WidgetScope
      }
    };
    exports2.TypeInfo.WidgetMetadataResponse.fields = {
      widgetMetadata: {
        typeInfo: exports2.TypeInfo.WidgetMetadata
      }
    };
    exports2.TypeInfo.WidgetResponse.fields = {
      dashboard: {
        typeInfo: exports2.TypeInfo.Dashboard
      }
    };
    exports2.TypeInfo.WidgetsVersionedList.fields = {
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.WidgetTypesResponse.fields = {
      widgetTypes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WidgetMetadata
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/DashboardApi.js
var require_DashboardApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/DashboardApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DashboardApi = void 0;
    var basem = require_ClientApiBases();
    var DashboardInterfaces = require_DashboardInterfaces();
    var DashboardApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Dashboard-api", options2);
      }
      /**
       * Create the supplied dashboard.
       *
       * @param {DashboardInterfaces.Dashboard} dashboard - The initial state of the dashboard
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      createDashboard(dashboard, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, dashboard, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a dashboard given its ID. This also deletes the widgets associated with this dashboard.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard to delete.
       */
      deleteDashboard(teamContext, dashboardId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a dashboard by its ID.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId
       */
      getDashboard(teamContext, dashboardId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of dashboards under a project.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getDashboardsByProject(teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace configuration for the specified dashboard. Replaces Widget list on Dashboard, only if property is supplied.
       *
       * @param {DashboardInterfaces.Dashboard} dashboard - The Configuration of the dashboard to replace.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard to replace.
       */
      replaceDashboard(dashboard, teamContext, dashboardId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, dashboard, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the name and position of dashboards in the supplied group, and remove omitted dashboards. Does not modify dashboard content.
       *
       * @param {DashboardInterfaces.DashboardGroup} group
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      replaceDashboards(group2, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.DashboardGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a widget on the specified dashboard.
       *
       * @param {DashboardInterfaces.Widget} widget - State of the widget to add
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of dashboard the widget will be added to.
       */
      createWidget(widget, teamContext, dashboardId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, widget, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete the specified widget.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to update.
       */
      deleteWidget(teamContext, dashboardId, widgetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current state of the specified widget.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to read.
       */
      getWidget(teamContext, dashboardId, widgetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Override the  state of the specified widget.
       *
       * @param {DashboardInterfaces.Widget} widget - State to be written for the widget.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to update.
       */
      replaceWidget(widget, teamContext, dashboardId, widgetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, widget, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Perform a partial update of the specified widget.
       *
       * @param {DashboardInterfaces.Widget} widget - Description of the widget changes to apply. All non-null fields will be replaced.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to update.
       */
      updateWidget(widget, teamContext, dashboardId, widgetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, widget, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the widget metadata satisfying the specified contribution ID.
       *
       * @param {string} contributionId - The ID of Contribution for the Widget
       * @param {string} project - Project ID or project name
       */
      getWidgetMetadata(contributionId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              contributionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Dashboard", "6b3628d3-e96f-4fc7-b176-50240b03b515", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.WidgetMetadataResponse, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all available widget metadata in alphabetical order, including widgets marked with isVisibleFromCatalog == false.
       *
       * @param {DashboardInterfaces.WidgetScope} scope
       * @param {string} project - Project ID or project name
       */
      getWidgetTypes(scope, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (scope == null) {
            throw new TypeError("scope can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$scope": scope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Dashboard", "6b3628d3-e96f-4fc7-b176-50240b03b515", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.WidgetTypesResponse, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.DashboardApi = DashboardApi;
    DashboardApi.RESOURCE_AREA_ID = "31c84e0a-3ece-48fd-a29d-100849af99ba";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/GalleryInterfaces.js
var require_GalleryInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/GalleryInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VSCodeWebExtensionStatisicsType = exports2.SortOrderType = exports2.SortByType = exports2.ReviewResourceType = exports2.ReviewPatchOperation = exports2.ReviewFilterOptions = exports2.ReviewEventOperation = exports2.RestApiResponseStatus = exports2.QnAItemStatus = exports2.PublisherState = exports2.PublisherRoleAccess = exports2.PublisherQueryFlags = exports2.PublisherPermissions = exports2.PublisherFlags = exports2.PublishedExtensionFlags = exports2.PagingDirection = exports2.NotificationTemplateType = exports2.ExtensionVersionFlags = exports2.ExtensionStatsAggregateType = exports2.ExtensionStatisticOperation = exports2.ExtensionQueryFlags = exports2.ExtensionQueryFilterType = exports2.ExtensionPolicyFlags = exports2.ExtensionLifecycleEventType = exports2.ExtensionDeploymentTechnology = exports2.DraftStateType = exports2.DraftPatchOperation = exports2.ConcernCategory = exports2.AcquisitionOperationType = exports2.AcquisitionOperationState = exports2.AcquisitionAssignmentType = void 0;
    var AcquisitionAssignmentType;
    (function(AcquisitionAssignmentType2) {
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["None"] = 0] = "None";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["Me"] = 1] = "Me";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["All"] = 2] = "All";
    })(AcquisitionAssignmentType = exports2.AcquisitionAssignmentType || (exports2.AcquisitionAssignmentType = {}));
    var AcquisitionOperationState;
    (function(AcquisitionOperationState2) {
      AcquisitionOperationState2[AcquisitionOperationState2["Disallow"] = 0] = "Disallow";
      AcquisitionOperationState2[AcquisitionOperationState2["Allow"] = 1] = "Allow";
      AcquisitionOperationState2[AcquisitionOperationState2["Completed"] = 3] = "Completed";
    })(AcquisitionOperationState = exports2.AcquisitionOperationState || (exports2.AcquisitionOperationState = {}));
    var AcquisitionOperationType;
    (function(AcquisitionOperationType2) {
      AcquisitionOperationType2[AcquisitionOperationType2["Get"] = 0] = "Get";
      AcquisitionOperationType2[AcquisitionOperationType2["Install"] = 1] = "Install";
      AcquisitionOperationType2[AcquisitionOperationType2["Buy"] = 2] = "Buy";
      AcquisitionOperationType2[AcquisitionOperationType2["Try"] = 3] = "Try";
      AcquisitionOperationType2[AcquisitionOperationType2["Request"] = 4] = "Request";
      AcquisitionOperationType2[AcquisitionOperationType2["None"] = 5] = "None";
      AcquisitionOperationType2[AcquisitionOperationType2["PurchaseRequest"] = 6] = "PurchaseRequest";
    })(AcquisitionOperationType = exports2.AcquisitionOperationType || (exports2.AcquisitionOperationType = {}));
    var ConcernCategory;
    (function(ConcernCategory2) {
      ConcernCategory2[ConcernCategory2["General"] = 1] = "General";
      ConcernCategory2[ConcernCategory2["Abusive"] = 2] = "Abusive";
      ConcernCategory2[ConcernCategory2["Spam"] = 4] = "Spam";
    })(ConcernCategory = exports2.ConcernCategory || (exports2.ConcernCategory = {}));
    var DraftPatchOperation;
    (function(DraftPatchOperation2) {
      DraftPatchOperation2[DraftPatchOperation2["Publish"] = 1] = "Publish";
      DraftPatchOperation2[DraftPatchOperation2["Cancel"] = 2] = "Cancel";
    })(DraftPatchOperation = exports2.DraftPatchOperation || (exports2.DraftPatchOperation = {}));
    var DraftStateType;
    (function(DraftStateType2) {
      DraftStateType2[DraftStateType2["Unpublished"] = 1] = "Unpublished";
      DraftStateType2[DraftStateType2["Published"] = 2] = "Published";
      DraftStateType2[DraftStateType2["Cancelled"] = 3] = "Cancelled";
      DraftStateType2[DraftStateType2["Error"] = 4] = "Error";
    })(DraftStateType = exports2.DraftStateType || (exports2.DraftStateType = {}));
    var ExtensionDeploymentTechnology;
    (function(ExtensionDeploymentTechnology2) {
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["Exe"] = 1] = "Exe";
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["Msi"] = 2] = "Msi";
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["Vsix"] = 3] = "Vsix";
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["ReferralLink"] = 4] = "ReferralLink";
    })(ExtensionDeploymentTechnology = exports2.ExtensionDeploymentTechnology || (exports2.ExtensionDeploymentTechnology = {}));
    var ExtensionLifecycleEventType;
    (function(ExtensionLifecycleEventType2) {
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Uninstall"] = 1] = "Uninstall";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Install"] = 2] = "Install";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Review"] = 3] = "Review";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Acquisition"] = 4] = "Acquisition";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Sales"] = 5] = "Sales";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Other"] = 999] = "Other";
    })(ExtensionLifecycleEventType = exports2.ExtensionLifecycleEventType || (exports2.ExtensionLifecycleEventType = {}));
    var ExtensionPolicyFlags;
    (function(ExtensionPolicyFlags2) {
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["None"] = 0] = "None";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Private"] = 1] = "Private";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Public"] = 2] = "Public";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Preview"] = 4] = "Preview";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Released"] = 8] = "Released";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["FirstParty"] = 16] = "FirstParty";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["All"] = 31] = "All";
    })(ExtensionPolicyFlags = exports2.ExtensionPolicyFlags || (exports2.ExtensionPolicyFlags = {}));
    var ExtensionQueryFilterType;
    (function(ExtensionQueryFilterType2) {
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Tag"] = 1] = "Tag";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["DisplayName"] = 2] = "DisplayName";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Private"] = 3] = "Private";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Id"] = 4] = "Id";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Category"] = 5] = "Category";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ContributionType"] = 6] = "ContributionType";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Name"] = 7] = "Name";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["InstallationTarget"] = 8] = "InstallationTarget";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Featured"] = 9] = "Featured";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["SearchText"] = 10] = "SearchText";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["FeaturedInCategory"] = 11] = "FeaturedInCategory";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ExcludeWithFlags"] = 12] = "ExcludeWithFlags";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["IncludeWithFlags"] = 13] = "IncludeWithFlags";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Lcid"] = 14] = "Lcid";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["InstallationTargetVersion"] = 15] = "InstallationTargetVersion";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["InstallationTargetVersionRange"] = 16] = "InstallationTargetVersionRange";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["VsixMetadata"] = 17] = "VsixMetadata";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["PublisherName"] = 18] = "PublisherName";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["PublisherDisplayName"] = 19] = "PublisherDisplayName";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["IncludeWithPublisherFlags"] = 20] = "IncludeWithPublisherFlags";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["OrganizationSharedWith"] = 21] = "OrganizationSharedWith";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ProductArchitecture"] = 22] = "ProductArchitecture";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["TargetPlatform"] = 23] = "TargetPlatform";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ExtensionName"] = 24] = "ExtensionName";
    })(ExtensionQueryFilterType = exports2.ExtensionQueryFilterType || (exports2.ExtensionQueryFilterType = {}));
    var ExtensionQueryFlags;
    (function(ExtensionQueryFlags2) {
      ExtensionQueryFlags2[ExtensionQueryFlags2["None"] = 0] = "None";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeVersions"] = 1] = "IncludeVersions";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeFiles"] = 2] = "IncludeFiles";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeCategoryAndTags"] = 4] = "IncludeCategoryAndTags";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeSharedAccounts"] = 8] = "IncludeSharedAccounts";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeVersionProperties"] = 16] = "IncludeVersionProperties";
      ExtensionQueryFlags2[ExtensionQueryFlags2["ExcludeNonValidated"] = 32] = "ExcludeNonValidated";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeInstallationTargets"] = 64] = "IncludeInstallationTargets";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeAssetUri"] = 128] = "IncludeAssetUri";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeStatistics"] = 256] = "IncludeStatistics";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeLatestVersionOnly"] = 512] = "IncludeLatestVersionOnly";
      ExtensionQueryFlags2[ExtensionQueryFlags2["UseFallbackAssetUri"] = 1024] = "UseFallbackAssetUri";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeMetadata"] = 2048] = "IncludeMetadata";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeMinimalPayloadForVsIde"] = 4096] = "IncludeMinimalPayloadForVsIde";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeLcids"] = 8192] = "IncludeLcids";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeSharedOrganizations"] = 16384] = "IncludeSharedOrganizations";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeNameConflictInfo"] = 32768] = "IncludeNameConflictInfo";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeLatestPrereleaseAndStableVersionOnly"] = 65536] = "IncludeLatestPrereleaseAndStableVersionOnly";
      ExtensionQueryFlags2[ExtensionQueryFlags2["AllAttributes"] = 16863] = "AllAttributes";
    })(ExtensionQueryFlags = exports2.ExtensionQueryFlags || (exports2.ExtensionQueryFlags = {}));
    var ExtensionStatisticOperation;
    (function(ExtensionStatisticOperation2) {
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["None"] = 0] = "None";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Set"] = 1] = "Set";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Increment"] = 2] = "Increment";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Decrement"] = 3] = "Decrement";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Delete"] = 4] = "Delete";
    })(ExtensionStatisticOperation = exports2.ExtensionStatisticOperation || (exports2.ExtensionStatisticOperation = {}));
    var ExtensionStatsAggregateType;
    (function(ExtensionStatsAggregateType2) {
      ExtensionStatsAggregateType2[ExtensionStatsAggregateType2["Daily"] = 1] = "Daily";
    })(ExtensionStatsAggregateType = exports2.ExtensionStatsAggregateType || (exports2.ExtensionStatsAggregateType = {}));
    var ExtensionVersionFlags;
    (function(ExtensionVersionFlags2) {
      ExtensionVersionFlags2[ExtensionVersionFlags2["None"] = 0] = "None";
      ExtensionVersionFlags2[ExtensionVersionFlags2["Validated"] = 1] = "Validated";
      ExtensionVersionFlags2[ExtensionVersionFlags2["Prerelease"] = 2] = "Prerelease";
    })(ExtensionVersionFlags = exports2.ExtensionVersionFlags || (exports2.ExtensionVersionFlags = {}));
    var NotificationTemplateType;
    (function(NotificationTemplateType2) {
      NotificationTemplateType2[NotificationTemplateType2["ReviewNotification"] = 1] = "ReviewNotification";
      NotificationTemplateType2[NotificationTemplateType2["QnaNotification"] = 2] = "QnaNotification";
      NotificationTemplateType2[NotificationTemplateType2["CustomerContactNotification"] = 3] = "CustomerContactNotification";
      NotificationTemplateType2[NotificationTemplateType2["PublisherMemberUpdateNotification"] = 4] = "PublisherMemberUpdateNotification";
    })(NotificationTemplateType = exports2.NotificationTemplateType || (exports2.NotificationTemplateType = {}));
    var PagingDirection;
    (function(PagingDirection2) {
      PagingDirection2[PagingDirection2["Backward"] = 1] = "Backward";
      PagingDirection2[PagingDirection2["Forward"] = 2] = "Forward";
    })(PagingDirection = exports2.PagingDirection || (exports2.PagingDirection = {}));
    var PublishedExtensionFlags;
    (function(PublishedExtensionFlags2) {
      PublishedExtensionFlags2[PublishedExtensionFlags2["None"] = 0] = "None";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Disabled"] = 1] = "Disabled";
      PublishedExtensionFlags2[PublishedExtensionFlags2["BuiltIn"] = 2] = "BuiltIn";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Validated"] = 4] = "Validated";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Trusted"] = 8] = "Trusted";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Paid"] = 16] = "Paid";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Public"] = 256] = "Public";
      PublishedExtensionFlags2[PublishedExtensionFlags2["MultiVersion"] = 512] = "MultiVersion";
      PublishedExtensionFlags2[PublishedExtensionFlags2["System"] = 1024] = "System";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Preview"] = 2048] = "Preview";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Unpublished"] = 4096] = "Unpublished";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Trial"] = 8192] = "Trial";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Locked"] = 16384] = "Locked";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Hidden"] = 32768] = "Hidden";
    })(PublishedExtensionFlags = exports2.PublishedExtensionFlags || (exports2.PublishedExtensionFlags = {}));
    var PublisherFlags;
    (function(PublisherFlags2) {
      PublisherFlags2[PublisherFlags2["UnChanged"] = 1073741824] = "UnChanged";
      PublisherFlags2[PublisherFlags2["None"] = 0] = "None";
      PublisherFlags2[PublisherFlags2["Disabled"] = 1] = "Disabled";
      PublisherFlags2[PublisherFlags2["Verified"] = 2] = "Verified";
      PublisherFlags2[PublisherFlags2["Certified"] = 4] = "Certified";
      PublisherFlags2[PublisherFlags2["ServiceFlags"] = 7] = "ServiceFlags";
    })(PublisherFlags = exports2.PublisherFlags || (exports2.PublisherFlags = {}));
    var PublisherPermissions;
    (function(PublisherPermissions2) {
      PublisherPermissions2[PublisherPermissions2["Read"] = 1] = "Read";
      PublisherPermissions2[PublisherPermissions2["UpdateExtension"] = 2] = "UpdateExtension";
      PublisherPermissions2[PublisherPermissions2["CreatePublisher"] = 4] = "CreatePublisher";
      PublisherPermissions2[PublisherPermissions2["PublishExtension"] = 8] = "PublishExtension";
      PublisherPermissions2[PublisherPermissions2["Admin"] = 16] = "Admin";
      PublisherPermissions2[PublisherPermissions2["TrustedPartner"] = 32] = "TrustedPartner";
      PublisherPermissions2[PublisherPermissions2["PrivateRead"] = 64] = "PrivateRead";
      PublisherPermissions2[PublisherPermissions2["DeleteExtension"] = 128] = "DeleteExtension";
      PublisherPermissions2[PublisherPermissions2["EditSettings"] = 256] = "EditSettings";
      PublisherPermissions2[PublisherPermissions2["ViewPermissions"] = 512] = "ViewPermissions";
      PublisherPermissions2[PublisherPermissions2["ManagePermissions"] = 1024] = "ManagePermissions";
      PublisherPermissions2[PublisherPermissions2["DeletePublisher"] = 2048] = "DeletePublisher";
    })(PublisherPermissions = exports2.PublisherPermissions || (exports2.PublisherPermissions = {}));
    var PublisherQueryFlags;
    (function(PublisherQueryFlags2) {
      PublisherQueryFlags2[PublisherQueryFlags2["None"] = 0] = "None";
      PublisherQueryFlags2[PublisherQueryFlags2["IncludeExtensions"] = 1] = "IncludeExtensions";
      PublisherQueryFlags2[PublisherQueryFlags2["IncludeEmailAddress"] = 2] = "IncludeEmailAddress";
    })(PublisherQueryFlags = exports2.PublisherQueryFlags || (exports2.PublisherQueryFlags = {}));
    var PublisherRoleAccess;
    (function(PublisherRoleAccess2) {
      PublisherRoleAccess2[PublisherRoleAccess2["Assigned"] = 1] = "Assigned";
      PublisherRoleAccess2[PublisherRoleAccess2["Inherited"] = 2] = "Inherited";
    })(PublisherRoleAccess = exports2.PublisherRoleAccess || (exports2.PublisherRoleAccess = {}));
    var PublisherState;
    (function(PublisherState2) {
      PublisherState2[PublisherState2["None"] = 0] = "None";
      PublisherState2[PublisherState2["VerificationPending"] = 1] = "VerificationPending";
      PublisherState2[PublisherState2["CertificationPending"] = 2] = "CertificationPending";
      PublisherState2[PublisherState2["CertificationRejected"] = 4] = "CertificationRejected";
      PublisherState2[PublisherState2["CertificationRevoked"] = 8] = "CertificationRevoked";
    })(PublisherState = exports2.PublisherState || (exports2.PublisherState = {}));
    var QnAItemStatus;
    (function(QnAItemStatus2) {
      QnAItemStatus2[QnAItemStatus2["None"] = 0] = "None";
      QnAItemStatus2[QnAItemStatus2["UserEditable"] = 1] = "UserEditable";
      QnAItemStatus2[QnAItemStatus2["PublisherCreated"] = 2] = "PublisherCreated";
    })(QnAItemStatus = exports2.QnAItemStatus || (exports2.QnAItemStatus = {}));
    var RestApiResponseStatus;
    (function(RestApiResponseStatus2) {
      RestApiResponseStatus2[RestApiResponseStatus2["Completed"] = 0] = "Completed";
      RestApiResponseStatus2[RestApiResponseStatus2["Failed"] = 1] = "Failed";
      RestApiResponseStatus2[RestApiResponseStatus2["Inprogress"] = 2] = "Inprogress";
      RestApiResponseStatus2[RestApiResponseStatus2["Skipped"] = 3] = "Skipped";
    })(RestApiResponseStatus = exports2.RestApiResponseStatus || (exports2.RestApiResponseStatus = {}));
    var ReviewEventOperation;
    (function(ReviewEventOperation2) {
      ReviewEventOperation2[ReviewEventOperation2["Create"] = 1] = "Create";
      ReviewEventOperation2[ReviewEventOperation2["Update"] = 2] = "Update";
      ReviewEventOperation2[ReviewEventOperation2["Delete"] = 3] = "Delete";
    })(ReviewEventOperation = exports2.ReviewEventOperation || (exports2.ReviewEventOperation = {}));
    var ReviewFilterOptions;
    (function(ReviewFilterOptions2) {
      ReviewFilterOptions2[ReviewFilterOptions2["None"] = 0] = "None";
      ReviewFilterOptions2[ReviewFilterOptions2["FilterEmptyReviews"] = 1] = "FilterEmptyReviews";
      ReviewFilterOptions2[ReviewFilterOptions2["FilterEmptyUserNames"] = 2] = "FilterEmptyUserNames";
    })(ReviewFilterOptions = exports2.ReviewFilterOptions || (exports2.ReviewFilterOptions = {}));
    var ReviewPatchOperation;
    (function(ReviewPatchOperation2) {
      ReviewPatchOperation2[ReviewPatchOperation2["FlagReview"] = 1] = "FlagReview";
      ReviewPatchOperation2[ReviewPatchOperation2["UpdateReview"] = 2] = "UpdateReview";
      ReviewPatchOperation2[ReviewPatchOperation2["ReplyToReview"] = 3] = "ReplyToReview";
      ReviewPatchOperation2[ReviewPatchOperation2["AdminResponseForReview"] = 4] = "AdminResponseForReview";
      ReviewPatchOperation2[ReviewPatchOperation2["DeleteAdminReply"] = 5] = "DeleteAdminReply";
      ReviewPatchOperation2[ReviewPatchOperation2["DeletePublisherReply"] = 6] = "DeletePublisherReply";
    })(ReviewPatchOperation = exports2.ReviewPatchOperation || (exports2.ReviewPatchOperation = {}));
    var ReviewResourceType;
    (function(ReviewResourceType2) {
      ReviewResourceType2[ReviewResourceType2["Review"] = 1] = "Review";
      ReviewResourceType2[ReviewResourceType2["PublisherReply"] = 2] = "PublisherReply";
      ReviewResourceType2[ReviewResourceType2["AdminReply"] = 3] = "AdminReply";
    })(ReviewResourceType = exports2.ReviewResourceType || (exports2.ReviewResourceType = {}));
    var SortByType;
    (function(SortByType2) {
      SortByType2[SortByType2["Relevance"] = 0] = "Relevance";
      SortByType2[SortByType2["LastUpdatedDate"] = 1] = "LastUpdatedDate";
      SortByType2[SortByType2["Title"] = 2] = "Title";
      SortByType2[SortByType2["Publisher"] = 3] = "Publisher";
      SortByType2[SortByType2["InstallCount"] = 4] = "InstallCount";
      SortByType2[SortByType2["PublishedDate"] = 5] = "PublishedDate";
      SortByType2[SortByType2["AverageRating"] = 6] = "AverageRating";
      SortByType2[SortByType2["TrendingDaily"] = 7] = "TrendingDaily";
      SortByType2[SortByType2["TrendingWeekly"] = 8] = "TrendingWeekly";
      SortByType2[SortByType2["TrendingMonthly"] = 9] = "TrendingMonthly";
      SortByType2[SortByType2["ReleaseDate"] = 10] = "ReleaseDate";
      SortByType2[SortByType2["Author"] = 11] = "Author";
      SortByType2[SortByType2["WeightedRating"] = 12] = "WeightedRating";
    })(SortByType = exports2.SortByType || (exports2.SortByType = {}));
    var SortOrderType;
    (function(SortOrderType2) {
      SortOrderType2[SortOrderType2["Default"] = 0] = "Default";
      SortOrderType2[SortOrderType2["Ascending"] = 1] = "Ascending";
      SortOrderType2[SortOrderType2["Descending"] = 2] = "Descending";
    })(SortOrderType = exports2.SortOrderType || (exports2.SortOrderType = {}));
    var VSCodeWebExtensionStatisicsType;
    (function(VSCodeWebExtensionStatisicsType2) {
      VSCodeWebExtensionStatisicsType2[VSCodeWebExtensionStatisicsType2["Install"] = 1] = "Install";
      VSCodeWebExtensionStatisicsType2[VSCodeWebExtensionStatisicsType2["Update"] = 2] = "Update";
      VSCodeWebExtensionStatisicsType2[VSCodeWebExtensionStatisicsType2["Uninstall"] = 3] = "Uninstall";
    })(VSCodeWebExtensionStatisicsType = exports2.VSCodeWebExtensionStatisicsType || (exports2.VSCodeWebExtensionStatisicsType = {}));
    exports2.TypeInfo = {
      AcquisitionAssignmentType: {
        enumValues: {
          "none": 0,
          "me": 1,
          "all": 2
        }
      },
      AcquisitionOperation: {},
      AcquisitionOperationState: {
        enumValues: {
          "disallow": 0,
          "allow": 1,
          "completed": 3
        }
      },
      AcquisitionOperationType: {
        enumValues: {
          "get": 0,
          "install": 1,
          "buy": 2,
          "try": 3,
          "request": 4,
          "none": 5,
          "purchaseRequest": 6
        }
      },
      AcquisitionOptions: {},
      AzureRestApiResponseModel: {},
      Concern: {},
      ConcernCategory: {
        enumValues: {
          "general": 1,
          "abusive": 2,
          "spam": 4
        }
      },
      CustomerLastContact: {},
      CustomerSupportRequest: {},
      DraftPatchOperation: {
        enumValues: {
          "publish": 1,
          "cancel": 2
        }
      },
      DraftStateType: {
        enumValues: {
          "unpublished": 1,
          "published": 2,
          "cancelled": 3,
          "error": 4
        }
      },
      ExtensionAcquisitionRequest: {},
      ExtensionDailyStat: {},
      ExtensionDailyStats: {},
      ExtensionDeploymentTechnology: {
        enumValues: {
          "exe": 1,
          "msi": 2,
          "vsix": 3,
          "referralLink": 4
        }
      },
      ExtensionDraft: {},
      ExtensionDraftPatch: {},
      ExtensionEvent: {},
      ExtensionEvents: {},
      ExtensionFilterResult: {},
      ExtensionLifecycleEventType: {
        enumValues: {
          "uninstall": 1,
          "install": 2,
          "review": 3,
          "acquisition": 4,
          "sales": 5,
          "other": 999
        }
      },
      ExtensionPayload: {},
      ExtensionPolicy: {},
      ExtensionPolicyFlags: {
        enumValues: {
          "none": 0,
          "private": 1,
          "public": 2,
          "preview": 4,
          "released": 8,
          "firstParty": 16,
          "all": 31
        }
      },
      ExtensionQuery: {},
      ExtensionQueryFilterType: {
        enumValues: {
          "tag": 1,
          "displayName": 2,
          "private": 3,
          "id": 4,
          "category": 5,
          "contributionType": 6,
          "name": 7,
          "installationTarget": 8,
          "featured": 9,
          "searchText": 10,
          "featuredInCategory": 11,
          "excludeWithFlags": 12,
          "includeWithFlags": 13,
          "lcid": 14,
          "installationTargetVersion": 15,
          "installationTargetVersionRange": 16,
          "vsixMetadata": 17,
          "publisherName": 18,
          "publisherDisplayName": 19,
          "includeWithPublisherFlags": 20,
          "organizationSharedWith": 21,
          "productArchitecture": 22,
          "targetPlatform": 23,
          "extensionName": 24
        }
      },
      ExtensionQueryFlags: {
        enumValues: {
          "none": 0,
          "includeVersions": 1,
          "includeFiles": 2,
          "includeCategoryAndTags": 4,
          "includeSharedAccounts": 8,
          "includeVersionProperties": 16,
          "excludeNonValidated": 32,
          "includeInstallationTargets": 64,
          "includeAssetUri": 128,
          "includeStatistics": 256,
          "includeLatestVersionOnly": 512,
          "useFallbackAssetUri": 1024,
          "includeMetadata": 2048,
          "includeMinimalPayloadForVsIde": 4096,
          "includeLcids": 8192,
          "includeSharedOrganizations": 16384,
          "includeNameConflictInfo": 32768,
          "includeLatestPrereleaseAndStableVersionOnly": 65536,
          "allAttributes": 16863
        }
      },
      ExtensionQueryResult: {},
      ExtensionStatisticOperation: {
        enumValues: {
          "none": 0,
          "set": 1,
          "increment": 2,
          "decrement": 3,
          "delete": 4
        }
      },
      ExtensionStatisticUpdate: {},
      ExtensionStatsAggregateType: {
        enumValues: {
          "daily": 1
        }
      },
      ExtensionVersion: {},
      ExtensionVersionFlags: {
        enumValues: {
          "none": 0,
          "validated": 1,
          "prerelease": 2
        }
      },
      NotificationsData: {},
      NotificationTemplateType: {
        enumValues: {
          "reviewNotification": 1,
          "qnaNotification": 2,
          "customerContactNotification": 3,
          "publisherMemberUpdateNotification": 4
        }
      },
      PagingDirection: {
        enumValues: {
          "backward": 1,
          "forward": 2
        }
      },
      PublishedExtension: {},
      PublishedExtensionFlags: {
        enumValues: {
          "none": 0,
          "disabled": 1,
          "builtIn": 2,
          "validated": 4,
          "trusted": 8,
          "paid": 16,
          "public": 256,
          "multiVersion": 512,
          "system": 1024,
          "preview": 2048,
          "unpublished": 4096,
          "trial": 8192,
          "locked": 16384,
          "hidden": 32768
        }
      },
      Publisher: {},
      PublisherBase: {},
      PublisherFacts: {},
      PublisherFilterResult: {},
      PublisherFlags: {
        enumValues: {
          "unChanged": 1073741824,
          "none": 0,
          "disabled": 1,
          "verified": 2,
          "certified": 4,
          "serviceFlags": 7
        }
      },
      PublisherPermissions: {
        enumValues: {
          "read": 1,
          "updateExtension": 2,
          "createPublisher": 4,
          "publishExtension": 8,
          "admin": 16,
          "trustedPartner": 32,
          "privateRead": 64,
          "deleteExtension": 128,
          "editSettings": 256,
          "viewPermissions": 512,
          "managePermissions": 1024,
          "deletePublisher": 2048
        }
      },
      PublisherQuery: {},
      PublisherQueryFlags: {
        enumValues: {
          "none": 0,
          "includeExtensions": 1,
          "includeEmailAddress": 2
        }
      },
      PublisherQueryResult: {},
      PublisherRoleAccess: {
        enumValues: {
          "assigned": 1,
          "inherited": 2
        }
      },
      PublisherRoleAssignment: {},
      PublisherState: {
        enumValues: {
          "none": 0,
          "verificationPending": 1,
          "certificationPending": 2,
          "certificationRejected": 4,
          "certificationRevoked": 8
        }
      },
      QnAItem: {},
      QnAItemStatus: {
        enumValues: {
          "none": 0,
          "userEditable": 1,
          "publisherCreated": 2
        }
      },
      QueryFilter: {},
      Question: {},
      QuestionsResult: {},
      Response: {},
      RestApiResponseStatus: {
        enumValues: {
          "completed": 0,
          "failed": 1,
          "inprogress": 2,
          "skipped": 3
        }
      },
      RestApiResponseStatusModel: {},
      Review: {},
      ReviewEventOperation: {
        enumValues: {
          "create": 1,
          "update": 2,
          "delete": 3
        }
      },
      ReviewEventProperties: {},
      ReviewFilterOptions: {
        enumValues: {
          "none": 0,
          "filterEmptyReviews": 1,
          "filterEmptyUserNames": 2
        }
      },
      ReviewPatch: {},
      ReviewPatchOperation: {
        enumValues: {
          "flagReview": 1,
          "updateReview": 2,
          "replyToReview": 3,
          "adminResponseForReview": 4,
          "deleteAdminReply": 5,
          "deletePublisherReply": 6
        }
      },
      ReviewReply: {},
      ReviewResourceType: {
        enumValues: {
          "review": 1,
          "publisherReply": 2,
          "adminReply": 3
        }
      },
      ReviewsResult: {},
      SortByType: {
        enumValues: {
          "relevance": 0,
          "lastUpdatedDate": 1,
          "title": 2,
          "publisher": 3,
          "installCount": 4,
          "publishedDate": 5,
          "averageRating": 6,
          "trendingDaily": 7,
          "trendingWeekly": 8,
          "trendingMonthly": 9,
          "releaseDate": 10,
          "author": 11,
          "weightedRating": 12
        }
      },
      SortOrderType: {
        enumValues: {
          "default": 0,
          "ascending": 1,
          "descending": 2
        }
      },
      UserExtensionPolicy: {},
      UserReportedConcern: {},
      VSCodeWebExtensionStatisicsType: {
        enumValues: {
          "install": 1,
          "update": 2,
          "uninstall": 3
        }
      }
    };
    exports2.TypeInfo.AcquisitionOperation.fields = {
      operationState: {
        enumType: exports2.TypeInfo.AcquisitionOperationState
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.AcquisitionOptions.fields = {
      defaultOperation: {
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      },
      operations: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      }
    };
    exports2.TypeInfo.AzureRestApiResponseModel.fields = {
      operationStatus: {
        typeInfo: exports2.TypeInfo.RestApiResponseStatusModel
      }
    };
    exports2.TypeInfo.Concern.fields = {
      category: {
        enumType: exports2.TypeInfo.ConcernCategory
      },
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CustomerLastContact.fields = {
      lastContactDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CustomerSupportRequest.fields = {
      review: {
        typeInfo: exports2.TypeInfo.Review
      }
    };
    exports2.TypeInfo.ExtensionAcquisitionRequest.fields = {
      assignmentType: {
        enumType: exports2.TypeInfo.AcquisitionAssignmentType
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.ExtensionDailyStat.fields = {
      statisticDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionDailyStats.fields = {
      dailyStats: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionDailyStat
      }
    };
    exports2.TypeInfo.ExtensionDraft.fields = {
      createdDate: {
        isDate: true
      },
      draftState: {
        enumType: exports2.TypeInfo.DraftStateType
      },
      lastUpdated: {
        isDate: true
      },
      payload: {
        typeInfo: exports2.TypeInfo.ExtensionPayload
      }
    };
    exports2.TypeInfo.ExtensionDraftPatch.fields = {
      operation: {
        enumType: exports2.TypeInfo.DraftPatchOperation
      }
    };
    exports2.TypeInfo.ExtensionEvent.fields = {
      statisticDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionEvents.fields = {
      events: {
        isDictionary: true,
        dictionaryValueFieldInfo: {
          isArray: true,
          typeInfo: exports2.TypeInfo.ExtensionEvent
        }
      }
    };
    exports2.TypeInfo.ExtensionFilterResult.fields = {
      extensions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublishedExtension
      }
    };
    exports2.TypeInfo.ExtensionPayload.fields = {
      type: {
        enumType: exports2.TypeInfo.ExtensionDeploymentTechnology
      }
    };
    exports2.TypeInfo.ExtensionPolicy.fields = {
      install: {
        enumType: exports2.TypeInfo.ExtensionPolicyFlags
      },
      request: {
        enumType: exports2.TypeInfo.ExtensionPolicyFlags
      }
    };
    exports2.TypeInfo.ExtensionQuery.fields = {
      filters: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryFilter
      },
      flags: {
        enumType: exports2.TypeInfo.ExtensionQueryFlags
      }
    };
    exports2.TypeInfo.ExtensionQueryResult.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionFilterResult
      }
    };
    exports2.TypeInfo.ExtensionStatisticUpdate.fields = {
      operation: {
        enumType: exports2.TypeInfo.ExtensionStatisticOperation
      }
    };
    exports2.TypeInfo.ExtensionVersion.fields = {
      flags: {
        enumType: exports2.TypeInfo.ExtensionVersionFlags
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationsData.fields = {
      type: {
        enumType: exports2.TypeInfo.NotificationTemplateType
      }
    };
    exports2.TypeInfo.PublishedExtension.fields = {
      deploymentType: {
        enumType: exports2.TypeInfo.ExtensionDeploymentTechnology
      },
      flags: {
        enumType: exports2.TypeInfo.PublishedExtensionFlags
      },
      lastUpdated: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      },
      publisher: {
        typeInfo: exports2.TypeInfo.PublisherFacts
      },
      releaseDate: {
        isDate: true
      },
      versions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionVersion
      }
    };
    exports2.TypeInfo.Publisher.fields = {
      extensions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublishedExtension
      },
      flags: {
        enumType: exports2.TypeInfo.PublisherFlags
      },
      lastUpdated: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.PublisherState
      }
    };
    exports2.TypeInfo.PublisherBase.fields = {
      extensions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublishedExtension
      },
      flags: {
        enumType: exports2.TypeInfo.PublisherFlags
      },
      lastUpdated: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.PublisherState
      }
    };
    exports2.TypeInfo.PublisherFacts.fields = {
      flags: {
        enumType: exports2.TypeInfo.PublisherFlags
      }
    };
    exports2.TypeInfo.PublisherFilterResult.fields = {
      publishers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Publisher
      }
    };
    exports2.TypeInfo.PublisherQuery.fields = {
      filters: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryFilter
      },
      flags: {
        enumType: exports2.TypeInfo.PublisherQueryFlags
      }
    };
    exports2.TypeInfo.PublisherQueryResult.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublisherFilterResult
      }
    };
    exports2.TypeInfo.PublisherRoleAssignment.fields = {
      access: {
        enumType: exports2.TypeInfo.PublisherRoleAccess
      }
    };
    exports2.TypeInfo.QnAItem.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.QueryFilter.fields = {
      direction: {
        enumType: exports2.TypeInfo.PagingDirection
      }
    };
    exports2.TypeInfo.Question.fields = {
      createdDate: {
        isDate: true
      },
      responses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Response
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.QuestionsResult.fields = {
      questions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Question
      }
    };
    exports2.TypeInfo.Response.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.RestApiResponseStatusModel.fields = {
      status: {
        enumType: exports2.TypeInfo.RestApiResponseStatus
      }
    };
    exports2.TypeInfo.Review.fields = {
      adminReply: {
        typeInfo: exports2.TypeInfo.ReviewReply
      },
      reply: {
        typeInfo: exports2.TypeInfo.ReviewReply
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReviewEventProperties.fields = {
      eventOperation: {
        enumType: exports2.TypeInfo.ReviewEventOperation
      },
      replyDate: {
        isDate: true
      },
      resourceType: {
        enumType: exports2.TypeInfo.ReviewResourceType
      },
      reviewDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReviewPatch.fields = {
      operation: {
        enumType: exports2.TypeInfo.ReviewPatchOperation
      },
      reportedConcern: {
        typeInfo: exports2.TypeInfo.UserReportedConcern
      },
      reviewItem: {
        typeInfo: exports2.TypeInfo.Review
      }
    };
    exports2.TypeInfo.ReviewReply.fields = {
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReviewsResult.fields = {
      reviews: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Review
      }
    };
    exports2.TypeInfo.UserExtensionPolicy.fields = {
      permissions: {
        typeInfo: exports2.TypeInfo.ExtensionPolicy
      }
    };
    exports2.TypeInfo.UserReportedConcern.fields = {
      category: {
        enumType: exports2.TypeInfo.ConcernCategory
      },
      submittedDate: {
        isDate: true
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/ExtensionManagementInterfaces.js
var require_ExtensionManagementInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/ExtensionManagementInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.InstalledExtensionStateIssueType = exports2.ExtensionUpdateType = exports2.ExtensionStateFlags = exports2.ExtensionRequestUpdateType = exports2.ExtensionRequestState = exports2.ExtensionFlags = exports2.ContributionQueryOptions = exports2.ContributionPropertyType = exports2.ContributionLicensingBehaviorType = exports2.AcquisitionOperationType = exports2.AcquisitionOperationState = exports2.AcquisitionAssignmentType = void 0;
    var GalleryInterfaces = require_GalleryInterfaces();
    var AcquisitionAssignmentType;
    (function(AcquisitionAssignmentType2) {
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["None"] = 0] = "None";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["Me"] = 1] = "Me";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["All"] = 2] = "All";
    })(AcquisitionAssignmentType = exports2.AcquisitionAssignmentType || (exports2.AcquisitionAssignmentType = {}));
    var AcquisitionOperationState;
    (function(AcquisitionOperationState2) {
      AcquisitionOperationState2[AcquisitionOperationState2["Disallow"] = 0] = "Disallow";
      AcquisitionOperationState2[AcquisitionOperationState2["Allow"] = 1] = "Allow";
      AcquisitionOperationState2[AcquisitionOperationState2["Completed"] = 3] = "Completed";
    })(AcquisitionOperationState = exports2.AcquisitionOperationState || (exports2.AcquisitionOperationState = {}));
    var AcquisitionOperationType;
    (function(AcquisitionOperationType2) {
      AcquisitionOperationType2[AcquisitionOperationType2["Get"] = 0] = "Get";
      AcquisitionOperationType2[AcquisitionOperationType2["Install"] = 1] = "Install";
      AcquisitionOperationType2[AcquisitionOperationType2["Buy"] = 2] = "Buy";
      AcquisitionOperationType2[AcquisitionOperationType2["Try"] = 3] = "Try";
      AcquisitionOperationType2[AcquisitionOperationType2["Request"] = 4] = "Request";
      AcquisitionOperationType2[AcquisitionOperationType2["None"] = 5] = "None";
      AcquisitionOperationType2[AcquisitionOperationType2["PurchaseRequest"] = 6] = "PurchaseRequest";
    })(AcquisitionOperationType = exports2.AcquisitionOperationType || (exports2.AcquisitionOperationType = {}));
    var ContributionLicensingBehaviorType;
    (function(ContributionLicensingBehaviorType2) {
      ContributionLicensingBehaviorType2[ContributionLicensingBehaviorType2["OnlyIfLicensed"] = 0] = "OnlyIfLicensed";
      ContributionLicensingBehaviorType2[ContributionLicensingBehaviorType2["OnlyIfUnlicensed"] = 1] = "OnlyIfUnlicensed";
      ContributionLicensingBehaviorType2[ContributionLicensingBehaviorType2["AlwaysInclude"] = 2] = "AlwaysInclude";
    })(ContributionLicensingBehaviorType = exports2.ContributionLicensingBehaviorType || (exports2.ContributionLicensingBehaviorType = {}));
    var ContributionPropertyType;
    (function(ContributionPropertyType2) {
      ContributionPropertyType2[ContributionPropertyType2["Unknown"] = 0] = "Unknown";
      ContributionPropertyType2[ContributionPropertyType2["String"] = 1] = "String";
      ContributionPropertyType2[ContributionPropertyType2["Uri"] = 2] = "Uri";
      ContributionPropertyType2[ContributionPropertyType2["Guid"] = 4] = "Guid";
      ContributionPropertyType2[ContributionPropertyType2["Boolean"] = 8] = "Boolean";
      ContributionPropertyType2[ContributionPropertyType2["Integer"] = 16] = "Integer";
      ContributionPropertyType2[ContributionPropertyType2["Double"] = 32] = "Double";
      ContributionPropertyType2[ContributionPropertyType2["DateTime"] = 64] = "DateTime";
      ContributionPropertyType2[ContributionPropertyType2["Dictionary"] = 128] = "Dictionary";
      ContributionPropertyType2[ContributionPropertyType2["Array"] = 256] = "Array";
      ContributionPropertyType2[ContributionPropertyType2["Object"] = 512] = "Object";
    })(ContributionPropertyType = exports2.ContributionPropertyType || (exports2.ContributionPropertyType = {}));
    var ContributionQueryOptions;
    (function(ContributionQueryOptions2) {
      ContributionQueryOptions2[ContributionQueryOptions2["None"] = 0] = "None";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeSelf"] = 16] = "IncludeSelf";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeChildren"] = 32] = "IncludeChildren";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeSubTree"] = 96] = "IncludeSubTree";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeAll"] = 112] = "IncludeAll";
      ContributionQueryOptions2[ContributionQueryOptions2["IgnoreConstraints"] = 256] = "IgnoreConstraints";
    })(ContributionQueryOptions = exports2.ContributionQueryOptions || (exports2.ContributionQueryOptions = {}));
    var ExtensionFlags;
    (function(ExtensionFlags2) {
      ExtensionFlags2[ExtensionFlags2["BuiltIn"] = 1] = "BuiltIn";
      ExtensionFlags2[ExtensionFlags2["Trusted"] = 2] = "Trusted";
    })(ExtensionFlags = exports2.ExtensionFlags || (exports2.ExtensionFlags = {}));
    var ExtensionRequestState;
    (function(ExtensionRequestState2) {
      ExtensionRequestState2[ExtensionRequestState2["Open"] = 0] = "Open";
      ExtensionRequestState2[ExtensionRequestState2["Accepted"] = 1] = "Accepted";
      ExtensionRequestState2[ExtensionRequestState2["Rejected"] = 2] = "Rejected";
    })(ExtensionRequestState = exports2.ExtensionRequestState || (exports2.ExtensionRequestState = {}));
    var ExtensionRequestUpdateType;
    (function(ExtensionRequestUpdateType2) {
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Created"] = 1] = "Created";
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Approved"] = 2] = "Approved";
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Rejected"] = 3] = "Rejected";
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Deleted"] = 4] = "Deleted";
    })(ExtensionRequestUpdateType = exports2.ExtensionRequestUpdateType || (exports2.ExtensionRequestUpdateType = {}));
    var ExtensionStateFlags;
    (function(ExtensionStateFlags2) {
      ExtensionStateFlags2[ExtensionStateFlags2["None"] = 0] = "None";
      ExtensionStateFlags2[ExtensionStateFlags2["Disabled"] = 1] = "Disabled";
      ExtensionStateFlags2[ExtensionStateFlags2["BuiltIn"] = 2] = "BuiltIn";
      ExtensionStateFlags2[ExtensionStateFlags2["MultiVersion"] = 4] = "MultiVersion";
      ExtensionStateFlags2[ExtensionStateFlags2["UnInstalled"] = 8] = "UnInstalled";
      ExtensionStateFlags2[ExtensionStateFlags2["VersionCheckError"] = 16] = "VersionCheckError";
      ExtensionStateFlags2[ExtensionStateFlags2["Trusted"] = 32] = "Trusted";
      ExtensionStateFlags2[ExtensionStateFlags2["Error"] = 64] = "Error";
      ExtensionStateFlags2[ExtensionStateFlags2["NeedsReauthorization"] = 128] = "NeedsReauthorization";
      ExtensionStateFlags2[ExtensionStateFlags2["AutoUpgradeError"] = 256] = "AutoUpgradeError";
      ExtensionStateFlags2[ExtensionStateFlags2["Warning"] = 512] = "Warning";
      ExtensionStateFlags2[ExtensionStateFlags2["Unpublished"] = 1024] = "Unpublished";
    })(ExtensionStateFlags = exports2.ExtensionStateFlags || (exports2.ExtensionStateFlags = {}));
    var ExtensionUpdateType;
    (function(ExtensionUpdateType2) {
      ExtensionUpdateType2[ExtensionUpdateType2["Installed"] = 1] = "Installed";
      ExtensionUpdateType2[ExtensionUpdateType2["Uninstalled"] = 2] = "Uninstalled";
      ExtensionUpdateType2[ExtensionUpdateType2["Enabled"] = 3] = "Enabled";
      ExtensionUpdateType2[ExtensionUpdateType2["Disabled"] = 4] = "Disabled";
      ExtensionUpdateType2[ExtensionUpdateType2["VersionUpdated"] = 5] = "VersionUpdated";
      ExtensionUpdateType2[ExtensionUpdateType2["ActionRequired"] = 6] = "ActionRequired";
      ExtensionUpdateType2[ExtensionUpdateType2["ActionResolved"] = 7] = "ActionResolved";
    })(ExtensionUpdateType = exports2.ExtensionUpdateType || (exports2.ExtensionUpdateType = {}));
    var InstalledExtensionStateIssueType;
    (function(InstalledExtensionStateIssueType2) {
      InstalledExtensionStateIssueType2[InstalledExtensionStateIssueType2["Warning"] = 0] = "Warning";
      InstalledExtensionStateIssueType2[InstalledExtensionStateIssueType2["Error"] = 1] = "Error";
    })(InstalledExtensionStateIssueType = exports2.InstalledExtensionStateIssueType || (exports2.InstalledExtensionStateIssueType = {}));
    exports2.TypeInfo = {
      AcquisitionAssignmentType: {
        enumValues: {
          "none": 0,
          "me": 1,
          "all": 2
        }
      },
      AcquisitionOperation: {},
      AcquisitionOperationState: {
        enumValues: {
          "disallow": 0,
          "allow": 1,
          "completed": 3
        }
      },
      AcquisitionOperationType: {
        enumValues: {
          "get": 0,
          "install": 1,
          "buy": 2,
          "try": 3,
          "request": 4,
          "none": 5,
          "purchaseRequest": 6
        }
      },
      AcquisitionOptions: {},
      ContributionLicensingBehaviorType: {
        enumValues: {
          "onlyIfLicensed": 0,
          "onlyIfUnlicensed": 1,
          "alwaysInclude": 2
        }
      },
      ContributionNodeQuery: {},
      ContributionPropertyDescription: {},
      ContributionPropertyType: {
        enumValues: {
          "unknown": 0,
          "string": 1,
          "uri": 2,
          "guid": 4,
          "boolean": 8,
          "integer": 16,
          "double": 32,
          "dateTime": 64,
          "dictionary": 128,
          "array": 256,
          "object": 512
        }
      },
      ContributionQueryOptions: {
        enumValues: {
          "none": 0,
          "includeSelf": 16,
          "includeChildren": 32,
          "includeSubTree": 96,
          "includeAll": 112,
          "ignoreConstraints": 256
        }
      },
      ContributionType: {},
      ExtensionAcquisitionRequest: {},
      ExtensionAuditLog: {},
      ExtensionAuditLogEntry: {},
      ExtensionEvent: {},
      ExtensionFlags: {
        enumValues: {
          "builtIn": 1,
          "trusted": 2
        }
      },
      ExtensionLicensing: {},
      ExtensionManifest: {},
      ExtensionRequest: {},
      ExtensionRequestEvent: {},
      ExtensionRequestsEvent: {},
      ExtensionRequestState: {
        enumValues: {
          "open": 0,
          "accepted": 1,
          "rejected": 2
        }
      },
      ExtensionRequestUpdateType: {
        enumValues: {
          "created": 1,
          "approved": 2,
          "rejected": 3,
          "deleted": 4
        }
      },
      ExtensionState: {},
      ExtensionStateFlags: {
        enumValues: {
          "none": 0,
          "disabled": 1,
          "builtIn": 2,
          "multiVersion": 4,
          "unInstalled": 8,
          "versionCheckError": 16,
          "trusted": 32,
          "error": 64,
          "needsReauthorization": 128,
          "autoUpgradeError": 256,
          "warning": 512,
          "unpublished": 1024
        }
      },
      ExtensionUpdateType: {
        enumValues: {
          "installed": 1,
          "uninstalled": 2,
          "enabled": 3,
          "disabled": 4,
          "versionUpdated": 5,
          "actionRequired": 6,
          "actionResolved": 7
        }
      },
      InstalledExtension: {},
      InstalledExtensionState: {},
      InstalledExtensionStateIssue: {},
      InstalledExtensionStateIssueType: {
        enumValues: {
          "warning": 0,
          "error": 1
        }
      },
      LicensingOverride: {},
      RequestedExtension: {}
    };
    exports2.TypeInfo.AcquisitionOperation.fields = {
      operationState: {
        enumType: exports2.TypeInfo.AcquisitionOperationState
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.AcquisitionOptions.fields = {
      defaultOperation: {
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      },
      operations: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      }
    };
    exports2.TypeInfo.ContributionNodeQuery.fields = {
      queryOptions: {
        enumType: exports2.TypeInfo.ContributionQueryOptions
      }
    };
    exports2.TypeInfo.ContributionPropertyDescription.fields = {
      type: {
        enumType: exports2.TypeInfo.ContributionPropertyType
      }
    };
    exports2.TypeInfo.ContributionType.fields = {
      properties: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.ContributionPropertyDescription
      }
    };
    exports2.TypeInfo.ExtensionAcquisitionRequest.fields = {
      assignmentType: {
        enumType: exports2.TypeInfo.AcquisitionAssignmentType
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.ExtensionAuditLog.fields = {
      entries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionAuditLogEntry
      }
    };
    exports2.TypeInfo.ExtensionAuditLogEntry.fields = {
      auditDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionEvent.fields = {
      extension: {
        typeInfo: GalleryInterfaces.TypeInfo.PublishedExtension
      },
      updateType: {
        enumType: exports2.TypeInfo.ExtensionUpdateType
      }
    };
    exports2.TypeInfo.ExtensionLicensing.fields = {
      overrides: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LicensingOverride
      }
    };
    exports2.TypeInfo.ExtensionManifest.fields = {
      contributionTypes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ContributionType
      },
      licensing: {
        typeInfo: exports2.TypeInfo.ExtensionLicensing
      }
    };
    exports2.TypeInfo.ExtensionRequest.fields = {
      requestDate: {
        isDate: true
      },
      requestState: {
        enumType: exports2.TypeInfo.ExtensionRequestState
      },
      resolveDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionRequestEvent.fields = {
      extension: {
        typeInfo: GalleryInterfaces.TypeInfo.PublishedExtension
      },
      request: {
        typeInfo: exports2.TypeInfo.ExtensionRequest
      },
      updateType: {
        enumType: exports2.TypeInfo.ExtensionRequestUpdateType
      }
    };
    exports2.TypeInfo.ExtensionRequestsEvent.fields = {
      extension: {
        typeInfo: GalleryInterfaces.TypeInfo.PublishedExtension
      },
      requests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionRequest
      },
      updateType: {
        enumType: exports2.TypeInfo.ExtensionRequestUpdateType
      }
    };
    exports2.TypeInfo.ExtensionState.fields = {
      flags: {
        enumType: exports2.TypeInfo.ExtensionStateFlags
      },
      installationIssues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InstalledExtensionStateIssue
      },
      lastUpdated: {
        isDate: true
      },
      lastVersionCheck: {
        isDate: true
      }
    };
    exports2.TypeInfo.InstalledExtension.fields = {
      contributionTypes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ContributionType
      },
      flags: {
        enumType: exports2.TypeInfo.ExtensionFlags
      },
      installState: {
        typeInfo: exports2.TypeInfo.InstalledExtensionState
      },
      lastPublished: {
        isDate: true
      },
      licensing: {
        typeInfo: exports2.TypeInfo.ExtensionLicensing
      }
    };
    exports2.TypeInfo.InstalledExtensionState.fields = {
      flags: {
        enumType: exports2.TypeInfo.ExtensionStateFlags
      },
      installationIssues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InstalledExtensionStateIssue
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.InstalledExtensionStateIssue.fields = {
      type: {
        enumType: exports2.TypeInfo.InstalledExtensionStateIssueType
      }
    };
    exports2.TypeInfo.LicensingOverride.fields = {
      behavior: {
        enumType: exports2.TypeInfo.ContributionLicensingBehaviorType
      }
    };
    exports2.TypeInfo.RequestedExtension.fields = {
      extensionRequests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionRequest
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/ExtensionManagementApi.js
var require_ExtensionManagementApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/ExtensionManagementApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtensionManagementApi = void 0;
    var basem = require_ClientApiBases();
    var ExtensionManagementInterfaces = require_ExtensionManagementInterfaces();
    var GalleryInterfaces = require_GalleryInterfaces();
    var ExtensionManagementApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-ExtensionManagement-api", options2);
      }
      /**
       * This API is called by acquisition/install page to get possible user actions like Buy/Request
       *
       * @param {string} itemId - Fully qualified name of extension (<publisher_id>.<extension_id>)
       * @param {boolean} testCommerce - Parameter to test paid preview extension without making azure plans public
       * @param {boolean} isFreeOrTrialInstall - Parameter represents install or trial workflow (required for legacy install flows)
       * @param {boolean} isAccountOwner - Parameter represents whether user is owner or PCA of an account
       * @param {boolean} isLinked - Parameter represents whether account is linked with a subscription
       * @param {boolean} isConnectedServer - Parameter represents whether Buy operation should be evaluated
       * @param {boolean} isBuyOperationValid
       */
      getAcquisitionOptions(itemId, testCommerce, isFreeOrTrialInstall, isAccountOwner, isLinked, isConnectedServer, isBuyOperationValid) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (itemId == null) {
            throw new TypeError("itemId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              itemId,
              testCommerce,
              isFreeOrTrialInstall,
              isAccountOwner,
              isLinked,
              isConnectedServer,
              isBuyOperationValid
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "288dff58-d13b-468e-9671-0fb754e9398c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.AcquisitionOptions, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ExtensionManagementInterfaces.ExtensionAcquisitionRequest} acquisitionRequest
       */
      requestAcquisition(acquisitionRequest) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "da616457-eed3-4672-92d7-18d21f5c1658", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, acquisitionRequest, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.ExtensionAcquisitionRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       */
      getAuditLog(publisherName, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "23a312e0-562d-42fb-a505-5a046b5635db", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.ExtensionAuditLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} registrationId
       */
      registerAuthorization(publisherName, extensionName, registrationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              registrationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "f21cfc80-d2d2-4248-98bb-7820c74c4606", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} doc
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      createDocumentByName(doc, publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, doc, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       * @param {string} documentId
       */
      deleteDocumentByName(publisherName, extensionName, scopeType, scopeValue, collectionName, documentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName,
              documentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       * @param {string} documentId
       */
      getDocumentByName(publisherName, extensionName, scopeType, scopeValue, collectionName, documentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName,
              documentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      getDocumentsByName(publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} doc
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      setDocumentByName(doc, publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, doc, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} doc
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      updateDocumentByName(doc, publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, doc, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query for one or more data collections for the specified extension.  Note: the token used for authorization must have been issued on behalf of the specified extension.
       *
       * @param {ExtensionManagementInterfaces.ExtensionDataCollectionQuery} collectionQuery
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       */
      queryCollectionsByName(collectionQuery, publisherName, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "56c331f1-ce53-4318-adfd-4db5c52a7a2e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, collectionQuery, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List state and version information for all installed extensions.
       *
       * @param {boolean} includeDisabled - If true (the default), include disabled extensions in the results.
       * @param {boolean} includeErrors - If true, include installed extensions in an error state in the results.
       * @param {boolean} includeInstallationIssues
       * @param {boolean} forceRefresh
       */
      getStates(includeDisabled, includeErrors, includeInstallationIssues, forceRefresh) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeDisabled,
              includeErrors,
              includeInstallationIssues,
              forceRefresh
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "ExtensionManagement", "92755d3d-9a8a-42b3-8a4d-87359fe5aa93", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.ExtensionState, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ExtensionManagementInterfaces.InstalledExtensionQuery} query
       */
      queryExtensions(query) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "ExtensionManagement", "046c980f-1345-4ce2-bf85-b46d10ff4cfd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List the installed extensions in the account / project collection.
       *
       * @param {boolean} includeDisabledExtensions - If true (the default), include disabled extensions in the results.
       * @param {boolean} includeErrors - If true, include installed extensions with errors.
       * @param {string[]} assetTypes - Determines which files are returned in the files array.  Provide the wildcard '*' to return all files, or a colon separated list to retrieve files with specific asset types.
       * @param {boolean} includeInstallationIssues
       */
      getInstalledExtensions(includeDisabledExtensions, includeErrors, assetTypes, includeInstallationIssues) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeDisabledExtensions,
              includeErrors,
              assetTypes: assetTypes && assetTypes.join(":"),
              includeInstallationIssues
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "ExtensionManagement", "275424d0-c844-4fe2-bda6-04933a1357d8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an installed extension. Typically this API is used to enable or disable an extension.
       *
       * @param {ExtensionManagementInterfaces.InstalledExtension} extension
       */
      updateInstalledExtension(extension) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "ExtensionManagement", "275424d0-c844-4fe2-bda6-04933a1357d8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, extension, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an installed extension by its publisher and extension name.
       *
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       * @param {string[]} assetTypes - Determines which files are returned in the files array.  Provide the wildcard '*' to return all files, or a colon separated list to retrieve files with specific asset types.
       */
      getInstalledExtensionByName(publisherName, extensionName, assetTypes) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              assetTypes: assetTypes && assetTypes.join(":")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "ExtensionManagement", "fb0da285-f23e-4b56-8b53-3ef5f9f6de66", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Install the specified extension into the account / project collection.
       *
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       * @param {string} version
       */
      installExtensionByName(publisherName, extensionName, version) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "ExtensionManagement", "fb0da285-f23e-4b56-8b53-3ef5f9f6de66", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Uninstall the specified extension from the account / project collection.
       *
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       * @param {string} reason
       * @param {string} reasonCode
       */
      uninstallExtensionByName(publisherName, extensionName, reason, reasonCode) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              reason,
              reasonCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "ExtensionManagement", "fb0da285-f23e-4b56-8b53-3ef5f9f6de66", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} userId
       */
      getPolicies(userId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              userId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "e5cc8c09-407b-4867-8319-2ae3338cbf6f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.UserExtensionPolicy, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} rejectMessage
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} requesterId
       * @param {ExtensionManagementInterfaces.ExtensionRequestState} state
       */
      resolveRequest(rejectMessage, publisherName, extensionName, requesterId, state) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (state == null) {
            throw new TypeError("state can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              requesterId
            };
            let queryValues = {
              state
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "aa93e1f3-511c-4364-8b9c-eb98818f2e0b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, rejectMessage, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getRequests() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "216b978f-b164-424e-ada2-b77561e842b7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.RequestedExtension, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} rejectMessage
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {ExtensionManagementInterfaces.ExtensionRequestState} state
       */
      resolveAllRequests(rejectMessage, publisherName, extensionName, state) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (state == null) {
            throw new TypeError("state can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              state
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "ba93e1f3-511c-4364-8b9c-eb98818f2e0b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, rejectMessage, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       */
      deleteRequest(publisherName, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "f5afca1e-a728-4294-aa2d-4af0173431b5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} requestMessage
       */
      requestExtension(publisherName, extensionName, requestMessage) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "f5afca1e-a728-4294-aa2d-4af0173431b5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, requestMessage, options2);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.RequestedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getToken() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "3a2e24ed-1d6f-4cb2-9f3b-45a96bbfaf50", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ExtensionManagementApi = ExtensionManagementApi;
    ExtensionManagementApi.RESOURCE_AREA_ID = "6c2b0933-3600-42ae-bf8b-93d4f7e83594";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/FeatureManagementInterfaces.js
var require_FeatureManagementInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/FeatureManagementInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ContributedFeatureEnabledValue = void 0;
    var ContributedFeatureEnabledValue;
    (function(ContributedFeatureEnabledValue2) {
      ContributedFeatureEnabledValue2[ContributedFeatureEnabledValue2["Undefined"] = -1] = "Undefined";
      ContributedFeatureEnabledValue2[ContributedFeatureEnabledValue2["Disabled"] = 0] = "Disabled";
      ContributedFeatureEnabledValue2[ContributedFeatureEnabledValue2["Enabled"] = 1] = "Enabled";
    })(ContributedFeatureEnabledValue = exports2.ContributedFeatureEnabledValue || (exports2.ContributedFeatureEnabledValue = {}));
    exports2.TypeInfo = {
      ContributedFeatureEnabledValue: {
        enumValues: {
          "undefined": -1,
          "disabled": 0,
          "enabled": 1
        }
      },
      ContributedFeatureState: {},
      ContributedFeatureStateQuery: {}
    };
    exports2.TypeInfo.ContributedFeatureState.fields = {
      state: {
        enumType: exports2.TypeInfo.ContributedFeatureEnabledValue
      }
    };
    exports2.TypeInfo.ContributedFeatureStateQuery.fields = {
      featureStates: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.ContributedFeatureState
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/FeatureManagementApi.js
var require_FeatureManagementApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/FeatureManagementApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureManagementApi = void 0;
    var basem = require_ClientApiBases();
    var FeatureManagementInterfaces = require_FeatureManagementInterfaces();
    var FeatureManagementApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-FeatureManagement-api", options2);
      }
      /**
       * Get a specific feature by its id
       *
       * @param {string} featureId - The contribution id of the feature
       */
      getFeature(featureId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              featureId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "c4209f25-7a27-41dd-9f04-06080c7b6afd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of all defined features
       *
       * @param {string} targetContributionId - Optional target contribution. If null/empty, return all features. If specified include the features that target the specified contribution.
       */
      getFeatures(targetContributionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              targetContributionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "c4209f25-7a27-41dd-9f04-06080c7b6afd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the state of the specified feature for the given user/all-users scope
       *
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       */
      getFeatureState(featureId, userScope) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "98911314-3f9b-4eaf-80e8-83900d8e85d9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set the state of a feature
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureState} feature - Posted feature state object. Should specify the effective value.
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to set the value. Should be "me" for the current user or "host" for all users.
       * @param {string} reason - Reason for changing the state
       * @param {string} reasonCode - Short reason code
       */
      setFeatureState(feature, featureId, userScope, reason, reasonCode) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope
            };
            let queryValues = {
              reason,
              reasonCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "98911314-3f9b-4eaf-80e8-83900d8e85d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, feature, options2);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the state of the specified feature for the given named scope
       *
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       * @param {string} scopeName - Scope at which to get the feature setting for (e.g. "project" or "team")
       * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
       */
      getFeatureStateForScope(featureId, userScope, scopeName, scopeValue) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope,
              scopeName,
              scopeValue
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "dd291e43-aa9f-4cee-8465-a93c78e414a4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set the state of a feature at a specific scope
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureState} feature - Posted feature state object. Should specify the effective value.
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to set the value. Should be "me" for the current user or "host" for all users.
       * @param {string} scopeName - Scope at which to get the feature setting for (e.g. "project" or "team")
       * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
       * @param {string} reason - Reason for changing the state
       * @param {string} reasonCode - Short reason code
       */
      setFeatureStateForScope(feature, featureId, userScope, scopeName, scopeValue, reason, reasonCode) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope,
              scopeName,
              scopeValue
            };
            let queryValues = {
              reason,
              reasonCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "dd291e43-aa9f-4cee-8465-a93c78e414a4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, feature, options2);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the effective state for a list of feature ids
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureStateQuery} query - Features to query along with current scope values
       */
      queryFeatureStates(query) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "2b4486ad-122b-400c-ae65-17b6672c1f9d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureStateQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the states of the specified features for the default scope
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureStateQuery} query - Query describing the features to query.
       * @param {string} userScope
       */
      queryFeatureStatesForDefaultScope(query, userScope) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              userScope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "3f810f28-03e2-4239-b0bc-788add3005e5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureStateQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the states of the specified features for the specific named scope
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureStateQuery} query - Query describing the features to query.
       * @param {string} userScope
       * @param {string} scopeName
       * @param {string} scopeValue
       */
      queryFeatureStatesForNamedScope(query, userScope, scopeName, scopeValue) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              userScope,
              scopeName,
              scopeValue
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "f29e997b-c2da-4d15-8380-765788a1a74c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureStateQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.FeatureManagementApi = FeatureManagementApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/FileContainerInterfaces.js
var require_FileContainerInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/FileContainerInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ContainerOptions = exports2.ContainerItemType = exports2.ContainerItemStatus = exports2.BlobCompressionType = void 0;
    var BlobCompressionType;
    (function(BlobCompressionType2) {
      BlobCompressionType2[BlobCompressionType2["None"] = 0] = "None";
      BlobCompressionType2[BlobCompressionType2["GZip"] = 1] = "GZip";
    })(BlobCompressionType = exports2.BlobCompressionType || (exports2.BlobCompressionType = {}));
    var ContainerItemStatus;
    (function(ContainerItemStatus2) {
      ContainerItemStatus2[ContainerItemStatus2["Created"] = 1] = "Created";
      ContainerItemStatus2[ContainerItemStatus2["PendingUpload"] = 2] = "PendingUpload";
    })(ContainerItemStatus = exports2.ContainerItemStatus || (exports2.ContainerItemStatus = {}));
    var ContainerItemType;
    (function(ContainerItemType2) {
      ContainerItemType2[ContainerItemType2["Any"] = 0] = "Any";
      ContainerItemType2[ContainerItemType2["Folder"] = 1] = "Folder";
      ContainerItemType2[ContainerItemType2["File"] = 2] = "File";
    })(ContainerItemType = exports2.ContainerItemType || (exports2.ContainerItemType = {}));
    var ContainerOptions;
    (function(ContainerOptions2) {
      ContainerOptions2[ContainerOptions2["None"] = 0] = "None";
    })(ContainerOptions = exports2.ContainerOptions || (exports2.ContainerOptions = {}));
    exports2.TypeInfo = {
      BlobCompressionType: {
        enumValues: {
          "none": 0,
          "gZip": 1
        }
      },
      ContainerItemBlobReference: {},
      ContainerItemStatus: {
        enumValues: {
          "created": 1,
          "pendingUpload": 2
        }
      },
      ContainerItemType: {
        enumValues: {
          "any": 0,
          "folder": 1,
          "file": 2
        }
      },
      ContainerOptions: {
        enumValues: {
          "none": 0
        }
      },
      FileContainer: {},
      FileContainerItem: {}
    };
    exports2.TypeInfo.ContainerItemBlobReference.fields = {
      compressionType: {
        enumType: exports2.TypeInfo.BlobCompressionType
      }
    };
    exports2.TypeInfo.FileContainer.fields = {
      dateCreated: {
        isDate: true
      },
      options: {
        enumType: exports2.TypeInfo.ContainerOptions
      }
    };
    exports2.TypeInfo.FileContainerItem.fields = {
      blobMetadata: {
        typeInfo: exports2.TypeInfo.ContainerItemBlobReference
      },
      dateCreated: {
        isDate: true
      },
      dateLastModified: {
        isDate: true
      },
      itemType: {
        enumType: exports2.TypeInfo.ContainerItemType
      },
      status: {
        enumType: exports2.TypeInfo.ContainerItemStatus
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/FileContainerApiBase.js
var require_FileContainerApiBase = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/FileContainerApiBase.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileContainerApiBase = void 0;
    var basem = require_ClientApiBases();
    var FileContainerInterfaces = require_FileContainerInterfaces();
    var FileContainerApiBase = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-FileContainer-api", options2);
      }
      /**
       * Creates the specified items in the referenced container.
       *
       * @param {VSSInterfaces.VssJsonCollectionWrapperV<FileContainerInterfaces.FileContainerItem[]>} items
       * @param {number} containerId
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       */
      createItems(items, containerId, scope) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              scope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, items, options2);
              let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainerItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the specified items in a container.
       *
       * @param {number} containerId - Container Id.
       * @param {string} itemPath - Path to delete.
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       */
      deleteItem(containerId, itemPath, scope) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (itemPath == null) {
            throw new TypeError("itemPath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              itemPath,
              scope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets containers filtered by a comma separated list of artifact uris within the same scope, if not specified returns all containers
       *
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       * @param {string} artifactUris
       */
      getContainers(scope, artifactUris) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              scope,
              artifactUris
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainer, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the specified file container object in a format dependent upon the given parameters or HTTP Accept request header
       *
       * @param {number} containerId - The requested container Id
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       * @param {string} itemPath - The path to the item of interest
       * @param {boolean} metadata - If true, this overrides any specified format parameter or HTTP Accept request header to provide non-recursive information for the given itemPath
       * @param {string} format - If specified, this overrides the HTTP Accept request header to return either 'json' or 'zip'.  If $format is specified, then api-version should also be specified as a query parameter.
       * @param {string} downloadFileName - If specified and returning other than JSON format, then this download name will be used (else defaults to itemPath)
       * @param {boolean} includeDownloadTickets
       * @param {boolean} isShallow - If true, returns only immediate children(files & folders) for the given itemPath. False will return all items recursively within itemPath.
       * @param {boolean} ignoreRequestedMediaType - Set to true to ignore the HTTP Accept request header. Default is false.
       * @param {boolean} includeBlobMetadata
       * @param {boolean} saveAbsolutePath - Set to false to not save the absolute path to the specified directory of the artifact in the returned archive. Works only for artifact directories. Default is true.
       * @param {boolean} preferRedirect - Set to true to get the redirect response which leads to the stream with content. Default is false.
       */
      getItems(containerId, scope, itemPath, metadata, format, downloadFileName, includeDownloadTickets, isShallow, ignoreRequestedMediaType, includeBlobMetadata, saveAbsolutePath, preferRedirect) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              scope,
              itemPath,
              metadata,
              "$format": format,
              downloadFileName,
              includeDownloadTickets,
              isShallow,
              ignoreRequestedMediaType,
              includeBlobMetadata,
              saveAbsolutePath,
              preferRedirect
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainerItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.FileContainerApiBase = FileContainerApiBase;
  }
});

// packages/core/node_modules/azure-devops-node-api/FileContainerApi.js
var require_FileContainerApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/FileContainerApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileContainerApi = void 0;
    var stream = require("stream");
    var zlib = require("zlib");
    var httpm = require_HttpClient();
    var FileContainerApiBase = require_FileContainerApiBase();
    var FileContainerInterfaces = require_FileContainerInterfaces();
    var FileContainerApi = class extends FileContainerApiBase.FileContainerApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, options2, userAgent);
      }
      /**
       * @param {number} containerId
       * @param {string} scope
       * @param {string} itemPath
       * @param {string} downloadFileName
       */
      getItem(containerId, scope, itemPath, downloadFileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              scope,
              itemPath,
              "$format": "OctetStream",
              downloadFileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("4.0-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/octet-stream", verData.apiVersion);
              let res = yield this.http.get(url);
              let rres = {};
              let statusCode = res.message.statusCode;
              rres.statusCode = statusCode;
              if (statusCode == httpm.HttpCodes.NotFound) {
                resolve(rres);
              }
              if (statusCode > 299) {
                let msg;
                let contents = yield res.readBody();
                let obj;
                if (contents && contents.length > 0) {
                  obj = JSON.parse(contents);
                  if (options2 && options2.responseProcessor) {
                    rres.result = options2.responseProcessor(obj);
                  } else {
                    rres.result = obj;
                  }
                }
                if (obj && obj.message) {
                  msg = obj.message;
                } else {
                  msg = "Failed request: (" + statusCode + ") " + res.message.url;
                }
                reject2(new Error(msg));
              } else {
                if (res.message.headers["content-encoding"] === "gzip") {
                  let unzipStream = zlib.createGunzip();
                  res.message.pipe(unzipStream);
                  rres.result = unzipStream;
                } else {
                  rres.result = res.message;
                }
                resolve(rres);
              }
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      createItem(contentStream, uncompressedLength, containerId, itemPath, scope, options2) {
        return new Promise((resolve, reject2) => {
          let chunkStream = new ChunkStream(this, uncompressedLength, containerId, itemPath, scope, options2);
          chunkStream.on("finish", () => {
            resolve(chunkStream.getItem());
          });
          contentStream.pipe(chunkStream);
        });
      }
      // used by ChunkStream
      _createItem(customHeaders, contentStream, containerId, itemPath, scope, onResult) {
        var routeValues = {
          containerId
        };
        var queryValues = {
          itemPath,
          scope
        };
        customHeaders = customHeaders || {};
        customHeaders["Content-Type"] = "";
        this.vsoClient.getVersioningData("4.0-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues).then((versioningData) => {
          var url = versioningData.requestUrl;
          var serializationData = { responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainerItem, responseIsCollection: false };
          let options2 = this.createRequestOptions("application/octet-stream", versioningData.apiVersion);
          options2.additionalHeaders = customHeaders;
          this.rest.uploadStream("PUT", url, contentStream, options2).then((res) => {
            let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainerItem, false);
            onResult(null, res.statusCode, ret);
          }).catch((err) => {
            onResult(err, err.statusCode, null);
          });
        }, (error2) => {
          onResult(error2, error2.statusCode, null);
        });
      }
    };
    exports2.FileContainerApi = FileContainerApi;
    var ChunkStream = class _ChunkStream extends stream.Writable {
      constructor(api, uncompressedLength, containerId, itemPath, scope, options2) {
        super();
        this._buffer = new Buffer(_ChunkStream.ChunkSize);
        this._length = 0;
        this._startRange = 0;
        this._bytesToSend = 0;
        this._totalReceived = 0;
        this._api = api;
        this._options = options2 || {};
        this._uncompressedLength = uncompressedLength;
        this._containerId = containerId;
        this._itemPath = itemPath;
        this._scope = scope;
        this._bytesToSend = this._options.isGzipped ? this._options.compressedLength : uncompressedLength;
      }
      _write(data, encoding, callback) {
        let chunk2 = data;
        if (!chunk2) {
          if (this._length == 0) {
            callback();
          } else {
            this._sendChunk(callback);
          }
          return;
        }
        let newBuffer = null;
        if (this._length + chunk2.length > _ChunkStream.ChunkSize) {
          let overflowPosition = chunk2.length - (_ChunkStream.ChunkSize - this._length);
          chunk2.copy(this._buffer, this._length, 0, overflowPosition);
          this._length += overflowPosition;
          newBuffer = chunk2.slice(overflowPosition);
        } else {
          chunk2.copy(this._buffer, this._length, 0, chunk2.length);
          this._length += chunk2.length;
        }
        this._totalReceived += chunk2.length;
        if (this._length >= _ChunkStream.ChunkSize || this._totalReceived >= this._bytesToSend) {
          this._sendChunk(callback, newBuffer);
        } else {
          callback();
        }
      }
      _sendChunk(callback, newBuffer) {
        let endRange = this._startRange + this._length;
        let headers = {
          "Content-Range": "bytes " + this._startRange + "-" + (endRange - 1) + "/" + this._bytesToSend,
          "Content-Length": this._length
        };
        if (this._options.isGzipped) {
          headers["Accept-Encoding"] = "gzip";
          headers["Content-Encoding"] = "gzip";
          headers["x-tfs-filelength"] = this._uncompressedLength;
        }
        this._startRange = endRange;
        this._api._createItem(headers, new BufferStream(this._buffer, this._length), this._containerId, this._itemPath, this._scope, (err, statusCode, item) => {
          if (newBuffer) {
            this._length = newBuffer.length;
            newBuffer.copy(this._buffer);
          } else {
            this._length = 0;
          }
          this._item = item;
          callback(err);
        });
      }
      getItem() {
        return this._item;
      }
    };
    ChunkStream.ChunkSize = 16 * 1024 * 1024;
    var BufferStream = class extends stream.Readable {
      constructor(buffer, length) {
        super();
        this._position = 0;
        this._length = 0;
        this._buffer = buffer;
        this._length = length;
      }
      _read(size2) {
        if (this._position >= this._length) {
          this.push(null);
          return;
        }
        let end = Math.min(this._position + size2, this._length);
        this.push(this._buffer.slice(this._position, end));
        this._position = end;
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/GalleryCompatHttpClientBase.js
var require_GalleryCompatHttpClientBase = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/GalleryCompatHttpClientBase.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GalleryCompatHttpClientBase = void 0;
    var basem = require_ClientApiBases();
    var GalleryInterfaces = require_GalleryInterfaces();
    var GalleryCompatHttpClientBase = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, userAgent, options2) {
        super(baseUrl, handlers, userAgent, options2);
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      */
      createExtensionJson(extensionPackage) {
        return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
          let routeValues = {};
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues);
            let url = verData.requestUrl;
            let options2 = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.create(url, extensionPackage, options2);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      * @param {string} extensionId
      */
      updateExtensionByIdJson(extensionPackage, extensionId) {
        return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
          let routeValues = {
            extensionId
          };
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues);
            let url = verData.requestUrl;
            let options2 = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.replace(url, extensionPackage, options2);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      * @param {string} publisherName
      */
      createExtensionWithPublisherJson(extensionPackage, publisherName) {
        return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
          let routeValues = {
            publisherName
          };
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues);
            let url = verData.requestUrl;
            let options2 = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.create(url, extensionPackage, options2);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      * @param {string} publisherName
      * @param {string} extensionName
      */
      updateExtensionJson(extensionPackage, publisherName, extensionName) {
        return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
          let routeValues = {
            publisherName,
            extensionName
          };
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues);
            let url = verData.requestUrl;
            let options2 = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.replace(url, extensionPackage, options2);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
    };
    exports2.GalleryCompatHttpClientBase = GalleryCompatHttpClientBase;
  }
});

// packages/core/node_modules/azure-devops-node-api/GalleryApi.js
var require_GalleryApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/GalleryApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GalleryApi = void 0;
    var compatBase = require_GalleryCompatHttpClientBase();
    var GalleryInterfaces = require_GalleryInterfaces();
    var GalleryApi = class extends compatBase.GalleryCompatHttpClientBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Gallery-api", options2);
      }
      /**
       * @param {string} extensionId
       * @param {string} accountName
       */
      shareExtensionById(extensionId, accountName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "1f19631b-a0b4-4a03-89c2-d79785d24360", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} accountName
       */
      unshareExtensionById(extensionId, accountName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "1f19631b-a0b4-4a03-89c2-d79785d24360", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} accountName
       */
      shareExtension(publisherName, extensionName, accountName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "a1e66d8f-f5de-4d16-8309-91a4e015ee46", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} accountName
       */
      unshareExtension(publisherName, extensionName, accountName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "a1e66d8f-f5de-4d16-8309-91a4e015ee46", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} itemId
       * @param {string} installationTarget
       * @param {boolean} testCommerce
       * @param {boolean} isFreeOrTrialInstall
       */
      getAcquisitionOptions(itemId, installationTarget, testCommerce, isFreeOrTrialInstall) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (installationTarget == null) {
            throw new TypeError("installationTarget can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              itemId
            };
            let queryValues = {
              installationTarget,
              testCommerce,
              isFreeOrTrialInstall
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "9d0a0105-075e-4760-aa15-8bcf54d1bd7d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.AcquisitionOptions, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionAcquisitionRequest} acquisitionRequest
       */
      requestAcquisition(acquisitionRequest) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "3adb1f2d-e328-446e-be73-9f6d98071c45", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, acquisitionRequest, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionAcquisitionRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} assetType
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAssetByName(customHeaders, publisherName, extensionName, version, assetType, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version,
              assetType
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7529171f-a002-4180-93ba-685f358a0482", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} version
       * @param {string} assetType
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAsset(customHeaders, extensionId, version, assetType, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId,
              version,
              assetType
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "5d545f3d-ef47-488b-8be3-f5ee1517856c", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} assetType
       * @param {string} accountToken
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAssetAuthenticated(customHeaders, publisherName, extensionName, version, assetType, accountToken, accountTokenHeader) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version,
              assetType
            };
            let queryValues = {
              accountToken
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "506aff36-2622-4f70-8063-77cce6366d20", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} azurePublisherId
       */
      associateAzurePublisher(publisherName, azurePublisherId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (azurePublisherId == null) {
            throw new TypeError("azurePublisherId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              azurePublisherId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "efd202a6-9d87-4ebc-9229-d2b8ae2fdb6d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      queryAssociatedAzurePublisher(publisherName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "efd202a6-9d87-4ebc-9229-d2b8ae2fdb6d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} languages
       */
      getCategories(languages) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              languages
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e0a5a71e-3ac3-43a0-ae7d-0bb5c3046a2a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} categoryName
       * @param {string} languages
       * @param {string} product
       */
      getCategoryDetails(categoryName, languages, product) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              categoryName
            };
            let queryValues = {
              languages,
              product
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "75d3c04d-84d2-4973-acd2-22627587dabc", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} product
       * @param {string} categoryId
       * @param {number} lcid
       * @param {string} source
       * @param {string} productVersion
       * @param {string} skus
       * @param {string} subSkus
       * @param {string} productArchitecture
       */
      getCategoryTree(product, categoryId, lcid, source, productVersion, skus, subSkus, productArchitecture) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              product,
              categoryId
            };
            let queryValues = {
              lcid,
              source,
              productVersion,
              skus,
              subSkus,
              productArchitecture
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "1102bb42-82b0-4955-8d8a-435d6b4cedd3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} product
       * @param {number} lcid
       * @param {string} source
       * @param {string} productVersion
       * @param {string} skus
       * @param {string} subSkus
       */
      getRootCategories(product, lcid, source, productVersion, skus, subSkus) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              product
            };
            let queryValues = {
              lcid,
              source,
              productVersion,
              skus,
              subSkus
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "31fba831-35b2-46f6-a641-d05de5a877d8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       */
      getCertificate(publisherName, extensionName, version) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e905ad6a-3f1f-4d08-9f6d-7d357ff8b7d0", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.CustomerSupportRequest} customerSupportRequest
       */
      createSupportRequest(customerSupportRequest) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "8eded385-026a-4c15-b810-b8eb402771f1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, customerSupportRequest, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       */
      createDraftForEditExtension(publisherName, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "02b33873-4e61-496e-83a2-59d1df46b7d8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionDraftPatch} draftPatch
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} draftId
       */
      performEditExtensionDraftOperation(draftPatch, publisherName, extensionName, draftId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              draftId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "02b33873-4e61-496e-83a2-59d1df46b7d8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, draftPatch, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} draftId
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      updatePayloadInDraftForEditExtension(customHeaders, contentStream, publisherName, extensionName, draftId, fileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              draftId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "02b33873-4e61-496e-83a2-59d1df46b7d8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} draftId
       * @param {string} assetType
       */
      addAssetForEditExtensionDraft(customHeaders, contentStream, publisherName, extensionName, draftId, assetType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              draftId,
              assetType
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "f1db9c47-6619-4998-a7e5-d7f9f41a4617", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {String} product - Header to pass the product type of the payload file
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      createDraftForNewExtension(customHeaders, contentStream, publisherName, product, fileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileProduct"] = "product";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b3ab127d-ebb9-4d22-b611-4e09593c8d79", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionDraftPatch} draftPatch
       * @param {string} publisherName
       * @param {string} draftId
       */
      performNewExtensionDraftOperation(draftPatch, publisherName, draftId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b3ab127d-ebb9-4d22-b611-4e09593c8d79", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, draftPatch, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} draftId
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      updatePayloadInDraftForNewExtension(customHeaders, contentStream, publisherName, draftId, fileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b3ab127d-ebb9-4d22-b611-4e09593c8d79", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} draftId
       * @param {string} assetType
       */
      addAssetForNewExtensionDraft(customHeaders, contentStream, publisherName, draftId, assetType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId,
              assetType
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "88c0b1c8-b4f1-498a-9b2a-8446ef9f32e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} draftId
       * @param {string} assetType
       * @param {string} extensionName
       */
      getAssetFromEditExtensionDraft(publisherName, draftId, assetType, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (extensionName == null) {
            throw new TypeError("extensionName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId,
              assetType
            };
            let queryValues = {
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "88c0b1c8-b4f1-498a-9b2a-8446ef9f32e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} draftId
       * @param {string} assetType
       */
      getAssetFromNewExtensionDraft(publisherName, draftId, assetType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId,
              assetType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "88c0b1c8-b4f1-498a-9b2a-8446ef9f32e7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get install/uninstall events of an extension. If both count and afterDate parameters are specified, count takes precedence.
       *
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {number} count - Count of events to fetch, applies to each event type.
       * @param {Date} afterDate - Fetch events that occurred on or after this date
       * @param {string} include - Filter options. Supported values: install, uninstall, review, acquisition, sales. Default is to fetch all types of events
       * @param {string} includeProperty - Event properties to include. Currently only 'lastContactDetails' is supported for uninstall events
       */
      getExtensionEvents(publisherName, extensionName, count, afterDate, include, includeProperty) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              count,
              afterDate,
              include,
              includeProperty
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "3d13c499-2168-4d06-bef4-14aba185dcd5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionEvents, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * API endpoint to publish extension install/uninstall events. This is meant to be invoked by EMS only for sending us data related to install/uninstall of an extension.
       *
       * @param {GalleryInterfaces.ExtensionEvents[]} extensionEvents
       */
      publishExtensionEvents(extensionEvents) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "0bf2bd3a-70e0-4d5d-8bf7-bd4a9c2ab6e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, extensionEvents, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionQuery} extensionQuery
       * @param {string} accountToken
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      queryExtensions(customHeaders, extensionQuery, accountToken, accountTokenHeader) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              accountToken
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "eb9d5ee1-6d43-456b-b80e-8a96fbc014b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.create(url, extensionQuery, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       */
      createExtension(customHeaders, contentStream, extensionType, reCaptchaToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              extensionType,
              reCaptchaToken
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} version
       */
      deleteExtensionById(extensionId, version) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId
            };
            let queryValues = {
              version
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} version
       * @param {GalleryInterfaces.ExtensionQueryFlags} flags
       */
      getExtensionById(extensionId, version, flags) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId
            };
            let queryValues = {
              version,
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} reCaptchaToken
       */
      updateExtensionById(extensionId, reCaptchaToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId
            };
            let queryValues = {
              reCaptchaToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       */
      createExtensionWithPublisher(customHeaders, contentStream, publisherName, extensionType, reCaptchaToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              extensionType,
              reCaptchaToken
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       */
      deleteExtension(publisherName, extensionName, version) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              version
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {GalleryInterfaces.ExtensionQueryFlags} flags
       * @param {string} accountToken
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getExtension(customHeaders, publisherName, extensionName, version, flags, accountToken, accountTokenHeader) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              version,
              flags,
              accountToken
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * REST endpoint to update an extension.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       * @param {boolean} bypassScopeCheck - This parameter decides if the scope change check needs to be invoked or not
       */
      updateExtension(customHeaders, contentStream, publisherName, extensionName, extensionType, reCaptchaToken, bypassScopeCheck) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              extensionType,
              reCaptchaToken,
              bypassScopeCheck
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {GalleryInterfaces.PublishedExtensionFlags} flags
       */
      updateExtensionProperties(publisherName, extensionName, flags) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} hostType
       * @param {string} hostName
       */
      shareExtensionWithHost(publisherName, extensionName, hostType, hostName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              hostType,
              hostName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "328a3af8-d124-46e9-9483-01690cd415b9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} hostType
       * @param {string} hostName
       */
      unshareExtensionWithHost(publisherName, extensionName, hostType, hostName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              hostType,
              hostName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "328a3af8-d124-46e9-9483-01690cd415b9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Rest end point to validate if an Azure publisher owns an extension for 3rd party commerce scenario. Azure only supports POST operations and the above signature is not typical of the REST operations. http://sharepoint/sites/AzureUX/_layouts/15/WopiFrame2.aspx?sourcedoc={A793D31E-6DC6-4174-8FA3-DE3F82B51642}&file=Data%20Market%20Partner%20integration%20with%20Marketplace%20service.docx&action=default
       *
       * @param {GalleryInterfaces.AzureRestApiRequestModel} azureRestApiRequestModel - All the parameters are sent in the request body
       */
      extensionValidator(azureRestApiRequestModel) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "05e8a5e1-8c59-4c2c-8856-0ff087d1a844", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, azureRestApiRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Send Notification
       *
       * @param {GalleryInterfaces.NotificationsData} notificationData - Denoting the data needed to send notification
       */
      sendNotifications(notificationData) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "eab39817-413c-4602-a49f-07ad00844980", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notificationData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This endpoint gets hit when you download a VSTS extension from the Web UI
       *
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getPackage(customHeaders, publisherName, extensionName, version, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7cb576f8-1cae-4c4b-b7b1-e4af5759e965", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} assetType
       * @param {string} assetToken
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAssetWithToken(customHeaders, publisherName, extensionName, version, assetType, assetToken, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version,
              assetType,
              assetToken
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "364415a1-0077-4a41-a7a0-06edd4497492", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete publisher asset like logo
       *
       * @param {string} publisherName - Internal name of the publisher
       * @param {string} assetType - Type of asset. Default value is 'logo'.
       */
      deletePublisherAsset(publisherName, assetType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              assetType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "21143299-34f9-4c62-8ca8-53da691192f9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get publisher asset like logo as a stream
       *
       * @param {string} publisherName - Internal name of the publisher
       * @param {string} assetType - Type of asset. Default value is 'logo'.
       */
      getPublisherAsset(publisherName, assetType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              assetType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "21143299-34f9-4c62-8ca8-53da691192f9", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update publisher asset like logo. It accepts asset file as an octet stream and file name is passed in header values.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName - Internal name of the publisher
       * @param {string} assetType - Type of asset. Default value is 'logo'.
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      updatePublisherAsset(customHeaders, contentStream, publisherName, assetType, fileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              assetType
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "21143299-34f9-4c62-8ca8-53da691192f9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      fetchDomainToken(publisherName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "67a609ef-fa74-4b52-8664-78d76f7b3634", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      verifyDomainToken(publisherName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "67a609ef-fa74-4b52-8664-78d76f7b3634", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.PublisherQuery} publisherQuery
       */
      queryPublishers(publisherQuery) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "2ad6ee0a-b53f-4034-9d1d-d009fda1212e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, publisherQuery, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublisherQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.Publisher} publisher
       */
      createPublisher(publisher) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, publisher, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      deletePublisher(publisherName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {number} flags
       */
      getPublisher(publisherName, flags) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.Publisher} publisher
       * @param {string} publisherName
       */
      updatePublisher(publisher, publisherName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, publisher, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Endpoint to add/modify publisher membership. Currently Supports only addition/modification of 1 user at a time Works only for adding members of same tenant.
       *
       * @param {GalleryInterfaces.PublisherUserRoleAssignmentRef[]} roleAssignments - List of user identifiers(email address) and role to be added. Currently only one entry is supported.
       * @param {string} publisherName - The name/id of publisher to which users have to be added
       * @param {boolean} limitToCallerIdentityDomain - Should cross tenant addtions be allowed or not.
       */
      updatePublisherMembers(roleAssignments, publisherName, limitToCallerIdentityDomain) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              limitToCallerIdentityDomain
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, roleAssignments, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublisherRoleAssignment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       * @param {boolean} bypassScopeCheck
       */
      publishExtensionWithPublisherSignature(customHeaders, contentStream, publisherName, extensionName, extensionType, reCaptchaToken, bypassScopeCheck) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              extensionType,
              reCaptchaToken,
              bypassScopeCheck
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "multipart/related";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0969", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      getPublisherWithoutToken(publisherName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "215a2ed8-458a-4850-ad5a-45f1dabc3461", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of questions with their responses associated with an extension.
       *
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} count - Number of questions to retrieve (defaults to 10).
       * @param {number} page - Page number from which set of questions are to be retrieved.
       * @param {Date} afterDate - If provided, results questions are returned which were posted after this date
       */
      getQuestions(publisherName, extensionName, count, page, afterDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              count,
              page,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "c010d03d-812c-4ade-ae07-c1862475eda5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.QuestionsResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Flags a concern with an existing question for an extension.
       *
       * @param {GalleryInterfaces.Concern} concern - User reported concern with a question for the extension.
       * @param {string} pubName - Name of the publisher who published the extension.
       * @param {string} extName - Name of the extension.
       * @param {number} questionId - Identifier of the question to be updated for the extension.
       */
      reportQuestion(concern, pubName, extName, questionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "784910cd-254a-494d-898b-0728549b2f10", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, concern, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Concern, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new question for an extension.
       *
       * @param {GalleryInterfaces.Question} question - Question to be created for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       */
      createQuestion(question, publisherName, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "6d1d9741-eca8-4701-a3a5-235afc82dfa4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, question, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Question, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes an existing question and all its associated responses for an extension. (soft delete)
       *
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question to be deleted for the extension.
       */
      deleteQuestion(publisherName, extensionName, questionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "6d1d9741-eca8-4701-a3a5-235afc82dfa4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing question for an extension.
       *
       * @param {GalleryInterfaces.Question} question - Updated question to be set for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question to be updated for the extension.
       */
      updateQuestion(question, publisherName, extensionName, questionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "6d1d9741-eca8-4701-a3a5-235afc82dfa4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, question, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Question, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new response for a given question for an extension.
       *
       * @param {GalleryInterfaces.Response} response - Response to be created for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question for which response is to be created for the extension.
       */
      createResponse(response, publisherName, extensionName, questionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7f8ae5e0-46b0-438f-b2e8-13e8513517bd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, response, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Response, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a response for an extension. (soft delete)
       *
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifies the question whose response is to be deleted.
       * @param {number} responseId - Identifies the response to be deleted.
       */
      deleteResponse(publisherName, extensionName, questionId, responseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId,
              responseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7f8ae5e0-46b0-438f-b2e8-13e8513517bd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing response for a given question for an extension.
       *
       * @param {GalleryInterfaces.Response} response - Updated response to be set for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question for which response is to be updated for the extension.
       * @param {number} responseId - Identifier of the response which has to be updated.
       */
      updateResponse(response, publisherName, extensionName, questionId, responseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId,
              responseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7f8ae5e0-46b0-438f-b2e8-13e8513517bd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, response, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Response, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns extension reports
       *
       * @param {string} publisherName - Name of the publisher who published the extension
       * @param {string} extensionName - Name of the extension
       * @param {number} days - Last n days report. If afterDate and days are specified, days will take priority
       * @param {number} count - Number of events to be returned
       * @param {Date} afterDate - Use if you want to fetch events newer than the specified date
       */
      getExtensionReports(publisherName, extensionName, days, count, afterDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              days,
              count,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "79e0c74f-157f-437e-845f-74fbb4121d4c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of reviews associated with an extension
       *
       * @param {string} publisherName - Name of the publisher who published the extension
       * @param {string} extensionName - Name of the extension
       * @param {number} count - Number of reviews to retrieve (defaults to 5)
       * @param {GalleryInterfaces.ReviewFilterOptions} filterOptions - FilterOptions to filter out empty reviews etcetera, defaults to none
       * @param {Date} beforeDate - Use if you want to fetch reviews older than the specified date, defaults to null
       * @param {Date} afterDate - Use if you want to fetch reviews newer than the specified date, defaults to null
       */
      getReviews(publisherName, extensionName, count, filterOptions, beforeDate, afterDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              count,
              filterOptions,
              beforeDate,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "5b3f819f-f247-42ad-8c00-dd9ab9ab246d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ReviewsResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a summary of the reviews
       *
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       * @param {Date} beforeDate - Use if you want to fetch summary of reviews older than the specified date, defaults to null
       * @param {Date} afterDate - Use if you want to fetch summary of reviews newer than the specified date, defaults to null
       */
      getReviewsSummary(pubName, extName, beforeDate, afterDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName
            };
            let queryValues = {
              beforeDate,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b7b44e21-209e-48f0-ae78-04727fc37d77", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new review for an extension
       *
       * @param {GalleryInterfaces.Review} review - Review to be created for the extension
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       */
      createReview(review, pubName, extName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e6e85b9d-aa70-40e6-aa28-d0fbf40b91a3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, review, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Review, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a review
       *
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       * @param {number} reviewId - Id of the review which needs to be updated
       */
      deleteReview(pubName, extName, reviewId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName,
              reviewId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e6e85b9d-aa70-40e6-aa28-d0fbf40b91a3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates or Flags a review
       *
       * @param {GalleryInterfaces.ReviewPatch} reviewPatch - ReviewPatch object which contains the changes to be applied to the review
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       * @param {number} reviewId - Id of the review which needs to be updated
       */
      updateReview(reviewPatch, pubName, extName, reviewId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName,
              reviewId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e6e85b9d-aa70-40e6-aa28-d0fbf40b91a3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, reviewPatch, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ReviewPatch, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionCategory} category
       */
      createCategory(category) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "476531a3-7024-4516-a76a-ed64d3008ad6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, category, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all setting entries for the given user/all-users scope
       *
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       * @param {string} key - Optional key under which to filter all the entries
       */
      getGalleryUserSettings(userScope, key) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              userScope,
              key
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "9b75ece3-7960-401c-848b-148ac01ca350", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set all setting entries for the given user/all-users scope
       *
       * @param {{ [key: string] : any; }} entries - A key-value pair of all settings that need to be set
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       */
      setGalleryUserSettings(entries, userScope) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              userScope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "9b75ece3-7960-401c-848b-148ac01ca350", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, entries, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} keyType
       * @param {number} expireCurrentSeconds
       */
      generateKey(keyType, expireCurrentSeconds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              keyType
            };
            let queryValues = {
              expireCurrentSeconds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "92ed5cf4-c38b-465a-9059-2f2fb7c624b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} keyType
       */
      getSigningKey(keyType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              keyType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "92ed5cf4-c38b-465a-9059-2f2fb7c624b5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionStatisticUpdate} extensionStatisticsUpdate
       * @param {string} publisherName
       * @param {string} extensionName
       */
      updateExtensionStatistics(extensionStatisticsUpdate, publisherName, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "a0ea3204-11e9-422d-a9ca-45851cc41400", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, extensionStatisticsUpdate, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {number} days
       * @param {GalleryInterfaces.ExtensionStatsAggregateType} aggregate
       * @param {Date} afterDate
       */
      getExtensionDailyStats(publisherName, extensionName, days, aggregate, afterDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              days,
              aggregate,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "ae06047e-51c5-4fb4-ab65-7be488544416", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDailyStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This route/location id only supports HTTP POST anonymously, so that the page view daily stat can be incremented from Marketplace client. Trying to call GET on this route should result in an exception. Without this explicit implementation, calling GET on this public route invokes the above GET implementation GetExtensionDailyStats.
       *
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {string} version - Version of the extension
       */
      getExtensionDailyStatsAnonymous(publisherName, extensionName, version) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4fa7adb6-ca65-4075-a232-5f28323288ea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDailyStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Increments a daily statistic associated with the extension
       *
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {string} version - Version of the extension
       * @param {string} statType - Type of stat to increment
       * @param {string} targetPlatform
       */
      incrementExtensionDailyStat(publisherName, extensionName, version, statType, targetPlatform) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (statType == null) {
            throw new TypeError("statType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version
            };
            let queryValues = {
              statType,
              targetPlatform
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4fa7adb6-ca65-4075-a232-5f28323288ea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} targetPlatform
       */
      getVerificationLog(publisherName, extensionName, version, targetPlatform) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version
            };
            let queryValues = {
              targetPlatform
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "c5523abe-b843-437f-875b-5833064efe4d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Endpoint to get the latest version(s) of a VS Code extension.
       *
       * @param {string} publisherName - The name of the publisher of the requested VS Code extension.
       * @param {string} extensionName - The extension name.
       */
      getVSCodeExtensionLatestVersion(publisherName, extensionName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "86037ad5-f601-40fb-b363-6ff262b61521", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} itemName
       * @param {string} version
       * @param {GalleryInterfaces.VSCodeWebExtensionStatisicsType} statType
       */
      updateVSCodeWebExtensionStatistics(itemName, version, statType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              itemName,
              version,
              statType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "205c91a8-7841-4fd3-ae4f-5a745d5a8df5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.GalleryApi = GalleryApi;
    GalleryApi.RESOURCE_AREA_ID = "69d21c00-f135-441b-b5ce-3626378e0819";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/PolicyInterfaces.js
var require_PolicyInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/PolicyInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.PolicyEvaluationStatus = void 0;
    var PolicyEvaluationStatus;
    (function(PolicyEvaluationStatus2) {
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Queued"] = 0] = "Queued";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Running"] = 1] = "Running";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Approved"] = 2] = "Approved";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Rejected"] = 3] = "Rejected";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["NotApplicable"] = 4] = "NotApplicable";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Broken"] = 5] = "Broken";
    })(PolicyEvaluationStatus = exports2.PolicyEvaluationStatus || (exports2.PolicyEvaluationStatus = {}));
    exports2.TypeInfo = {
      PolicyConfiguration: {},
      PolicyEvaluationRecord: {},
      PolicyEvaluationStatus: {
        enumValues: {
          "queued": 0,
          "running": 1,
          "approved": 2,
          "rejected": 3,
          "notApplicable": 4,
          "broken": 5
        }
      }
    };
    exports2.TypeInfo.PolicyConfiguration.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.PolicyEvaluationRecord.fields = {
      completedDate: {
        isDate: true
      },
      configuration: {
        typeInfo: exports2.TypeInfo.PolicyConfiguration
      },
      startedDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.PolicyEvaluationStatus
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/GitInterfaces.js
var require_GitInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/GitInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VersionControlRecursionType = exports2.VersionControlChangeType = exports2.TfvcVersionType = exports2.TfvcVersionOption = exports2.SupportedIdeType = exports2.RefFavoriteType = exports2.PullRequestTimeRangeType = exports2.PullRequestStatus = exports2.PullRequestMergeFailureType = exports2.PullRequestAsyncStatus = exports2.LineDiffBlockChangeType = exports2.IterationReason = exports2.ItemContentType = exports2.GitVersionType = exports2.GitVersionOptions = exports2.GitStatusState = exports2.GitResolutionWhichAction = exports2.GitResolutionStatus = exports2.GitResolutionRename1to2Action = exports2.GitResolutionPathConflictAction = exports2.GitResolutionMergeType = exports2.GitResolutionError = exports2.GitRefUpdateStatus = exports2.GitRefUpdateMode = exports2.GitRefSearchType = exports2.GitPullRequestReviewFileType = exports2.GitPullRequestQueryType = exports2.GitPullRequestQueryIncludeOptions = exports2.GitPullRequestMergeStrategy = exports2.GitPathActions = exports2.GitObjectType = exports2.GitHistoryMode = exports2.GitConflictUpdateStatus = exports2.GitConflictType = exports2.GitAsyncRefOperationFailureStatus = exports2.GitAsyncOperationStatus = exports2.CommentType = exports2.CommentThreadStatus = void 0;
    var PolicyInterfaces = require_PolicyInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var CommentThreadStatus;
    (function(CommentThreadStatus2) {
      CommentThreadStatus2[CommentThreadStatus2["Unknown"] = 0] = "Unknown";
      CommentThreadStatus2[CommentThreadStatus2["Active"] = 1] = "Active";
      CommentThreadStatus2[CommentThreadStatus2["Fixed"] = 2] = "Fixed";
      CommentThreadStatus2[CommentThreadStatus2["WontFix"] = 3] = "WontFix";
      CommentThreadStatus2[CommentThreadStatus2["Closed"] = 4] = "Closed";
      CommentThreadStatus2[CommentThreadStatus2["ByDesign"] = 5] = "ByDesign";
      CommentThreadStatus2[CommentThreadStatus2["Pending"] = 6] = "Pending";
    })(CommentThreadStatus = exports2.CommentThreadStatus || (exports2.CommentThreadStatus = {}));
    var CommentType;
    (function(CommentType2) {
      CommentType2[CommentType2["Unknown"] = 0] = "Unknown";
      CommentType2[CommentType2["Text"] = 1] = "Text";
      CommentType2[CommentType2["CodeChange"] = 2] = "CodeChange";
      CommentType2[CommentType2["System"] = 3] = "System";
    })(CommentType = exports2.CommentType || (exports2.CommentType = {}));
    var GitAsyncOperationStatus;
    (function(GitAsyncOperationStatus2) {
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Queued"] = 1] = "Queued";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["InProgress"] = 2] = "InProgress";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Completed"] = 3] = "Completed";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Failed"] = 4] = "Failed";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Abandoned"] = 5] = "Abandoned";
    })(GitAsyncOperationStatus = exports2.GitAsyncOperationStatus || (exports2.GitAsyncOperationStatus = {}));
    var GitAsyncRefOperationFailureStatus;
    (function(GitAsyncRefOperationFailureStatus2) {
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["None"] = 0] = "None";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["InvalidRefName"] = 1] = "InvalidRefName";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["RefNameConflict"] = 2] = "RefNameConflict";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["CreateBranchPermissionRequired"] = 3] = "CreateBranchPermissionRequired";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["WritePermissionRequired"] = 4] = "WritePermissionRequired";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["TargetBranchDeleted"] = 5] = "TargetBranchDeleted";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["GitObjectTooLarge"] = 6] = "GitObjectTooLarge";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["OperationIndentityNotFound"] = 7] = "OperationIndentityNotFound";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["AsyncOperationNotFound"] = 8] = "AsyncOperationNotFound";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["Other"] = 9] = "Other";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["EmptyCommitterSignature"] = 10] = "EmptyCommitterSignature";
    })(GitAsyncRefOperationFailureStatus = exports2.GitAsyncRefOperationFailureStatus || (exports2.GitAsyncRefOperationFailureStatus = {}));
    var GitConflictType;
    (function(GitConflictType2) {
      GitConflictType2[GitConflictType2["None"] = 0] = "None";
      GitConflictType2[GitConflictType2["AddAdd"] = 1] = "AddAdd";
      GitConflictType2[GitConflictType2["AddRename"] = 2] = "AddRename";
      GitConflictType2[GitConflictType2["DeleteEdit"] = 3] = "DeleteEdit";
      GitConflictType2[GitConflictType2["DeleteRename"] = 4] = "DeleteRename";
      GitConflictType2[GitConflictType2["DirectoryFile"] = 5] = "DirectoryFile";
      GitConflictType2[GitConflictType2["DirectoryChild"] = 6] = "DirectoryChild";
      GitConflictType2[GitConflictType2["EditDelete"] = 7] = "EditDelete";
      GitConflictType2[GitConflictType2["EditEdit"] = 8] = "EditEdit";
      GitConflictType2[GitConflictType2["FileDirectory"] = 9] = "FileDirectory";
      GitConflictType2[GitConflictType2["Rename1to2"] = 10] = "Rename1to2";
      GitConflictType2[GitConflictType2["Rename2to1"] = 11] = "Rename2to1";
      GitConflictType2[GitConflictType2["RenameAdd"] = 12] = "RenameAdd";
      GitConflictType2[GitConflictType2["RenameDelete"] = 13] = "RenameDelete";
      GitConflictType2[GitConflictType2["RenameRename"] = 14] = "RenameRename";
    })(GitConflictType = exports2.GitConflictType || (exports2.GitConflictType = {}));
    var GitConflictUpdateStatus;
    (function(GitConflictUpdateStatus2) {
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["Succeeded"] = 0] = "Succeeded";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["BadRequest"] = 1] = "BadRequest";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["InvalidResolution"] = 2] = "InvalidResolution";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["UnsupportedConflictType"] = 3] = "UnsupportedConflictType";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["NotFound"] = 4] = "NotFound";
    })(GitConflictUpdateStatus = exports2.GitConflictUpdateStatus || (exports2.GitConflictUpdateStatus = {}));
    var GitHistoryMode;
    (function(GitHistoryMode2) {
      GitHistoryMode2[GitHistoryMode2["SimplifiedHistory"] = 0] = "SimplifiedHistory";
      GitHistoryMode2[GitHistoryMode2["FirstParent"] = 1] = "FirstParent";
      GitHistoryMode2[GitHistoryMode2["FullHistory"] = 2] = "FullHistory";
      GitHistoryMode2[GitHistoryMode2["FullHistorySimplifyMerges"] = 3] = "FullHistorySimplifyMerges";
    })(GitHistoryMode = exports2.GitHistoryMode || (exports2.GitHistoryMode = {}));
    var GitObjectType;
    (function(GitObjectType2) {
      GitObjectType2[GitObjectType2["Bad"] = 0] = "Bad";
      GitObjectType2[GitObjectType2["Commit"] = 1] = "Commit";
      GitObjectType2[GitObjectType2["Tree"] = 2] = "Tree";
      GitObjectType2[GitObjectType2["Blob"] = 3] = "Blob";
      GitObjectType2[GitObjectType2["Tag"] = 4] = "Tag";
      GitObjectType2[GitObjectType2["Ext2"] = 5] = "Ext2";
      GitObjectType2[GitObjectType2["OfsDelta"] = 6] = "OfsDelta";
      GitObjectType2[GitObjectType2["RefDelta"] = 7] = "RefDelta";
    })(GitObjectType = exports2.GitObjectType || (exports2.GitObjectType = {}));
    var GitPathActions;
    (function(GitPathActions2) {
      GitPathActions2[GitPathActions2["None"] = 0] = "None";
      GitPathActions2[GitPathActions2["Edit"] = 1] = "Edit";
      GitPathActions2[GitPathActions2["Delete"] = 2] = "Delete";
      GitPathActions2[GitPathActions2["Add"] = 3] = "Add";
      GitPathActions2[GitPathActions2["Rename"] = 4] = "Rename";
    })(GitPathActions = exports2.GitPathActions || (exports2.GitPathActions = {}));
    var GitPullRequestMergeStrategy;
    (function(GitPullRequestMergeStrategy2) {
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["NoFastForward"] = 1] = "NoFastForward";
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["Squash"] = 2] = "Squash";
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["Rebase"] = 3] = "Rebase";
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["RebaseMerge"] = 4] = "RebaseMerge";
    })(GitPullRequestMergeStrategy = exports2.GitPullRequestMergeStrategy || (exports2.GitPullRequestMergeStrategy = {}));
    var GitPullRequestQueryIncludeOptions;
    (function(GitPullRequestQueryIncludeOptions2) {
      GitPullRequestQueryIncludeOptions2[GitPullRequestQueryIncludeOptions2["NotSet"] = 0] = "NotSet";
      GitPullRequestQueryIncludeOptions2[GitPullRequestQueryIncludeOptions2["Labels"] = 1] = "Labels";
    })(GitPullRequestQueryIncludeOptions = exports2.GitPullRequestQueryIncludeOptions || (exports2.GitPullRequestQueryIncludeOptions = {}));
    var GitPullRequestQueryType;
    (function(GitPullRequestQueryType2) {
      GitPullRequestQueryType2[GitPullRequestQueryType2["NotSet"] = 0] = "NotSet";
      GitPullRequestQueryType2[GitPullRequestQueryType2["LastMergeCommit"] = 1] = "LastMergeCommit";
      GitPullRequestQueryType2[GitPullRequestQueryType2["Commit"] = 2] = "Commit";
    })(GitPullRequestQueryType = exports2.GitPullRequestQueryType || (exports2.GitPullRequestQueryType = {}));
    var GitPullRequestReviewFileType;
    (function(GitPullRequestReviewFileType2) {
      GitPullRequestReviewFileType2[GitPullRequestReviewFileType2["ChangeEntry"] = 0] = "ChangeEntry";
      GitPullRequestReviewFileType2[GitPullRequestReviewFileType2["Attachment"] = 1] = "Attachment";
    })(GitPullRequestReviewFileType = exports2.GitPullRequestReviewFileType || (exports2.GitPullRequestReviewFileType = {}));
    var GitRefSearchType;
    (function(GitRefSearchType2) {
      GitRefSearchType2[GitRefSearchType2["Exact"] = 0] = "Exact";
      GitRefSearchType2[GitRefSearchType2["StartsWith"] = 1] = "StartsWith";
      GitRefSearchType2[GitRefSearchType2["Contains"] = 2] = "Contains";
    })(GitRefSearchType = exports2.GitRefSearchType || (exports2.GitRefSearchType = {}));
    var GitRefUpdateMode;
    (function(GitRefUpdateMode2) {
      GitRefUpdateMode2[GitRefUpdateMode2["BestEffort"] = 0] = "BestEffort";
      GitRefUpdateMode2[GitRefUpdateMode2["AllOrNone"] = 1] = "AllOrNone";
    })(GitRefUpdateMode = exports2.GitRefUpdateMode || (exports2.GitRefUpdateMode = {}));
    var GitRefUpdateStatus;
    (function(GitRefUpdateStatus2) {
      GitRefUpdateStatus2[GitRefUpdateStatus2["Succeeded"] = 0] = "Succeeded";
      GitRefUpdateStatus2[GitRefUpdateStatus2["ForcePushRequired"] = 1] = "ForcePushRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["StaleOldObjectId"] = 2] = "StaleOldObjectId";
      GitRefUpdateStatus2[GitRefUpdateStatus2["InvalidRefName"] = 3] = "InvalidRefName";
      GitRefUpdateStatus2[GitRefUpdateStatus2["Unprocessed"] = 4] = "Unprocessed";
      GitRefUpdateStatus2[GitRefUpdateStatus2["UnresolvableToCommit"] = 5] = "UnresolvableToCommit";
      GitRefUpdateStatus2[GitRefUpdateStatus2["WritePermissionRequired"] = 6] = "WritePermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["ManageNotePermissionRequired"] = 7] = "ManageNotePermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["CreateBranchPermissionRequired"] = 8] = "CreateBranchPermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["CreateTagPermissionRequired"] = 9] = "CreateTagPermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["RejectedByPlugin"] = 10] = "RejectedByPlugin";
      GitRefUpdateStatus2[GitRefUpdateStatus2["Locked"] = 11] = "Locked";
      GitRefUpdateStatus2[GitRefUpdateStatus2["RefNameConflict"] = 12] = "RefNameConflict";
      GitRefUpdateStatus2[GitRefUpdateStatus2["RejectedByPolicy"] = 13] = "RejectedByPolicy";
      GitRefUpdateStatus2[GitRefUpdateStatus2["SucceededNonExistentRef"] = 14] = "SucceededNonExistentRef";
      GitRefUpdateStatus2[GitRefUpdateStatus2["SucceededCorruptRef"] = 15] = "SucceededCorruptRef";
    })(GitRefUpdateStatus = exports2.GitRefUpdateStatus || (exports2.GitRefUpdateStatus = {}));
    var GitResolutionError;
    (function(GitResolutionError2) {
      GitResolutionError2[GitResolutionError2["None"] = 0] = "None";
      GitResolutionError2[GitResolutionError2["MergeContentNotFound"] = 1] = "MergeContentNotFound";
      GitResolutionError2[GitResolutionError2["PathInUse"] = 2] = "PathInUse";
      GitResolutionError2[GitResolutionError2["InvalidPath"] = 3] = "InvalidPath";
      GitResolutionError2[GitResolutionError2["UnknownAction"] = 4] = "UnknownAction";
      GitResolutionError2[GitResolutionError2["UnknownMergeType"] = 5] = "UnknownMergeType";
      GitResolutionError2[GitResolutionError2["OtherError"] = 255] = "OtherError";
    })(GitResolutionError = exports2.GitResolutionError || (exports2.GitResolutionError = {}));
    var GitResolutionMergeType;
    (function(GitResolutionMergeType2) {
      GitResolutionMergeType2[GitResolutionMergeType2["Undecided"] = 0] = "Undecided";
      GitResolutionMergeType2[GitResolutionMergeType2["TakeSourceContent"] = 1] = "TakeSourceContent";
      GitResolutionMergeType2[GitResolutionMergeType2["TakeTargetContent"] = 2] = "TakeTargetContent";
      GitResolutionMergeType2[GitResolutionMergeType2["AutoMerged"] = 3] = "AutoMerged";
      GitResolutionMergeType2[GitResolutionMergeType2["UserMerged"] = 4] = "UserMerged";
    })(GitResolutionMergeType = exports2.GitResolutionMergeType || (exports2.GitResolutionMergeType = {}));
    var GitResolutionPathConflictAction;
    (function(GitResolutionPathConflictAction2) {
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["Undecided"] = 0] = "Undecided";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepSourceRenameTarget"] = 1] = "KeepSourceRenameTarget";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepSourceDeleteTarget"] = 2] = "KeepSourceDeleteTarget";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepTargetRenameSource"] = 3] = "KeepTargetRenameSource";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepTargetDeleteSource"] = 4] = "KeepTargetDeleteSource";
    })(GitResolutionPathConflictAction = exports2.GitResolutionPathConflictAction || (exports2.GitResolutionPathConflictAction = {}));
    var GitResolutionRename1to2Action;
    (function(GitResolutionRename1to2Action2) {
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["Undecided"] = 0] = "Undecided";
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["KeepSourcePath"] = 1] = "KeepSourcePath";
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["KeepTargetPath"] = 2] = "KeepTargetPath";
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["KeepBothFiles"] = 3] = "KeepBothFiles";
    })(GitResolutionRename1to2Action = exports2.GitResolutionRename1to2Action || (exports2.GitResolutionRename1to2Action = {}));
    var GitResolutionStatus;
    (function(GitResolutionStatus2) {
      GitResolutionStatus2[GitResolutionStatus2["Unresolved"] = 0] = "Unresolved";
      GitResolutionStatus2[GitResolutionStatus2["PartiallyResolved"] = 1] = "PartiallyResolved";
      GitResolutionStatus2[GitResolutionStatus2["Resolved"] = 2] = "Resolved";
    })(GitResolutionStatus = exports2.GitResolutionStatus || (exports2.GitResolutionStatus = {}));
    var GitResolutionWhichAction;
    (function(GitResolutionWhichAction2) {
      GitResolutionWhichAction2[GitResolutionWhichAction2["Undecided"] = 0] = "Undecided";
      GitResolutionWhichAction2[GitResolutionWhichAction2["PickSourceAction"] = 1] = "PickSourceAction";
      GitResolutionWhichAction2[GitResolutionWhichAction2["PickTargetAction"] = 2] = "PickTargetAction";
    })(GitResolutionWhichAction = exports2.GitResolutionWhichAction || (exports2.GitResolutionWhichAction = {}));
    var GitStatusState;
    (function(GitStatusState2) {
      GitStatusState2[GitStatusState2["NotSet"] = 0] = "NotSet";
      GitStatusState2[GitStatusState2["Pending"] = 1] = "Pending";
      GitStatusState2[GitStatusState2["Succeeded"] = 2] = "Succeeded";
      GitStatusState2[GitStatusState2["Failed"] = 3] = "Failed";
      GitStatusState2[GitStatusState2["Error"] = 4] = "Error";
      GitStatusState2[GitStatusState2["NotApplicable"] = 5] = "NotApplicable";
      GitStatusState2[GitStatusState2["PartiallySucceeded"] = 6] = "PartiallySucceeded";
    })(GitStatusState = exports2.GitStatusState || (exports2.GitStatusState = {}));
    var GitVersionOptions;
    (function(GitVersionOptions2) {
      GitVersionOptions2[GitVersionOptions2["None"] = 0] = "None";
      GitVersionOptions2[GitVersionOptions2["PreviousChange"] = 1] = "PreviousChange";
      GitVersionOptions2[GitVersionOptions2["FirstParent"] = 2] = "FirstParent";
    })(GitVersionOptions = exports2.GitVersionOptions || (exports2.GitVersionOptions = {}));
    var GitVersionType;
    (function(GitVersionType2) {
      GitVersionType2[GitVersionType2["Branch"] = 0] = "Branch";
      GitVersionType2[GitVersionType2["Tag"] = 1] = "Tag";
      GitVersionType2[GitVersionType2["Commit"] = 2] = "Commit";
    })(GitVersionType = exports2.GitVersionType || (exports2.GitVersionType = {}));
    var ItemContentType;
    (function(ItemContentType2) {
      ItemContentType2[ItemContentType2["RawText"] = 0] = "RawText";
      ItemContentType2[ItemContentType2["Base64Encoded"] = 1] = "Base64Encoded";
    })(ItemContentType = exports2.ItemContentType || (exports2.ItemContentType = {}));
    var IterationReason;
    (function(IterationReason2) {
      IterationReason2[IterationReason2["Push"] = 0] = "Push";
      IterationReason2[IterationReason2["ForcePush"] = 1] = "ForcePush";
      IterationReason2[IterationReason2["Create"] = 2] = "Create";
      IterationReason2[IterationReason2["Rebase"] = 4] = "Rebase";
      IterationReason2[IterationReason2["Unknown"] = 8] = "Unknown";
      IterationReason2[IterationReason2["Retarget"] = 16] = "Retarget";
      IterationReason2[IterationReason2["ResolveConflicts"] = 32] = "ResolveConflicts";
    })(IterationReason = exports2.IterationReason || (exports2.IterationReason = {}));
    var LineDiffBlockChangeType;
    (function(LineDiffBlockChangeType2) {
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["None"] = 0] = "None";
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["Add"] = 1] = "Add";
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["Delete"] = 2] = "Delete";
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["Edit"] = 3] = "Edit";
    })(LineDiffBlockChangeType = exports2.LineDiffBlockChangeType || (exports2.LineDiffBlockChangeType = {}));
    var PullRequestAsyncStatus;
    (function(PullRequestAsyncStatus2) {
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["NotSet"] = 0] = "NotSet";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Queued"] = 1] = "Queued";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Conflicts"] = 2] = "Conflicts";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Succeeded"] = 3] = "Succeeded";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["RejectedByPolicy"] = 4] = "RejectedByPolicy";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Failure"] = 5] = "Failure";
    })(PullRequestAsyncStatus = exports2.PullRequestAsyncStatus || (exports2.PullRequestAsyncStatus = {}));
    var PullRequestMergeFailureType;
    (function(PullRequestMergeFailureType2) {
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["None"] = 0] = "None";
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["Unknown"] = 1] = "Unknown";
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["CaseSensitive"] = 2] = "CaseSensitive";
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["ObjectTooLarge"] = 3] = "ObjectTooLarge";
    })(PullRequestMergeFailureType = exports2.PullRequestMergeFailureType || (exports2.PullRequestMergeFailureType = {}));
    var PullRequestStatus;
    (function(PullRequestStatus2) {
      PullRequestStatus2[PullRequestStatus2["NotSet"] = 0] = "NotSet";
      PullRequestStatus2[PullRequestStatus2["Active"] = 1] = "Active";
      PullRequestStatus2[PullRequestStatus2["Abandoned"] = 2] = "Abandoned";
      PullRequestStatus2[PullRequestStatus2["Completed"] = 3] = "Completed";
      PullRequestStatus2[PullRequestStatus2["All"] = 4] = "All";
    })(PullRequestStatus = exports2.PullRequestStatus || (exports2.PullRequestStatus = {}));
    var PullRequestTimeRangeType;
    (function(PullRequestTimeRangeType2) {
      PullRequestTimeRangeType2[PullRequestTimeRangeType2["Created"] = 1] = "Created";
      PullRequestTimeRangeType2[PullRequestTimeRangeType2["Closed"] = 2] = "Closed";
    })(PullRequestTimeRangeType = exports2.PullRequestTimeRangeType || (exports2.PullRequestTimeRangeType = {}));
    var RefFavoriteType;
    (function(RefFavoriteType2) {
      RefFavoriteType2[RefFavoriteType2["Invalid"] = 0] = "Invalid";
      RefFavoriteType2[RefFavoriteType2["Folder"] = 1] = "Folder";
      RefFavoriteType2[RefFavoriteType2["Ref"] = 2] = "Ref";
    })(RefFavoriteType = exports2.RefFavoriteType || (exports2.RefFavoriteType = {}));
    var SupportedIdeType;
    (function(SupportedIdeType2) {
      SupportedIdeType2[SupportedIdeType2["Unknown"] = 0] = "Unknown";
      SupportedIdeType2[SupportedIdeType2["AndroidStudio"] = 1] = "AndroidStudio";
      SupportedIdeType2[SupportedIdeType2["AppCode"] = 2] = "AppCode";
      SupportedIdeType2[SupportedIdeType2["CLion"] = 3] = "CLion";
      SupportedIdeType2[SupportedIdeType2["DataGrip"] = 4] = "DataGrip";
      SupportedIdeType2[SupportedIdeType2["Eclipse"] = 13] = "Eclipse";
      SupportedIdeType2[SupportedIdeType2["IntelliJ"] = 5] = "IntelliJ";
      SupportedIdeType2[SupportedIdeType2["MPS"] = 6] = "MPS";
      SupportedIdeType2[SupportedIdeType2["PhpStorm"] = 7] = "PhpStorm";
      SupportedIdeType2[SupportedIdeType2["PyCharm"] = 8] = "PyCharm";
      SupportedIdeType2[SupportedIdeType2["RubyMine"] = 9] = "RubyMine";
      SupportedIdeType2[SupportedIdeType2["Tower"] = 10] = "Tower";
      SupportedIdeType2[SupportedIdeType2["VisualStudio"] = 11] = "VisualStudio";
      SupportedIdeType2[SupportedIdeType2["VSCode"] = 14] = "VSCode";
      SupportedIdeType2[SupportedIdeType2["WebStorm"] = 12] = "WebStorm";
    })(SupportedIdeType = exports2.SupportedIdeType || (exports2.SupportedIdeType = {}));
    var TfvcVersionOption;
    (function(TfvcVersionOption2) {
      TfvcVersionOption2[TfvcVersionOption2["None"] = 0] = "None";
      TfvcVersionOption2[TfvcVersionOption2["Previous"] = 1] = "Previous";
      TfvcVersionOption2[TfvcVersionOption2["UseRename"] = 2] = "UseRename";
    })(TfvcVersionOption = exports2.TfvcVersionOption || (exports2.TfvcVersionOption = {}));
    var TfvcVersionType;
    (function(TfvcVersionType2) {
      TfvcVersionType2[TfvcVersionType2["None"] = 0] = "None";
      TfvcVersionType2[TfvcVersionType2["Changeset"] = 1] = "Changeset";
      TfvcVersionType2[TfvcVersionType2["Shelveset"] = 2] = "Shelveset";
      TfvcVersionType2[TfvcVersionType2["Change"] = 3] = "Change";
      TfvcVersionType2[TfvcVersionType2["Date"] = 4] = "Date";
      TfvcVersionType2[TfvcVersionType2["Latest"] = 5] = "Latest";
      TfvcVersionType2[TfvcVersionType2["Tip"] = 6] = "Tip";
      TfvcVersionType2[TfvcVersionType2["MergeSource"] = 7] = "MergeSource";
    })(TfvcVersionType = exports2.TfvcVersionType || (exports2.TfvcVersionType = {}));
    var VersionControlChangeType;
    (function(VersionControlChangeType2) {
      VersionControlChangeType2[VersionControlChangeType2["None"] = 0] = "None";
      VersionControlChangeType2[VersionControlChangeType2["Add"] = 1] = "Add";
      VersionControlChangeType2[VersionControlChangeType2["Edit"] = 2] = "Edit";
      VersionControlChangeType2[VersionControlChangeType2["Encoding"] = 4] = "Encoding";
      VersionControlChangeType2[VersionControlChangeType2["Rename"] = 8] = "Rename";
      VersionControlChangeType2[VersionControlChangeType2["Delete"] = 16] = "Delete";
      VersionControlChangeType2[VersionControlChangeType2["Undelete"] = 32] = "Undelete";
      VersionControlChangeType2[VersionControlChangeType2["Branch"] = 64] = "Branch";
      VersionControlChangeType2[VersionControlChangeType2["Merge"] = 128] = "Merge";
      VersionControlChangeType2[VersionControlChangeType2["Lock"] = 256] = "Lock";
      VersionControlChangeType2[VersionControlChangeType2["Rollback"] = 512] = "Rollback";
      VersionControlChangeType2[VersionControlChangeType2["SourceRename"] = 1024] = "SourceRename";
      VersionControlChangeType2[VersionControlChangeType2["TargetRename"] = 2048] = "TargetRename";
      VersionControlChangeType2[VersionControlChangeType2["Property"] = 4096] = "Property";
      VersionControlChangeType2[VersionControlChangeType2["All"] = 8191] = "All";
    })(VersionControlChangeType = exports2.VersionControlChangeType || (exports2.VersionControlChangeType = {}));
    var VersionControlRecursionType;
    (function(VersionControlRecursionType2) {
      VersionControlRecursionType2[VersionControlRecursionType2["None"] = 0] = "None";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevel"] = 1] = "OneLevel";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevelPlusNestedEmptyFolders"] = 4] = "OneLevelPlusNestedEmptyFolders";
      VersionControlRecursionType2[VersionControlRecursionType2["Full"] = 120] = "Full";
    })(VersionControlRecursionType = exports2.VersionControlRecursionType || (exports2.VersionControlRecursionType = {}));
    exports2.TypeInfo = {
      AdvSecEnablementStatus: {},
      Attachment: {},
      BillableCommitterDetail: {},
      Change: {},
      ChangeList: {},
      Comment: {},
      CommentThread: {},
      CommentThreadStatus: {
        enumValues: {
          "unknown": 0,
          "active": 1,
          "fixed": 2,
          "wontFix": 3,
          "closed": 4,
          "byDesign": 5,
          "pending": 6
        }
      },
      CommentType: {
        enumValues: {
          "unknown": 0,
          "text": 1,
          "codeChange": 2,
          "system": 3
        }
      },
      FileDiff: {},
      GitAnnotatedTag: {},
      GitAsyncOperationStatus: {
        enumValues: {
          "queued": 1,
          "inProgress": 2,
          "completed": 3,
          "failed": 4,
          "abandoned": 5
        }
      },
      GitAsyncRefOperation: {},
      GitAsyncRefOperationDetail: {},
      GitAsyncRefOperationFailureStatus: {
        enumValues: {
          "none": 0,
          "invalidRefName": 1,
          "refNameConflict": 2,
          "createBranchPermissionRequired": 3,
          "writePermissionRequired": 4,
          "targetBranchDeleted": 5,
          "gitObjectTooLarge": 6,
          "operationIndentityNotFound": 7,
          "asyncOperationNotFound": 8,
          "other": 9,
          "emptyCommitterSignature": 10
        }
      },
      GitAsyncRefOperationParameters: {},
      GitAsyncRefOperationSource: {},
      GitBaseVersionDescriptor: {},
      GitBranchStats: {},
      GitChange: {},
      GitCherryPick: {},
      GitCommit: {},
      GitCommitChanges: {},
      GitCommitDiffs: {},
      GitCommitRef: {},
      GitCommitToCreate: {},
      GitConflict: {},
      GitConflictAddAdd: {},
      GitConflictAddRename: {},
      GitConflictDeleteEdit: {},
      GitConflictDeleteRename: {},
      GitConflictDirectoryFile: {},
      GitConflictEditDelete: {},
      GitConflictEditEdit: {},
      GitConflictFileDirectory: {},
      GitConflictRename1to2: {},
      GitConflictRename2to1: {},
      GitConflictRenameAdd: {},
      GitConflictRenameDelete: {},
      GitConflictRenameRename: {},
      GitConflictType: {
        enumValues: {
          "none": 0,
          "addAdd": 1,
          "addRename": 2,
          "deleteEdit": 3,
          "deleteRename": 4,
          "directoryFile": 5,
          "directoryChild": 6,
          "editDelete": 7,
          "editEdit": 8,
          "fileDirectory": 9,
          "rename1to2": 10,
          "rename2to1": 11,
          "renameAdd": 12,
          "renameDelete": 13,
          "renameRename": 14
        }
      },
      GitConflictUpdateResult: {},
      GitConflictUpdateStatus: {
        enumValues: {
          "succeeded": 0,
          "badRequest": 1,
          "invalidResolution": 2,
          "unsupportedConflictType": 3,
          "notFound": 4
        }
      },
      GitDeletedRepository: {},
      GitForkRef: {},
      GitForkSyncRequest: {},
      GitForkTeamProjectReference: {},
      GitHistoryMode: {
        enumValues: {
          "simplifiedHistory": 0,
          "firstParent": 1,
          "fullHistory": 2,
          "fullHistorySimplifyMerges": 3
        }
      },
      GitImportFailedEvent: {},
      GitImportRequest: {},
      GitImportSucceededEvent: {},
      GitItem: {},
      GitItemDescriptor: {},
      GitItemRequestData: {},
      GitLastChangeTreeItems: {},
      GitMerge: {},
      GitObject: {},
      GitObjectType: {
        enumValues: {
          "bad": 0,
          "commit": 1,
          "tree": 2,
          "blob": 3,
          "tag": 4,
          "ext2": 5,
          "ofsDelta": 6,
          "refDelta": 7
        }
      },
      GitPathAction: {},
      GitPathActions: {
        enumValues: {
          "none": 0,
          "edit": 1,
          "delete": 2,
          "add": 3,
          "rename": 4
        }
      },
      GitPathToItemsCollection: {},
      GitPolicyConfigurationResponse: {},
      GitPullRequest: {},
      GitPullRequestChange: {},
      GitPullRequestCommentThread: {},
      GitPullRequestCompletionOptions: {},
      GitPullRequestIteration: {},
      GitPullRequestIterationChanges: {},
      GitPullRequestMergeStrategy: {
        enumValues: {
          "noFastForward": 1,
          "squash": 2,
          "rebase": 3,
          "rebaseMerge": 4
        }
      },
      GitPullRequestQuery: {},
      GitPullRequestQueryIncludeOptions: {
        enumValues: {
          "notSet": 0,
          "labels": 1
        }
      },
      GitPullRequestQueryInput: {},
      GitPullRequestQueryType: {
        enumValues: {
          "notSet": 0,
          "lastMergeCommit": 1,
          "commit": 2
        }
      },
      GitPullRequestReviewFileType: {
        enumValues: {
          "changeEntry": 0,
          "attachment": 1
        }
      },
      GitPullRequestSearchCriteria: {},
      GitPullRequestStatus: {},
      GitPush: {},
      GitPushEventData: {},
      GitPushRef: {},
      GitPushSearchCriteria: {},
      GitQueryBranchStatsCriteria: {},
      GitQueryCommitsCriteria: {},
      GitQueryRefsCriteria: {},
      GitRef: {},
      GitRefFavorite: {},
      GitRefSearchType: {
        enumValues: {
          "exact": 0,
          "startsWith": 1,
          "contains": 2
        }
      },
      GitRefUpdateMode: {
        enumValues: {
          "bestEffort": 0,
          "allOrNone": 1
        }
      },
      GitRefUpdateResult: {},
      GitRefUpdateStatus: {
        enumValues: {
          "succeeded": 0,
          "forcePushRequired": 1,
          "staleOldObjectId": 2,
          "invalidRefName": 3,
          "unprocessed": 4,
          "unresolvableToCommit": 5,
          "writePermissionRequired": 6,
          "manageNotePermissionRequired": 7,
          "createBranchPermissionRequired": 8,
          "createTagPermissionRequired": 9,
          "rejectedByPlugin": 10,
          "locked": 11,
          "refNameConflict": 12,
          "rejectedByPolicy": 13,
          "succeededNonExistentRef": 14,
          "succeededCorruptRef": 15
        }
      },
      GitRepository: {},
      GitRepositoryCreateOptions: {},
      GitRepositoryRef: {},
      GitResolutionError: {
        enumValues: {
          "none": 0,
          "mergeContentNotFound": 1,
          "pathInUse": 2,
          "invalidPath": 3,
          "unknownAction": 4,
          "unknownMergeType": 5,
          "otherError": 255
        }
      },
      GitResolutionMergeContent: {},
      GitResolutionMergeType: {
        enumValues: {
          "undecided": 0,
          "takeSourceContent": 1,
          "takeTargetContent": 2,
          "autoMerged": 3,
          "userMerged": 4
        }
      },
      GitResolutionPathConflict: {},
      GitResolutionPathConflictAction: {
        enumValues: {
          "undecided": 0,
          "keepSourceRenameTarget": 1,
          "keepSourceDeleteTarget": 2,
          "keepTargetRenameSource": 3,
          "keepTargetDeleteSource": 4
        }
      },
      GitResolutionPickOneAction: {},
      GitResolutionRename1to2: {},
      GitResolutionRename1to2Action: {
        enumValues: {
          "undecided": 0,
          "keepSourcePath": 1,
          "keepTargetPath": 2,
          "keepBothFiles": 3
        }
      },
      GitResolutionStatus: {
        enumValues: {
          "unresolved": 0,
          "partiallyResolved": 1,
          "resolved": 2
        }
      },
      GitResolutionWhichAction: {
        enumValues: {
          "undecided": 0,
          "pickSourceAction": 1,
          "pickTargetAction": 2
        }
      },
      GitRevert: {},
      GitStatus: {},
      GitStatusState: {
        enumValues: {
          "notSet": 0,
          "pending": 1,
          "succeeded": 2,
          "failed": 3,
          "error": 4,
          "notApplicable": 5,
          "partiallySucceeded": 6
        }
      },
      GitTargetVersionDescriptor: {},
      GitTreeDiff: {},
      GitTreeDiffEntry: {},
      GitTreeDiffResponse: {},
      GitTreeEntryRef: {},
      GitTreeRef: {},
      GitUserDate: {},
      GitVersionDescriptor: {},
      GitVersionOptions: {
        enumValues: {
          "none": 0,
          "previousChange": 1,
          "firstParent": 2
        }
      },
      GitVersionType: {
        enumValues: {
          "branch": 0,
          "tag": 1,
          "commit": 2
        }
      },
      HistoryEntry: {},
      IncludedGitCommit: {},
      ItemContent: {},
      ItemContentType: {
        enumValues: {
          "rawText": 0,
          "base64Encoded": 1
        }
      },
      ItemDetailsOptions: {},
      IterationReason: {
        enumValues: {
          "push": 0,
          "forcePush": 1,
          "create": 2,
          "rebase": 4,
          "unknown": 8,
          "retarget": 16,
          "resolveConflicts": 32
        }
      },
      LineDiffBlock: {},
      LineDiffBlockChangeType: {
        enumValues: {
          "none": 0,
          "add": 1,
          "delete": 2,
          "edit": 3
        }
      },
      PullRequestAsyncStatus: {
        enumValues: {
          "notSet": 0,
          "queued": 1,
          "conflicts": 2,
          "succeeded": 3,
          "rejectedByPolicy": 4,
          "failure": 5
        }
      },
      PullRequestMergeFailureType: {
        enumValues: {
          "none": 0,
          "unknown": 1,
          "caseSensitive": 2,
          "objectTooLarge": 3
        }
      },
      PullRequestStatus: {
        enumValues: {
          "notSet": 0,
          "active": 1,
          "abandoned": 2,
          "completed": 3,
          "all": 4
        }
      },
      PullRequestTimeRangeType: {
        enumValues: {
          "created": 1,
          "closed": 2
        }
      },
      RefFavoriteType: {
        enumValues: {
          "invalid": 0,
          "folder": 1,
          "ref": 2
        }
      },
      SupportedIde: {},
      SupportedIdeType: {
        enumValues: {
          "unknown": 0,
          "androidStudio": 1,
          "appCode": 2,
          "cLion": 3,
          "dataGrip": 4,
          "eclipse": 13,
          "intelliJ": 5,
          "mps": 6,
          "phpStorm": 7,
          "pyCharm": 8,
          "rubyMine": 9,
          "tower": 10,
          "visualStudio": 11,
          "vsCode": 14,
          "webStorm": 12
        }
      },
      TfvcBranch: {},
      TfvcBranchRef: {},
      TfvcChange: {},
      TfvcChangeset: {},
      TfvcChangesetRef: {},
      TfvcCheckinEventData: {},
      TfvcHistoryEntry: {},
      TfvcItem: {},
      TfvcItemDescriptor: {},
      TfvcItemPreviousHash: {},
      TfvcItemRequestData: {},
      TfvcLabel: {},
      TfvcLabelRef: {},
      TfvcShelveset: {},
      TfvcShelvesetRef: {},
      TfvcVersionDescriptor: {},
      TfvcVersionOption: {
        enumValues: {
          "none": 0,
          "previous": 1,
          "useRename": 2
        }
      },
      TfvcVersionType: {
        enumValues: {
          "none": 0,
          "changeset": 1,
          "shelveset": 2,
          "change": 3,
          "date": 4,
          "latest": 5,
          "tip": 6,
          "mergeSource": 7
        }
      },
      UpdateRefsRequest: {},
      VersionControlChangeType: {
        enumValues: {
          "none": 0,
          "add": 1,
          "edit": 2,
          "encoding": 4,
          "rename": 8,
          "delete": 16,
          "undelete": 32,
          "branch": 64,
          "merge": 128,
          "lock": 256,
          "rollback": 512,
          "sourceRename": 1024,
          "targetRename": 2048,
          "property": 4096,
          "all": 8191
        }
      },
      VersionControlProjectInfo: {},
      VersionControlRecursionType: {
        enumValues: {
          "none": 0,
          "oneLevel": 1,
          "oneLevelPlusNestedEmptyFolders": 4,
          "full": 120
        }
      }
    };
    exports2.TypeInfo.AdvSecEnablementStatus.fields = {
      changedOnDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Attachment.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BillableCommitterDetail.fields = {
      commitTime: {
        isDate: true
      },
      pushedTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.Change.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.ChangeList.fields = {
      changeCounts: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.VersionControlChangeType
      },
      creationDate: {
        isDate: true
      },
      sortDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Comment.fields = {
      commentType: {
        enumType: exports2.TypeInfo.CommentType
      },
      lastContentUpdatedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CommentThread.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      },
      lastUpdatedDate: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.CommentThreadStatus
      }
    };
    exports2.TypeInfo.FileDiff.fields = {
      lineDiffBlocks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LineDiffBlock
      }
    };
    exports2.TypeInfo.GitAnnotatedTag.fields = {
      taggedBy: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      taggedObject: {
        typeInfo: exports2.TypeInfo.GitObject
      }
    };
    exports2.TypeInfo.GitAsyncRefOperation.fields = {
      detailedStatus: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationDetail
      },
      parameters: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationParameters
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitAsyncRefOperationDetail.fields = {
      status: {
        enumType: exports2.TypeInfo.GitAsyncRefOperationFailureStatus
      }
    };
    exports2.TypeInfo.GitAsyncRefOperationParameters.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      source: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationSource
      }
    };
    exports2.TypeInfo.GitAsyncRefOperationSource.fields = {
      commitList: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      }
    };
    exports2.TypeInfo.GitBaseVersionDescriptor.fields = {
      baseVersionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      baseVersionType: {
        enumType: exports2.TypeInfo.GitVersionType
      },
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.GitBranchStats.fields = {
      commit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      }
    };
    exports2.TypeInfo.GitChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.GitCherryPick.fields = {
      detailedStatus: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationDetail
      },
      parameters: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationParameters
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitCommit.fields = {
      author: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      },
      committer: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      push: {
        typeInfo: exports2.TypeInfo.GitPushRef
      },
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitCommitChanges.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      }
    };
    exports2.TypeInfo.GitCommitDiffs.fields = {
      changeCounts: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.VersionControlChangeType
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      }
    };
    exports2.TypeInfo.GitCommitRef.fields = {
      author: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      },
      committer: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      push: {
        typeInfo: exports2.TypeInfo.GitPushRef
      },
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitCommitToCreate.fields = {
      baseRef: {
        typeInfo: exports2.TypeInfo.GitRef
      },
      pathActions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPathAction
      }
    };
    exports2.TypeInfo.GitConflict.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictAddAdd.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionMergeContent
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictAddRename.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictDeleteEdit.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictDeleteRename.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictDirectoryFile.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      },
      sourceTree: {
        typeInfo: exports2.TypeInfo.GitTreeRef
      }
    };
    exports2.TypeInfo.GitConflictEditDelete.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictEditEdit.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionMergeContent
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictFileDirectory.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      },
      targetTree: {
        typeInfo: exports2.TypeInfo.GitTreeRef
      }
    };
    exports2.TypeInfo.GitConflictRename1to2.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionRename1to2
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRename2to1.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRenameAdd.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRenameDelete.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRenameRename.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionMergeContent
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictUpdateResult.fields = {
      updatedConflict: {
        typeInfo: exports2.TypeInfo.GitConflict
      },
      updateStatus: {
        enumType: exports2.TypeInfo.GitConflictUpdateStatus
      }
    };
    exports2.TypeInfo.GitDeletedRepository.fields = {
      createdDate: {
        isDate: true
      },
      deletedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitForkRef.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitForkSyncRequest.fields = {
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitForkTeamProjectReference.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: TfsCoreInterfaces.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.GitImportFailedEvent.fields = {
      targetRepository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitImportRequest.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitImportSucceededEvent.fields = {
      targetRepository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitItem.fields = {
      gitObjectType: {
        enumType: exports2.TypeInfo.GitObjectType
      },
      latestProcessedChange: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      }
    };
    exports2.TypeInfo.GitItemDescriptor.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      },
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.GitItemRequestData.fields = {
      itemDescriptors: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitItemDescriptor
      }
    };
    exports2.TypeInfo.GitLastChangeTreeItems.fields = {
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      lastExploredTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitMerge.fields = {
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitObject.fields = {
      objectType: {
        enumType: exports2.TypeInfo.GitObjectType
      }
    };
    exports2.TypeInfo.GitPathAction.fields = {
      action: {
        enumType: exports2.TypeInfo.GitPathActions
      }
    };
    exports2.TypeInfo.GitPathToItemsCollection.fields = {
      items: {
        isDictionary: true,
        dictionaryValueFieldInfo: {
          isArray: true,
          typeInfo: exports2.TypeInfo.GitItem
        }
      }
    };
    exports2.TypeInfo.GitPolicyConfigurationResponse.fields = {
      policyConfigurations: {
        isArray: true,
        typeInfo: PolicyInterfaces.TypeInfo.PolicyConfiguration
      }
    };
    exports2.TypeInfo.GitPullRequest.fields = {
      closedDate: {
        isDate: true
      },
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      completionOptions: {
        typeInfo: exports2.TypeInfo.GitPullRequestCompletionOptions
      },
      completionQueueTime: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      forkSource: {
        typeInfo: exports2.TypeInfo.GitForkRef
      },
      lastMergeCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      lastMergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      lastMergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeFailureType: {
        enumType: exports2.TypeInfo.PullRequestMergeFailureType
      },
      mergeStatus: {
        enumType: exports2.TypeInfo.PullRequestAsyncStatus
      },
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      status: {
        enumType: exports2.TypeInfo.PullRequestStatus
      }
    };
    exports2.TypeInfo.GitPullRequestChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.GitPullRequestCommentThread.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      },
      lastUpdatedDate: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.CommentThreadStatus
      }
    };
    exports2.TypeInfo.GitPullRequestCompletionOptions.fields = {
      mergeStrategy: {
        enumType: exports2.TypeInfo.GitPullRequestMergeStrategy
      }
    };
    exports2.TypeInfo.GitPullRequestIteration.fields = {
      changeList: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPullRequestChange
      },
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      commonRefCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      createdDate: {
        isDate: true
      },
      push: {
        typeInfo: exports2.TypeInfo.GitPushRef
      },
      reason: {
        enumType: exports2.TypeInfo.IterationReason
      },
      sourceRefCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      targetRefCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitPullRequestIterationChanges.fields = {
      changeEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPullRequestChange
      }
    };
    exports2.TypeInfo.GitPullRequestQuery.fields = {
      queries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPullRequestQueryInput
      }
    };
    exports2.TypeInfo.GitPullRequestQueryInput.fields = {
      include: {
        enumType: exports2.TypeInfo.GitPullRequestQueryIncludeOptions
      },
      type: {
        enumType: exports2.TypeInfo.GitPullRequestQueryType
      }
    };
    exports2.TypeInfo.GitPullRequestSearchCriteria.fields = {
      maxTime: {
        isDate: true
      },
      minTime: {
        isDate: true
      },
      queryTimeRangeType: {
        enumType: exports2.TypeInfo.PullRequestTimeRangeType
      },
      status: {
        enumType: exports2.TypeInfo.PullRequestStatus
      }
    };
    exports2.TypeInfo.GitPullRequestStatus.fields = {
      creationDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.GitStatusState
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitPush.fields = {
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      date: {
        isDate: true
      },
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitPushEventData.fields = {
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommit
      },
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitPushRef.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitPushSearchCriteria.fields = {
      fromDate: {
        isDate: true
      },
      toDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitQueryBranchStatsCriteria.fields = {
      baseCommit: {
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      },
      targetCommits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.GitQueryCommitsCriteria.fields = {
      compareVersion: {
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      },
      historyMode: {
        enumType: exports2.TypeInfo.GitHistoryMode
      },
      itemVersion: {
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.GitQueryRefsCriteria.fields = {
      searchType: {
        enumType: exports2.TypeInfo.GitRefSearchType
      }
    };
    exports2.TypeInfo.GitRef.fields = {
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitRefFavorite.fields = {
      type: {
        enumType: exports2.TypeInfo.RefFavoriteType
      }
    };
    exports2.TypeInfo.GitRefUpdateResult.fields = {
      updateStatus: {
        enumType: exports2.TypeInfo.GitRefUpdateStatus
      }
    };
    exports2.TypeInfo.GitRepository.fields = {
      creationDate: {
        isDate: true
      },
      parentRepository: {
        typeInfo: exports2.TypeInfo.GitRepositoryRef
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitRepositoryCreateOptions.fields = {
      parentRepository: {
        typeInfo: exports2.TypeInfo.GitRepositoryRef
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitRepositoryRef.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitResolutionMergeContent.fields = {
      mergeType: {
        enumType: exports2.TypeInfo.GitResolutionMergeType
      }
    };
    exports2.TypeInfo.GitResolutionPathConflict.fields = {
      action: {
        enumType: exports2.TypeInfo.GitResolutionPathConflictAction
      }
    };
    exports2.TypeInfo.GitResolutionPickOneAction.fields = {
      action: {
        enumType: exports2.TypeInfo.GitResolutionWhichAction
      }
    };
    exports2.TypeInfo.GitResolutionRename1to2.fields = {
      action: {
        enumType: exports2.TypeInfo.GitResolutionRename1to2Action
      },
      mergeType: {
        enumType: exports2.TypeInfo.GitResolutionMergeType
      }
    };
    exports2.TypeInfo.GitRevert.fields = {
      detailedStatus: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationDetail
      },
      parameters: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationParameters
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitStatus.fields = {
      creationDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.GitStatusState
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitTargetVersionDescriptor.fields = {
      targetVersionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      targetVersionType: {
        enumType: exports2.TypeInfo.GitVersionType
      },
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.GitTreeDiff.fields = {
      diffEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitTreeDiffEntry
      }
    };
    exports2.TypeInfo.GitTreeDiffEntry.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      objectType: {
        enumType: exports2.TypeInfo.GitObjectType
      }
    };
    exports2.TypeInfo.GitTreeDiffResponse.fields = {
      treeDiff: {
        typeInfo: exports2.TypeInfo.GitTreeDiff
      }
    };
    exports2.TypeInfo.GitTreeEntryRef.fields = {
      gitObjectType: {
        enumType: exports2.TypeInfo.GitObjectType
      }
    };
    exports2.TypeInfo.GitTreeRef.fields = {
      treeEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitTreeEntryRef
      }
    };
    exports2.TypeInfo.GitUserDate.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitVersionDescriptor.fields = {
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.HistoryEntry.fields = {
      itemChangeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      }
    };
    exports2.TypeInfo.IncludedGitCommit.fields = {
      commitTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.ItemContent.fields = {
      contentType: {
        enumType: exports2.TypeInfo.ItemContentType
      }
    };
    exports2.TypeInfo.ItemDetailsOptions.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      }
    };
    exports2.TypeInfo.LineDiffBlock.fields = {
      changeType: {
        enumType: exports2.TypeInfo.LineDiffBlockChangeType
      }
    };
    exports2.TypeInfo.SupportedIde.fields = {
      ideType: {
        enumType: exports2.TypeInfo.SupportedIdeType
      }
    };
    exports2.TypeInfo.TfvcBranch.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcBranch
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcBranchRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.TfvcChangeset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChangesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcCheckinEventData.fields = {
      changeset: {
        typeInfo: exports2.TypeInfo.TfvcChangeset
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.TfvcHistoryEntry.fields = {
      itemChangeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      }
    };
    exports2.TypeInfo.TfvcItem.fields = {
      changeDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItemDescriptor.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      },
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.TfvcItemPreviousHash.fields = {
      changeDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItemRequestData.fields = {
      itemDescriptors: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItemDescriptor
      }
    };
    exports2.TypeInfo.TfvcLabel.fields = {
      items: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItem
      },
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcLabelRef.fields = {
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelveset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelvesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcVersionDescriptor.fields = {
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.UpdateRefsRequest.fields = {
      updateMode: {
        enumType: exports2.TypeInfo.GitRefUpdateMode
      }
    };
    exports2.TypeInfo.VersionControlProjectInfo.fields = {
      defaultSourceControlType: {
        enumType: TfsCoreInterfaces.TypeInfo.SourceControlTypes
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/GitApi.js
var require_GitApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/GitApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitApi = void 0;
    var basem = require_ClientApiBases();
    var GitInterfaces = require_GitInterfaces();
    var GitApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Git-api", options2);
      }
      /**
       * DELETE Deletes Enablement status and BillableCommitters data from DB. Deleting the enablement data will effectively disable it for the repositories affected.
       *
       * @param {boolean} allProjects
       * @param {boolean} includeBillableCommitters
       * @param {string[]} projectIds
       */
      deleteEnablementStatus(allProjects, includeBillableCommitters, projectIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (allProjects == null) {
            throw new TypeError("allProjects can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$allProjects": allProjects,
              "$includeBillableCommitters": includeBillableCommitters,
              projectIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET Enablement status for project's repositories.
       *
       * @param {string[]} projectIds - Null defaults to all projects in the host, list of project's repos status to return
       * @param {Date} billingDate - UTC expected, Null defaults to UtcNow(), can be provided for a point in time status
       * @param {number} skip - Skip X rows of resultset to simulate paging.
       * @param {number} take - Return Y rows of resultset to simulate paging.
       */
      getEnablementStatus(projectIds, billingDate, skip, take) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              projectIds,
              "$billingDate": billingDate,
              "$skip": skip,
              "$take": take
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.AdvSecEnablementStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {boolean} enableOnCreateHost
       */
      getEnableOnCreateHost(enableOnCreateHost) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (enableOnCreateHost == null) {
            throw new TypeError("enableOnCreateHost can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateHost": enableOnCreateHost
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} enableOnCreateProjectId
       */
      getEnableOnCreateProject(enableOnCreateProjectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (enableOnCreateProjectId == null) {
            throw new TypeError("enableOnCreateProjectId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateProjectId": enableOnCreateProjectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {boolean} enableOnCreateHost
       */
      setEnableOnCreateHost(enableOnCreateHost) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (enableOnCreateHost == null) {
            throw new TypeError("enableOnCreateHost can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateHost": enableOnCreateHost
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} enableOnCreateProjectId
       * @param {boolean} enableOnStatus
       */
      setEnableOnCreateProject(enableOnCreateProjectId, enableOnStatus) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (enableOnCreateProjectId == null) {
            throw new TypeError("enableOnCreateProjectId can not be null or undefined");
          }
          if (enableOnStatus == null) {
            throw new TypeError("enableOnStatus can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateProjectId": enableOnCreateProjectId,
              "$enableOnStatus": enableOnStatus
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * POST Enablement status for repositories.
       *
       * @param {GitInterfaces.AdvSecEnablementUpdate[]} enablementUpdates
       */
      updateEnablementStatus(enablementUpdates) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, enablementUpdates, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get estimated billable pushers for an Organization for last 90 days.
       *
       */
      getEstimatedBillablePushersOrg() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "2277ffbe-28d4-40d6-9c26-40baf26d1408", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get estimated billable pushers for a project for last 90 days.
       *
       * @param {string} project - Project ID or project name
       */
      getEstimatedBillablePushersProject(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1df7833e-1eed-447b-81a3-390c74923900", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get estimated billable committers for a repository for the last 90 days.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId
       */
      getEstimatedBillableCommittersRepo(project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5dcec07b-a844-4efb-9fc1-968fd1f149db", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET Advanced Security Permission status.
       *
       * @param {string} projectName
       * @param {string} repositoryId - Repository user is trying to access
       * @param {string} permission - Permission being requestd, must be "viewAlert" "dismissAlert" "manage" "viewEnablement" or "repoRead"
       */
      getPermission(projectName, repositoryId, permission) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$projectName": projectName,
              "$repositoryId": repositoryId,
              "$permission": permission
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "61b21a05-a60f-4910-a733-ba5347c2142d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an annotated tag.
       *
       * @param {GitInterfaces.GitAnnotatedTag} tagObject - Object containing details of tag to be created.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID or name of the repository.
       */
      createAnnotatedTag(tagObject, project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5e8a8081-3851-4626-b677-9891cc04102e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tagObject, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitAnnotatedTag, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an annotated tag.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID or name of the repository.
       * @param {string} objectId - ObjectId (Sha1Id) of tag to get.
       */
      getAnnotatedTag(project, repositoryId, objectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              objectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5e8a8081-3851-4626-b677-9891cc04102e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitAnnotatedTag, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve actual billable committers for Advanced Security service for a given date.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} billingDate - UTC expected.  If not specified defaults to the previous billing day.
       * @param {number} skip - Skip X rows of resultset to simulate paging.
       * @param {number} take - Return Y rows of resultset to simulate paging.
       */
      getBillableCommitters(project, billingDate, skip, take) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$billingDate": billingDate,
              "$skip": skip,
              "$take": take
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5c5e3ebc-37b0-4547-a957-945912d44922", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve detailed actual billable committers for Advanced Security service for a given date. Detailed results intentionally does not filter out soft deleted projects and repositories to help diagnose billing issues.
       *
       * @param {string} project - Project ID or project name
       * @param {string} includeDetails - Return all the details on the billable committers.
       * @param {Date} billingDate - UTC expected. If not specified defaults to the previous billing day.
       */
      getBillableCommittersDetail(project, includeDetails, billingDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (includeDetails == null) {
            throw new TypeError("includeDetails can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$includeDetails": includeDetails,
              "$billingDate": billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5c5e3ebc-37b0-4547-a957-945912d44922", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.BillableCommitterDetail, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single blob.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} sha1 - SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip
       * @param {string} fileName - Provide a fileName to use for a download.
       * @param {boolean} resolveLfs - If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types
       */
      getBlob(repositoryId, sha12, project, download, fileName, resolveLfs) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1: sha12
            };
            let queryValues = {
              download,
              fileName,
              resolveLfs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single blob.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} sha1 - SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip
       * @param {string} fileName - Provide a fileName to use for a download.
       * @param {boolean} resolveLfs - If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types
       */
      getBlobContent(repositoryId, sha12, project, download, fileName, resolveLfs) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1: sha12
            };
            let queryValues = {
              download,
              fileName,
              resolveLfs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets one or more blobs in a zip file download.
       *
       * @param {string[]} blobIds - Blob IDs (SHA1 hashes) to be returned in the zip file.
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} filename
       */
      getBlobsZip(blobIds, repositoryId, project, filename) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.post(url, JSON.stringify(blobIds), { "Accept": accept, "Content-Type": "application/json" })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single blob.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} sha1 - SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip
       * @param {string} fileName - Provide a fileName to use for a download.
       * @param {boolean} resolveLfs - If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types
       */
      getBlobZip(repositoryId, sha12, project, download, fileName, resolveLfs) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1: sha12
            };
            let queryValues = {
              download,
              fileName,
              resolveLfs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve statistics about a single branch.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} name - Name of the branch.
       * @param {string} project - Project ID or project name
       * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor - Identifies the commit or branch to use as the base.
       */
      getBranch(repositoryId, name, project, baseVersionDescriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (name == null) {
            throw new TypeError("name can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              name,
              baseVersionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitBranchStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve statistics about all branches within a repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor - Identifies the commit or branch to use as the base.
       */
      getBranches(repositoryId, project, baseVersionDescriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              baseVersionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitBranchStats, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve statistics for multiple commits
       *
       * @param {GitInterfaces.GitQueryBranchStatsCriteria} searchCriteria - Base Commit and List of Target Commits to compare.
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       */
      getBranchStatsBatch(searchCriteria, repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, searchCriteria, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitBranchStats, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve changes for a particular commit.
       *
       * @param {string} commitId - The id of the commit.
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {string} project - Project ID or project name
       * @param {number} top - The maximum number of changes to return.
       * @param {number} skip - The number of changes to skip.
       */
      getChanges(commitId, repositoryId, project, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            let queryValues = {
              top,
              skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5bf884f5-3e07-42e9-afb8-1b872267bf16", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitChanges, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve one conflict for a cherry pick by ID
       *
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      getCherryPickConflict(repositoryId, cherryPickId, conflictId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all conflicts for a cherry pick
       *
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken
       * @param {number} top
       * @param {boolean} excludeResolved
       * @param {boolean} onlyResolved
       * @param {boolean} includeObsolete
       */
      getCherryPickConflicts(repositoryId, cherryPickId, project, continuationToken, top, excludeResolved, onlyResolved, includeObsolete) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId
            };
            let queryValues = {
              continuationToken,
              "$top": top,
              excludeResolved,
              onlyResolved,
              includeObsolete
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update merge conflict resolution
       *
       * @param {GitInterfaces.GitConflict} conflict
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      updateCherryPickConflict(conflict, repositoryId, cherryPickId, conflictId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflict, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update multiple merge conflict resolutions
       *
       * @param {GitInterfaces.GitConflict[]} conflictUpdates
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {string} project - Project ID or project name
       */
      updateCherryPickConflicts(conflictUpdates, repositoryId, cherryPickId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflictUpdates, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflictUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Given a commitId, returns a list of commits that are in the same cherry-pick family.
       *
       * @param {string} repositoryNameOrId
       * @param {string} commitId
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks
       */
      getCherryPickRelationships(repositoryNameOrId, commitId, project, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              commitId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "8af142a4-27c2-4168-9e82-46b8629aaa0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Cherry pick a specific commit or commits that are associated to a pull request into a new branch.
       *
       * @param {GitInterfaces.GitAsyncRefOperationParameters} cherryPickToCreate
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       */
      createCherryPick(cherryPickToCreate, project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cherryPickToCreate, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCherryPick, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a cherry pick operation by cherry pick Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cherryPickId - ID of the cherry pick.
       * @param {string} repositoryId - ID of the repository.
       */
      getCherryPick(project, cherryPickId, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cherryPickId,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCherryPick, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a cherry pick operation for a specific branch. This operation is expensive due to the underlying object structure, so this API only looks at the 1000 most recent cherry pick operations.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       * @param {string} refName - The GitAsyncRefOperationParameters generatedRefName used for the cherry pick operation.
       */
      getCherryPickForRefName(project, repositoryId, refName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (refName == null) {
            throw new TypeError("refName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              refName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCherryPick, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Find the closest common commit (the merge base) between base and target commits, and get the diff between either the base and target commits or common and target commits.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} diffCommonCommit - If true, diff between common and target commits. If false, diff between base and target commits.
       * @param {number} top - Maximum number of changes to return. Defaults to 100.
       * @param {number} skip - Number of changes to skip
       * @param {GitInterfaces.GitBaseVersionDescriptor} baseVersionDescriptor - Descriptor for base commit.
       * @param {GitInterfaces.GitTargetVersionDescriptor} targetVersionDescriptor - Descriptor for target commit.
       */
      getCommitDiffs(repositoryId, project, diffCommonCommit, top, skip, baseVersionDescriptor, targetVersionDescriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              diffCommonCommit,
              "$top": top,
              "$skip": skip
            };
            if (baseVersionDescriptor) {
              queryValues.baseVersionType = baseVersionDescriptor.versionType;
              queryValues.baseVersion = baseVersionDescriptor.version;
              queryValues.baseVersionOptions = baseVersionDescriptor.versionOptions;
            }
            if (targetVersionDescriptor) {
              queryValues.targetVersionType = targetVersionDescriptor.versionType;
              queryValues.targetVersion = targetVersionDescriptor.version;
              queryValues.targetVersionOptions = targetVersionDescriptor.versionOptions;
            }
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "615588d5-c0c7-4b88-88f8-e625306446e8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitDiffs, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a particular commit.
       *
       * @param {string} commitId - The id of the commit.
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {string} project - Project ID or project name
       * @param {number} changeCount - The number of changes to include in the result.
       */
      getCommit(commitId, repositoryId, project, changeCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            let queryValues = {
              changeCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommit, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve git commits for a project
       *
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria
       * @param {string} project - Project ID or project name
       * @param {number} skip
       * @param {number} top
       */
      getCommits(repositoryId, searchCriteria, project, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (searchCriteria == null) {
            throw new TypeError("searchCriteria can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              searchCriteria,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a list of commits associated with a particular push.
       *
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {number} pushId - The id of the push.
       * @param {string} project - Project ID or project name
       * @param {number} top - The maximum number of commits to return ("get the top x commits").
       * @param {number} skip - The number of commits to skip.
       * @param {boolean} includeLinks - Set to false to avoid including REST Url links for resources. Defaults to true.
       */
      getPushCommits(repositoryId, pushId, project, top, skip, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (pushId == null) {
            throw new TypeError("pushId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              pushId,
              top,
              skip,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve git commits for a project matching the search criteria
       *
       * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria - Search options
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Number of commits to skip. The value cannot exceed 3,000,000.
       * @param {number} top - Maximum number of commits to return. The value cannot exceed 50,000.
       * @param {boolean} includeStatuses - True to include additional commit status information.
       */
      getCommitsBatch(searchCriteria, repositoryId, project, skip, top, includeStatuses) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              "$skip": skip,
              "$top": top,
              includeStatuses
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "6400dfb2-0bcb-462b-b992-5a57f8f1416c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, searchCriteria, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve deleted git repositories.
       *
       * @param {string} project - Project ID or project name
       */
      getDeletedRepositories(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "2b6869c4-cb25-42b5-b7a3-0d3e6be0a11a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitDeletedRepository, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the file diffs for each of the specified files
       *
       * @param {GitInterfaces.FileDiffsCriteria} fileDiffsCriteria - List of file parameters objects
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository
       */
      getFileDiffs(fileDiffsCriteria, project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "c4c5a7e6-e9f3-4730-a92b-84baacff694b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, fileDiffsCriteria, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.FileDiff, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all forks of a repository in the collection.
       *
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {string} collectionId - Team project collection ID.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - True to include links.
       */
      getForks(repositoryNameOrId, collectionId, project, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              collectionId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "158c0340-bf6f-489c-9625-d572a1480d57", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepositoryRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Request that another repository's refs be fetched into this one. It syncs two existing forks. To create a fork, please see the <a href="https://docs.microsoft.com/en-us/rest/api/vsts/git/repositories/create?view=azure-devops-rest-5.1"> repositories endpoint</a>
       *
       * @param {GitInterfaces.GitForkSyncRequestParameters} syncParams - Source repository and ref mapping.
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - True to include links
       */
      createForkSyncRequest(syncParams, repositoryNameOrId, project, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1703f858-b9d1-46af-ab62-483e9e1055b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, syncParams, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitForkSyncRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific fork sync operation's details.
       *
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {number} forkSyncOperationId - OperationId of the sync request.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - True to include links.
       */
      getForkSyncRequest(repositoryNameOrId, forkSyncOperationId, project, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              forkSyncOperationId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1703f858-b9d1-46af-ab62-483e9e1055b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitForkSyncRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all requested fork sync operations on this repository.
       *
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeAbandoned - True to include abandoned requests.
       * @param {boolean} includeLinks - True to include links.
       */
      getForkSyncRequests(repositoryNameOrId, project, includeAbandoned, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId
            };
            let queryValues = {
              includeAbandoned,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1703f858-b9d1-46af-ab62-483e9e1055b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitForkSyncRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveHfs - Set to true to resolve Git HFS pointer files to return actual content from Git HFS.  Default is true.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getHfsItem(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveHfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveHfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "17f0a869-1589-43f0-9901-db1b2519087d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveHfs - Set to true to resolve Git HFS pointer files to return actual content from Git HFS.  Default is true.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getHfsItemContent(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveHfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveHfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "17f0a869-1589-43f0-9901-db1b2519087d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {boolean} includeLinks - Set to true to include links to items.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} zipForUnix - Set to true to keep the file permissions for unix (and POSIX) systems like executables and symlinks
       */
      getHfsItems(repositoryId, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, includeLinks, versionDescriptor, zipForUnix) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              includeLinks,
              versionDescriptor,
              zipForUnix
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "17f0a869-1589-43f0-9901-db1b2519087d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveHfs - Set to true to resolve Git HFS pointer files to return actual content from Git HFS.  Default is true.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getHfsItemText(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveHfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveHfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "17f0a869-1589-43f0-9901-db1b2519087d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveHfs - Set to true to resolve Git HFS pointer files to return actual content from Git HFS.  Default is true.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getHfsItemZip(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveHfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveHfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "17f0a869-1589-43f0-9901-db1b2519087d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an import request.
       *
       * @param {GitInterfaces.GitImportRequest} importRequest - The import request to create.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       */
      createImportRequest(importRequest, project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, importRequest, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a particular import request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {number} importRequestId - The unique identifier for the import request.
       */
      getImportRequest(project, repositoryId, importRequestId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              importRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve import requests for a repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {boolean} includeAbandoned - True to include abandoned import requests in the results.
       */
      queryImportRequests(project, repositoryId, includeAbandoned) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              includeAbandoned
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retry or abandon a failed import request.
       *
       * @param {GitInterfaces.GitImportRequest} importRequestToUpdate - The updated version of the import request. Currently, the only change allowed is setting the Status to Queued or Abandoned.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {number} importRequestId - The unique identifier for the import request to update.
       */
      updateImportRequest(importRequestToUpdate, project, repositoryId, importRequestId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              importRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, importRequestToUpdate, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItem(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItemContent(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {boolean} includeLinks - Set to true to include links to items.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} zipForUnix - Set to true to keep the file permissions for unix (and POSIX) systems like executables and symlinks
       */
      getItems(repositoryId, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, includeLinks, versionDescriptor, zipForUnix) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              includeLinks,
              versionDescriptor,
              zipForUnix
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItemText(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItemZip(repositoryId, path10, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path10,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
       *
       * @param {GitInterfaces.GitItemRequestData} requestData - Request data attributes: ItemDescriptors, IncludeContentMetadata, LatestProcessedChange, IncludeLinks. ItemDescriptors: Collection of items to fetch, including path, version, and recursion level. IncludeContentMetadata: Whether to include metadata for all items LatestProcessedChange: Whether to include shallow ref to commit that last changed each item. IncludeLinks: Whether to include the _links field on the shallow references.
       * @param {string} repositoryId - The name or ID of the repository
       * @param {string} project - Project ID or project name
       */
      getItemsBatch(requestData, repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "630fd2e4-fb88-4f85-ad21-13f3fd1fbca9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, requestData, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Find the merge bases of two commits, optionally across forks. If otherRepositoryId is not specified, the merge bases will only be calculated within the context of the local repositoryNameOrId.
       *
       * @param {string} repositoryNameOrId - ID or name of the local repository.
       * @param {string} commitId - First commit, usually the tip of the target branch of the potential merge.
       * @param {string} otherCommitId - Other commit, usually the tip of the source branch of the potential merge.
       * @param {string} project - Project ID or project name
       * @param {string} otherCollectionId - The collection ID where otherCommitId lives.
       * @param {string} otherRepositoryId - The repository ID where otherCommitId lives.
       */
      getMergeBases(repositoryNameOrId, commitId, otherCommitId, project, otherCollectionId, otherRepositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (otherCommitId == null) {
            throw new TypeError("otherCommitId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              commitId
            };
            let queryValues = {
              otherCommitId,
              otherCollectionId,
              otherRepositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7cf2abb6-c964-4f7e-9872-f78c66e72e9c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Request a git merge operation. Currently we support merging only 2 commits.
       *
       * @param {GitInterfaces.GitMergeParameters} mergeParameters - Parents commitIds and merge commit messsage.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {boolean} includeLinks - True to include links
       */
      createMergeRequest(mergeParameters, project, repositoryNameOrId, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "985f7ae9-844f-4906-9897-7ef41516c0e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, mergeParameters, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitMerge, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific merge operation's details.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {number} mergeOperationId - OperationId of the merge request.
       * @param {boolean} includeLinks - True to include links
       */
      getMergeRequest(project, repositoryNameOrId, mergeOperationId, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              mergeOperationId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "985f7ae9-844f-4906-9897-7ef41516c0e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitMerge, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a new file to a pull request.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} fileName - The name of the file.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createAttachment(customHeaders, contentStream, fileName, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Attachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a pull request attachment.
       *
       * @param {string} fileName - The name of the attachment to delete.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      deleteAttachment(fileName, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the file content of a pull request attachment.
       *
       * @param {string} fileName - The name of the attachment.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getAttachmentContent(fileName, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of files attached to a given pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getAttachments(repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Attachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the file content of a pull request attachment.
       *
       * @param {string} fileName - The name of the attachment.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getAttachmentZip(fileName, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a like on a comment.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - The ID of the thread that contains the comment.
       * @param {number} commentId - The ID of the comment.
       * @param {string} project - Project ID or project name
       */
      createLike(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5f2e2851-1389-425b-a00b-fb2adb3ef31b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a like on a comment.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - The ID of the thread that contains the comment.
       * @param {number} commentId - The ID of the comment.
       * @param {string} project - Project ID or project name
       */
      deleteLike(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5f2e2851-1389-425b-a00b-fb2adb3ef31b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get likes for a comment.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - The ID of the thread that contains the comment.
       * @param {number} commentId - The ID of the comment.
       * @param {string} project - Project ID or project name
       */
      getLikes(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5f2e2851-1389-425b-a00b-fb2adb3ef31b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the commits for the specified iteration of a pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the iteration from which to get the commits.
       * @param {string} project - Project ID or project name
       * @param {number} top - Maximum number of commits to return. The maximum number of commits that can be returned per batch is 500.
       * @param {number} skip - Number of commits to skip.
       */
      getPullRequestIterationCommits(repositoryId, pullRequestId, iterationId, project, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            let queryValues = {
              top,
              skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "e7ea0883-095f-4926-b5fb-f24691c26fb9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the commits for the specified pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestCommits(repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "52823034-34a8-4576-922c-8d8b77e9e4c4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve one conflict for a pull request by ID
       *
       * @param {string} repositoryId
       * @param {number} pullRequestId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      getPullRequestConflict(repositoryId, pullRequestId, conflictId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all conflicts for a pull request
       *
       * @param {string} repositoryId - The repository of the Pull Request.
       * @param {number} pullRequestId - The pull request ID.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Conflicts to skip.
       * @param {number} top - Conflicts to return after skip.
       * @param {boolean} includeObsolete - Includes obsolete conflicts.
       * @param {boolean} excludeResolved - Excludes conflicts already resolved.
       * @param {boolean} onlyResolved - Returns only the conflicts that are resolved.
       */
      getPullRequestConflicts(repositoryId, pullRequestId, project, skip, top, includeObsolete, excludeResolved, onlyResolved) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              "$skip": skip,
              "$top": top,
              includeObsolete,
              excludeResolved,
              onlyResolved
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update merge conflict resolution
       *
       * @param {GitInterfaces.GitConflict} conflict
       * @param {string} repositoryId
       * @param {number} pullRequestId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      updatePullRequestConflict(conflict, repositoryId, pullRequestId, conflictId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflict, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update multiple merge conflict resolutions
       *
       * @param {GitInterfaces.GitConflict[]} conflictUpdates
       * @param {string} repositoryId
       * @param {number} pullRequestId
       * @param {string} project - Project ID or project name
       */
      updatePullRequestConflicts(conflictUpdates, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflictUpdates, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflictUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve the changes made in a pull request between two iterations.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration. <br /> Iteration one is the head of the source branch at the time the pull request is created and subsequent iterations are created when there are pushes to the source branch. Allowed values are between 1 and the maximum iteration on this pull request.
       * @param {string} project - Project ID or project name
       * @param {number} top - Optional. The number of changes to retrieve.  The default value is 100 and the maximum value is 2000.
       * @param {number} skip - Optional. The number of changes to ignore.  For example, to retrieve changes 101-150, set top 50 and skip to 100.
       * @param {number} compareTo - ID of the pull request iteration to compare against.  The default value is zero which indicates the comparison is made against the common commit between the source and target branches
       */
      getPullRequestIterationChanges(repositoryId, pullRequestId, iterationId, project, top, skip, compareTo) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip,
              "$compareTo": compareTo
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4216bdcf-b6b1-4d59-8b82-c34cc183fc8b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestIterationChanges, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the specified iteration for a pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration to return.
       * @param {string} project - Project ID or project name
       */
      getPullRequestIteration(repositoryId, pullRequestId, iterationId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d43911ee-6958-46b0-a42b-8445b8a0d004", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestIteration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the list of iterations for the specified pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeCommits - If true, include the commits associated with each iteration in the response.
       */
      getPullRequestIterations(repositoryId, pullRequestId, project, includeCommits) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              includeCommits
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d43911ee-6958-46b0-a42b-8445b8a0d004", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestIteration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pull request status on the iteration. This operation will have the same result as Create status on pull request with specified iteration ID in the request body.
       *
       * @param {GitInterfaces.GitPullRequestStatus} status - Pull request status to create.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {string} project - Project ID or project name
       */
      createPullRequestIterationStatus(status, repositoryId, pullRequestId, iterationId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, status, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete pull request iteration status.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      deletePullRequestIterationStatus(repositoryId, pullRequestId, iterationId, statusId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the specific pull request iteration status by ID. The status ID is unique within the pull request across all iterations.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      getPullRequestIterationStatus(repositoryId, pullRequestId, iterationId, statusId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the statuses associated with a pull request iteration.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {string} project - Project ID or project name
       */
      getPullRequestIterationStatuses(repositoryId, pullRequestId, iterationId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update pull request iteration statuses collection. The only supported operation type is `remove`.
       *
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - Operations to apply to the pull request statuses in JSON Patch format.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestIterationStatuses(customHeaders, patchDocument, repositoryId, pullRequestId, iterationId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a tag (if that does not exists yet) and add that as a label (tag) for a specified pull request. The only required field is the name of the new label (tag).
       *
       * @param {TfsCoreInterfaces.WebApiCreateTagRequestData} label - Label to assign to the pull request.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      createPullRequestLabel(label, repositoryId, pullRequestId, project, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, label, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a label (tag) from the set of those assigned to the pull request. The tag itself will not be deleted.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} labelIdOrName - The name or ID of the label requested.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      deletePullRequestLabels(repositoryId, pullRequestId, labelIdOrName, project, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              labelIdOrName
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves a single label (tag) that has been assigned to a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} labelIdOrName - The name or ID of the label requested.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      getPullRequestLabel(repositoryId, pullRequestId, labelIdOrName, project, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              labelIdOrName
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the labels (tags) assigned to a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      getPullRequestLabels(repositoryId, pullRequestId, project, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get external properties of the pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestProperties(repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "48a52185-5b9e-4736-9dc1-bb1e2feac80b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create or update pull request external properties. The patch operation can be `add`, `replace` or `remove`. For `add` operation, the path can be empty. If the path is empty, the value must be a list of key value pairs. For `replace` operation, the path cannot be empty. If the path does not exist, the property will be added to the collection. For `remove` operation, the path cannot be empty. If the path does not exist, no action will be performed.
       *
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - Properties to add, replace or remove in JSON Patch format.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestProperties(customHeaders, patchDocument, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "48a52185-5b9e-4736-9dc1-bb1e2feac80b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This API is used to find what pull requests are related to a given commit.  It can be used to either find the pull request that created a particular merge commit or it can be used to find all pull requests that have ever merged a particular commit.  The input is a list of queries which each contain a list of commits. For each commit that you search against, you will get back a dictionary of commit -> pull requests.
       *
       * @param {GitInterfaces.GitPullRequestQuery} queries - The list of queries to perform.
       * @param {string} repositoryId - ID of the repository.
       * @param {string} project - Project ID or project name
       */
      getPullRequestQuery(queries, repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b3a6eebe-9cf0-49ea-b6cb-1a4c5f5007b0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queries, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a reviewer to a pull request or cast a vote.
       *
       * @param {GitInterfaces.IdentityRefWithVote} reviewer - Reviewer's vote.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.<br />Reviewers can set their own vote with this method.  When adding other reviewers, vote must be set to zero.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer.
       * @param {string} project - Project ID or project name
       */
      createPullRequestReviewer(reviewer, repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, reviewer, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add reviewers to a pull request.
       *
       * @param {VSSInterfaces.IdentityRef[]} reviewers - Reviewers to add to the pull request.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createPullRequestReviewers(reviewers, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, reviewers, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add an unmaterialized identity to the reviewers of a pull request.
       *
       * @param {GitInterfaces.IdentityRefWithVote} reviewer - Reviewer to add to the pull request.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createUnmaterializedPullRequestReviewer(reviewer, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, reviewer, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Remove a reviewer from a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer to remove.
       * @param {string} project - Project ID or project name
       */
      deletePullRequestReviewer(repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a particular reviewer on a pull request
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer.
       * @param {string} project - Project ID or project name
       */
      getPullRequestReviewer(repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve the reviewers for a pull request
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestReviewers(repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Edit a reviewer entry. These fields are patchable: isFlagged, hasDeclined
       *
       * @param {GitInterfaces.IdentityRefWithVote} reviewer - Reviewer data.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestReviewer(reviewer, repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, reviewer, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reset the votes of multiple reviewers on a pull request.  NOTE: This endpoint only supports updating votes, but does not support updating required reviewers (use policy) or display names.
       *
       * @param {GitInterfaces.IdentityRefWithVote[]} patchVotes - IDs of the reviewers whose votes will be reset to zero
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request
       * @param {string} project - Project ID or project name
       */
      updatePullRequestReviewers(patchVotes, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, patchVotes, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a pull request.
       *
       * @param {number} pullRequestId - The ID of the pull request to retrieve.
       * @param {string} project - Project ID or project name
       */
      getPullRequestById(pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "01a46dea-7d46-4d40-bc84-319e7c260d99", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all pull requests matching a specified criteria.
       *
       * @param {string} project - Project ID or project name
       * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria - Pull requests will be returned that match this search criteria.
       * @param {number} maxCommentLength - Not used.
       * @param {number} skip - The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       * @param {number} top - The number of pull requests to retrieve.
       */
      getPullRequestsByProject(project, searchCriteria, maxCommentLength, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (searchCriteria == null) {
            throw new TypeError("searchCriteria can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              searchCriteria,
              maxCommentLength,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "a5d28130-9cd2-40fa-9f08-902e7daa9efb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pull request.
       *
       * @param {GitInterfaces.GitPullRequest} gitPullRequestToCreate - The pull request to create.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {string} project - Project ID or project name
       * @param {boolean} supportsIterations - If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed.
       */
      createPullRequest(gitPullRequestToCreate, repositoryId, project, supportsIterations) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              supportsIterations
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, gitPullRequestToCreate, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - The ID of the pull request to retrieve.
       * @param {string} project - Project ID or project name
       * @param {number} maxCommentLength - Not used.
       * @param {number} skip - Not used.
       * @param {number} top - Not used.
       * @param {boolean} includeCommits - If true, the pull request will be returned with the associated commits.
       * @param {boolean} includeWorkItemRefs - If true, the pull request will be returned with the associated work item references.
       */
      getPullRequest(repositoryId, pullRequestId, project, maxCommentLength, skip, top, includeCommits, includeWorkItemRefs) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              maxCommentLength,
              "$skip": skip,
              "$top": top,
              includeCommits,
              includeWorkItemRefs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all pull requests matching a specified criteria.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria - Pull requests will be returned that match this search criteria.
       * @param {string} project - Project ID or project name
       * @param {number} maxCommentLength - Not used.
       * @param {number} skip - The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       * @param {number} top - The number of pull requests to retrieve.
       */
      getPullRequests(repositoryId, searchCriteria, project, maxCommentLength, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (searchCriteria == null) {
            throw new TypeError("searchCriteria can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              searchCriteria,
              maxCommentLength,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a pull request
       *
       * @param {GitInterfaces.GitPullRequest} gitPullRequestToUpdate - The pull request content that should be updated.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request to update.
       * @param {string} project - Project ID or project name
       */
      updatePullRequest(gitPullRequestToUpdate, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, gitPullRequestToUpdate, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Sends an e-mail notification about a specific pull request to a set of recipients
       *
       * @param {GitInterfaces.ShareNotificationContext} userMessage
       * @param {string} repositoryId - ID of the git repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      sharePullRequest(userMessage, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "696f3a82-47c9-487f-9117-b9d00972ca84", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, userMessage, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pull request status.
       *
       * @param {GitInterfaces.GitPullRequestStatus} status - Pull request status to create.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createPullRequestStatus(status, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, status, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete pull request status.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      deletePullRequestStatus(repositoryId, pullRequestId, statusId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the specific pull request status by ID. The status ID is unique within the pull request across all iterations.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      getPullRequestStatus(repositoryId, pullRequestId, statusId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the statuses associated with a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestStatuses(repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update pull request statuses collection. The only supported operation type is `remove`.
       *
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - Operations to apply to the pull request statuses in JSON Patch format.
       * @param {string} repositoryId - The repository ID of the pull requests target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestStatuses(customHeaders, patchDocument, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a comment on a specific thread in a pull request (up to 500 comments can be created per thread).
       *
       * @param {GitInterfaces.Comment} comment - The comment to create. Comments can be up to 150,000 characters.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {string} project - Project ID or project name
       */
      createComment(comment, repositoryId, pullRequestId, threadId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, comment, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a comment associated with a specific thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {number} commentId - ID of the comment.
       * @param {string} project - Project ID or project name
       */
      deleteComment(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a comment associated with a specific thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {number} commentId - ID of the comment.
       * @param {string} project - Project ID or project name
       */
      getComment(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all comments associated with a specific thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread.
       * @param {string} project - Project ID or project name
       */
      getComments(repositoryId, pullRequestId, threadId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a comment associated with a specific thread in a pull request.
       *
       * @param {GitInterfaces.Comment} comment - The comment content that should be updated. Comments can be up to 150,000 characters.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {number} commentId - ID of the comment to update.
       * @param {string} project - Project ID or project name
       */
      updateComment(comment, repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, comment, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a thread in a pull request.
       *
       * @param {GitInterfaces.GitPullRequestCommentThread} commentThread - The thread to create. Thread must contain at least one comment.
       * @param {string} repositoryId - Repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createThread(commentThread, repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, commentThread, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread.
       * @param {string} project - Project ID or project name
       * @param {number} iteration - If specified, thread position will be tracked using this iteration as the right side of the diff.
       * @param {number} baseIteration - If specified, thread position will be tracked using this iteration as the left side of the diff.
       */
      getPullRequestThread(repositoryId, pullRequestId, threadId, project, iteration, baseIteration) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            let queryValues = {
              "$iteration": iteration,
              "$baseIteration": baseIteration
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all threads in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {number} iteration - If specified, thread positions will be tracked using this iteration as the right side of the diff.
       * @param {number} baseIteration - If specified, thread positions will be tracked using this iteration as the left side of the diff.
       */
      getThreads(repositoryId, pullRequestId, project, iteration, baseIteration) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              "$iteration": iteration,
              "$baseIteration": baseIteration
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a thread in a pull request.
       *
       * @param {GitInterfaces.GitPullRequestCommentThread} commentThread - The thread content that should be updated.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread to update.
       * @param {string} project - Project ID or project name
       */
      updateThread(commentThread, repositoryId, pullRequestId, threadId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, commentThread, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a list of work items associated with a pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestWorkItemRefs(repositoryId, pullRequestId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "0a637fcc-5370-4ce8-b0e8-98091f5f9482", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Push changes to the repository.
       *
       * @param {GitInterfaces.GitPush} push
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       */
      createPush(push2, repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, push2, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPush, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves a particular push.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {number} pushId - ID of the push.
       * @param {string} project - Project ID or project name
       * @param {number} includeCommits - The number of commits to include in the result.
       * @param {boolean} includeRefUpdates - If true, include the list of refs that were updated by the push.
       */
      getPush(repositoryId, pushId, project, includeCommits, includeRefUpdates) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pushId
            };
            let queryValues = {
              includeCommits,
              includeRefUpdates
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPush, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves pushes associated with the specified repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Number of pushes to skip.
       * @param {number} top - Number of pushes to return.
       * @param {GitInterfaces.GitPushSearchCriteria} searchCriteria - Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.
       */
      getPushes(repositoryId, project, skip, top, searchCriteria) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              "$skip": skip,
              "$top": top,
              searchCriteria
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPush, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Destroy (hard delete) a soft-deleted Git repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The ID of the repository.
       */
      deleteRepositoryFromRecycleBin(project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "a663da97-81db-4eb3-8b83-287670f63073", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve soft-deleted git repositories from the recycle bin.
       *
       * @param {string} project - Project ID or project name
       */
      getRecycleBinRepositories(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "a663da97-81db-4eb3-8b83-287670f63073", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitDeletedRepository, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Recover a soft-deleted Git repository. Recently deleted repositories go into a soft-delete state for a period of time before they are hard deleted and become unrecoverable.
       *
       * @param {GitInterfaces.GitRecycleBinRepositoryDetails} repositoryDetails
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The ID of the repository.
       */
      restoreRepositoryFromRecycleBin(repositoryDetails, project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "a663da97-81db-4eb3-8b83-287670f63073", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, repositoryDetails, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queries the provided repository for its refs and returns them.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} filter - [optional] A filter to apply to the refs (starts with).
       * @param {boolean} includeLinks - [optional] Specifies if referenceLinks should be included in the result. default is false.
       * @param {boolean} includeStatuses - [optional] Includes up to the first 1000 commit statuses for each ref. The default value is false.
       * @param {boolean} includeMyBranches - [optional] Includes only branches that the user owns, the branches the user favorites, and the default branch. The default value is false. Cannot be combined with the filter parameter.
       * @param {boolean} latestStatusesOnly - [optional] True to include only the tip commit status for each ref. This option requires `includeStatuses` to be true. The default value is false.
       * @param {boolean} peelTags - [optional] Annotated tags will populate the PeeledObjectId property. default is false.
       * @param {string} filterContains - [optional] A filter to apply to the refs (contains).
       */
      getRefs(repositoryId, project, filter2, includeLinks, includeStatuses, includeMyBranches, latestStatusesOnly, peelTags, filterContains) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              filter: filter2,
              includeLinks,
              includeStatuses,
              includeMyBranches,
              latestStatusesOnly,
              peelTags,
              filterContains
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Lock or Unlock a branch.
       *
       * @param {GitInterfaces.GitRefUpdate} newRefInfo - The ref update action (lock/unlock) to perform
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} filter - The name of the branch to lock/unlock
       * @param {string} project - Project ID or project name
       * @param {string} projectId - ID or name of the team project. Optional if specifying an ID for repository.
       */
      updateRef(newRefInfo, repositoryId, filter2, project, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (filter2 == null) {
            throw new TypeError("filter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              filter: filter2,
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newRefInfo, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creating, updating, or deleting refs(branches).
       *
       * @param {GitInterfaces.GitRefUpdate[]} refUpdates - List of ref updates to attempt to perform
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - ID or name of the team project. Optional if specifying an ID for repository.
       */
      updateRefs(refUpdates, repositoryId, project, projectId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, refUpdates, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a ref favorite
       *
       * @param {GitInterfaces.GitRefFavorite} favorite - The ref favorite to create.
       * @param {string} project - Project ID or project name
       */
      createFavorite(favorite, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, favorite, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the refs favorite specified
       *
       * @param {string} project - Project ID or project name
       * @param {number} favoriteId - The Id of the ref favorite to delete.
       */
      deleteRefFavorite(project, favoriteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              favoriteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the refs favorite for a favorite Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} favoriteId - The Id of the requested ref favorite.
       */
      getRefFavorite(project, favoriteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              favoriteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the refs favorites for a repo and an identity.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The id of the repository.
       * @param {string} identityId - The id of the identity whose favorites are to be retrieved. If null, the requesting identity is used.
       */
      getRefFavorites(project, repositoryId, identityId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              repositoryId,
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} identityId
       */
      getRefFavoritesForProject(project, identityId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4720896c-594c-4a6d-b94c-12eddd80b34a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a git repository in a team project.
       *
       * @param {GitInterfaces.GitRepositoryCreateOptions} gitRepositoryToCreate - Specify the repo name, team project and/or parent repository. Team project information can be omitted from gitRepositoryToCreate if the request is project-scoped (i.e., includes project Id).
       * @param {string} project - Project ID or project name
       * @param {string} sourceRef - [optional] Specify the source refs to use while creating a fork repo
       */
      createRepository(gitRepositoryToCreate, project, sourceRef) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              sourceRef
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, gitRepositoryToCreate, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a git repository
       *
       * @param {string} repositoryId - The ID of the repository.
       * @param {string} project - Project ID or project name
       */
      deleteRepository(repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve git repositories.
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - [optional] True to include reference links. The default value is false.
       * @param {boolean} includeAllUrls - [optional] True to include all remote URLs. The default value is false.
       * @param {boolean} includeHidden - [optional] True to include hidden repositories. The default value is false.
       */
      getRepositories(project, includeLinks, includeAllUrls, includeHidden) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeLinks,
              includeAllUrls,
              includeHidden
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a git repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       */
      getRepository(repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a git repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {boolean} includeParent - True to include parent repository. Only available in authenticated calls.
       * @param {string} project - Project ID or project name
       */
      getRepositoryWithParent(repositoryId, includeParent, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (includeParent == null) {
            throw new TypeError("includeParent can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              includeParent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the Git repository with either a new repo name or a new default branch.
       *
       * @param {GitInterfaces.GitRepository} newRepositoryInfo - Specify a new repo name or a new default branch of the repository
       * @param {string} repositoryId - The ID of the repository.
       * @param {string} project - Project ID or project name
       */
      updateRepository(newRepositoryInfo, repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newRepositoryInfo, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve git repositories with filter by name and pagination.
       *
       * @param {string} projectId - ID or name of theteam project.
       * @param {boolean} includeLinks - [optional] True to include reference links. The default value is false.
       * @param {boolean} includeAllUrls - [optional] True to include all remote URLs. The default value is false.
       * @param {boolean} includeHidden - [optional] True to include hidden repositories. The default value is false.
       * @param {string} filterContains - [optional] A filter to apply to the refs (contains).
       * @param {number} top - [optional] Maximum number of repositories to return. It cannot be bigger than 500. If it is not provided but continuationToken is, top will default to 100.
       * @param {string} continuationToken - The continuation token used for pagination.
       */
      getRepositoriesPaged(projectId, includeLinks, includeAllUrls, includeHidden, filterContains, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              includeLinks,
              includeAllUrls,
              includeHidden,
              filterContains,
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "82aea7e8-9501-45dd-ac58-b069aa73b926", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve one conflict for a revert by ID
       *
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      getRevertConflict(repositoryId, revertId, conflictId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all conflicts for a revert
       *
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken
       * @param {number} top
       * @param {boolean} excludeResolved
       * @param {boolean} onlyResolved
       * @param {boolean} includeObsolete
       */
      getRevertConflicts(repositoryId, revertId, project, continuationToken, top, excludeResolved, onlyResolved, includeObsolete) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId
            };
            let queryValues = {
              continuationToken,
              "$top": top,
              excludeResolved,
              onlyResolved,
              includeObsolete
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update merge conflict resolution
       *
       * @param {GitInterfaces.GitConflict} conflict
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      updateRevertConflict(conflict, repositoryId, revertId, conflictId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflict, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update multiple merge conflict resolutions
       *
       * @param {GitInterfaces.GitConflict[]} conflictUpdates
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {string} project - Project ID or project name
       */
      updateRevertConflicts(conflictUpdates, repositoryId, revertId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflictUpdates, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflictUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Starts the operation to create a new branch which reverts changes introduced by either a specific commit or commits that are associated to a pull request.
       *
       * @param {GitInterfaces.GitAsyncRefOperationParameters} revertToCreate
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       */
      createRevert(revertToCreate, project, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, revertToCreate, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRevert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a revert operation by revert Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} revertId - ID of the revert operation.
       * @param {string} repositoryId - ID of the repository.
       */
      getRevert(project, revertId, repositoryId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              revertId,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRevert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a revert operation for a specific branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       * @param {string} refName - The GitAsyncRefOperationParameters generatedRefName used for the revert operation.
       */
      getRevertForRefName(project, repositoryId, refName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (refName == null) {
            throw new TypeError("refName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              refName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRevert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create Git commit status.
       *
       * @param {GitInterfaces.GitStatus} gitCommitStatusToCreate - Git commit status object to create.
       * @param {string} commitId - ID of the Git commit.
       * @param {string} repositoryId - ID of the repository.
       * @param {string} project - Project ID or project name
       */
      createCommitStatus(gitCommitStatusToCreate, commitId, repositoryId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, gitCommitStatusToCreate, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get statuses associated with the Git commit.
       *
       * @param {string} commitId - ID of the Git commit.
       * @param {string} repositoryId - ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {number} top - Optional. The number of statuses to retrieve. Default is 1000.
       * @param {number} skip - Optional. The number of statuses to ignore. Default is 0. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       * @param {boolean} latestOnly - The flag indicates whether to get only latest statuses grouped by `Context.Name` and `Context.Genre`.
       */
      getStatuses(commitId, repositoryId, project, top, skip, latestOnly) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            let queryValues = {
              top,
              skip,
              latestOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a pull request suggestion for a particular repository or team project.
       *
       * @param {string} repositoryId - ID of the git repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} preferCompareBranch - If true, prefer the compare branch over the default branch as target branch for pull requests.
       */
      getSuggestions(repositoryId, project, preferCompareBranch) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              preferCompareBranch
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "9393b4fb-4445-4919-972b-9ad16f442d83", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * The Tree endpoint returns the collection of objects underneath the specified tree. Trees are folders in a Git repository.
       *
       * @param {string} repositoryId - Repository Id.
       * @param {string} sha1 - SHA1 hash of the tree object.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project Id.
       * @param {boolean} recursive - Search recursively. Include trees underneath this tree. Default is false.
       * @param {string} fileName - Name to use if a .zip file is returned. Default is the object ID.
       */
      getTree(repositoryId, sha12, project, projectId, recursive, fileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1: sha12
            };
            let queryValues = {
              projectId,
              recursive,
              fileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitTreeRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * The Tree endpoint returns the collection of objects underneath the specified tree. Trees are folders in a Git repository.
       *
       * @param {string} repositoryId - Repository Id.
       * @param {string} sha1 - SHA1 hash of the tree object.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project Id.
       * @param {boolean} recursive - Search recursively. Include trees underneath this tree. Default is false.
       * @param {string} fileName - Name to use if a .zip file is returned. Default is the object ID.
       */
      getTreeZip(repositoryId, sha12, project, projectId, recursive, fileName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1: sha12
            };
            let queryValues = {
              projectId,
              recursive,
              fileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.GitApi = GitApi;
    GitApi.RESOURCE_AREA_ID = "4e080c62-fa21-4fbc-8fef-2a10a2b38049";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/common/VSSInterfaces.js
var require_VSSInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/common/VSSInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.Operation = exports2.JWTAlgorithm = exports2.DeploymentFlags = exports2.ConnectOptions = void 0;
    var ConnectOptions;
    (function(ConnectOptions2) {
      ConnectOptions2[ConnectOptions2["None"] = 0] = "None";
      ConnectOptions2[ConnectOptions2["IncludeServices"] = 1] = "IncludeServices";
      ConnectOptions2[ConnectOptions2["IncludeLastUserAccess"] = 2] = "IncludeLastUserAccess";
      ConnectOptions2[ConnectOptions2["IncludeInheritedDefinitionsOnly"] = 4] = "IncludeInheritedDefinitionsOnly";
      ConnectOptions2[ConnectOptions2["IncludeNonInheritedDefinitionsOnly"] = 8] = "IncludeNonInheritedDefinitionsOnly";
    })(ConnectOptions = exports2.ConnectOptions || (exports2.ConnectOptions = {}));
    var DeploymentFlags;
    (function(DeploymentFlags2) {
      DeploymentFlags2[DeploymentFlags2["None"] = 0] = "None";
      DeploymentFlags2[DeploymentFlags2["Hosted"] = 1] = "Hosted";
      DeploymentFlags2[DeploymentFlags2["OnPremises"] = 2] = "OnPremises";
    })(DeploymentFlags = exports2.DeploymentFlags || (exports2.DeploymentFlags = {}));
    var JWTAlgorithm;
    (function(JWTAlgorithm2) {
      JWTAlgorithm2[JWTAlgorithm2["None"] = 0] = "None";
      JWTAlgorithm2[JWTAlgorithm2["HS256"] = 1] = "HS256";
      JWTAlgorithm2[JWTAlgorithm2["RS256"] = 2] = "RS256";
    })(JWTAlgorithm = exports2.JWTAlgorithm || (exports2.JWTAlgorithm = {}));
    var Operation;
    (function(Operation2) {
      Operation2[Operation2["Add"] = 0] = "Add";
      Operation2[Operation2["Remove"] = 1] = "Remove";
      Operation2[Operation2["Replace"] = 2] = "Replace";
      Operation2[Operation2["Move"] = 3] = "Move";
      Operation2[Operation2["Copy"] = 4] = "Copy";
      Operation2[Operation2["Test"] = 5] = "Test";
    })(Operation = exports2.Operation || (exports2.Operation = {}));
    exports2.TypeInfo = {
      ConnectOptions: {
        enumValues: {
          "none": 0,
          "includeServices": 1,
          "includeLastUserAccess": 2,
          "includeInheritedDefinitionsOnly": 4,
          "includeNonInheritedDefinitionsOnly": 8
        }
      },
      DeploymentFlags: {
        enumValues: {
          "none": 0,
          "hosted": 1,
          "onPremises": 2
        }
      },
      JsonPatchOperation: {},
      JWTAlgorithm: {
        enumValues: {
          "none": 0,
          "hS256": 1,
          "rS256": 2
        }
      },
      Operation: {
        enumValues: {
          "add": 0,
          "remove": 1,
          "replace": 2,
          "move": 3,
          "copy": 4,
          "test": 5
        }
      },
      SignedUrl: {},
      TraceFilter: {},
      VssNotificationEvent: {}
    };
    exports2.TypeInfo.JsonPatchOperation.fields = {
      op: {
        enumType: exports2.TypeInfo.Operation
      }
    };
    exports2.TypeInfo.SignedUrl.fields = {
      signatureExpires: {
        isDate: true
      }
    };
    exports2.TypeInfo.TraceFilter.fields = {
      timeCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.VssNotificationEvent.fields = {
      sourceEventCreatedTime: {
        isDate: true
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/LocationsInterfaces.js
var require_LocationsInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/LocationsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ServiceStatus = exports2.RelativeToSetting = exports2.InheritLevel = void 0;
    var VSSInterfaces = require_VSSInterfaces();
    var InheritLevel;
    (function(InheritLevel2) {
      InheritLevel2[InheritLevel2["None"] = 0] = "None";
      InheritLevel2[InheritLevel2["Deployment"] = 1] = "Deployment";
      InheritLevel2[InheritLevel2["Account"] = 2] = "Account";
      InheritLevel2[InheritLevel2["Collection"] = 4] = "Collection";
      InheritLevel2[InheritLevel2["All"] = 7] = "All";
    })(InheritLevel = exports2.InheritLevel || (exports2.InheritLevel = {}));
    var RelativeToSetting;
    (function(RelativeToSetting2) {
      RelativeToSetting2[RelativeToSetting2["Context"] = 0] = "Context";
      RelativeToSetting2[RelativeToSetting2["WebApplication"] = 2] = "WebApplication";
      RelativeToSetting2[RelativeToSetting2["FullyQualified"] = 3] = "FullyQualified";
    })(RelativeToSetting = exports2.RelativeToSetting || (exports2.RelativeToSetting = {}));
    var ServiceStatus;
    (function(ServiceStatus2) {
      ServiceStatus2[ServiceStatus2["Assigned"] = 0] = "Assigned";
      ServiceStatus2[ServiceStatus2["Active"] = 1] = "Active";
      ServiceStatus2[ServiceStatus2["Moving"] = 2] = "Moving";
    })(ServiceStatus = exports2.ServiceStatus || (exports2.ServiceStatus = {}));
    exports2.TypeInfo = {
      ConnectionData: {},
      InheritLevel: {
        enumValues: {
          "none": 0,
          "deployment": 1,
          "account": 2,
          "collection": 4,
          "all": 7
        }
      },
      LocationServiceData: {},
      RelativeToSetting: {
        enumValues: {
          "context": 0,
          "webApplication": 2,
          "fullyQualified": 3
        }
      },
      ServiceDefinition: {},
      ServiceStatus: {
        enumValues: {
          "assigned": 0,
          "active": 1,
          "moving": 2
        }
      }
    };
    exports2.TypeInfo.ConnectionData.fields = {
      deploymentType: {
        enumType: VSSInterfaces.TypeInfo.DeploymentFlags
      },
      lastUserAccess: {
        isDate: true
      },
      locationServiceData: {
        typeInfo: exports2.TypeInfo.LocationServiceData
      }
    };
    exports2.TypeInfo.LocationServiceData.fields = {
      serviceDefinitions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ServiceDefinition
      }
    };
    exports2.TypeInfo.ServiceDefinition.fields = {
      inheritLevel: {
        enumType: exports2.TypeInfo.InheritLevel
      },
      relativeToSetting: {
        enumType: exports2.TypeInfo.RelativeToSetting
      },
      status: {
        enumType: exports2.TypeInfo.ServiceStatus
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/LocationsApi.js
var require_LocationsApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/LocationsApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LocationsApi = void 0;
    var basem = require_ClientApiBases();
    var LocationsInterfaces = require_LocationsInterfaces();
    var LocationsApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Locations-api", options2);
      }
      /**
       * This was copied and adapted from TeamFoundationConnectionService.Connect()
       *
       * @param {VSSInterfaces.ConnectOptions} connectOptions
       * @param {number} lastChangeId - Obsolete 32-bit LastChangeId
       * @param {number} lastChangeId64 - Non-truncated 64-bit LastChangeId
       */
      getConnectionData(connectOptions, lastChangeId, lastChangeId64) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              connectOptions,
              lastChangeId,
              lastChangeId64
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "00d9565f-ed9c-4a06-9a50-00e7896ccab4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, LocationsInterfaces.TypeInfo.ConnectionData, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} areaId
       * @param {string} enterpriseName
       * @param {string} organizationName
       * @param {string} accessMapping
       */
      getResourceArea(areaId, enterpriseName, organizationName, accessMapping) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              areaId
            };
            let queryValues = {
              enterpriseName,
              organizationName,
              accessMapping
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} areaId
       * @param {string} hostId
       * @param {string} accessMapping
       */
      getResourceAreaByHost(areaId, hostId, accessMapping) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (hostId == null) {
            throw new TypeError("hostId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              areaId
            };
            let queryValues = {
              hostId,
              accessMapping
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} areaId
       * @param {string} instanceId
       * @param {string} accessMapping
       */
      getResourceAreaByInstanceId(areaId, instanceId, accessMapping) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (instanceId == null) {
            throw new TypeError("instanceId can not be null or undefined");
          }
          if (accessMapping == null) {
            throw new TypeError("accessMapping can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              areaId
            };
            let queryValues = {
              instanceId,
              accessMapping
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} enterpriseName
       * @param {string} organizationName
       */
      getResourceAreas(enterpriseName, organizationName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              enterpriseName,
              organizationName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} hostId
       */
      getResourceAreasByHost(hostId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (hostId == null) {
            throw new TypeError("hostId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              hostId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} serviceType
       * @param {string} identifier
       */
      deleteServiceDefinition(serviceType, identifier) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              serviceType,
              identifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Finds a given service definition.
       *
       * @param {string} serviceType
       * @param {string} identifier
       * @param {boolean} allowFaultIn - If true, we will attempt to fault in a host instance mapping if in SPS.
       * @param {boolean} previewFaultIn - If true, we will calculate and return a host instance mapping, but not persist it.
       */
      getServiceDefinition(serviceType, identifier, allowFaultIn, previewFaultIn) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              serviceType,
              identifier
            };
            let queryValues = {
              allowFaultIn,
              previewFaultIn
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, LocationsInterfaces.TypeInfo.ServiceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} serviceType
       */
      getServiceDefinitions(serviceType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              serviceType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, LocationsInterfaces.TypeInfo.ServiceDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {VSSInterfaces.VssJsonCollectionWrapperV<LocationsInterfaces.ServiceDefinition[]>} serviceDefinitions
       */
      updateServiceDefinitions(serviceDefinitions) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, serviceDefinitions, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.LocationsApi = LocationsApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/ManagementInterfaces.js
var require_ManagementInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/ManagementInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.Plan = void 0;
    var Plan;
    (function(Plan2) {
      Plan2[Plan2["None"] = 0] = "None";
      Plan2[Plan2["CodeSecurity"] = 1] = "CodeSecurity";
      Plan2[Plan2["SecretProtection"] = 2] = "SecretProtection";
      Plan2[Plan2["All"] = 3] = "All";
    })(Plan = exports2.Plan || (exports2.Plan = {}));
    exports2.TypeInfo = {
      AdvSecEnablementSettings: {},
      AdvSecEnablementStatus: {},
      BillableCommitterDetails: {},
      CodeSecurityFeatures: {},
      MeterUsage: {},
      MeterUsageForPlan: {},
      OrgEnablementSettings: {},
      Plan: {
        enumValues: {
          "codeSecurity": 1,
          "secretProtection": 2,
          "all": 3
        }
      },
      ProjectEnablementSettings: {},
      RepoEnablementSettings: {},
      SecretProtectionFeatures: {}
    };
    exports2.TypeInfo.AdvSecEnablementSettings.fields = {
      reposEnablementStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AdvSecEnablementStatus
      }
    };
    exports2.TypeInfo.AdvSecEnablementStatus.fields = {
      advSecEnablementLastChangedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BillableCommitterDetails.fields = {
      commitTime: {
        isDate: true
      },
      pushedTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.CodeSecurityFeatures.fields = {
      codeSecurityEnablementLastChangedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.MeterUsage.fields = {
      billingDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.MeterUsageForPlan.fields = {
      billingDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.OrgEnablementSettings.fields = {
      codeSecurityFeatures: {
        typeInfo: exports2.TypeInfo.CodeSecurityFeatures
      },
      reposEnablementStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RepoEnablementSettings
      },
      secretProtectionFeatures: {
        typeInfo: exports2.TypeInfo.SecretProtectionFeatures
      }
    };
    exports2.TypeInfo.ProjectEnablementSettings.fields = {
      codeSecurityFeatures: {
        typeInfo: exports2.TypeInfo.CodeSecurityFeatures
      },
      reposEnablementStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RepoEnablementSettings
      },
      secretProtectionFeatures: {
        typeInfo: exports2.TypeInfo.SecretProtectionFeatures
      }
    };
    exports2.TypeInfo.RepoEnablementSettings.fields = {
      codeSecurityFeatures: {
        typeInfo: exports2.TypeInfo.CodeSecurityFeatures
      },
      secretProtectionFeatures: {
        typeInfo: exports2.TypeInfo.SecretProtectionFeatures
      }
    };
    exports2.TypeInfo.SecretProtectionFeatures.fields = {
      secretProtectionEnablementLastChangedDate: {
        isDate: true
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/ManagementApi.js
var require_ManagementApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/ManagementApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ManagementApi = void 0;
    var basem = require_ClientApiBases();
    var ManagementInterfaces = require_ManagementInterfaces();
    var ManagementApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Management-api", options2);
      }
      /**
       * Determines if Code Security, Secret Protection, and their features are enabled for the repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       * @param {boolean} includeAllProperties - When true, will also determine if pushes are blocked when secrets are detected
       */
      getRepoEnablementStatus2(project, repository, includeAllProperties) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "1fcb5ea0-1e19-4c71-ab26-0784bce2d551", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.RepoEnablementSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the enablement status of Code Security and Secret Protection, along with their respective features, for a given repository.
       *
       * @param {ManagementInterfaces.RepoEnablementSettings} savedAdvSecEnablementStatus - new status
       * @param {string} project - Project ID or project name
       * @param {string} repository - Name or ID of the repository
       */
      updateRepoAdvSecEnablementStatus2(savedAdvSecEnablementStatus, project, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "1fcb5ea0-1e19-4c71-ab26-0784bce2d551", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, savedAdvSecEnablementStatus, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * During multi-org billing computation in primary scale unit(EUS21), this API is used to create billing snapshot for a specific org. Primary scale unit will call this API for each org in different scsle units to create billing snapshot. Data will be stored in the org specific partition DB -> billing snapshot table. This is needed as customers will fetch billing data from their org specific partition DB.
       *
       * @param {ManagementInterfaces.MeterUsage} meterUsage
       */
      createBillingSnapshot(meterUsage) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, meterUsage, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all billable committers details, including those not matched with a VSID.
       *
       * @param {Date} billingDate - The date to query, or if not provided, today
       */
      getBillableCommitterDetails(billingDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Details"
            };
            let queryValues = {
              billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.BillableCommitterDetails, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getLastMeterUsage() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Last"
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.MeterUsage, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get commiters used when calculating billing information.
       *
       * @param {Date} billingDate - The date to query, or if not provided, today
       */
      getMeterUsage(billingDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            let queryValues = {
              billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.MeterUsage, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * During multi-org billing computation in primary scale unit(EUS21), this API is used to create billing snapshot for a specific org. Primary scale unit will call this API for each org in different scsle units to create billing snapshot. Data will be stored in the org specific partition DB -> billing snapshot table. This is needed as customers will fetch billing data from their org specific partition DB.
       *
       * @param {ManagementInterfaces.MeterUsageForPlan} meterUsage
       * @param {ManagementInterfaces.Plan} plan
       */
      createBillingSnapshot2(meterUsage, plan) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (plan == null) {
            throw new TypeError("plan can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            let queryValues = {
              plan
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "9615bfcf-d592-4664-9059-4be0150ff16d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, meterUsage, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all billable committers details, including those not matched with a VSID.
       *
       * @param {ManagementInterfaces.Plan} plan - The plan to query. Plans supported: CodeSecurity and SecretProtection. This is a mandatory parameter.
       * @param {Date} billingDate - The date to query, or if not provided, today
       */
      getBillableCommitterDetails2(plan, billingDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (plan == null) {
            throw new TypeError("plan can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Details"
            };
            let queryValues = {
              plan,
              billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "9615bfcf-d592-4664-9059-4be0150ff16d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.BillableCommitterDetails, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ManagementInterfaces.Plan} plan
       */
      getLastMeterUsage2(plan) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (plan == null) {
            throw new TypeError("plan can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Last"
            };
            let queryValues = {
              plan
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "9615bfcf-d592-4664-9059-4be0150ff16d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.MeterUsageForPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get commiters used when calculating billing information.
       *
       * @param {ManagementInterfaces.Plan} plan - The plan to query. Plans supported: CodeSecurity and SecretProtection. This is a mandatory parameter.
       * @param {Date} billingDate - The date to query, or if not provided, today
       */
      getMeterUsage2(plan, billingDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (plan == null) {
            throw new TypeError("plan can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            let queryValues = {
              plan,
              billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "9615bfcf-d592-4664-9059-4be0150ff16d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.MeterUsageForPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current status of Advanced Security for the organization
       *
       * @param {boolean} includeAllProperties - When true, also determine if pushes are blocked if they contain secrets
       */
      getOrgEnablementStatus(includeAllProperties) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d0c0450f-8882-46f4-a5a8-e48fea3095b0", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.AdvSecEnablementSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of Advanced Security for the organization
       *
       * @param {ManagementInterfaces.AdvSecEnablementSettingsUpdate} savedAdvSecEnablementStatus - The new status
       */
      updateOrgEnablementStatus(savedAdvSecEnablementStatus) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d0c0450f-8882-46f4-a5a8-e48fea3095b0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, savedAdvSecEnablementStatus, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current status of Advanced Security for the organization
       *
       * @param {boolean} includeAllProperties - When true, also determine if pushes are blocked if they contain secrets
       */
      getOrgEnablementStatus2(includeAllProperties) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "41d7fd8d-71f1-485f-b48d-f68eb7f04a6b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.OrgEnablementSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of Advanced Security for the organization
       *
       * @param {ManagementInterfaces.OrgEnablementSettings} orgEnablementSettings - The new status
       */
      updateOrgEnablementStatus2(orgEnablementSettings) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "41d7fd8d-71f1-485f-b48d-f68eb7f04a6b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, orgEnablementSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the pushers that would be added to the customer's usage if Advanced Security was enabled for this organization.
       *
       */
      getEstimatedBillablePushersDetailsForOrg() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Details"
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "10a9e9c3-89bf-4312-92ed-139ddbcd2e28", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the committers that would be added to the customer's usage if Advanced Security was enabled for this organization.
       *
       */
      getEstimatedOrgBillablePushers() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "10a9e9c3-89bf-4312-92ed-139ddbcd2e28", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the pushers that would be added to the customer's usage if Advanced Security was enabled for this organization.
       *
       * @param {ManagementInterfaces.Plan} plan - The plan to query.
       */
      getEstimatedBillablePushersDetailsForOrg2(plan) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (plan == null) {
            throw new TypeError("plan can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            let queryValues = {
              plan
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "3fae4c8a-0597-45be-bf45-2925fe8036b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current status of Advanced Security for a project
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} includeAllProperties - When true, also determine if pushes are blocked if they contain secrets
       */
      getProjectEnablementStatus(project, includeAllProperties) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "6b9a4b47-5f2d-40f3-8286-b0152079074d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.AdvSecEnablementSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of Advanced Security for the project
       *
       * @param {ManagementInterfaces.AdvSecEnablementSettingsUpdate} savedAdvSecEnablementStatus - The new status
       * @param {string} project - Project ID or project name
       */
      updateProjectEnablementStatus(savedAdvSecEnablementStatus, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "6b9a4b47-5f2d-40f3-8286-b0152079074d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, savedAdvSecEnablementStatus, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current status of Advanced Security for a project
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} includeAllProperties - When true, also determine if pushes are blocked if they contain secrets
       */
      getProjectEnablementStatus2(project, includeAllProperties) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "534d98d2-d5a0-4bf4-94b3-1328019302f8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.ProjectEnablementSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of Advanced Security for the project
       *
       * @param {ManagementInterfaces.ProjectEnablementSettings} projectEnablementSettings - The new status
       * @param {string} project - Project ID or project name
       */
      updateProjectEnablementStatus2(projectEnablementSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "534d98d2-d5a0-4bf4-94b3-1328019302f8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, projectEnablementSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the pushers that would be added to the customer's usage if Advanced Security was enabled for this project.
       *
       * @param {string} project - Project ID or project name
       */
      getEstimatedBillablePushersDetailsForProject(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Details",
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "bf09cb40-ecf4-4496-8cf7-9ec60c64fd3e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the number of committers that would be added to the customer's usage if Advanced Security was enabled for this project.
       *
       * @param {string} project - Project ID or project name
       */
      getEstimatedBillablePushersForProject(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "bf09cb40-ecf4-4496-8cf7-9ec60c64fd3e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the pushers that would be added to the customer's usage if Advanced Security was enabled for this project.
       *
       * @param {string} project - Project ID or project name
       * @param {ManagementInterfaces.Plan} plan
       */
      getEstimatedBillablePushersDetailsForProject2(project, plan) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              project
            };
            let queryValues = {
              plan
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "ffd0d73d-54b4-4f56-9d83-e8b08db8bfcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Determine if Advanced Security is enabled for a repository
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       * @param {boolean} includeAllProperties - When true, will also determine if pushes are blocked when secrets are detected
       */
      getRepoEnablementStatus(project, repository, includeAllProperties) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d11a1c2b-b904-43dc-b970-bf42486262db", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.AdvSecEnablementStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the enablement of Advanced Security for a repository
       *
       * @param {ManagementInterfaces.AdvSecEnablementStatusUpdate} savedAdvSecEnablementStatus - new status
       * @param {string} project - Project ID or project name
       * @param {string} repository - Name or ID of the repository
       */
      updateRepoAdvSecEnablementStatus(savedAdvSecEnablementStatus, project, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d11a1c2b-b904-43dc-b970-bf42486262db", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, savedAdvSecEnablementStatus, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the committers that would be added to the customer's usage if Advanced Security was enabled for this repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository
       */
      getEstimatedBillableCommitersDetailsForRepo(project, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Details",
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "b60f1ebf-ae77-4557-bd7f-ae3d5598dd1f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the committers that would be added to the customer's usage if Advanced Security was enabled for this repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       */
      getEstimatedBillableCommittersForRepo(project, repository) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "b60f1ebf-ae77-4557-bd7f-ae3d5598dd1f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the pushers that would be added to the customer's usage if Advanced Security was enabled for this repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       * @param {ManagementInterfaces.Plan} plan - The plan to query.
       */
      getEstimatedRepoBillableCommittersDetails2(project, repository, plan) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              project,
              repository
            };
            let queryValues = {
              plan
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "1a7b7e0d-e0b6-48b4-b0b6-9b6c2a1984e3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ManagementApi = ManagementApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/NotificationInterfaces.js
var require_NotificationInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/NotificationInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.SubscriptionTemplateType = exports2.SubscriptionTemplateQueryFlags = exports2.SubscriptionStatus = exports2.SubscriptionQueryFlags = exports2.SubscriptionPermissions = exports2.SubscriptionFlags = exports2.SubscriptionFieldType = exports2.SubscriberFlags = exports2.NotificationSubscriberDeliveryPreference = exports2.NotificationStatisticType = exports2.NotificationReasonType = exports2.NotificationOperation = exports2.EventTypeQueryFlags = exports2.EventPublisherQueryFlags = exports2.EvaluationOperationStatus = exports2.DefaultGroupDeliveryPreference = void 0;
    var DefaultGroupDeliveryPreference;
    (function(DefaultGroupDeliveryPreference2) {
      DefaultGroupDeliveryPreference2[DefaultGroupDeliveryPreference2["NoDelivery"] = -1] = "NoDelivery";
      DefaultGroupDeliveryPreference2[DefaultGroupDeliveryPreference2["EachMember"] = 2] = "EachMember";
    })(DefaultGroupDeliveryPreference = exports2.DefaultGroupDeliveryPreference || (exports2.DefaultGroupDeliveryPreference = {}));
    var EvaluationOperationStatus;
    (function(EvaluationOperationStatus2) {
      EvaluationOperationStatus2[EvaluationOperationStatus2["NotSet"] = 0] = "NotSet";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Queued"] = 1] = "Queued";
      EvaluationOperationStatus2[EvaluationOperationStatus2["InProgress"] = 2] = "InProgress";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Cancelled"] = 3] = "Cancelled";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Succeeded"] = 4] = "Succeeded";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Failed"] = 5] = "Failed";
      EvaluationOperationStatus2[EvaluationOperationStatus2["TimedOut"] = 6] = "TimedOut";
      EvaluationOperationStatus2[EvaluationOperationStatus2["NotFound"] = 7] = "NotFound";
    })(EvaluationOperationStatus = exports2.EvaluationOperationStatus || (exports2.EvaluationOperationStatus = {}));
    var EventPublisherQueryFlags;
    (function(EventPublisherQueryFlags2) {
      EventPublisherQueryFlags2[EventPublisherQueryFlags2["None"] = 0] = "None";
      EventPublisherQueryFlags2[EventPublisherQueryFlags2["IncludeRemoteServices"] = 2] = "IncludeRemoteServices";
    })(EventPublisherQueryFlags = exports2.EventPublisherQueryFlags || (exports2.EventPublisherQueryFlags = {}));
    var EventTypeQueryFlags;
    (function(EventTypeQueryFlags2) {
      EventTypeQueryFlags2[EventTypeQueryFlags2["None"] = 0] = "None";
      EventTypeQueryFlags2[EventTypeQueryFlags2["IncludeFields"] = 1] = "IncludeFields";
    })(EventTypeQueryFlags = exports2.EventTypeQueryFlags || (exports2.EventTypeQueryFlags = {}));
    var NotificationOperation;
    (function(NotificationOperation2) {
      NotificationOperation2[NotificationOperation2["None"] = 0] = "None";
      NotificationOperation2[NotificationOperation2["SuspendUnprocessed"] = 1] = "SuspendUnprocessed";
    })(NotificationOperation = exports2.NotificationOperation || (exports2.NotificationOperation = {}));
    var NotificationReasonType;
    (function(NotificationReasonType2) {
      NotificationReasonType2[NotificationReasonType2["Unknown"] = 0] = "Unknown";
      NotificationReasonType2[NotificationReasonType2["Follows"] = 1] = "Follows";
      NotificationReasonType2[NotificationReasonType2["Personal"] = 2] = "Personal";
      NotificationReasonType2[NotificationReasonType2["PersonalAlias"] = 3] = "PersonalAlias";
      NotificationReasonType2[NotificationReasonType2["DirectMember"] = 4] = "DirectMember";
      NotificationReasonType2[NotificationReasonType2["IndirectMember"] = 5] = "IndirectMember";
      NotificationReasonType2[NotificationReasonType2["GroupAlias"] = 6] = "GroupAlias";
      NotificationReasonType2[NotificationReasonType2["SubscriptionAlias"] = 7] = "SubscriptionAlias";
      NotificationReasonType2[NotificationReasonType2["SingleRole"] = 8] = "SingleRole";
      NotificationReasonType2[NotificationReasonType2["DirectMemberGroupRole"] = 9] = "DirectMemberGroupRole";
      NotificationReasonType2[NotificationReasonType2["InDirectMemberGroupRole"] = 10] = "InDirectMemberGroupRole";
      NotificationReasonType2[NotificationReasonType2["AliasMemberGroupRole"] = 11] = "AliasMemberGroupRole";
    })(NotificationReasonType = exports2.NotificationReasonType || (exports2.NotificationReasonType = {}));
    var NotificationStatisticType;
    (function(NotificationStatisticType2) {
      NotificationStatisticType2[NotificationStatisticType2["NotificationBySubscription"] = 0] = "NotificationBySubscription";
      NotificationStatisticType2[NotificationStatisticType2["EventsByEventType"] = 1] = "EventsByEventType";
      NotificationStatisticType2[NotificationStatisticType2["NotificationByEventType"] = 2] = "NotificationByEventType";
      NotificationStatisticType2[NotificationStatisticType2["EventsByEventTypePerUser"] = 3] = "EventsByEventTypePerUser";
      NotificationStatisticType2[NotificationStatisticType2["NotificationByEventTypePerUser"] = 4] = "NotificationByEventTypePerUser";
      NotificationStatisticType2[NotificationStatisticType2["Events"] = 5] = "Events";
      NotificationStatisticType2[NotificationStatisticType2["Notifications"] = 6] = "Notifications";
      NotificationStatisticType2[NotificationStatisticType2["NotificationFailureBySubscription"] = 7] = "NotificationFailureBySubscription";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedRangeStart"] = 100] = "UnprocessedRangeStart";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedEventsByPublisher"] = 101] = "UnprocessedEventsByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedEventDelayByPublisher"] = 102] = "UnprocessedEventDelayByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedNotificationsByChannelByPublisher"] = 103] = "UnprocessedNotificationsByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedNotificationDelayByChannelByPublisher"] = 104] = "UnprocessedNotificationDelayByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["DelayRangeStart"] = 200] = "DelayRangeStart";
      NotificationStatisticType2[NotificationStatisticType2["TotalPipelineTime"] = 201] = "TotalPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["NotificationPipelineTime"] = 202] = "NotificationPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["EventPipelineTime"] = 203] = "EventPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["HourlyRangeStart"] = 1e3] = "HourlyRangeStart";
      NotificationStatisticType2[NotificationStatisticType2["HourlyNotificationBySubscription"] = 1001] = "HourlyNotificationBySubscription";
      NotificationStatisticType2[NotificationStatisticType2["HourlyEventsByEventTypePerUser"] = 1002] = "HourlyEventsByEventTypePerUser";
      NotificationStatisticType2[NotificationStatisticType2["HourlyEvents"] = 1003] = "HourlyEvents";
      NotificationStatisticType2[NotificationStatisticType2["HourlyNotifications"] = 1004] = "HourlyNotifications";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedEventsByPublisher"] = 1101] = "HourlyUnprocessedEventsByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedEventDelayByPublisher"] = 1102] = "HourlyUnprocessedEventDelayByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedNotificationsByChannelByPublisher"] = 1103] = "HourlyUnprocessedNotificationsByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedNotificationDelayByChannelByPublisher"] = 1104] = "HourlyUnprocessedNotificationDelayByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyTotalPipelineTime"] = 1201] = "HourlyTotalPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["HourlyNotificationPipelineTime"] = 1202] = "HourlyNotificationPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["HourlyEventPipelineTime"] = 1203] = "HourlyEventPipelineTime";
    })(NotificationStatisticType = exports2.NotificationStatisticType || (exports2.NotificationStatisticType = {}));
    var NotificationSubscriberDeliveryPreference;
    (function(NotificationSubscriberDeliveryPreference2) {
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["NoDelivery"] = -1] = "NoDelivery";
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["PreferredEmailAddress"] = 1] = "PreferredEmailAddress";
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["EachMember"] = 2] = "EachMember";
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["UseDefault"] = 3] = "UseDefault";
    })(NotificationSubscriberDeliveryPreference = exports2.NotificationSubscriberDeliveryPreference || (exports2.NotificationSubscriberDeliveryPreference = {}));
    var SubscriberFlags;
    (function(SubscriberFlags2) {
      SubscriberFlags2[SubscriberFlags2["None"] = 0] = "None";
      SubscriberFlags2[SubscriberFlags2["DeliveryPreferencesEditable"] = 2] = "DeliveryPreferencesEditable";
      SubscriberFlags2[SubscriberFlags2["SupportsPreferredEmailAddressDelivery"] = 4] = "SupportsPreferredEmailAddressDelivery";
      SubscriberFlags2[SubscriberFlags2["SupportsEachMemberDelivery"] = 8] = "SupportsEachMemberDelivery";
      SubscriberFlags2[SubscriberFlags2["SupportsNoDelivery"] = 16] = "SupportsNoDelivery";
      SubscriberFlags2[SubscriberFlags2["IsUser"] = 32] = "IsUser";
      SubscriberFlags2[SubscriberFlags2["IsGroup"] = 64] = "IsGroup";
      SubscriberFlags2[SubscriberFlags2["IsTeam"] = 128] = "IsTeam";
    })(SubscriberFlags = exports2.SubscriberFlags || (exports2.SubscriberFlags = {}));
    var SubscriptionFieldType;
    (function(SubscriptionFieldType2) {
      SubscriptionFieldType2[SubscriptionFieldType2["String"] = 1] = "String";
      SubscriptionFieldType2[SubscriptionFieldType2["Integer"] = 2] = "Integer";
      SubscriptionFieldType2[SubscriptionFieldType2["DateTime"] = 3] = "DateTime";
      SubscriptionFieldType2[SubscriptionFieldType2["PlainText"] = 5] = "PlainText";
      SubscriptionFieldType2[SubscriptionFieldType2["Html"] = 7] = "Html";
      SubscriptionFieldType2[SubscriptionFieldType2["TreePath"] = 8] = "TreePath";
      SubscriptionFieldType2[SubscriptionFieldType2["History"] = 9] = "History";
      SubscriptionFieldType2[SubscriptionFieldType2["Double"] = 10] = "Double";
      SubscriptionFieldType2[SubscriptionFieldType2["Guid"] = 11] = "Guid";
      SubscriptionFieldType2[SubscriptionFieldType2["Boolean"] = 12] = "Boolean";
      SubscriptionFieldType2[SubscriptionFieldType2["Identity"] = 13] = "Identity";
      SubscriptionFieldType2[SubscriptionFieldType2["PicklistInteger"] = 14] = "PicklistInteger";
      SubscriptionFieldType2[SubscriptionFieldType2["PicklistString"] = 15] = "PicklistString";
      SubscriptionFieldType2[SubscriptionFieldType2["PicklistDouble"] = 16] = "PicklistDouble";
      SubscriptionFieldType2[SubscriptionFieldType2["TeamProject"] = 17] = "TeamProject";
    })(SubscriptionFieldType = exports2.SubscriptionFieldType || (exports2.SubscriptionFieldType = {}));
    var SubscriptionFlags;
    (function(SubscriptionFlags2) {
      SubscriptionFlags2[SubscriptionFlags2["None"] = 0] = "None";
      SubscriptionFlags2[SubscriptionFlags2["GroupSubscription"] = 1] = "GroupSubscription";
      SubscriptionFlags2[SubscriptionFlags2["ContributedSubscription"] = 2] = "ContributedSubscription";
      SubscriptionFlags2[SubscriptionFlags2["CanOptOut"] = 4] = "CanOptOut";
      SubscriptionFlags2[SubscriptionFlags2["TeamSubscription"] = 8] = "TeamSubscription";
      SubscriptionFlags2[SubscriptionFlags2["OneActorMatches"] = 16] = "OneActorMatches";
    })(SubscriptionFlags = exports2.SubscriptionFlags || (exports2.SubscriptionFlags = {}));
    var SubscriptionPermissions;
    (function(SubscriptionPermissions2) {
      SubscriptionPermissions2[SubscriptionPermissions2["None"] = 0] = "None";
      SubscriptionPermissions2[SubscriptionPermissions2["View"] = 1] = "View";
      SubscriptionPermissions2[SubscriptionPermissions2["Edit"] = 2] = "Edit";
      SubscriptionPermissions2[SubscriptionPermissions2["Delete"] = 4] = "Delete";
    })(SubscriptionPermissions = exports2.SubscriptionPermissions || (exports2.SubscriptionPermissions = {}));
    var SubscriptionQueryFlags;
    (function(SubscriptionQueryFlags2) {
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["None"] = 0] = "None";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeInvalidSubscriptions"] = 2] = "IncludeInvalidSubscriptions";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeDeletedSubscriptions"] = 4] = "IncludeDeletedSubscriptions";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeFilterDetails"] = 8] = "IncludeFilterDetails";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["AlwaysReturnBasicInformation"] = 16] = "AlwaysReturnBasicInformation";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeSystemSubscriptions"] = 32] = "IncludeSystemSubscriptions";
    })(SubscriptionQueryFlags = exports2.SubscriptionQueryFlags || (exports2.SubscriptionQueryFlags = {}));
    var SubscriptionStatus;
    (function(SubscriptionStatus2) {
      SubscriptionStatus2[SubscriptionStatus2["JailedByNotificationsVolume"] = -200] = "JailedByNotificationsVolume";
      SubscriptionStatus2[SubscriptionStatus2["PendingDeletion"] = -100] = "PendingDeletion";
      SubscriptionStatus2[SubscriptionStatus2["DisabledArgumentException"] = -12] = "DisabledArgumentException";
      SubscriptionStatus2[SubscriptionStatus2["DisabledProjectInvalid"] = -11] = "DisabledProjectInvalid";
      SubscriptionStatus2[SubscriptionStatus2["DisabledMissingPermissions"] = -10] = "DisabledMissingPermissions";
      SubscriptionStatus2[SubscriptionStatus2["DisabledFromProbation"] = -9] = "DisabledFromProbation";
      SubscriptionStatus2[SubscriptionStatus2["DisabledInactiveIdentity"] = -8] = "DisabledInactiveIdentity";
      SubscriptionStatus2[SubscriptionStatus2["DisabledMessageQueueNotSupported"] = -7] = "DisabledMessageQueueNotSupported";
      SubscriptionStatus2[SubscriptionStatus2["DisabledMissingIdentity"] = -6] = "DisabledMissingIdentity";
      SubscriptionStatus2[SubscriptionStatus2["DisabledInvalidRoleExpression"] = -5] = "DisabledInvalidRoleExpression";
      SubscriptionStatus2[SubscriptionStatus2["DisabledInvalidPathClause"] = -4] = "DisabledInvalidPathClause";
      SubscriptionStatus2[SubscriptionStatus2["DisabledAsDuplicateOfDefault"] = -3] = "DisabledAsDuplicateOfDefault";
      SubscriptionStatus2[SubscriptionStatus2["DisabledByAdmin"] = -2] = "DisabledByAdmin";
      SubscriptionStatus2[SubscriptionStatus2["Disabled"] = -1] = "Disabled";
      SubscriptionStatus2[SubscriptionStatus2["Enabled"] = 0] = "Enabled";
      SubscriptionStatus2[SubscriptionStatus2["EnabledOnProbation"] = 1] = "EnabledOnProbation";
    })(SubscriptionStatus = exports2.SubscriptionStatus || (exports2.SubscriptionStatus = {}));
    var SubscriptionTemplateQueryFlags;
    (function(SubscriptionTemplateQueryFlags2) {
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["None"] = 0] = "None";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeUser"] = 1] = "IncludeUser";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeGroup"] = 2] = "IncludeGroup";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeUserAndGroup"] = 4] = "IncludeUserAndGroup";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeEventTypeInformation"] = 22] = "IncludeEventTypeInformation";
    })(SubscriptionTemplateQueryFlags = exports2.SubscriptionTemplateQueryFlags || (exports2.SubscriptionTemplateQueryFlags = {}));
    var SubscriptionTemplateType;
    (function(SubscriptionTemplateType2) {
      SubscriptionTemplateType2[SubscriptionTemplateType2["User"] = 0] = "User";
      SubscriptionTemplateType2[SubscriptionTemplateType2["Team"] = 1] = "Team";
      SubscriptionTemplateType2[SubscriptionTemplateType2["Both"] = 2] = "Both";
      SubscriptionTemplateType2[SubscriptionTemplateType2["None"] = 3] = "None";
    })(SubscriptionTemplateType = exports2.SubscriptionTemplateType || (exports2.SubscriptionTemplateType = {}));
    exports2.TypeInfo = {
      ActorNotificationReason: {},
      BatchNotificationOperation: {},
      DefaultGroupDeliveryPreference: {
        enumValues: {
          "noDelivery": -1,
          "eachMember": 2
        }
      },
      EvaluationOperationStatus: {
        enumValues: {
          "notSet": 0,
          "queued": 1,
          "inProgress": 2,
          "cancelled": 3,
          "succeeded": 4,
          "failed": 5,
          "timedOut": 6,
          "notFound": 7
        }
      },
      EventBacklogStatus: {},
      EventProcessingLog: {},
      EventPublisherQueryFlags: {
        enumValues: {
          "none": 0,
          "includeRemoteServices": 2
        }
      },
      EventTypeQueryFlags: {
        enumValues: {
          "none": 0,
          "includeFields": 1
        }
      },
      INotificationDiagnosticLog: {},
      NotificationAdminSettings: {},
      NotificationAdminSettingsUpdateParameters: {},
      NotificationBacklogStatus: {},
      NotificationDeliveryLog: {},
      NotificationDiagnosticLog: {},
      NotificationEventBacklogStatus: {},
      NotificationEventField: {},
      NotificationEventFieldType: {},
      NotificationEventType: {},
      NotificationJobDiagnosticLog: {},
      NotificationOperation: {
        enumValues: {
          "none": 0,
          "suspendUnprocessed": 1
        }
      },
      NotificationReason: {},
      NotificationReasonType: {
        enumValues: {
          "unknown": 0,
          "follows": 1,
          "personal": 2,
          "personalAlias": 3,
          "directMember": 4,
          "indirectMember": 5,
          "groupAlias": 6,
          "subscriptionAlias": 7,
          "singleRole": 8,
          "directMemberGroupRole": 9,
          "inDirectMemberGroupRole": 10,
          "aliasMemberGroupRole": 11
        }
      },
      NotificationStatistic: {},
      NotificationStatisticsQuery: {},
      NotificationStatisticsQueryConditions: {},
      NotificationStatisticType: {
        enumValues: {
          "notificationBySubscription": 0,
          "eventsByEventType": 1,
          "notificationByEventType": 2,
          "eventsByEventTypePerUser": 3,
          "notificationByEventTypePerUser": 4,
          "events": 5,
          "notifications": 6,
          "notificationFailureBySubscription": 7,
          "unprocessedRangeStart": 100,
          "unprocessedEventsByPublisher": 101,
          "unprocessedEventDelayByPublisher": 102,
          "unprocessedNotificationsByChannelByPublisher": 103,
          "unprocessedNotificationDelayByChannelByPublisher": 104,
          "delayRangeStart": 200,
          "totalPipelineTime": 201,
          "notificationPipelineTime": 202,
          "eventPipelineTime": 203,
          "hourlyRangeStart": 1e3,
          "hourlyNotificationBySubscription": 1001,
          "hourlyEventsByEventTypePerUser": 1002,
          "hourlyEvents": 1003,
          "hourlyNotifications": 1004,
          "hourlyUnprocessedEventsByPublisher": 1101,
          "hourlyUnprocessedEventDelayByPublisher": 1102,
          "hourlyUnprocessedNotificationsByChannelByPublisher": 1103,
          "hourlyUnprocessedNotificationDelayByChannelByPublisher": 1104,
          "hourlyTotalPipelineTime": 1201,
          "hourlyNotificationPipelineTime": 1202,
          "hourlyEventPipelineTime": 1203
        }
      },
      NotificationSubscriber: {},
      NotificationSubscriberDeliveryPreference: {
        enumValues: {
          "noDelivery": -1,
          "preferredEmailAddress": 1,
          "eachMember": 2,
          "useDefault": 3
        }
      },
      NotificationSubscriberUpdateParameters: {},
      NotificationSubscription: {},
      NotificationSubscriptionTemplate: {},
      NotificationSubscriptionUpdateParameters: {},
      SubscriberFlags: {
        enumValues: {
          "none": 0,
          "deliveryPreferencesEditable": 2,
          "supportsPreferredEmailAddressDelivery": 4,
          "supportsEachMemberDelivery": 8,
          "supportsNoDelivery": 16,
          "isUser": 32,
          "isGroup": 64,
          "isTeam": 128
        }
      },
      SubscriptionDiagnostics: {},
      SubscriptionEvaluationRequest: {},
      SubscriptionEvaluationResult: {},
      SubscriptionFieldType: {
        enumValues: {
          "string": 1,
          "integer": 2,
          "dateTime": 3,
          "plainText": 5,
          "html": 7,
          "treePath": 8,
          "history": 9,
          "double": 10,
          "guid": 11,
          "boolean": 12,
          "identity": 13,
          "picklistInteger": 14,
          "picklistString": 15,
          "picklistDouble": 16,
          "teamProject": 17
        }
      },
      SubscriptionFlags: {
        enumValues: {
          "none": 0,
          "groupSubscription": 1,
          "contributedSubscription": 2,
          "canOptOut": 4,
          "teamSubscription": 8,
          "oneActorMatches": 16
        }
      },
      SubscriptionPermissions: {
        enumValues: {
          "none": 0,
          "view": 1,
          "edit": 2,
          "delete": 4
        }
      },
      SubscriptionQuery: {},
      SubscriptionQueryCondition: {},
      SubscriptionQueryFlags: {
        enumValues: {
          "none": 0,
          "includeInvalidSubscriptions": 2,
          "includeDeletedSubscriptions": 4,
          "includeFilterDetails": 8,
          "alwaysReturnBasicInformation": 16,
          "includeSystemSubscriptions": 32
        }
      },
      SubscriptionStatus: {
        enumValues: {
          "jailedByNotificationsVolume": -200,
          "pendingDeletion": -100,
          "disabledArgumentException": -12,
          "disabledProjectInvalid": -11,
          "disabledMissingPermissions": -10,
          "disabledFromProbation": -9,
          "disabledInactiveIdentity": -8,
          "disabledMessageQueueNotSupported": -7,
          "disabledMissingIdentity": -6,
          "disabledInvalidRoleExpression": -5,
          "disabledInvalidPathClause": -4,
          "disabledAsDuplicateOfDefault": -3,
          "disabledByAdmin": -2,
          "disabled": -1,
          "enabled": 0,
          "enabledOnProbation": 1
        }
      },
      SubscriptionTemplateQueryFlags: {
        enumValues: {
          "none": 0,
          "includeUser": 1,
          "includeGroup": 2,
          "includeUserAndGroup": 4,
          "includeEventTypeInformation": 22
        }
      },
      SubscriptionTemplateType: {
        enumValues: {
          "user": 0,
          "team": 1,
          "both": 2,
          "none": 3
        }
      },
      SubscriptionTraceDiagnosticLog: {},
      SubscriptionTraceEventProcessingLog: {},
      SubscriptionTraceNotificationDeliveryLog: {},
      SubscriptionTracing: {}
    };
    exports2.TypeInfo.ActorNotificationReason.fields = {
      notificationReasonType: {
        enumType: exports2.TypeInfo.NotificationReasonType
      }
    };
    exports2.TypeInfo.BatchNotificationOperation.fields = {
      notificationOperation: {
        enumType: exports2.TypeInfo.NotificationOperation
      }
    };
    exports2.TypeInfo.EventBacklogStatus.fields = {
      captureTime: {
        isDate: true
      },
      lastEventBatchStartTime: {
        isDate: true
      },
      lastEventProcessedTime: {
        isDate: true
      },
      lastJobBatchStartTime: {
        isDate: true
      },
      lastJobProcessedTime: {
        isDate: true
      },
      oldestPendingEventTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.EventProcessingLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.INotificationDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationAdminSettings.fields = {
      defaultGroupDeliveryPreference: {
        enumType: exports2.TypeInfo.DefaultGroupDeliveryPreference
      }
    };
    exports2.TypeInfo.NotificationAdminSettingsUpdateParameters.fields = {
      defaultGroupDeliveryPreference: {
        enumType: exports2.TypeInfo.DefaultGroupDeliveryPreference
      }
    };
    exports2.TypeInfo.NotificationBacklogStatus.fields = {
      captureTime: {
        isDate: true
      },
      lastJobBatchStartTime: {
        isDate: true
      },
      lastJobProcessedTime: {
        isDate: true
      },
      lastNotificationBatchStartTime: {
        isDate: true
      },
      lastNotificationProcessedTime: {
        isDate: true
      },
      oldestPendingNotificationTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationDeliveryLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationEventBacklogStatus.fields = {
      eventBacklogStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.EventBacklogStatus
      },
      notificationBacklogStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.NotificationBacklogStatus
      }
    };
    exports2.TypeInfo.NotificationEventField.fields = {
      fieldType: {
        typeInfo: exports2.TypeInfo.NotificationEventFieldType
      }
    };
    exports2.TypeInfo.NotificationEventFieldType.fields = {
      subscriptionFieldType: {
        enumType: exports2.TypeInfo.SubscriptionFieldType
      }
    };
    exports2.TypeInfo.NotificationEventType.fields = {
      fields: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.NotificationEventField
      }
    };
    exports2.TypeInfo.NotificationJobDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationReason.fields = {
      notificationReasonType: {
        enumType: exports2.TypeInfo.NotificationReasonType
      }
    };
    exports2.TypeInfo.NotificationStatistic.fields = {
      date: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.NotificationStatisticType
      }
    };
    exports2.TypeInfo.NotificationStatisticsQuery.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.NotificationStatisticsQueryConditions
      }
    };
    exports2.TypeInfo.NotificationStatisticsQueryConditions.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.NotificationStatisticType
      }
    };
    exports2.TypeInfo.NotificationSubscriber.fields = {
      deliveryPreference: {
        enumType: exports2.TypeInfo.NotificationSubscriberDeliveryPreference
      },
      flags: {
        enumType: exports2.TypeInfo.SubscriberFlags
      }
    };
    exports2.TypeInfo.NotificationSubscriberUpdateParameters.fields = {
      deliveryPreference: {
        enumType: exports2.TypeInfo.NotificationSubscriberDeliveryPreference
      }
    };
    exports2.TypeInfo.NotificationSubscription.fields = {
      diagnostics: {
        typeInfo: exports2.TypeInfo.SubscriptionDiagnostics
      },
      flags: {
        enumType: exports2.TypeInfo.SubscriptionFlags
      },
      modifiedDate: {
        isDate: true
      },
      permissions: {
        enumType: exports2.TypeInfo.SubscriptionPermissions
      },
      status: {
        enumType: exports2.TypeInfo.SubscriptionStatus
      }
    };
    exports2.TypeInfo.NotificationSubscriptionTemplate.fields = {
      notificationEventInformation: {
        typeInfo: exports2.TypeInfo.NotificationEventType
      },
      type: {
        enumType: exports2.TypeInfo.SubscriptionTemplateType
      }
    };
    exports2.TypeInfo.NotificationSubscriptionUpdateParameters.fields = {
      status: {
        enumType: exports2.TypeInfo.SubscriptionStatus
      }
    };
    exports2.TypeInfo.SubscriptionDiagnostics.fields = {
      deliveryResults: {
        typeInfo: exports2.TypeInfo.SubscriptionTracing
      },
      deliveryTracing: {
        typeInfo: exports2.TypeInfo.SubscriptionTracing
      },
      evaluationTracing: {
        typeInfo: exports2.TypeInfo.SubscriptionTracing
      }
    };
    exports2.TypeInfo.SubscriptionEvaluationRequest.fields = {
      minEventsCreatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionEvaluationResult.fields = {
      evaluationJobStatus: {
        enumType: exports2.TypeInfo.EvaluationOperationStatus
      }
    };
    exports2.TypeInfo.SubscriptionQuery.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SubscriptionQueryCondition
      },
      queryFlags: {
        enumType: exports2.TypeInfo.SubscriptionQueryFlags
      }
    };
    exports2.TypeInfo.SubscriptionQueryCondition.fields = {
      flags: {
        enumType: exports2.TypeInfo.SubscriptionFlags
      }
    };
    exports2.TypeInfo.SubscriptionTraceDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionTraceEventProcessingLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionTraceNotificationDeliveryLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionTracing.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/NotificationApi.js
var require_NotificationApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/NotificationApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotificationApi = void 0;
    var basem = require_ClientApiBases();
    var NotificationInterfaces = require_NotificationInterfaces();
    var VSSInterfaces = require_VSSInterfaces();
    var NotificationApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Notification-api", options2);
      }
      /**
       * @param {NotificationInterfaces.BatchNotificationOperation} operation
       */
      performBatchNotificationOperations(operation) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "8f3c6ab2-5bae-4537-b16e-f84e0955599e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, operation, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of diagnostic logs for this service.
       *
       * @param {string} source - ID specifying which type of logs to check diagnostics for.
       * @param {string} entryId - The ID of the specific log to query for.
       * @param {Date} startTime - Start time for the time range to query in.
       * @param {Date} endTime - End time for the time range to query in.
       */
      listLogs(source, entryId, startTime, endTime) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              source,
              entryId
            };
            let queryValues = {
              startTime,
              endTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "991842f3-eb16-4aea-ac81-81353ef2b75c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.INotificationDiagnosticLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the diagnostics settings for a subscription.
       *
       * @param {string} subscriptionId - The id of the notifications subscription.
       */
      getSubscriptionDiagnostics(subscriptionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "20f1929d-4be7-4c2e-a74e-d47640ff3418", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.SubscriptionDiagnostics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the diagnostics settings for a subscription.
       *
       * @param {NotificationInterfaces.UpdateSubscripitonDiagnosticsParameters} updateParameters
       * @param {string} subscriptionId - The id of the notifications subscription.
       */
      updateSubscriptionDiagnostics(updateParameters, subscriptionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "20f1929d-4be7-4c2e-a74e-d47640ff3418", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.SubscriptionDiagnostics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Publish an event. This request must be directed to the service "extmgmt".
       *
       * @param {VSSInterfaces.VssNotificationEvent} notificationEvent
       */
      publishEvent(notificationEvent) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "14c57b7a-c0e6-4555-9f51-e067188fdd8e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notificationEvent, options2);
              let ret = this.formatResponse(res.result, VSSInterfaces.TypeInfo.VssNotificationEvent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Tranform a notification event.
       *
       * @param {NotificationInterfaces.EventTransformRequest} transformRequest - Object to be transformed.
       */
      transformEvent(transformRequest) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "9463a800-1b44-450e-9083-f948ea174b45", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, transformRequest, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NotificationInterfaces.FieldValuesQuery} inputValuesQuery
       * @param {string} eventType
       */
      queryEventTypes(inputValuesQuery, eventType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              eventType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "b5bbdd21-c178-4398-b6db-0166d910028a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, inputValuesQuery, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationEventField, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific event type.
       *
       * @param {string} eventType - The ID of the event type.
       */
      getEventType(eventType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              eventType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cc84fb5f-6247-4c7a-aeae-e5a3c3fddb21", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationEventType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List available event types for this service. Optionally filter by only event types for the specified publisher.
       *
       * @param {string} publisherId - Limit to event types for this publisher
       */
      listEventTypes(publisherId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              publisherId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cc84fb5f-6247-4c7a-aeae-e5a3c3fddb21", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationEventType, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} notificationId
       */
      getNotificationReasons(notificationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              notificationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "19824fa9-1c76-40e6-9cce-cf0b9ca1cb60", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationReason, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} notificationIds
       */
      listNotificationReasons(notificationIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              notificationIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "19824fa9-1c76-40e6-9cce-cf0b9ca1cb60", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationReason, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getSettings() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cbe076d8-2803-45ff-8d8d-44653686ea2a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationAdminSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NotificationInterfaces.NotificationAdminSettingsUpdateParameters} updateParameters
       */
      updateSettings(updateParameters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cbe076d8-2803-45ff-8d8d-44653686ea2a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationAdminSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get delivery preferences of a notifications subscriber.
       *
       * @param {string} subscriberId - ID of the user or group.
       */
      getSubscriber(subscriberId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "4d5caff1-25ba-430b-b808-7a1f352cc197", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscriber, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update delivery preferences of a notifications subscriber.
       *
       * @param {NotificationInterfaces.NotificationSubscriberUpdateParameters} updateParameters
       * @param {string} subscriberId - ID of the user or group.
       */
      updateSubscriber(updateParameters, subscriberId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "4d5caff1-25ba-430b-b808-7a1f352cc197", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscriber, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query for subscriptions. A subscription is returned if it matches one or more of the specified conditions.
       *
       * @param {NotificationInterfaces.SubscriptionQuery} subscriptionQuery
       */
      querySubscriptions(subscriptionQuery) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "6864db85-08c0-4006-8e8e-cc1bebe31675", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, subscriptionQuery, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new subscription.
       *
       * @param {NotificationInterfaces.NotificationSubscriptionCreateParameters} createParameters
       */
      createSubscription(createParameters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createParameters, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a subscription.
       *
       * @param {string} subscriptionId
       */
      deleteSubscription(subscriptionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a notification subscription by its ID.
       *
       * @param {string} subscriptionId
       * @param {NotificationInterfaces.SubscriptionQueryFlags} queryFlags
       */
      getSubscription(subscriptionId, queryFlags) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            let queryValues = {
              queryFlags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of notification subscriptions, either by subscription IDs or by all subscriptions for a given user or group.
       *
       * @param {string} targetId - User or Group ID
       * @param {string[]} ids - List of subscription IDs
       * @param {NotificationInterfaces.SubscriptionQueryFlags} queryFlags
       */
      listSubscriptions(targetId, ids, queryFlags) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              targetId,
              ids: ids && ids.join(","),
              queryFlags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an existing subscription. Depending on the type of subscription and permissions, the caller can update the description, filter settings, channel (delivery) settings and more.
       *
       * @param {NotificationInterfaces.NotificationSubscriptionUpdateParameters} updateParameters
       * @param {string} subscriptionId
       */
      updateSubscription(updateParameters, subscriptionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get available subscription templates.
       *
       */
      getSubscriptionTemplates() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "fa5d24ba-7484-4f3d-888d-4ec6b1974082", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscriptionTemplate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Publish an event. This request is only for the Token service since it's a deploy only service.
       *
       * @param {VSSInterfaces.VssNotificationEvent} notificationEvent
       */
      publishTokenEvent(notificationEvent) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "31dc86a2-67e8-4452-99a4-2b301ba28291", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notificationEvent, options2);
              let ret = this.formatResponse(res.result, VSSInterfaces.TypeInfo.VssNotificationEvent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the specified user's settings for the specified subscription. This API is typically used to opt in or out of a shared subscription. User settings can only be applied to shared subscriptions, like team subscriptions or default subscriptions.
       *
       * @param {NotificationInterfaces.SubscriptionUserSettings} userSettings
       * @param {string} subscriptionId
       * @param {string} userId - ID of the user
       */
      updateSubscriptionUserSettings(userSettings, subscriptionId, userId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId,
              userId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "ed5a3dff-aeb5-41b1-b4f7-89e66e58b62e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, userSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.NotificationApi = NotificationApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/PolicyApi.js
var require_PolicyApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/PolicyApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PolicyApi = void 0;
    var basem = require_ClientApiBases();
    var PolicyInterfaces = require_PolicyInterfaces();
    var PolicyApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Policy-api", options2);
      }
      /**
       * Create a policy configuration of a given policy type.
       *
       * @param {PolicyInterfaces.PolicyConfiguration} configuration - The policy configuration to create.
       * @param {string} project - Project ID or project name
       */
      createPolicyConfiguration(configuration, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, configuration, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a policy configuration by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - ID of the policy configuration to delete.
       */
      deletePolicyConfiguration(project, configurationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a policy configuration by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - ID of the policy configuration
       */
      getPolicyConfiguration(project, configurationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of policy configurations in a project.
       *
       * @param {string} project - Project ID or project name
       * @param {string} scope - [Provided for legacy reasons] The scope on which a subset of policies is defined.
       * @param {string} policyType - Filter returned policies to only this type
       */
      getPolicyConfigurations(project, scope, policyType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scope,
              policyType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a policy configuration by its ID.
       *
       * @param {PolicyInterfaces.PolicyConfiguration} configuration - The policy configuration to update.
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - ID of the existing policy configuration to be updated.
       */
      updatePolicyConfiguration(configuration, project, configurationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, configuration, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the present evaluation state of a policy.
       *
       * @param {string} project - Project ID or project name
       * @param {string} evaluationId - ID of the policy evaluation to be retrieved.
       */
      getPolicyEvaluation(project, evaluationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              evaluationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "46aecb7a-5d2c-4647-897b-0209505a9fe4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyEvaluationRecord, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Requeue the policy evaluation.
       *
       * @param {string} project - Project ID or project name
       * @param {string} evaluationId - ID of the policy evaluation to be retrieved.
       */
      requeuePolicyEvaluation(project, evaluationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              evaluationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "46aecb7a-5d2c-4647-897b-0209505a9fe4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyEvaluationRecord, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves a list of all the policy evaluation statuses for a specific pull request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} artifactId - A string which uniquely identifies the target of a policy evaluation.
       * @param {boolean} includeNotApplicable - Some policies might determine that they do not apply to a specific pull request. Setting this parameter to true will return evaluation records even for policies which don't apply to this pull request.
       * @param {number} top - The number of policy evaluation records to retrieve.
       * @param {number} skip - The number of policy evaluation records to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       */
      getPolicyEvaluations(project, artifactId, includeNotApplicable, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactId == null) {
            throw new TypeError("artifactId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              artifactId,
              includeNotApplicable,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "c23ddff5-229c-4d04-a80b-0fdce9f360c8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyEvaluationRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a specific revision of a given policy by ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - The policy configuration ID.
       * @param {number} revisionId - The revision ID.
       */
      getPolicyConfigurationRevision(project, configurationId, revisionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId,
              revisionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "fe1e68a2-60d3-43cb-855b-85e41ae97c95", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all revisions for a given policy.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - The policy configuration ID.
       * @param {number} top - The number of revisions to retrieve.
       * @param {number} skip - The number of revisions to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       */
      getPolicyConfigurationRevisions(project, configurationId, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "fe1e68a2-60d3-43cb-855b-85e41ae97c95", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a specific policy type by ID.
       *
       * @param {string} project - Project ID or project name
       * @param {string} typeId - The policy ID.
       */
      getPolicyType(project, typeId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              typeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "44096322-2d3d-466a-bb30-d1b7de69f61f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all available policy types.
       *
       * @param {string} project - Project ID or project name
       */
      getPolicyTypes(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "44096322-2d3d-466a-bb30-d1b7de69f61f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.PolicyApi = PolicyApi;
    PolicyApi.RESOURCE_AREA_ID = "fb13a388-40dd-4a04-b530-013a739c72ef";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/ProfileInterfaces.js
var require_ProfileInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/ProfileInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.AvatarSize = void 0;
    var AvatarSize;
    (function(AvatarSize2) {
      AvatarSize2[AvatarSize2["Small"] = 0] = "Small";
      AvatarSize2[AvatarSize2["Medium"] = 1] = "Medium";
      AvatarSize2[AvatarSize2["Large"] = 2] = "Large";
    })(AvatarSize = exports2.AvatarSize || (exports2.AvatarSize = {}));
    exports2.TypeInfo = {
      AttributeDescriptor: {
        fields: null
      },
      AttributesContainer: {
        fields: null
      },
      Avatar: {
        fields: null
      },
      AvatarSize: {
        enumValues: {
          "small": 0,
          "medium": 1,
          "large": 2
        }
      },
      CoreProfileAttribute: {
        fields: null
      },
      Country: {
        fields: null
      },
      CreateProfileContext: {
        fields: null
      },
      GeoRegion: {
        fields: null
      },
      Profile: {
        fields: null
      },
      ProfileAttribute: {
        fields: null
      },
      ProfileAttributeBase: {
        fields: null
      },
      ProfileRegion: {
        fields: null
      },
      ProfileRegions: {
        fields: null
      }
    };
    exports2.TypeInfo.AttributeDescriptor.fields = {};
    exports2.TypeInfo.AttributesContainer.fields = {
      attributes: {}
    };
    exports2.TypeInfo.Avatar.fields = {
      size: {
        enumType: exports2.TypeInfo.AvatarSize
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.CoreProfileAttribute.fields = {
      descriptor: {
        typeInfo: exports2.TypeInfo.AttributeDescriptor
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.Country.fields = {};
    exports2.TypeInfo.CreateProfileContext.fields = {};
    exports2.TypeInfo.GeoRegion.fields = {};
    exports2.TypeInfo.Profile.fields = {
      applicationContainer: {
        typeInfo: exports2.TypeInfo.AttributesContainer
      },
      coreAttributes: {},
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProfileAttribute.fields = {
      descriptor: {
        typeInfo: exports2.TypeInfo.AttributeDescriptor
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProfileAttributeBase.fields = {
      descriptor: {
        typeInfo: exports2.TypeInfo.AttributeDescriptor
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProfileRegion.fields = {};
    exports2.TypeInfo.ProfileRegions.fields = {
      regions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ProfileRegion
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/ProfileApi.js
var require_ProfileApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/ProfileApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProfileApi = void 0;
    var basem = require_ClientApiBases();
    var ProfileInterfaces = require_ProfileInterfaces();
    var ProfileApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Profile-api", options2);
      }
      /**
      * @param {string} id
      * @param {string} descriptor
      */
      deleteProfileAttribute(id, descriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              descriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {string} descriptor
      */
      getProfileAttribute(id, descriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              descriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.ProfileAttribute, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {string} partition
      * @param {string} modifiedSince
      * @param {string} modifiedAfterRevision
      * @param {boolean} withCoreAttributes
      * @param {string} coreAttributes
      */
      getProfileAttributes(id, partition, modifiedSince, modifiedAfterRevision, withCoreAttributes, coreAttributes) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              partition,
              modifiedSince,
              modifiedAfterRevision,
              withCoreAttributes,
              coreAttributes
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.ProfileAttribute, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {any} container
      * @param {string} id
      * @param {string} descriptor
      */
      setProfileAttribute(container, id, descriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              descriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, container, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {VSSInterfaces.VssJsonCollectionWrapperV<ProfileInterfaces.ProfileAttributeBase<any>[]>} attributesCollection
      * @param {string} id
      */
      setProfileAttributes(attributesCollection, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, attributesCollection, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {string} size
      * @param {string} format
      */
      getAvatar(id, size2, format) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              size: size2,
              format
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Avatar, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {any} container
      * @param {string} id
      * @param {string} size
      * @param {string} format
      * @param {string} displayName
      */
      getAvatarPreview(container, id, size2, format, displayName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              size: size2,
              format,
              displayName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, container, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Avatar, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      */
      resetAvatar(id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {any} container
      * @param {string} id
      */
      setAvatar(container, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, container, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * Lookup up country/region based on provided IPv4, null if using the remote IPv4 address.
      *
      * @param {string} ipaddress - IPv4 address to be used for reverse lookup, null if using RemoteIPAddress in request context
      */
      getGeoRegion(ipaddress) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              ipaddress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "3bcda9c0-3078-48a5-a1e0-83bd05931ad0", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * Create profile
      *
      * @param {ProfileInterfaces.CreateProfileContext} createProfileContext - Context for profile creation
      * @param {boolean} autoCreate - Create profile automatically
      */
      createProfile(createProfileContext, autoCreate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              autoCreate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.3", "Profile", "f83735dc-483f-4238-a291-d45f6080a9af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createProfileContext, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {boolean} details
      * @param {boolean} withAttributes
      * @param {string} partition
      * @param {string} coreAttributes
      * @param {boolean} forceRefresh
      */
      getProfile(id, details, withAttributes, partition, coreAttributes, forceRefresh) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              details,
              withAttributes,
              partition,
              coreAttributes,
              forceRefresh
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.3", "Profile", "f83735dc-483f-4238-a291-d45f6080a9af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * Update profile
      *
      * @param {ProfileInterfaces.Profile} profile - Update profile
      * @param {string} id - Profile ID
      */
      updateProfile(profile, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.3", "Profile", "f83735dc-483f-4238-a291-d45f6080a9af", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, profile, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      */
      getRegions() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "92d8d1c9-26b8-4774-a929-d640a73da524", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      */
      getSupportedLcids() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "d5bd1aa6-c269-4bcd-ad32-75fa17475584", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {boolean} includeAvatar
      */
      getUserDefaults(includeAvatar) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeAvatar
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "b583a356-1da7-4237-9f4c-1deb2edbc7e8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      */
      refreshUserDefaults(id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "b583a356-1da7-4237-9f4c-1deb2edbc7e8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, options2);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ProfileApi = ProfileApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/ProjectAnalysisInterfaces.js
var require_ProjectAnalysisInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/ProjectAnalysisInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ResultPhase = exports2.AggregationType = void 0;
    var AggregationType;
    (function(AggregationType2) {
      AggregationType2[AggregationType2["Hourly"] = 0] = "Hourly";
      AggregationType2[AggregationType2["Daily"] = 1] = "Daily";
    })(AggregationType = exports2.AggregationType || (exports2.AggregationType = {}));
    var ResultPhase;
    (function(ResultPhase2) {
      ResultPhase2[ResultPhase2["Preliminary"] = 0] = "Preliminary";
      ResultPhase2[ResultPhase2["Full"] = 1] = "Full";
    })(ResultPhase = exports2.ResultPhase || (exports2.ResultPhase = {}));
    exports2.TypeInfo = {
      AggregationType: {
        enumValues: {
          "hourly": 0,
          "daily": 1
        }
      },
      CodeChangeTrendItem: {},
      ProjectActivityMetrics: {},
      ProjectLanguageAnalytics: {},
      RepositoryActivityMetrics: {},
      RepositoryLanguageAnalytics: {},
      ResultPhase: {
        enumValues: {
          "preliminary": 0,
          "full": 1
        }
      }
    };
    exports2.TypeInfo.CodeChangeTrendItem.fields = {
      time: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProjectActivityMetrics.fields = {
      codeChangesTrend: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CodeChangeTrendItem
      }
    };
    exports2.TypeInfo.ProjectLanguageAnalytics.fields = {
      repositoryLanguageAnalytics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RepositoryLanguageAnalytics
      },
      resultPhase: {
        enumType: exports2.TypeInfo.ResultPhase
      }
    };
    exports2.TypeInfo.RepositoryActivityMetrics.fields = {
      codeChangesTrend: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CodeChangeTrendItem
      }
    };
    exports2.TypeInfo.RepositoryLanguageAnalytics.fields = {
      resultPhase: {
        enumType: exports2.TypeInfo.ResultPhase
      },
      updatedTime: {
        isDate: true
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/ProjectAnalysisApi.js
var require_ProjectAnalysisApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/ProjectAnalysisApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectAnalysisApi = void 0;
    var basem = require_ClientApiBases();
    var ProjectAnalysisInterfaces = require_ProjectAnalysisInterfaces();
    var ProjectAnalysisApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-ProjectAnalysis-api", options2);
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getProjectLanguageAnalytics(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "5b02a779-1867-433f-90b7-d23ed5e33e57", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.ProjectLanguageAnalytics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {Date} fromDate
       * @param {ProjectAnalysisInterfaces.AggregationType} aggregationType
       */
      getProjectActivityMetrics(project, fromDate, aggregationType) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (fromDate == null) {
            throw new TypeError("fromDate can not be null or undefined");
          }
          if (aggregationType == null) {
            throw new TypeError("aggregationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromDate,
              aggregationType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "e40ae584-9ea6-4f06-a7c7-6284651b466b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.ProjectActivityMetrics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves git activity metrics for repositories matching a specified criteria.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} fromDate - Date from which, the trends are to be fetched.
       * @param {ProjectAnalysisInterfaces.AggregationType} aggregationType - Bucket size on which, trends are to be aggregated.
       * @param {number} skip - The number of repositories to ignore.
       * @param {number} top - The number of repositories for which activity metrics are to be retrieved.
       */
      getGitRepositoriesActivityMetrics(project, fromDate, aggregationType, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (fromDate == null) {
            throw new TypeError("fromDate can not be null or undefined");
          }
          if (aggregationType == null) {
            throw new TypeError("aggregationType can not be null or undefined");
          }
          if (skip == null) {
            throw new TypeError("skip can not be null or undefined");
          }
          if (top == null) {
            throw new TypeError("top can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromDate,
              aggregationType,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "df7fbbca-630a-40e3-8aa3-7a3faf66947e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.RepositoryActivityMetrics, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId
       * @param {Date} fromDate
       * @param {ProjectAnalysisInterfaces.AggregationType} aggregationType
       */
      getRepositoryActivityMetrics(project, repositoryId, fromDate, aggregationType) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (fromDate == null) {
            throw new TypeError("fromDate can not be null or undefined");
          }
          if (aggregationType == null) {
            throw new TypeError("aggregationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              fromDate,
              aggregationType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "df7fbbca-630a-40e3-8aa3-7a3faf66947e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.RepositoryActivityMetrics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ProjectAnalysisApi = ProjectAnalysisApi;
    ProjectAnalysisApi.RESOURCE_AREA_ID = "7658fa33-b1bf-4580-990f-fac5896773d3";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/common/FormInputInterfaces.js
var require_FormInputInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/common/FormInputInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.InputMode = exports2.InputFilterOperator = exports2.InputDataType = void 0;
    var InputDataType;
    (function(InputDataType2) {
      InputDataType2[InputDataType2["None"] = 0] = "None";
      InputDataType2[InputDataType2["String"] = 10] = "String";
      InputDataType2[InputDataType2["Number"] = 20] = "Number";
      InputDataType2[InputDataType2["Boolean"] = 30] = "Boolean";
      InputDataType2[InputDataType2["Guid"] = 40] = "Guid";
      InputDataType2[InputDataType2["Uri"] = 50] = "Uri";
    })(InputDataType = exports2.InputDataType || (exports2.InputDataType = {}));
    var InputFilterOperator;
    (function(InputFilterOperator2) {
      InputFilterOperator2[InputFilterOperator2["Equals"] = 0] = "Equals";
      InputFilterOperator2[InputFilterOperator2["NotEquals"] = 1] = "NotEquals";
    })(InputFilterOperator = exports2.InputFilterOperator || (exports2.InputFilterOperator = {}));
    var InputMode;
    (function(InputMode2) {
      InputMode2[InputMode2["None"] = 0] = "None";
      InputMode2[InputMode2["TextBox"] = 10] = "TextBox";
      InputMode2[InputMode2["PasswordBox"] = 20] = "PasswordBox";
      InputMode2[InputMode2["Combo"] = 30] = "Combo";
      InputMode2[InputMode2["RadioButtons"] = 40] = "RadioButtons";
      InputMode2[InputMode2["CheckBox"] = 50] = "CheckBox";
      InputMode2[InputMode2["TextArea"] = 60] = "TextArea";
    })(InputMode = exports2.InputMode || (exports2.InputMode = {}));
    exports2.TypeInfo = {
      InputDataType: {
        enumValues: {
          "none": 0,
          "string": 10,
          "number": 20,
          "boolean": 30,
          "guid": 40,
          "uri": 50
        }
      },
      InputDescriptor: {
        fields: null
      },
      InputFilter: {
        fields: null
      },
      InputFilterCondition: {
        fields: null
      },
      InputFilterOperator: {
        enumValues: {
          "equals": 0,
          "notEquals": 1
        }
      },
      InputMode: {
        enumValues: {
          "none": 0,
          "textBox": 10,
          "passwordBox": 20,
          "combo": 30,
          "radioButtons": 40,
          "checkBox": 50,
          "textArea": 60
        }
      },
      InputValidation: {
        fields: null
      },
      InputValue: {
        fields: null
      },
      InputValues: {
        fields: null
      },
      InputValuesError: {
        fields: null
      },
      InputValuesQuery: {
        fields: null
      }
    };
    exports2.TypeInfo.InputDescriptor.fields = {
      inputMode: {
        enumType: exports2.TypeInfo.InputMode
      },
      validation: {
        typeInfo: exports2.TypeInfo.InputValidation
      },
      values: {
        typeInfo: exports2.TypeInfo.InputValues
      }
    };
    exports2.TypeInfo.InputFilter.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InputFilterCondition
      }
    };
    exports2.TypeInfo.InputFilterCondition.fields = {
      operator: {
        enumType: exports2.TypeInfo.InputFilterOperator
      }
    };
    exports2.TypeInfo.InputValidation.fields = {
      dataType: {
        enumType: exports2.TypeInfo.InputDataType
      }
    };
    exports2.TypeInfo.InputValue.fields = {};
    exports2.TypeInfo.InputValues.fields = {
      error: {
        typeInfo: exports2.TypeInfo.InputValuesError
      },
      possibleValues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InputValue
      }
    };
    exports2.TypeInfo.InputValuesError.fields = {};
    exports2.TypeInfo.InputValuesQuery.fields = {
      inputValues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InputValues
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/ReleaseInterfaces.js
var require_ReleaseInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/ReleaseInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.YamlFileSourceTypes = exports2.VariableGroupActionFilter = exports2.TaskStatus = exports2.SingleReleaseExpands = exports2.SenderType = exports2.ScheduleDays = exports2.ReleaseTriggerType = exports2.ReleaseStatus = exports2.ReleaseReason = exports2.ReleaseQueryOrder = exports2.ReleaseExpands = exports2.ReleaseEnvironmentExpands = exports2.ReleaseDefinitionSource = exports2.ReleaseDefinitionQueryOrder = exports2.ReleaseDefinitionExpands = exports2.PullRequestSystemType = exports2.PropertySelectorType = exports2.PipelineProcessTypes = exports2.ParallelExecutionTypes = exports2.ManualInterventionType = exports2.ManualInterventionStatus = exports2.MailSectionType = exports2.IssueSource = exports2.GateStatus = exports2.FolderPathQueryOrder = exports2.EnvironmentTriggerType = exports2.EnvironmentStatus = exports2.DeployPhaseTypes = exports2.DeployPhaseStatus = exports2.DeploymentStatus = exports2.DeploymentsQueryType = exports2.DeploymentReason = exports2.DeploymentOperationStatus = exports2.DeploymentExpands = exports2.DeploymentAuthorizationOwner = exports2.ConditionType = exports2.AuthorizationHeaderFor = exports2.AuditAction = exports2.ApprovalType = exports2.ApprovalStatus = exports2.ApprovalFilters = exports2.ApprovalExecutionOrder = exports2.AgentArtifactType = void 0;
    var FormInputInterfaces = require_FormInputInterfaces();
    var AgentArtifactType;
    (function(AgentArtifactType2) {
      AgentArtifactType2[AgentArtifactType2["XamlBuild"] = 0] = "XamlBuild";
      AgentArtifactType2[AgentArtifactType2["Build"] = 1] = "Build";
      AgentArtifactType2[AgentArtifactType2["Jenkins"] = 2] = "Jenkins";
      AgentArtifactType2[AgentArtifactType2["FileShare"] = 3] = "FileShare";
      AgentArtifactType2[AgentArtifactType2["Nuget"] = 4] = "Nuget";
      AgentArtifactType2[AgentArtifactType2["TfsOnPrem"] = 5] = "TfsOnPrem";
      AgentArtifactType2[AgentArtifactType2["GitHub"] = 6] = "GitHub";
      AgentArtifactType2[AgentArtifactType2["TFGit"] = 7] = "TFGit";
      AgentArtifactType2[AgentArtifactType2["ExternalTfsBuild"] = 8] = "ExternalTfsBuild";
      AgentArtifactType2[AgentArtifactType2["Custom"] = 9] = "Custom";
      AgentArtifactType2[AgentArtifactType2["Tfvc"] = 10] = "Tfvc";
    })(AgentArtifactType = exports2.AgentArtifactType || (exports2.AgentArtifactType = {}));
    var ApprovalExecutionOrder;
    (function(ApprovalExecutionOrder2) {
      ApprovalExecutionOrder2[ApprovalExecutionOrder2["BeforeGates"] = 1] = "BeforeGates";
      ApprovalExecutionOrder2[ApprovalExecutionOrder2["AfterSuccessfulGates"] = 2] = "AfterSuccessfulGates";
      ApprovalExecutionOrder2[ApprovalExecutionOrder2["AfterGatesAlways"] = 4] = "AfterGatesAlways";
    })(ApprovalExecutionOrder = exports2.ApprovalExecutionOrder || (exports2.ApprovalExecutionOrder = {}));
    var ApprovalFilters;
    (function(ApprovalFilters2) {
      ApprovalFilters2[ApprovalFilters2["None"] = 0] = "None";
      ApprovalFilters2[ApprovalFilters2["ManualApprovals"] = 1] = "ManualApprovals";
      ApprovalFilters2[ApprovalFilters2["AutomatedApprovals"] = 2] = "AutomatedApprovals";
      ApprovalFilters2[ApprovalFilters2["ApprovalSnapshots"] = 4] = "ApprovalSnapshots";
      ApprovalFilters2[ApprovalFilters2["All"] = 7] = "All";
    })(ApprovalFilters = exports2.ApprovalFilters || (exports2.ApprovalFilters = {}));
    var ApprovalStatus;
    (function(ApprovalStatus2) {
      ApprovalStatus2[ApprovalStatus2["Undefined"] = 0] = "Undefined";
      ApprovalStatus2[ApprovalStatus2["Pending"] = 1] = "Pending";
      ApprovalStatus2[ApprovalStatus2["Approved"] = 2] = "Approved";
      ApprovalStatus2[ApprovalStatus2["Rejected"] = 4] = "Rejected";
      ApprovalStatus2[ApprovalStatus2["Reassigned"] = 6] = "Reassigned";
      ApprovalStatus2[ApprovalStatus2["Canceled"] = 7] = "Canceled";
      ApprovalStatus2[ApprovalStatus2["Skipped"] = 8] = "Skipped";
    })(ApprovalStatus = exports2.ApprovalStatus || (exports2.ApprovalStatus = {}));
    var ApprovalType;
    (function(ApprovalType2) {
      ApprovalType2[ApprovalType2["Undefined"] = 0] = "Undefined";
      ApprovalType2[ApprovalType2["PreDeploy"] = 1] = "PreDeploy";
      ApprovalType2[ApprovalType2["PostDeploy"] = 2] = "PostDeploy";
      ApprovalType2[ApprovalType2["All"] = 3] = "All";
    })(ApprovalType = exports2.ApprovalType || (exports2.ApprovalType = {}));
    var AuditAction;
    (function(AuditAction2) {
      AuditAction2[AuditAction2["Add"] = 1] = "Add";
      AuditAction2[AuditAction2["Update"] = 2] = "Update";
      AuditAction2[AuditAction2["Delete"] = 3] = "Delete";
      AuditAction2[AuditAction2["Undelete"] = 4] = "Undelete";
    })(AuditAction = exports2.AuditAction || (exports2.AuditAction = {}));
    var AuthorizationHeaderFor;
    (function(AuthorizationHeaderFor2) {
      AuthorizationHeaderFor2[AuthorizationHeaderFor2["RevalidateApproverIdentity"] = 0] = "RevalidateApproverIdentity";
      AuthorizationHeaderFor2[AuthorizationHeaderFor2["OnBehalfOf"] = 1] = "OnBehalfOf";
    })(AuthorizationHeaderFor = exports2.AuthorizationHeaderFor || (exports2.AuthorizationHeaderFor = {}));
    var ConditionType;
    (function(ConditionType2) {
      ConditionType2[ConditionType2["Undefined"] = 0] = "Undefined";
      ConditionType2[ConditionType2["Event"] = 1] = "Event";
      ConditionType2[ConditionType2["EnvironmentState"] = 2] = "EnvironmentState";
      ConditionType2[ConditionType2["Artifact"] = 4] = "Artifact";
    })(ConditionType = exports2.ConditionType || (exports2.ConditionType = {}));
    var DeploymentAuthorizationOwner;
    (function(DeploymentAuthorizationOwner2) {
      DeploymentAuthorizationOwner2[DeploymentAuthorizationOwner2["Automatic"] = 0] = "Automatic";
      DeploymentAuthorizationOwner2[DeploymentAuthorizationOwner2["DeploymentSubmitter"] = 1] = "DeploymentSubmitter";
      DeploymentAuthorizationOwner2[DeploymentAuthorizationOwner2["FirstPreDeploymentApprover"] = 2] = "FirstPreDeploymentApprover";
    })(DeploymentAuthorizationOwner = exports2.DeploymentAuthorizationOwner || (exports2.DeploymentAuthorizationOwner = {}));
    var DeploymentExpands;
    (function(DeploymentExpands2) {
      DeploymentExpands2[DeploymentExpands2["All"] = 0] = "All";
      DeploymentExpands2[DeploymentExpands2["DeploymentOnly"] = 1] = "DeploymentOnly";
      DeploymentExpands2[DeploymentExpands2["Approvals"] = 2] = "Approvals";
      DeploymentExpands2[DeploymentExpands2["Artifacts"] = 4] = "Artifacts";
    })(DeploymentExpands = exports2.DeploymentExpands || (exports2.DeploymentExpands = {}));
    var DeploymentOperationStatus;
    (function(DeploymentOperationStatus2) {
      DeploymentOperationStatus2[DeploymentOperationStatus2["Undefined"] = 0] = "Undefined";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Queued"] = 1] = "Queued";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Scheduled"] = 2] = "Scheduled";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Pending"] = 4] = "Pending";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Approved"] = 8] = "Approved";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Rejected"] = 16] = "Rejected";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Deferred"] = 32] = "Deferred";
      DeploymentOperationStatus2[DeploymentOperationStatus2["QueuedForAgent"] = 64] = "QueuedForAgent";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseInProgress"] = 128] = "PhaseInProgress";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseSucceeded"] = 256] = "PhaseSucceeded";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhasePartiallySucceeded"] = 512] = "PhasePartiallySucceeded";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseFailed"] = 1024] = "PhaseFailed";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Canceled"] = 2048] = "Canceled";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseCanceled"] = 4096] = "PhaseCanceled";
      DeploymentOperationStatus2[DeploymentOperationStatus2["ManualInterventionPending"] = 8192] = "ManualInterventionPending";
      DeploymentOperationStatus2[DeploymentOperationStatus2["QueuedForPipeline"] = 16384] = "QueuedForPipeline";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Cancelling"] = 32768] = "Cancelling";
      DeploymentOperationStatus2[DeploymentOperationStatus2["EvaluatingGates"] = 65536] = "EvaluatingGates";
      DeploymentOperationStatus2[DeploymentOperationStatus2["GateFailed"] = 131072] = "GateFailed";
      DeploymentOperationStatus2[DeploymentOperationStatus2["All"] = 258047] = "All";
    })(DeploymentOperationStatus = exports2.DeploymentOperationStatus || (exports2.DeploymentOperationStatus = {}));
    var DeploymentReason;
    (function(DeploymentReason2) {
      DeploymentReason2[DeploymentReason2["None"] = 0] = "None";
      DeploymentReason2[DeploymentReason2["Manual"] = 1] = "Manual";
      DeploymentReason2[DeploymentReason2["Automated"] = 2] = "Automated";
      DeploymentReason2[DeploymentReason2["Scheduled"] = 4] = "Scheduled";
      DeploymentReason2[DeploymentReason2["RedeployTrigger"] = 8] = "RedeployTrigger";
    })(DeploymentReason = exports2.DeploymentReason || (exports2.DeploymentReason = {}));
    var DeploymentsQueryType;
    (function(DeploymentsQueryType2) {
      DeploymentsQueryType2[DeploymentsQueryType2["Regular"] = 1] = "Regular";
      DeploymentsQueryType2[DeploymentsQueryType2["FailingSince"] = 2] = "FailingSince";
    })(DeploymentsQueryType = exports2.DeploymentsQueryType || (exports2.DeploymentsQueryType = {}));
    var DeploymentStatus;
    (function(DeploymentStatus2) {
      DeploymentStatus2[DeploymentStatus2["Undefined"] = 0] = "Undefined";
      DeploymentStatus2[DeploymentStatus2["NotDeployed"] = 1] = "NotDeployed";
      DeploymentStatus2[DeploymentStatus2["InProgress"] = 2] = "InProgress";
      DeploymentStatus2[DeploymentStatus2["Succeeded"] = 4] = "Succeeded";
      DeploymentStatus2[DeploymentStatus2["PartiallySucceeded"] = 8] = "PartiallySucceeded";
      DeploymentStatus2[DeploymentStatus2["Failed"] = 16] = "Failed";
      DeploymentStatus2[DeploymentStatus2["All"] = 31] = "All";
    })(DeploymentStatus = exports2.DeploymentStatus || (exports2.DeploymentStatus = {}));
    var DeployPhaseStatus;
    (function(DeployPhaseStatus2) {
      DeployPhaseStatus2[DeployPhaseStatus2["Undefined"] = 0] = "Undefined";
      DeployPhaseStatus2[DeployPhaseStatus2["NotStarted"] = 1] = "NotStarted";
      DeployPhaseStatus2[DeployPhaseStatus2["InProgress"] = 2] = "InProgress";
      DeployPhaseStatus2[DeployPhaseStatus2["PartiallySucceeded"] = 4] = "PartiallySucceeded";
      DeployPhaseStatus2[DeployPhaseStatus2["Succeeded"] = 8] = "Succeeded";
      DeployPhaseStatus2[DeployPhaseStatus2["Failed"] = 16] = "Failed";
      DeployPhaseStatus2[DeployPhaseStatus2["Canceled"] = 32] = "Canceled";
      DeployPhaseStatus2[DeployPhaseStatus2["Skipped"] = 64] = "Skipped";
      DeployPhaseStatus2[DeployPhaseStatus2["Cancelling"] = 128] = "Cancelling";
    })(DeployPhaseStatus = exports2.DeployPhaseStatus || (exports2.DeployPhaseStatus = {}));
    var DeployPhaseTypes;
    (function(DeployPhaseTypes2) {
      DeployPhaseTypes2[DeployPhaseTypes2["Undefined"] = 0] = "Undefined";
      DeployPhaseTypes2[DeployPhaseTypes2["AgentBasedDeployment"] = 1] = "AgentBasedDeployment";
      DeployPhaseTypes2[DeployPhaseTypes2["RunOnServer"] = 2] = "RunOnServer";
      DeployPhaseTypes2[DeployPhaseTypes2["MachineGroupBasedDeployment"] = 4] = "MachineGroupBasedDeployment";
      DeployPhaseTypes2[DeployPhaseTypes2["DeploymentGates"] = 8] = "DeploymentGates";
    })(DeployPhaseTypes = exports2.DeployPhaseTypes || (exports2.DeployPhaseTypes = {}));
    var EnvironmentStatus;
    (function(EnvironmentStatus2) {
      EnvironmentStatus2[EnvironmentStatus2["Undefined"] = 0] = "Undefined";
      EnvironmentStatus2[EnvironmentStatus2["NotStarted"] = 1] = "NotStarted";
      EnvironmentStatus2[EnvironmentStatus2["InProgress"] = 2] = "InProgress";
      EnvironmentStatus2[EnvironmentStatus2["Succeeded"] = 4] = "Succeeded";
      EnvironmentStatus2[EnvironmentStatus2["Canceled"] = 8] = "Canceled";
      EnvironmentStatus2[EnvironmentStatus2["Rejected"] = 16] = "Rejected";
      EnvironmentStatus2[EnvironmentStatus2["Queued"] = 32] = "Queued";
      EnvironmentStatus2[EnvironmentStatus2["Scheduled"] = 64] = "Scheduled";
      EnvironmentStatus2[EnvironmentStatus2["PartiallySucceeded"] = 128] = "PartiallySucceeded";
    })(EnvironmentStatus = exports2.EnvironmentStatus || (exports2.EnvironmentStatus = {}));
    var EnvironmentTriggerType;
    (function(EnvironmentTriggerType2) {
      EnvironmentTriggerType2[EnvironmentTriggerType2["Undefined"] = 0] = "Undefined";
      EnvironmentTriggerType2[EnvironmentTriggerType2["DeploymentGroupRedeploy"] = 1] = "DeploymentGroupRedeploy";
      EnvironmentTriggerType2[EnvironmentTriggerType2["RollbackRedeploy"] = 2] = "RollbackRedeploy";
    })(EnvironmentTriggerType = exports2.EnvironmentTriggerType || (exports2.EnvironmentTriggerType = {}));
    var FolderPathQueryOrder;
    (function(FolderPathQueryOrder2) {
      FolderPathQueryOrder2[FolderPathQueryOrder2["None"] = 0] = "None";
      FolderPathQueryOrder2[FolderPathQueryOrder2["Ascending"] = 1] = "Ascending";
      FolderPathQueryOrder2[FolderPathQueryOrder2["Descending"] = 2] = "Descending";
    })(FolderPathQueryOrder = exports2.FolderPathQueryOrder || (exports2.FolderPathQueryOrder = {}));
    var GateStatus;
    (function(GateStatus2) {
      GateStatus2[GateStatus2["None"] = 0] = "None";
      GateStatus2[GateStatus2["Pending"] = 1] = "Pending";
      GateStatus2[GateStatus2["InProgress"] = 2] = "InProgress";
      GateStatus2[GateStatus2["Succeeded"] = 4] = "Succeeded";
      GateStatus2[GateStatus2["Failed"] = 8] = "Failed";
      GateStatus2[GateStatus2["Canceled"] = 16] = "Canceled";
    })(GateStatus = exports2.GateStatus || (exports2.GateStatus = {}));
    var IssueSource;
    (function(IssueSource2) {
      IssueSource2[IssueSource2["None"] = 0] = "None";
      IssueSource2[IssueSource2["User"] = 1] = "User";
      IssueSource2[IssueSource2["System"] = 2] = "System";
    })(IssueSource = exports2.IssueSource || (exports2.IssueSource = {}));
    var MailSectionType;
    (function(MailSectionType2) {
      MailSectionType2[MailSectionType2["Details"] = 0] = "Details";
      MailSectionType2[MailSectionType2["Environments"] = 1] = "Environments";
      MailSectionType2[MailSectionType2["Issues"] = 2] = "Issues";
      MailSectionType2[MailSectionType2["TestResults"] = 3] = "TestResults";
      MailSectionType2[MailSectionType2["WorkItems"] = 4] = "WorkItems";
      MailSectionType2[MailSectionType2["ReleaseInfo"] = 5] = "ReleaseInfo";
    })(MailSectionType = exports2.MailSectionType || (exports2.MailSectionType = {}));
    var ManualInterventionStatus;
    (function(ManualInterventionStatus2) {
      ManualInterventionStatus2[ManualInterventionStatus2["Unknown"] = 0] = "Unknown";
      ManualInterventionStatus2[ManualInterventionStatus2["Pending"] = 1] = "Pending";
      ManualInterventionStatus2[ManualInterventionStatus2["Rejected"] = 2] = "Rejected";
      ManualInterventionStatus2[ManualInterventionStatus2["Approved"] = 4] = "Approved";
      ManualInterventionStatus2[ManualInterventionStatus2["Canceled"] = 8] = "Canceled";
      ManualInterventionStatus2[ManualInterventionStatus2["Bypassed"] = 16] = "Bypassed";
    })(ManualInterventionStatus = exports2.ManualInterventionStatus || (exports2.ManualInterventionStatus = {}));
    var ManualInterventionType;
    (function(ManualInterventionType2) {
      ManualInterventionType2[ManualInterventionType2["Task"] = 1] = "Task";
      ManualInterventionType2[ManualInterventionType2["ProofOfPresence"] = 2] = "ProofOfPresence";
    })(ManualInterventionType = exports2.ManualInterventionType || (exports2.ManualInterventionType = {}));
    var ParallelExecutionTypes;
    (function(ParallelExecutionTypes2) {
      ParallelExecutionTypes2[ParallelExecutionTypes2["None"] = 0] = "None";
      ParallelExecutionTypes2[ParallelExecutionTypes2["MultiConfiguration"] = 1] = "MultiConfiguration";
      ParallelExecutionTypes2[ParallelExecutionTypes2["MultiMachine"] = 2] = "MultiMachine";
    })(ParallelExecutionTypes = exports2.ParallelExecutionTypes || (exports2.ParallelExecutionTypes = {}));
    var PipelineProcessTypes;
    (function(PipelineProcessTypes2) {
      PipelineProcessTypes2[PipelineProcessTypes2["Designer"] = 1] = "Designer";
      PipelineProcessTypes2[PipelineProcessTypes2["Yaml"] = 2] = "Yaml";
    })(PipelineProcessTypes = exports2.PipelineProcessTypes || (exports2.PipelineProcessTypes = {}));
    var PropertySelectorType;
    (function(PropertySelectorType2) {
      PropertySelectorType2[PropertySelectorType2["Inclusion"] = 0] = "Inclusion";
      PropertySelectorType2[PropertySelectorType2["Exclusion"] = 1] = "Exclusion";
    })(PropertySelectorType = exports2.PropertySelectorType || (exports2.PropertySelectorType = {}));
    var PullRequestSystemType;
    (function(PullRequestSystemType2) {
      PullRequestSystemType2[PullRequestSystemType2["None"] = 0] = "None";
      PullRequestSystemType2[PullRequestSystemType2["TfsGit"] = 1] = "TfsGit";
      PullRequestSystemType2[PullRequestSystemType2["GitHub"] = 2] = "GitHub";
    })(PullRequestSystemType = exports2.PullRequestSystemType || (exports2.PullRequestSystemType = {}));
    var ReleaseDefinitionExpands;
    (function(ReleaseDefinitionExpands2) {
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["None"] = 0] = "None";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Environments"] = 2] = "Environments";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Artifacts"] = 4] = "Artifacts";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Triggers"] = 8] = "Triggers";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Variables"] = 16] = "Variables";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Tags"] = 32] = "Tags";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["LastRelease"] = 64] = "LastRelease";
    })(ReleaseDefinitionExpands = exports2.ReleaseDefinitionExpands || (exports2.ReleaseDefinitionExpands = {}));
    var ReleaseDefinitionQueryOrder;
    (function(ReleaseDefinitionQueryOrder2) {
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["IdAscending"] = 0] = "IdAscending";
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["IdDescending"] = 1] = "IdDescending";
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["NameAscending"] = 2] = "NameAscending";
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["NameDescending"] = 3] = "NameDescending";
    })(ReleaseDefinitionQueryOrder = exports2.ReleaseDefinitionQueryOrder || (exports2.ReleaseDefinitionQueryOrder = {}));
    var ReleaseDefinitionSource;
    (function(ReleaseDefinitionSource2) {
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["Undefined"] = 0] = "Undefined";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["RestApi"] = 1] = "RestApi";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["UserInterface"] = 2] = "UserInterface";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["Ibiza"] = 4] = "Ibiza";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["PortalExtensionApi"] = 8] = "PortalExtensionApi";
    })(ReleaseDefinitionSource = exports2.ReleaseDefinitionSource || (exports2.ReleaseDefinitionSource = {}));
    var ReleaseEnvironmentExpands;
    (function(ReleaseEnvironmentExpands2) {
      ReleaseEnvironmentExpands2[ReleaseEnvironmentExpands2["None"] = 0] = "None";
      ReleaseEnvironmentExpands2[ReleaseEnvironmentExpands2["Tasks"] = 1] = "Tasks";
    })(ReleaseEnvironmentExpands = exports2.ReleaseEnvironmentExpands || (exports2.ReleaseEnvironmentExpands = {}));
    var ReleaseExpands;
    (function(ReleaseExpands2) {
      ReleaseExpands2[ReleaseExpands2["None"] = 0] = "None";
      ReleaseExpands2[ReleaseExpands2["Environments"] = 2] = "Environments";
      ReleaseExpands2[ReleaseExpands2["Artifacts"] = 4] = "Artifacts";
      ReleaseExpands2[ReleaseExpands2["Approvals"] = 8] = "Approvals";
      ReleaseExpands2[ReleaseExpands2["ManualInterventions"] = 16] = "ManualInterventions";
      ReleaseExpands2[ReleaseExpands2["Variables"] = 32] = "Variables";
      ReleaseExpands2[ReleaseExpands2["Tags"] = 64] = "Tags";
    })(ReleaseExpands = exports2.ReleaseExpands || (exports2.ReleaseExpands = {}));
    var ReleaseQueryOrder;
    (function(ReleaseQueryOrder2) {
      ReleaseQueryOrder2[ReleaseQueryOrder2["Descending"] = 0] = "Descending";
      ReleaseQueryOrder2[ReleaseQueryOrder2["Ascending"] = 1] = "Ascending";
    })(ReleaseQueryOrder = exports2.ReleaseQueryOrder || (exports2.ReleaseQueryOrder = {}));
    var ReleaseReason;
    (function(ReleaseReason2) {
      ReleaseReason2[ReleaseReason2["None"] = 0] = "None";
      ReleaseReason2[ReleaseReason2["Manual"] = 1] = "Manual";
      ReleaseReason2[ReleaseReason2["ContinuousIntegration"] = 2] = "ContinuousIntegration";
      ReleaseReason2[ReleaseReason2["Schedule"] = 3] = "Schedule";
      ReleaseReason2[ReleaseReason2["PullRequest"] = 4] = "PullRequest";
    })(ReleaseReason = exports2.ReleaseReason || (exports2.ReleaseReason = {}));
    var ReleaseStatus;
    (function(ReleaseStatus2) {
      ReleaseStatus2[ReleaseStatus2["Undefined"] = 0] = "Undefined";
      ReleaseStatus2[ReleaseStatus2["Draft"] = 1] = "Draft";
      ReleaseStatus2[ReleaseStatus2["Active"] = 2] = "Active";
      ReleaseStatus2[ReleaseStatus2["Abandoned"] = 4] = "Abandoned";
    })(ReleaseStatus = exports2.ReleaseStatus || (exports2.ReleaseStatus = {}));
    var ReleaseTriggerType;
    (function(ReleaseTriggerType2) {
      ReleaseTriggerType2[ReleaseTriggerType2["Undefined"] = 0] = "Undefined";
      ReleaseTriggerType2[ReleaseTriggerType2["ArtifactSource"] = 1] = "ArtifactSource";
      ReleaseTriggerType2[ReleaseTriggerType2["Schedule"] = 2] = "Schedule";
      ReleaseTriggerType2[ReleaseTriggerType2["SourceRepo"] = 3] = "SourceRepo";
      ReleaseTriggerType2[ReleaseTriggerType2["ContainerImage"] = 4] = "ContainerImage";
      ReleaseTriggerType2[ReleaseTriggerType2["Package"] = 5] = "Package";
      ReleaseTriggerType2[ReleaseTriggerType2["PullRequest"] = 6] = "PullRequest";
    })(ReleaseTriggerType = exports2.ReleaseTriggerType || (exports2.ReleaseTriggerType = {}));
    var ScheduleDays;
    (function(ScheduleDays2) {
      ScheduleDays2[ScheduleDays2["None"] = 0] = "None";
      ScheduleDays2[ScheduleDays2["Monday"] = 1] = "Monday";
      ScheduleDays2[ScheduleDays2["Tuesday"] = 2] = "Tuesday";
      ScheduleDays2[ScheduleDays2["Wednesday"] = 4] = "Wednesday";
      ScheduleDays2[ScheduleDays2["Thursday"] = 8] = "Thursday";
      ScheduleDays2[ScheduleDays2["Friday"] = 16] = "Friday";
      ScheduleDays2[ScheduleDays2["Saturday"] = 32] = "Saturday";
      ScheduleDays2[ScheduleDays2["Sunday"] = 64] = "Sunday";
      ScheduleDays2[ScheduleDays2["All"] = 127] = "All";
    })(ScheduleDays = exports2.ScheduleDays || (exports2.ScheduleDays = {}));
    var SenderType;
    (function(SenderType2) {
      SenderType2[SenderType2["ServiceAccount"] = 1] = "ServiceAccount";
      SenderType2[SenderType2["RequestingUser"] = 2] = "RequestingUser";
    })(SenderType = exports2.SenderType || (exports2.SenderType = {}));
    var SingleReleaseExpands;
    (function(SingleReleaseExpands2) {
      SingleReleaseExpands2[SingleReleaseExpands2["None"] = 0] = "None";
      SingleReleaseExpands2[SingleReleaseExpands2["Tasks"] = 1] = "Tasks";
    })(SingleReleaseExpands = exports2.SingleReleaseExpands || (exports2.SingleReleaseExpands = {}));
    var TaskStatus;
    (function(TaskStatus2) {
      TaskStatus2[TaskStatus2["Unknown"] = 0] = "Unknown";
      TaskStatus2[TaskStatus2["Pending"] = 1] = "Pending";
      TaskStatus2[TaskStatus2["InProgress"] = 2] = "InProgress";
      TaskStatus2[TaskStatus2["Success"] = 3] = "Success";
      TaskStatus2[TaskStatus2["Failure"] = 4] = "Failure";
      TaskStatus2[TaskStatus2["Canceled"] = 5] = "Canceled";
      TaskStatus2[TaskStatus2["Skipped"] = 6] = "Skipped";
      TaskStatus2[TaskStatus2["Succeeded"] = 7] = "Succeeded";
      TaskStatus2[TaskStatus2["Failed"] = 8] = "Failed";
      TaskStatus2[TaskStatus2["PartiallySucceeded"] = 9] = "PartiallySucceeded";
    })(TaskStatus = exports2.TaskStatus || (exports2.TaskStatus = {}));
    var VariableGroupActionFilter;
    (function(VariableGroupActionFilter2) {
      VariableGroupActionFilter2[VariableGroupActionFilter2["None"] = 0] = "None";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Manage"] = 2] = "Manage";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Use"] = 16] = "Use";
    })(VariableGroupActionFilter = exports2.VariableGroupActionFilter || (exports2.VariableGroupActionFilter = {}));
    var YamlFileSourceTypes;
    (function(YamlFileSourceTypes2) {
      YamlFileSourceTypes2[YamlFileSourceTypes2["None"] = 0] = "None";
      YamlFileSourceTypes2[YamlFileSourceTypes2["TFSGit"] = 1] = "TFSGit";
    })(YamlFileSourceTypes = exports2.YamlFileSourceTypes || (exports2.YamlFileSourceTypes = {}));
    exports2.TypeInfo = {
      AgentArtifactDefinition: {},
      AgentArtifactType: {
        enumValues: {
          "xamlBuild": 0,
          "build": 1,
          "jenkins": 2,
          "fileShare": 3,
          "nuget": 4,
          "tfsOnPrem": 5,
          "gitHub": 6,
          "tfGit": 7,
          "externalTfsBuild": 8,
          "custom": 9,
          "tfvc": 10
        }
      },
      AgentBasedDeployPhase: {},
      AgentDeploymentInput: {},
      ApprovalExecutionOrder: {
        enumValues: {
          "beforeGates": 1,
          "afterSuccessfulGates": 2,
          "afterGatesAlways": 4
        }
      },
      ApprovalFilters: {
        enumValues: {
          "none": 0,
          "manualApprovals": 1,
          "automatedApprovals": 2,
          "approvalSnapshots": 4,
          "all": 7
        }
      },
      ApprovalOptions: {},
      ApprovalStatus: {
        enumValues: {
          "undefined": 0,
          "pending": 1,
          "approved": 2,
          "rejected": 4,
          "reassigned": 6,
          "canceled": 7,
          "skipped": 8
        }
      },
      ApprovalType: {
        enumValues: {
          "undefined": 0,
          "preDeploy": 1,
          "postDeploy": 2,
          "all": 3
        }
      },
      ArtifactContributionDefinition: {},
      ArtifactMetadata: {},
      ArtifactSourceTrigger: {},
      ArtifactTypeDefinition: {},
      ArtifactVersion: {},
      ArtifactVersionQueryResult: {},
      AuditAction: {
        enumValues: {
          "add": 1,
          "update": 2,
          "delete": 3,
          "undelete": 4
        }
      },
      AuthorizationHeaderFor: {
        enumValues: {
          "revalidateApproverIdentity": 0,
          "onBehalfOf": 1
        }
      },
      AutoTriggerIssue: {},
      AzureKeyVaultVariableGroupProviderData: {},
      AzureKeyVaultVariableValue: {},
      BuildVersion: {},
      Change: {},
      CodeRepositoryReference: {},
      Condition: {},
      ConditionType: {
        enumValues: {
          "undefined": 0,
          "event": 1,
          "environmentState": 2,
          "artifact": 4
        }
      },
      ContainerImageTrigger: {},
      ContinuousDeploymentTriggerIssue: {},
      Deployment: {},
      DeploymentApprovalCompletedEvent: {},
      DeploymentApprovalPendingEvent: {},
      DeploymentAttempt: {},
      DeploymentAuthorizationInfo: {},
      DeploymentAuthorizationOwner: {
        enumValues: {
          "automatic": 0,
          "deploymentSubmitter": 1,
          "firstPreDeploymentApprover": 2
        }
      },
      DeploymentCompletedEvent: {},
      DeploymentExpands: {
        enumValues: {
          "all": 0,
          "deploymentOnly": 1,
          "approvals": 2,
          "artifacts": 4
        }
      },
      DeploymentJob: {},
      DeploymentManualInterventionPendingEvent: {},
      DeploymentOperationStatus: {
        enumValues: {
          "undefined": 0,
          "queued": 1,
          "scheduled": 2,
          "pending": 4,
          "approved": 8,
          "rejected": 16,
          "deferred": 32,
          "queuedForAgent": 64,
          "phaseInProgress": 128,
          "phaseSucceeded": 256,
          "phasePartiallySucceeded": 512,
          "phaseFailed": 1024,
          "canceled": 2048,
          "phaseCanceled": 4096,
          "manualInterventionPending": 8192,
          "queuedForPipeline": 16384,
          "cancelling": 32768,
          "evaluatingGates": 65536,
          "gateFailed": 131072,
          "all": 258047
        }
      },
      DeploymentQueryParameters: {},
      DeploymentReason: {
        enumValues: {
          "none": 0,
          "manual": 1,
          "automated": 2,
          "scheduled": 4,
          "redeployTrigger": 8
        }
      },
      DeploymentsQueryType: {
        enumValues: {
          "regular": 1,
          "failingSince": 2
        }
      },
      DeploymentStartedEvent: {},
      DeploymentStatus: {
        enumValues: {
          "undefined": 0,
          "notDeployed": 1,
          "inProgress": 2,
          "succeeded": 4,
          "partiallySucceeded": 8,
          "failed": 16,
          "all": 31
        }
      },
      DeployPhase: {},
      DeployPhaseStatus: {
        enumValues: {
          "undefined": 0,
          "notStarted": 1,
          "inProgress": 2,
          "partiallySucceeded": 4,
          "succeeded": 8,
          "failed": 16,
          "canceled": 32,
          "skipped": 64,
          "cancelling": 128
        }
      },
      DeployPhaseTypes: {
        enumValues: {
          "undefined": 0,
          "agentBasedDeployment": 1,
          "runOnServer": 2,
          "machineGroupBasedDeployment": 4,
          "deploymentGates": 8
        }
      },
      EnvironmentStatus: {
        enumValues: {
          "undefined": 0,
          "notStarted": 1,
          "inProgress": 2,
          "succeeded": 4,
          "canceled": 8,
          "rejected": 16,
          "queued": 32,
          "scheduled": 64,
          "partiallySucceeded": 128
        }
      },
      EnvironmentTrigger: {},
      EnvironmentTriggerType: {
        enumValues: {
          "undefined": 0,
          "deploymentGroupRedeploy": 1,
          "rollbackRedeploy": 2
        }
      },
      ExecutionInput: {},
      Folder: {},
      FolderPathQueryOrder: {
        enumValues: {
          "none": 0,
          "ascending": 1,
          "descending": 2
        }
      },
      GatesDeployPhase: {},
      GateStatus: {
        enumValues: {
          "none": 0,
          "pending": 1,
          "inProgress": 2,
          "succeeded": 4,
          "failed": 8,
          "canceled": 16
        }
      },
      IgnoredGate: {},
      IssueSource: {
        enumValues: {
          "none": 0,
          "user": 1,
          "system": 2
        }
      },
      MachineGroupBasedDeployPhase: {},
      MailMessage: {},
      MailSectionType: {
        enumValues: {
          "details": 0,
          "environments": 1,
          "issues": 2,
          "testResults": 3,
          "workItems": 4,
          "releaseInfo": 5
        }
      },
      ManualIntervention: {},
      ManualInterventionStatus: {
        enumValues: {
          "unknown": 0,
          "pending": 1,
          "rejected": 2,
          "approved": 4,
          "canceled": 8,
          "bypassed": 16
        }
      },
      ManualInterventionType: {
        enumValues: {
          "task": 1,
          "proofOfPresence": 2
        }
      },
      ManualInterventionUpdateMetadata: {},
      MultiConfigInput: {},
      MultiMachineInput: {},
      PackageTrigger: {},
      ParallelExecutionInputBase: {},
      ParallelExecutionTypes: {
        enumValues: {
          "none": 0,
          "multiConfiguration": 1,
          "multiMachine": 2
        }
      },
      PipelineProcess: {},
      PipelineProcessTypes: {
        enumValues: {
          "designer": 1,
          "yaml": 2
        }
      },
      PropertySelector: {},
      PropertySelectorType: {
        enumValues: {
          "inclusion": 0,
          "exclusion": 1
        }
      },
      PullRequestConfiguration: {},
      PullRequestSystemType: {
        enumValues: {
          "none": 0,
          "tfsGit": 1,
          "gitHub": 2
        }
      },
      PullRequestTrigger: {},
      Release: {},
      ReleaseAbandonedEvent: {},
      ReleaseApproval: {},
      ReleaseApprovalHistory: {},
      ReleaseApprovalPendingEvent: {},
      ReleaseCondition: {},
      ReleaseCreatedEvent: {},
      ReleaseDefinition: {},
      ReleaseDefinitionApprovals: {},
      ReleaseDefinitionEnvironment: {},
      ReleaseDefinitionEnvironmentTemplate: {},
      ReleaseDefinitionExpands: {
        enumValues: {
          "none": 0,
          "environments": 2,
          "artifacts": 4,
          "triggers": 8,
          "variables": 16,
          "tags": 32,
          "lastRelease": 64
        }
      },
      ReleaseDefinitionQueryOrder: {
        enumValues: {
          "idAscending": 0,
          "idDescending": 1,
          "nameAscending": 2,
          "nameDescending": 3
        }
      },
      ReleaseDefinitionRevision: {},
      ReleaseDefinitionSource: {
        enumValues: {
          "undefined": 0,
          "restApi": 1,
          "userInterface": 2,
          "ibiza": 4,
          "portalExtensionApi": 8
        }
      },
      ReleaseDefinitionSummary: {},
      ReleaseDeployPhase: {},
      ReleaseEnvironment: {},
      ReleaseEnvironmentCompletedEvent: {},
      ReleaseEnvironmentExpands: {
        enumValues: {
          "none": 0,
          "tasks": 1
        }
      },
      ReleaseEnvironmentStatusUpdatedEvent: {},
      ReleaseEnvironmentUpdateMetadata: {},
      ReleaseExpands: {
        enumValues: {
          "none": 0,
          "environments": 2,
          "artifacts": 4,
          "approvals": 8,
          "manualInterventions": 16,
          "variables": 32,
          "tags": 64
        }
      },
      ReleaseGates: {},
      ReleaseGatesPhase: {},
      ReleaseNotCreatedEvent: {},
      ReleaseQueryOrder: {
        enumValues: {
          "descending": 0,
          "ascending": 1
        }
      },
      ReleaseReason: {
        enumValues: {
          "none": 0,
          "manual": 1,
          "continuousIntegration": 2,
          "schedule": 3,
          "pullRequest": 4
        }
      },
      ReleaseReference: {},
      ReleaseRevision: {},
      ReleaseSchedule: {},
      ReleaseStartMetadata: {},
      ReleaseStatus: {
        enumValues: {
          "undefined": 0,
          "draft": 1,
          "active": 2,
          "abandoned": 4
        }
      },
      ReleaseTask: {},
      ReleaseTaskAttachment: {},
      ReleaseTasksUpdatedEvent: {},
      ReleaseTriggerBase: {},
      ReleaseTriggerType: {
        enumValues: {
          "undefined": 0,
          "artifactSource": 1,
          "schedule": 2,
          "sourceRepo": 3,
          "containerImage": 4,
          "package": 5,
          "pullRequest": 6
        }
      },
      ReleaseUpdatedEvent: {},
      ReleaseUpdateMetadata: {},
      RunOnServerDeployPhase: {},
      ScheduleDays: {
        enumValues: {
          "none": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 4,
          "thursday": 8,
          "friday": 16,
          "saturday": 32,
          "sunday": 64,
          "all": 127
        }
      },
      ScheduledReleaseTrigger: {},
      SenderType: {
        enumValues: {
          "serviceAccount": 1,
          "requestingUser": 2
        }
      },
      ServerDeploymentInput: {},
      SingleReleaseExpands: {
        enumValues: {
          "none": 0,
          "tasks": 1
        }
      },
      SourcePullRequestVersion: {},
      SourceRepoTrigger: {},
      SummaryMailSection: {},
      TaskStatus: {
        enumValues: {
          "unknown": 0,
          "pending": 1,
          "inProgress": 2,
          "success": 3,
          "failure": 4,
          "canceled": 5,
          "skipped": 6,
          "succeeded": 7,
          "failed": 8,
          "partiallySucceeded": 9
        }
      },
      VariableGroup: {},
      VariableGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      YamlFileSource: {},
      YamlFileSourceTypes: {
        enumValues: {
          "none": 0,
          "tfsGit": 1
        }
      },
      YamlPipelineProcess: {}
    };
    exports2.TypeInfo.AgentArtifactDefinition.fields = {
      artifactType: {
        enumType: exports2.TypeInfo.AgentArtifactType
      }
    };
    exports2.TypeInfo.AgentBasedDeployPhase.fields = {
      deploymentInput: {
        typeInfo: exports2.TypeInfo.AgentDeploymentInput
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.AgentDeploymentInput.fields = {
      parallelExecution: {
        typeInfo: exports2.TypeInfo.ExecutionInput
      }
    };
    exports2.TypeInfo.ApprovalOptions.fields = {
      executionOrder: {
        enumType: exports2.TypeInfo.ApprovalExecutionOrder
      }
    };
    exports2.TypeInfo.ArtifactContributionDefinition.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.ArtifactMetadata.fields = {
      instanceReference: {
        typeInfo: exports2.TypeInfo.BuildVersion
      }
    };
    exports2.TypeInfo.ArtifactSourceTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ArtifactTypeDefinition.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.ArtifactVersion.fields = {
      defaultVersion: {
        typeInfo: exports2.TypeInfo.BuildVersion
      },
      versions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildVersion
      }
    };
    exports2.TypeInfo.ArtifactVersionQueryResult.fields = {
      artifactVersions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ArtifactVersion
      }
    };
    exports2.TypeInfo.AutoTriggerIssue.fields = {
      issueSource: {
        enumType: exports2.TypeInfo.IssueSource
      },
      releaseTriggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableGroupProviderData.fields = {
      lastRefreshedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableValue.fields = {
      expires: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildVersion.fields = {
      sourcePullRequestVersion: {
        typeInfo: exports2.TypeInfo.SourcePullRequestVersion
      }
    };
    exports2.TypeInfo.Change.fields = {
      timestamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.CodeRepositoryReference.fields = {
      systemType: {
        enumType: exports2.TypeInfo.PullRequestSystemType
      }
    };
    exports2.TypeInfo.Condition.fields = {
      conditionType: {
        enumType: exports2.TypeInfo.ConditionType
      }
    };
    exports2.TypeInfo.ContainerImageTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ContinuousDeploymentTriggerIssue.fields = {
      issueSource: {
        enumType: exports2.TypeInfo.IssueSource
      },
      releaseTriggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.Deployment.fields = {
      completedOn: {
        isDate: true
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Condition
      },
      deploymentStatus: {
        enumType: exports2.TypeInfo.DeploymentStatus
      },
      lastModifiedOn: {
        isDate: true
      },
      operationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      postDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      preDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      queuedOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.DeploymentReason
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      scheduledDeploymentTime: {
        isDate: true
      },
      startedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.DeploymentApprovalCompletedEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeploymentApprovalPendingEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      approvalOptions: {
        typeInfo: exports2.TypeInfo.ApprovalOptions
      },
      completedApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      pendingApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeploymentAttempt.fields = {
      job: {
        typeInfo: exports2.TypeInfo.ReleaseTask
      },
      lastModifiedOn: {
        isDate: true
      },
      operationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      postDeploymentGates: {
        typeInfo: exports2.TypeInfo.ReleaseGates
      },
      preDeploymentGates: {
        typeInfo: exports2.TypeInfo.ReleaseGates
      },
      queuedOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.DeploymentReason
      },
      releaseDeployPhases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseDeployPhase
      },
      status: {
        enumType: exports2.TypeInfo.DeploymentStatus
      },
      tasks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTask
      }
    };
    exports2.TypeInfo.DeploymentAuthorizationInfo.fields = {
      authorizationHeaderFor: {
        enumType: exports2.TypeInfo.AuthorizationHeaderFor
      }
    };
    exports2.TypeInfo.DeploymentCompletedEvent.fields = {
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      }
    };
    exports2.TypeInfo.DeploymentJob.fields = {
      job: {
        typeInfo: exports2.TypeInfo.ReleaseTask
      },
      tasks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTask
      }
    };
    exports2.TypeInfo.DeploymentManualInterventionPendingEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      manualIntervention: {
        typeInfo: exports2.TypeInfo.ManualIntervention
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeploymentQueryParameters.fields = {
      deploymentStatus: {
        enumType: exports2.TypeInfo.DeploymentStatus
      },
      expands: {
        enumType: exports2.TypeInfo.DeploymentExpands
      },
      maxModifiedTime: {
        isDate: true
      },
      minModifiedTime: {
        isDate: true
      },
      operationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      queryOrder: {
        enumType: exports2.TypeInfo.ReleaseQueryOrder
      },
      queryType: {
        enumType: exports2.TypeInfo.DeploymentsQueryType
      }
    };
    exports2.TypeInfo.DeploymentStartedEvent.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeployPhase.fields = {
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.EnvironmentTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.EnvironmentTriggerType
      }
    };
    exports2.TypeInfo.ExecutionInput.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.Folder.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GatesDeployPhase.fields = {
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.IgnoredGate.fields = {
      lastModifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.MachineGroupBasedDeployPhase.fields = {
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.MailMessage.fields = {
      replyBy: {
        isDate: true
      },
      sections: {
        isArray: true,
        enumType: exports2.TypeInfo.MailSectionType
      },
      senderType: {
        enumType: exports2.TypeInfo.SenderType
      }
    };
    exports2.TypeInfo.ManualIntervention.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ManualInterventionStatus
      },
      type: {
        enumType: exports2.TypeInfo.ManualInterventionType
      }
    };
    exports2.TypeInfo.ManualInterventionUpdateMetadata.fields = {
      status: {
        enumType: exports2.TypeInfo.ManualInterventionStatus
      }
    };
    exports2.TypeInfo.MultiConfigInput.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.MultiMachineInput.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.PackageTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ParallelExecutionInputBase.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.PipelineProcess.fields = {
      type: {
        enumType: exports2.TypeInfo.PipelineProcessTypes
      }
    };
    exports2.TypeInfo.PropertySelector.fields = {
      selectorType: {
        enumType: exports2.TypeInfo.PropertySelectorType
      }
    };
    exports2.TypeInfo.PullRequestConfiguration.fields = {
      codeRepositoryReference: {
        typeInfo: exports2.TypeInfo.CodeRepositoryReference
      }
    };
    exports2.TypeInfo.PullRequestTrigger.fields = {
      pullRequestConfiguration: {
        typeInfo: exports2.TypeInfo.PullRequestConfiguration
      },
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.Release.fields = {
      createdOn: {
        isDate: true
      },
      environments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      modifiedOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.ReleaseReason
      },
      status: {
        enumType: exports2.TypeInfo.ReleaseStatus
      },
      variableGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.VariableGroup
      }
    };
    exports2.TypeInfo.ReleaseAbandonedEvent.fields = {
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseApproval.fields = {
      approvalType: {
        enumType: exports2.TypeInfo.ApprovalType
      },
      createdOn: {
        isDate: true
      },
      history: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApprovalHistory
      },
      modifiedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ApprovalStatus
      }
    };
    exports2.TypeInfo.ReleaseApprovalHistory.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseApprovalPendingEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      approvalOptions: {
        typeInfo: exports2.TypeInfo.ApprovalOptions
      },
      completedApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      environments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      pendingApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      }
    };
    exports2.TypeInfo.ReleaseCondition.fields = {
      conditionType: {
        enumType: exports2.TypeInfo.ConditionType
      }
    };
    exports2.TypeInfo.ReleaseCreatedEvent.fields = {
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseDefinition.fields = {
      createdOn: {
        isDate: true
      },
      environments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseDefinitionEnvironment
      },
      lastRelease: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      modifiedOn: {
        isDate: true
      },
      pipelineProcess: {
        typeInfo: exports2.TypeInfo.PipelineProcess
      },
      source: {
        enumType: exports2.TypeInfo.ReleaseDefinitionSource
      },
      triggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTriggerBase
      }
    };
    exports2.TypeInfo.ReleaseDefinitionApprovals.fields = {
      approvalOptions: {
        typeInfo: exports2.TypeInfo.ApprovalOptions
      }
    };
    exports2.TypeInfo.ReleaseDefinitionEnvironment.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Condition
      },
      deployPhases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeployPhase
      },
      environmentTriggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.EnvironmentTrigger
      },
      postDeployApprovals: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      preDeployApprovals: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      schedules: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseSchedule
      }
    };
    exports2.TypeInfo.ReleaseDefinitionEnvironmentTemplate.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionEnvironment
      }
    };
    exports2.TypeInfo.ReleaseDefinitionRevision.fields = {
      changedDate: {
        isDate: true
      },
      changeType: {
        enumType: exports2.TypeInfo.AuditAction
      }
    };
    exports2.TypeInfo.ReleaseDefinitionSummary.fields = {
      releases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseDeployPhase.fields = {
      deploymentJobs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentJob
      },
      manualInterventions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ManualIntervention
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      },
      startedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.DeployPhaseStatus
      }
    };
    exports2.TypeInfo.ReleaseEnvironment.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseCondition
      },
      createdOn: {
        isDate: true
      },
      deployPhasesSnapshot: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeployPhase
      },
      deploySteps: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentAttempt
      },
      modifiedOn: {
        isDate: true
      },
      nextScheduledUtcTime: {
        isDate: true
      },
      postApprovalsSnapshot: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      postDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      preApprovalsSnapshot: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      preDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      scheduledDeploymentTime: {
        isDate: true
      },
      schedules: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseSchedule
      },
      status: {
        enumType: exports2.TypeInfo.EnvironmentStatus
      },
      variableGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.VariableGroup
      }
    };
    exports2.TypeInfo.ReleaseEnvironmentCompletedEvent.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      reason: {
        enumType: exports2.TypeInfo.DeploymentReason
      }
    };
    exports2.TypeInfo.ReleaseEnvironmentStatusUpdatedEvent.fields = {
      environmentStatus: {
        enumType: exports2.TypeInfo.EnvironmentStatus
      },
      latestDeploymentOperationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      latestDeploymentStatus: {
        enumType: exports2.TypeInfo.DeploymentStatus
      }
    };
    exports2.TypeInfo.ReleaseEnvironmentUpdateMetadata.fields = {
      scheduledDeploymentTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.EnvironmentStatus
      }
    };
    exports2.TypeInfo.ReleaseGates.fields = {
      deploymentJobs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentJob
      },
      ignoredGates: {
        isArray: true,
        typeInfo: exports2.TypeInfo.IgnoredGate
      },
      lastModifiedOn: {
        isDate: true
      },
      stabilizationCompletedOn: {
        isDate: true
      },
      startedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.GateStatus
      },
      succeedingSince: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseGatesPhase.fields = {
      deploymentJobs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentJob
      },
      ignoredGates: {
        isArray: true,
        typeInfo: exports2.TypeInfo.IgnoredGate
      },
      manualInterventions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ManualIntervention
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      },
      stabilizationCompletedOn: {
        isDate: true
      },
      startedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.DeployPhaseStatus
      },
      succeedingSince: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseNotCreatedEvent.fields = {
      releaseReason: {
        enumType: exports2.TypeInfo.ReleaseReason
      }
    };
    exports2.TypeInfo.ReleaseReference.fields = {
      createdOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.ReleaseReason
      }
    };
    exports2.TypeInfo.ReleaseRevision.fields = {
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseSchedule.fields = {
      daysToRelease: {
        enumType: exports2.TypeInfo.ScheduleDays
      }
    };
    exports2.TypeInfo.ReleaseStartMetadata.fields = {
      artifacts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ArtifactMetadata
      },
      reason: {
        enumType: exports2.TypeInfo.ReleaseReason
      }
    };
    exports2.TypeInfo.ReleaseTask.fields = {
      dateEnded: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.TaskStatus
      }
    };
    exports2.TypeInfo.ReleaseTaskAttachment.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseTasksUpdatedEvent.fields = {
      job: {
        typeInfo: exports2.TypeInfo.ReleaseTask
      },
      tasks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTask
      }
    };
    exports2.TypeInfo.ReleaseTriggerBase.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ReleaseUpdatedEvent.fields = {
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseUpdateMetadata.fields = {
      status: {
        enumType: exports2.TypeInfo.ReleaseStatus
      }
    };
    exports2.TypeInfo.RunOnServerDeployPhase.fields = {
      deploymentInput: {
        typeInfo: exports2.TypeInfo.ServerDeploymentInput
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.ScheduledReleaseTrigger.fields = {
      schedule: {
        typeInfo: exports2.TypeInfo.ReleaseSchedule
      },
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ServerDeploymentInput.fields = {
      parallelExecution: {
        typeInfo: exports2.TypeInfo.ExecutionInput
      }
    };
    exports2.TypeInfo.SourcePullRequestVersion.fields = {
      pullRequestMergedAt: {
        isDate: true
      }
    };
    exports2.TypeInfo.SourceRepoTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.SummaryMailSection.fields = {
      sectionType: {
        enumType: exports2.TypeInfo.MailSectionType
      }
    };
    exports2.TypeInfo.VariableGroup.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.YamlFileSource.fields = {
      type: {
        enumType: exports2.TypeInfo.YamlFileSourceTypes
      }
    };
    exports2.TypeInfo.YamlPipelineProcess.fields = {
      fileSource: {
        typeInfo: exports2.TypeInfo.YamlFileSource
      },
      type: {
        enumType: exports2.TypeInfo.PipelineProcessTypes
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/ReleaseApi.js
var require_ReleaseApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/ReleaseApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReleaseApi = void 0;
    var basem = require_ClientApiBases();
    var ReleaseInterfaces = require_ReleaseInterfaces();
    var ReleaseApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Release-api", options2);
      }
      /**
       * Returns the artifact details that automation agent requires
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getAgentArtifactDefinitions(project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "f2571c27-bf50-4938-b396-32d109ddef26", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.AgentArtifactDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of approvals
       *
       * @param {string} project - Project ID or project name
       * @param {string} assignedToFilter - Approvals assigned to this user.
       * @param {ReleaseInterfaces.ApprovalStatus} statusFilter - Approvals with this status. Default is 'pending'.
       * @param {number[]} releaseIdsFilter - Approvals for release id(s) mentioned in the filter. Multiple releases can be mentioned by separating them with ',' e.g. releaseIdsFilter=1,2,3,4.
       * @param {ReleaseInterfaces.ApprovalType} typeFilter - Approval with this type.
       * @param {number} top - Number of approvals to get. Default is 50.
       * @param {number} continuationToken - Gets the approvals after the continuation token provided.
       * @param {ReleaseInterfaces.ReleaseQueryOrder} queryOrder - Gets the results in the defined order of created approvals. Default is 'descending'.
       * @param {boolean} includeMyGroupApprovals - 'true' to include my group approvals. Default is 'false'.
       */
      getApprovals(project, assignedToFilter, statusFilter, releaseIdsFilter, typeFilter, top, continuationToken, queryOrder, includeMyGroupApprovals) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              assignedToFilter,
              statusFilter,
              releaseIdsFilter: releaseIdsFilter && releaseIdsFilter.join(","),
              typeFilter,
              top,
              continuationToken,
              queryOrder,
              includeMyGroupApprovals
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "b47c6458-e73b-47cb-a770-4df1e8813a91", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get approval history.
       *
       * @param {string} project - Project ID or project name
       * @param {number} approvalStepId - Id of the approval.
       */
      getApprovalHistory(project, approvalStepId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              approvalStepId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "250c7158-852e-4130-a00f-a0cce9b72d05", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an approval.
       *
       * @param {string} project - Project ID or project name
       * @param {number} approvalId - Id of the approval.
       * @param {boolean} includeHistory - 'true' to include history of the approval. Default is 'false'.
       */
      getApproval(project, approvalId, includeHistory) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              approvalId
            };
            let queryValues = {
              includeHistory
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "9328e074-59fb-465a-89d9-b09c82ee5109", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update status of an approval
       *
       * @param {ReleaseInterfaces.ReleaseApproval} approval - ReleaseApproval object having status, approver and comments.
       * @param {string} project - Project ID or project name
       * @param {number} approvalId - Id of the approval.
       */
      updateReleaseApproval(approval, project, approvalId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              approvalId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "9328e074-59fb-465a-89d9-b09c82ee5109", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, approval, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.ReleaseApproval[]} approvals
       * @param {string} project - Project ID or project name
       */
      updateReleaseApprovals(approvals, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "c957584a-82aa-4131-8222-6d47f78bfa7a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, approvals, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a task attachment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} timelineId - Timeline Id of the task.
       * @param {string} recordId - Record Id of attachment.
       * @param {string} type - Type of the attachment.
       * @param {string} name - Name of the attachment.
       */
      getTaskAttachmentContent(project, releaseId, environmentId, attemptId, timelineId, recordId, type, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c4071f6d-3697-46ca-858e-8b10ff09e52f", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a release task attachment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} planId - Plan Id of the deploy phase.
       * @param {string} timelineId - Timeline Id of the task.
       * @param {string} recordId - Record Id of attachment.
       * @param {string} type - Type of the attachment.
       * @param {string} name - Name of the attachment.
       */
      getReleaseTaskAttachmentContent(project, releaseId, environmentId, attemptId, planId, timelineId, recordId, type, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "60b86efb-7b8c-4853-8f9f-aa142b77b479", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the task attachments.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} timelineId - Timeline Id of the task.
       * @param {string} type - Type of the attachment.
       */
      getTaskAttachments(project, releaseId, environmentId, attemptId, timelineId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "214111ee-2415-4df2-8ed2-74417f7d61f9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the release task attachments.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} planId - Plan Id of the deploy phase.
       * @param {string} type - Type of the attachment.
       */
      getReleaseTaskAttachments(project, releaseId, environmentId, attemptId, planId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              planId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "a4d06688-0dfa-4895-82a5-f43ec9452306", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} artifactType
       * @param {string} sourceId
       * @param {string} artifactVersionId
       * @param {string} project - Project ID or project name
       */
      getAutoTriggerIssues(artifactType, sourceId, artifactVersionId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactType == null) {
            throw new TypeError("artifactType can not be null or undefined");
          }
          if (sourceId == null) {
            throw new TypeError("sourceId can not be null or undefined");
          }
          if (artifactVersionId == null) {
            throw new TypeError("artifactVersionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              artifactType,
              sourceId,
              artifactVersionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c1a68497-69da-40fb-9423-cab19cfeeca9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.AutoTriggerIssue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent deployment for an environment.
       *
       * @param {string} projectId - The ID of the Project.
       * @param {number} releaseDefinitionId - The ID of the Release Definition.
       * @param {number} environmentId - The ID of the Environment.
       * @param {string} branchName - The name of the branch.
       */
      getDeploymentBadge(projectId, releaseDefinitionId, environmentId, branchName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              releaseDefinitionId,
              environmentId,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "1a60a35d-b8c9-45fb-bf67-da0829711147", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} baseReleaseId
       * @param {number} top
       * @param {string} artifactAlias
       */
      getReleaseChanges(project, releaseId, baseReleaseId, top, artifactAlias) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              baseReleaseId,
              "$top": top,
              artifactAlias
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "8dcf9fe9-ca37-4113-8ee1-37928e98407c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Change, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       * @param {string[]} propertyFilters
       */
      getDefinitionEnvironments(project, taskGroupId, propertyFilters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              taskGroupId,
              propertyFilters: propertyFilters && propertyFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "12b5d21a-f54c-430e-a8c1-7515d196890e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a release definition
       *
       * @param {ReleaseInterfaces.ReleaseDefinition} releaseDefinition - release definition object to create.
       * @param {string} project - Project ID or project name
       */
      createReleaseDefinition(releaseDefinition, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releaseDefinition, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a release definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition.
       * @param {string} comment - Comment for deleting a release definition.
       * @param {boolean} forceDelete - 'true' to automatically cancel any in-progress release deployments and proceed with release definition deletion . Default is 'false'.
       */
      deleteReleaseDefinition(project, definitionId, comment, forceDelete) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              comment,
              forceDelete
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a release definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition.
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definition will contain values for the specified property Ids (if they exist). If not set, properties will not be included.
       * @param {boolean} includeDisabled - Boolean flag to include disabled definitions.
       */
      getReleaseDefinition(project, definitionId, propertyFilters, includeDisabled) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              propertyFilters: propertyFilters && propertyFilters.join(","),
              includeDisabled
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release definition of a given revision.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition.
       * @param {number} revision - Revision number of the release definition.
       */
      getReleaseDefinitionRevision(project, definitionId, revision) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (revision == null) {
            throw new TypeError("revision can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of release definitions.
       *
       * @param {string} project - Project ID or project name
       * @param {string} searchText - Get release definitions with names containing searchText.
       * @param {ReleaseInterfaces.ReleaseDefinitionExpands} expand - The properties that should be expanded in the list of Release definitions.
       * @param {string} artifactType - Release definitions with given artifactType will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.
       * @param {string} artifactSourceId - Release definitions with given artifactSourceId will be returned. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json at https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.
       * @param {number} top - Number of release definitions to get.
       * @param {string} continuationToken - Gets the release definitions after the continuation token provided.
       * @param {ReleaseInterfaces.ReleaseDefinitionQueryOrder} queryOrder - Gets the results in the defined order. Default is 'IdAscending'.
       * @param {string} path - Gets the release definitions under the specified path.
       * @param {boolean} isExactNameMatch - 'true'to gets the release definitions with exact match as specified in searchText. Default is 'false'.
       * @param {string[]} tagFilter - A comma-delimited list of tags. Only release definitions with these tags will be returned.
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definitions will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release Definition from results irrespective of whether it has property set or not.
       * @param {string[]} definitionIdFilter - A comma-delimited list of release definitions to retrieve.
       * @param {boolean} isDeleted - 'true' to get release definitions that has been deleted. Default is 'false'
       * @param {boolean} searchTextContainsFolderName - 'true' to get the release definitions under the folder with name as specified in searchText. Default is 'false'.
       */
      getReleaseDefinitions(project, searchText, expand, artifactType, artifactSourceId, top, continuationToken, queryOrder, path10, isExactNameMatch, tagFilter, propertyFilters, definitionIdFilter, isDeleted, searchTextContainsFolderName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              searchText,
              "$expand": expand,
              artifactType,
              artifactSourceId,
              "$top": top,
              continuationToken,
              queryOrder,
              path: path10,
              isExactNameMatch,
              tagFilter: tagFilter && tagFilter.join(","),
              propertyFilters: propertyFilters && propertyFilters.join(","),
              definitionIdFilter: definitionIdFilter && definitionIdFilter.join(","),
              isDeleted,
              searchTextContainsFolderName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Undelete a release definition.
       *
       * @param {ReleaseInterfaces.ReleaseDefinitionUndeleteParameter} releaseDefinitionUndeleteParameter - Object for undelete release definition.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition to be undeleted
       */
      undeleteReleaseDefinition(releaseDefinitionUndeleteParameter, project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, releaseDefinitionUndeleteParameter, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a release definition.
       *
       * @param {ReleaseInterfaces.ReleaseDefinition} releaseDefinition - Release definition object to update.
       * @param {string} project - Project ID or project name
       * @param {boolean} skipTasksValidation - Skip task validation boolean flag
       */
      updateReleaseDefinition(releaseDefinition, project, skipTasksValidation) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              skipTasksValidation
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, releaseDefinition, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployments
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - List the deployments for a given definition id.
       * @param {number} definitionEnvironmentId - List the deployments for a given definition environment id.
       * @param {string} createdBy - List the deployments for which deployments are created as identity specified.
       * @param {Date} minModifiedTime - List the deployments with LastModified time >= minModifiedTime.
       * @param {Date} maxModifiedTime - List the deployments with LastModified time <= maxModifiedTime.
       * @param {ReleaseInterfaces.DeploymentStatus} deploymentStatus - List the deployments with given deployment status. Default is 'All'.
       * @param {ReleaseInterfaces.DeploymentOperationStatus} operationStatus - List the deployments with given operation status. Default is 'All'.
       * @param {boolean} latestAttemptsOnly - 'true' to include deployments with latest attempt only. Default is 'false'.
       * @param {ReleaseInterfaces.ReleaseQueryOrder} queryOrder - List the deployments with given query order. Default is 'Descending'.
       * @param {number} top - List the deployments with given top. Default top is '50' and Max top is '100'.
       * @param {number} continuationToken - List the deployments with deployment id >= continuationToken.
       * @param {string} createdFor - List the deployments for which deployments are requested as identity specified.
       * @param {Date} minStartedTime - List the deployments with StartedOn time >= minStartedTime.
       * @param {Date} maxStartedTime - List the deployments with StartedOn time <= maxStartedTime.
       * @param {string} sourceBranch - List the deployments that are deployed from given branch name.
       */
      getDeployments(project, definitionId, definitionEnvironmentId, createdBy, minModifiedTime, maxModifiedTime, deploymentStatus, operationStatus, latestAttemptsOnly, queryOrder, top, continuationToken, createdFor, minStartedTime, maxStartedTime, sourceBranch) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionId,
              definitionEnvironmentId,
              createdBy,
              minModifiedTime,
              maxModifiedTime,
              deploymentStatus,
              operationStatus,
              latestAttemptsOnly,
              queryOrder,
              "$top": top,
              continuationToken,
              createdFor,
              minStartedTime,
              maxStartedTime,
              sourceBranch
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "b005ef73-cddc-448e-9ba2-5193bf36b19f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Deployment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.DeploymentQueryParameters} queryParameters
       * @param {string} project - Project ID or project name
       */
      getDeploymentsForMultipleEnvironments(queryParameters, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "b005ef73-cddc-448e-9ba2-5193bf36b19f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queryParameters, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Deployment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a release environment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {ReleaseInterfaces.ReleaseEnvironmentExpands} expand - A property that should be expanded in the environment.
       */
      getReleaseEnvironment(project, releaseId, environmentId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a7e426b1-03dc-48af-9dfe-c98bac612dcb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseEnvironment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of a release environment
       *
       * @param {ReleaseInterfaces.ReleaseEnvironmentUpdateMetadata} environmentUpdateData - Environment update meta data.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       */
      updateReleaseEnvironment(environmentUpdateData, project, releaseId, environmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a7e426b1-03dc-48af-9dfe-c98bac612dcb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, environmentUpdateData, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseEnvironment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a definition environment template
       *
       * @param {ReleaseInterfaces.ReleaseDefinitionEnvironmentTemplate} template - Definition environment template to create
       * @param {string} project - Project ID or project name
       */
      createDefinitionEnvironmentTemplate(template2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, template2, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a definition environment template
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - Id of the definition environment template
       */
      deleteDefinitionEnvironmentTemplate(project, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (templateId == null) {
            throw new TypeError("templateId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a definition environment template
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - Id of the definition environment template
       */
      getDefinitionEnvironmentTemplate(project, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (templateId == null) {
            throw new TypeError("templateId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of definition environment templates
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} isDeleted - 'true' to get definition environment templates that have been deleted. Default is 'false'
       */
      listDefinitionEnvironmentTemplates(project, isDeleted) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              isDeleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Undelete a release definition environment template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - Id of the definition environment template to be undeleted
       */
      undeleteReleaseDefinitionEnvironmentTemplate(project, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (templateId == null) {
            throw new TypeError("templateId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.FavoriteItem[]} favoriteItems
       * @param {string} project - Project ID or project name
       * @param {string} scope
       * @param {string} identityId
       */
      createFavorites(favoriteItems, project, scope, identityId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              scope
            };
            let queryValues = {
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "938f7222-9acb-48fe-b8a3-4eda04597171", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, favoriteItems, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} scope
       * @param {string} identityId
       * @param {string} favoriteItemIds
       */
      deleteFavorites(project, scope, identityId, favoriteItemIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              scope
            };
            let queryValues = {
              identityId,
              favoriteItemIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "938f7222-9acb-48fe-b8a3-4eda04597171", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} scope
       * @param {string} identityId
       */
      getFavorites(project, scope, identityId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              scope
            };
            let queryValues = {
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "938f7222-9acb-48fe-b8a3-4eda04597171", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} flightName
       */
      getFlightAssignments(flightName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              flightName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "409d301f-3046-46f3-beb9-4357fbce0a8c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new folder.
       *
       * @param {ReleaseInterfaces.Folder} folder - folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder.
       */
      createFolder(folder, project, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, folder, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a definition folder for given folder name and path and all it's existing definitions.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder to delete.
       */
      deleteFolder(project, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets folders.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder.
       * @param {ReleaseInterfaces.FolderPathQueryOrder} queryOrder - Gets the results in the defined order. Default is 'None'.
       */
      getFolders(project, path10, queryOrder) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path10
            };
            let queryValues = {
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Folder, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing folder at given existing path.
       *
       * @param {ReleaseInterfaces.Folder} folder - folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder to update.
       */
      updateFolder(folder, project, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, folder, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the gate for a deployment.
       *
       * @param {ReleaseInterfaces.GateUpdateMetadata} gateUpdateMetadata - Metadata to patch the Release Gates.
       * @param {string} project - Project ID or project name
       * @param {number} gateStepId - Gate step Id.
       */
      updateGates(gateUpdateMetadata, project, gateStepId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              gateStepId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "2666a539-2001-4f80-bcc7-0379956749d4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, gateUpdateMetadata, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseGates, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getReleaseHistory(project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "23f461c8-629a-4144-a076-3054fa5f268a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {FormInputInterfaces.InputValuesQuery} query
       * @param {string} project - Project ID or project name
       */
      getInputValues(query, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "71dd499b-317d-45ea-9134-140ea1932b5e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} sourceId
       */
      getIssues(project, buildId, sourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              sourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "cd42261a-f5c6-41c8-9259-f078989b9f25", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.AutoTriggerIssue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets gate logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} gateId - Id of the gate.
       * @param {number} taskId - ReleaseTask Id for the log.
       */
      getGateLog(project, releaseId, environmentId, gateId, taskId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              gateId,
              taskId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "dec7ca5a-7f7f-4797-8bf1-8efc0dc93b28", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get logs for a release Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       */
      getLogs(project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "c37fbab5-214b-48e4-a55b-cb6b4f6e4038", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} taskId - ReleaseTask Id for the log.
       * @param {number} attemptId - Id of the attempt.
       */
      getLog(project, releaseId, environmentId, taskId, attemptId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              taskId
            };
            let queryValues = {
              attemptId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "e71ba1ed-c0a4-4a28-a61f-2dd5f68cf3fd", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the task log of a release as a plain text file.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} attemptId
       * @param {string} timelineId
       * @param {number} taskId - ReleaseTask Id for the log.
       * @param {number} startLine - Starting line number for logs
       * @param {number} endLine - Ending line number for logs
       */
      getTaskLog2(project, releaseId, environmentId, attemptId, timelineId, taskId, startLine, endLine) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId,
              taskId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "2577e6c3-6999-4400-bc69-fe1d837755fe", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the task log of a release as a plain text file.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} releaseDeployPhaseId - Release deploy phase Id.
       * @param {number} taskId - ReleaseTask Id for the log.
       * @param {number} startLine - Starting line number for logs
       * @param {number} endLine - Ending line number for logs
       */
      getTaskLog(project, releaseId, environmentId, releaseDeployPhaseId, taskId, startLine, endLine) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              releaseDeployPhaseId,
              taskId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "17c91af7-09fd-4256-bff1-c24ee4f73bc0", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get manual intervention for a given release and manual intervention id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} manualInterventionId - Id of the manual intervention.
       */
      getManualIntervention(project, releaseId, manualInterventionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              manualInterventionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "616c46e4-f370-4456-adaa-fbaf79c7b79e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ManualIntervention, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List all manual interventions for a given release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       */
      getManualInterventions(project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "616c46e4-f370-4456-adaa-fbaf79c7b79e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ManualIntervention, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update manual intervention.
       *
       * @param {ReleaseInterfaces.ManualInterventionUpdateMetadata} manualInterventionUpdateMetadata - Meta data to update manual intervention.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} manualInterventionId - Id of the manual intervention.
       */
      updateManualIntervention(manualInterventionUpdateMetadata, project, releaseId, manualInterventionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              manualInterventionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "616c46e4-f370-4456-adaa-fbaf79c7b79e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, manualInterventionUpdateMetadata, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ManualIntervention, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {Date} minMetricsTime
       */
      getMetrics(project, minMetricsTime) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              minMetricsTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "cd1502bb-3c73-4e11-80a6-d11308dceae5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets Org pipeline release settings
       *
       */
      getOrgPipelineReleaseSettings() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "d156c759-ca4e-492b-90d4-db03971796ea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates Org pipeline release settings
       *
       * @param {ReleaseInterfaces.OrgPipelineReleaseSettingsUpdateParameters} newSettings
       */
      updateOrgPipelineReleaseSettings(newSettings) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "d156c759-ca4e-492b-90d4-db03971796ea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets pipeline release settings
       *
       * @param {string} project - Project ID or project name
       */
      getPipelineReleaseSettings(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "e816b9f4-f9fe-46ba-bdcc-a9af6abf3144", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates pipeline release settings
       *
       * @param {ReleaseInterfaces.ProjectPipelineReleaseSettingsUpdateParameters} newSettings
       * @param {string} project - Project ID or project name
       */
      updatePipelineReleaseSettings(newSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "e816b9f4-f9fe-46ba-bdcc-a9af6abf3144", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} artifactType
       * @param {string} artifactSourceId
       */
      getReleaseProjects(artifactType, artifactSourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactType == null) {
            throw new TypeError("artifactType can not be null or undefined");
          }
          if (artifactSourceId == null) {
            throw new TypeError("artifactSourceId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              artifactType,
              artifactSourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "917ace4a-79d1-45a7-987c-7be4db4268fa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of releases
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Releases from this release definition Id.
       * @param {number} definitionEnvironmentId
       * @param {string} searchText - Releases with names containing searchText.
       * @param {string} createdBy - Releases created by this user.
       * @param {ReleaseInterfaces.ReleaseStatus} statusFilter - Releases that have this status.
       * @param {number} environmentStatusFilter
       * @param {Date} minCreatedTime - Releases that were created after this time.
       * @param {Date} maxCreatedTime - Releases that were created before this time.
       * @param {ReleaseInterfaces.ReleaseQueryOrder} queryOrder - Gets the results in the defined order of created date for releases. Default is descending.
       * @param {number} top - Number of releases to get. Default is 50.
       * @param {number} continuationToken - Gets the releases after the continuation token provided.
       * @param {ReleaseInterfaces.ReleaseExpands} expand - The property that should be expanded in the list of releases.
       * @param {string} artifactTypeId - Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.
       * @param {string} sourceId - Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.
       * @param {string} artifactVersionId - Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId.
       * @param {string} sourceBranchFilter - Releases with given sourceBranchFilter will be returned (Not to be used with environmentStatusFilter).
       * @param {boolean} isDeleted - Gets the soft deleted releases, if true.
       * @param {string[]} tagFilter - A comma-delimited list of tags. Only releases with these tags will be returned.
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not.
       * @param {number[]} releaseIdFilter - A comma-delimited list of releases Ids. Only releases with these Ids will be returned.
       * @param {string} path - Releases under this folder path will be returned
       */
      getReleases(project, definitionId, definitionEnvironmentId, searchText, createdBy, statusFilter, environmentStatusFilter, minCreatedTime, maxCreatedTime, queryOrder, top, continuationToken, expand, artifactTypeId, sourceId, artifactVersionId, sourceBranchFilter, isDeleted, tagFilter, propertyFilters, releaseIdFilter, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionId,
              definitionEnvironmentId,
              searchText,
              createdBy,
              statusFilter,
              environmentStatusFilter,
              minCreatedTime,
              maxCreatedTime,
              queryOrder,
              "$top": top,
              continuationToken,
              "$expand": expand,
              artifactTypeId,
              sourceId,
              artifactVersionId,
              sourceBranchFilter,
              isDeleted,
              tagFilter: tagFilter && tagFilter.join(","),
              propertyFilters: propertyFilters && propertyFilters.join(","),
              releaseIdFilter: releaseIdFilter && releaseIdFilter.join(","),
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a release.
       *
       * @param {ReleaseInterfaces.ReleaseStartMetadata} releaseStartMetadata - Metadata to create a release.
       * @param {string} project - Project ID or project name
       */
      createRelease(releaseStartMetadata, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releaseStartMetadata, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Soft delete a release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {string} comment - Comment for deleting a release.
       */
      deleteRelease(project, releaseId, comment) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              comment
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a Release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {ReleaseInterfaces.ApprovalFilters} approvalFilters - A filter which would allow fetching approval steps selectively based on whether it is automated, or manual. This would also decide whether we should fetch pre and post approval snapshots. Assumes All by default
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Release will contain values for the specified property Ids (if they exist). If not set, properties will not be included.
       * @param {ReleaseInterfaces.SingleReleaseExpands} expand - A property that should be expanded in the release.
       * @param {number} topGateRecords - Number of release gate records to get. Default is 5.
       * @param {boolean} includeDisabledDefinitions - Include disabled definitions (if set to 'false' returns error, default is 'true')
       */
      getRelease(project, releaseId, approvalFilters, propertyFilters, expand, topGateRecords, includeDisabledDefinitions) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              approvalFilters,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              "$expand": expand,
              "$topGateRecords": topGateRecords,
              includeDisabledDefinitions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release summary of a given definition Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the definition to get release summary.
       * @param {number} releaseCount - Count of releases to be included in summary.
       * @param {boolean} includeArtifact - Include artifact details.Default is 'false'.
       * @param {number[]} definitionEnvironmentIdsFilter
       */
      getReleaseDefinitionSummary(project, definitionId, releaseCount, includeArtifact, definitionEnvironmentIdsFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (definitionId == null) {
            throw new TypeError("definitionId can not be null or undefined");
          }
          if (releaseCount == null) {
            throw new TypeError("releaseCount can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionId,
              releaseCount,
              includeArtifact,
              definitionEnvironmentIdsFilter: definitionEnvironmentIdsFilter && definitionEnvironmentIdsFilter.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release for a given revision number.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} definitionSnapshotRevision - Definition snapshot revision number.
       */
      getReleaseRevision(project, releaseId, definitionSnapshotRevision) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (definitionSnapshotRevision == null) {
            throw new TypeError("definitionSnapshotRevision can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              definitionSnapshotRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Undelete a soft deleted release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of release to be undeleted.
       * @param {string} comment - Any comment for undeleting.
       */
      undeleteRelease(project, releaseId, comment) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (comment == null) {
            throw new TypeError("comment can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              comment
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a complete release object.
       *
       * @param {ReleaseInterfaces.Release} release - Release object for update.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release to update.
       */
      updateRelease(release, project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, release, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update few properties of a release.
       *
       * @param {ReleaseInterfaces.ReleaseUpdateMetadata} releaseUpdateMetadata - Properties of release to update.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release to update.
       */
      updateReleaseResource(releaseUpdateMetadata, project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.9", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, releaseUpdateMetadata, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the release settings
       *
       * @param {string} project - Project ID or project name
       */
      getReleaseSettings(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c63c3718-7cfd-41e0-b89b-81c1ca143437", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the release settings
       *
       * @param {ReleaseInterfaces.ReleaseSettings} releaseSettings
       * @param {string} project - Project ID or project name
       */
      updateReleaseSettings(releaseSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c63c3718-7cfd-41e0-b89b-81c1ca143437", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, releaseSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release definition for a given definitionId and revision
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the definition.
       * @param {number} revision - Id of the revision.
       */
      getDefinitionRevision(project, definitionId, revision) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId,
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "258b82e0-9d41-43f3-86d6-fef14ddd44bc", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get revision history for a release definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the definition.
       */
      getReleaseDefinitionHistory(project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "258b82e0-9d41-43f3-86d6-fef14ddd44bc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getSummaryMailSections(project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "224e92b2-8d13-4c14-b120-13d877c516f8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.SummaryMailSection, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.MailMessage} mailMessage
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      sendSummaryMail(mailMessage, project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "224e92b2-8d13-4c14-b120-13d877c516f8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, mailMessage, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} definitionId
       */
      getSourceBranches(project, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "0e5def23-78b3-461f-8198-1558f25041c8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       * @param {string} tag
       */
      addDefinitionTag(project, releaseDefinitionId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds multiple tags to a definition
       *
       * @param {string[]} tags
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       */
      addDefinitionTags(tags, project, releaseDefinitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a tag from a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       * @param {string} tag
       */
      deleteDefinitionTag(project, releaseDefinitionId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       */
      getDefinitionTags(project, releaseDefinitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a releaseId
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} tag
       */
      addReleaseTag(project, releaseId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds tag to a release
       *
       * @param {string[]} tags
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      addReleaseTags(tags, project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a tag from a release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} tag
       */
      deleteReleaseTag(project, releaseId, tag) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getReleaseTags(project, releaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getTags(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "86cee25a-68ba-4ba3-9171-8ad6ffc6df93", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} environmentId
       * @param {number} releaseDeployPhaseId
       */
      getTasksForTaskGroup(project, releaseId, environmentId, releaseDeployPhaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              releaseDeployPhaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "4259191d-4b0a-4409-9fb3-09f22ab9bc47", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTask, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} environmentId
       * @param {number} attemptId
       * @param {string} timelineId
       */
      getTasks2(project, releaseId, environmentId, attemptId, timelineId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "4259291d-4b0a-4409-9fb3-04f22ab9bc47", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTask, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} environmentId
       * @param {number} attemptId
       */
      getTasks(project, releaseId, environmentId, attemptId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId
            };
            let queryValues = {
              attemptId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "36b276e0-3c70-4320-a63c-1a2e1466a0d1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTask, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getArtifactTypeDefinitions(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "8efc2a3c-1fc8-4f6d-9822-75e98cecb48f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ArtifactTypeDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       */
      getArtifactVersions(project, releaseDefinitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseDefinitionId == null) {
            throw new TypeError("releaseDefinitionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseDefinitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "30fc787e-a9e0-4a07-9fbc-3e903aa051d2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ArtifactVersionQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.Artifact[]} artifacts
       * @param {string} project - Project ID or project name
       */
      getArtifactVersionsForSources(artifacts, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "30fc787e-a9e0-4a07-9fbc-3e903aa051d2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, artifacts, options2);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ArtifactVersionQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} baseReleaseId
       * @param {number} top
       * @param {string} artifactAlias
       */
      getReleaseWorkItemsRefs(project, releaseId, baseReleaseId, top, artifactAlias) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              baseReleaseId,
              "$top": top,
              artifactAlias
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "4f165cc0-875c-4768-b148-f12f78769fab", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ReleaseApi = ReleaseApi;
    ReleaseApi.RESOURCE_AREA_ID = "efc2f575-36ef-48e9-b672-0c6fb4a48ac5";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/SecurityRolesInterfaces.js
var require_SecurityRolesInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/SecurityRolesInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.RoleAccess = void 0;
    var RoleAccess;
    (function(RoleAccess2) {
      RoleAccess2[RoleAccess2["Assigned"] = 1] = "Assigned";
      RoleAccess2[RoleAccess2["Inherited"] = 2] = "Inherited";
    })(RoleAccess = exports2.RoleAccess || (exports2.RoleAccess = {}));
    exports2.TypeInfo = {
      RoleAccess: {
        enumValues: {
          "assigned": 1,
          "inherited": 2
        }
      },
      RoleAssignment: {}
    };
    exports2.TypeInfo.RoleAssignment.fields = {
      access: {
        enumType: exports2.TypeInfo.RoleAccess
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/SecurityRolesApi.js
var require_SecurityRolesApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/SecurityRolesApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecurityRolesApi = void 0;
    var basem = require_ClientApiBases();
    var SecurityRolesInterfaces = require_SecurityRolesInterfaces();
    var SecurityRolesApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-SecurityRoles-api", options2);
      }
      /**
       * @param {string} scopeId
       * @param {string} resourceId
       */
      getRoleAssignments(scopeId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, SecurityRolesInterfaces.TypeInfo.RoleAssignment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeId
       * @param {string} resourceId
       * @param {string} identityId
       */
      removeRoleAssignment(scopeId, resourceId, identityId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId,
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string[]} identityIds
       * @param {string} scopeId
       * @param {string} resourceId
       */
      removeRoleAssignments(identityIds, scopeId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, identityIds, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {SecurityRolesInterfaces.UserRoleAssignmentRef} roleAssignment
       * @param {string} scopeId
       * @param {string} resourceId
       * @param {string} identityId
       */
      setRoleAssignment(roleAssignment, scopeId, resourceId, identityId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId,
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, roleAssignment, options2);
              let ret = this.formatResponse(res.result, SecurityRolesInterfaces.TypeInfo.RoleAssignment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {SecurityRolesInterfaces.UserRoleAssignmentRef[]} roleAssignments
       * @param {string} scopeId
       * @param {string} resourceId
       */
      setRoleAssignments(roleAssignments, scopeId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, roleAssignments, options2);
              let ret = this.formatResponse(res.result, SecurityRolesInterfaces.TypeInfo.RoleAssignment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeId
       */
      getRoleDefinitions(scopeId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "f4cc9a86-453c-48d2-b44d-d3bd5c105f4f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.SecurityRolesApi = SecurityRolesApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/TaskAgentInterfaces.js
var require_TaskAgentInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/TaskAgentInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VariableGroupQueryOrder = exports2.VariableGroupActionFilter = exports2.TimelineRecordState = exports2.TaskResult = exports2.TaskOrchestrationPlanState = exports2.TaskOrchestrationItemType = exports2.TaskGroupQueryOrder = exports2.TaskGroupExpands = exports2.TaskDefinitionStatus = exports2.TaskCommandMode = exports2.TaskAgentUpdateReasonType = exports2.TaskAgentStatusFilter = exports2.TaskAgentStatus = exports2.TaskAgentRequestUpdateOptions = exports2.TaskAgentQueueActionFilter = exports2.TaskAgentPoolType = exports2.TaskAgentPoolOptions = exports2.TaskAgentPoolMaintenanceScheduleDays = exports2.TaskAgentPoolMaintenanceJobStatus = exports2.TaskAgentPoolMaintenanceJobResult = exports2.TaskAgentPoolActionFilter = exports2.TaskAgentJobStepType = exports2.TaskAgentJobResultFilter = exports2.StageTriggerType = exports2.SecureFileActionFilter = exports2.ResourceLockStatus = exports2.PlanGroupStatusFilter = exports2.PlanGroupStatus = exports2.OrchestrationType = exports2.OperationType = exports2.OperatingSystemType = exports2.MaskType = exports2.MachineGroupActionFilter = exports2.LogLevel = exports2.IssueType = exports2.ExclusiveLockType = exports2.EnvironmentResourceType = exports2.EnvironmentExpands = exports2.EnvironmentActionFilter = exports2.ElasticPoolState = exports2.ElasticNodeState = exports2.ElasticComputeState = exports2.ElasticAgentState = exports2.DeploymentTargetExpands = exports2.DeploymentPoolSummaryExpands = exports2.DeploymentMachineExpands = exports2.DeploymentGroupExpands = exports2.DeploymentGroupActionFilter = exports2.DemandSourceType = exports2.AuditAction = exports2.AadLoginPromptOption = void 0;
    var FormInputInterfaces = require_FormInputInterfaces();
    var AadLoginPromptOption;
    (function(AadLoginPromptOption2) {
      AadLoginPromptOption2[AadLoginPromptOption2["NoOption"] = 0] = "NoOption";
      AadLoginPromptOption2[AadLoginPromptOption2["Login"] = 1] = "Login";
      AadLoginPromptOption2[AadLoginPromptOption2["SelectAccount"] = 2] = "SelectAccount";
      AadLoginPromptOption2[AadLoginPromptOption2["FreshLogin"] = 3] = "FreshLogin";
      AadLoginPromptOption2[AadLoginPromptOption2["FreshLoginWithMfa"] = 4] = "FreshLoginWithMfa";
    })(AadLoginPromptOption = exports2.AadLoginPromptOption || (exports2.AadLoginPromptOption = {}));
    var AuditAction;
    (function(AuditAction2) {
      AuditAction2[AuditAction2["Add"] = 1] = "Add";
      AuditAction2[AuditAction2["Update"] = 2] = "Update";
      AuditAction2[AuditAction2["Delete"] = 3] = "Delete";
      AuditAction2[AuditAction2["Undelete"] = 4] = "Undelete";
    })(AuditAction = exports2.AuditAction || (exports2.AuditAction = {}));
    var DemandSourceType;
    (function(DemandSourceType2) {
      DemandSourceType2[DemandSourceType2["Task"] = 0] = "Task";
      DemandSourceType2[DemandSourceType2["Feature"] = 1] = "Feature";
    })(DemandSourceType = exports2.DemandSourceType || (exports2.DemandSourceType = {}));
    var DeploymentGroupActionFilter;
    (function(DeploymentGroupActionFilter2) {
      DeploymentGroupActionFilter2[DeploymentGroupActionFilter2["None"] = 0] = "None";
      DeploymentGroupActionFilter2[DeploymentGroupActionFilter2["Manage"] = 2] = "Manage";
      DeploymentGroupActionFilter2[DeploymentGroupActionFilter2["Use"] = 16] = "Use";
    })(DeploymentGroupActionFilter = exports2.DeploymentGroupActionFilter || (exports2.DeploymentGroupActionFilter = {}));
    var DeploymentGroupExpands;
    (function(DeploymentGroupExpands2) {
      DeploymentGroupExpands2[DeploymentGroupExpands2["None"] = 0] = "None";
      DeploymentGroupExpands2[DeploymentGroupExpands2["Machines"] = 2] = "Machines";
      DeploymentGroupExpands2[DeploymentGroupExpands2["Tags"] = 4] = "Tags";
    })(DeploymentGroupExpands = exports2.DeploymentGroupExpands || (exports2.DeploymentGroupExpands = {}));
    var DeploymentMachineExpands;
    (function(DeploymentMachineExpands2) {
      DeploymentMachineExpands2[DeploymentMachineExpands2["None"] = 0] = "None";
      DeploymentMachineExpands2[DeploymentMachineExpands2["Capabilities"] = 2] = "Capabilities";
      DeploymentMachineExpands2[DeploymentMachineExpands2["AssignedRequest"] = 4] = "AssignedRequest";
    })(DeploymentMachineExpands = exports2.DeploymentMachineExpands || (exports2.DeploymentMachineExpands = {}));
    var DeploymentPoolSummaryExpands;
    (function(DeploymentPoolSummaryExpands2) {
      DeploymentPoolSummaryExpands2[DeploymentPoolSummaryExpands2["None"] = 0] = "None";
      DeploymentPoolSummaryExpands2[DeploymentPoolSummaryExpands2["DeploymentGroups"] = 2] = "DeploymentGroups";
      DeploymentPoolSummaryExpands2[DeploymentPoolSummaryExpands2["Resource"] = 4] = "Resource";
    })(DeploymentPoolSummaryExpands = exports2.DeploymentPoolSummaryExpands || (exports2.DeploymentPoolSummaryExpands = {}));
    var DeploymentTargetExpands;
    (function(DeploymentTargetExpands2) {
      DeploymentTargetExpands2[DeploymentTargetExpands2["None"] = 0] = "None";
      DeploymentTargetExpands2[DeploymentTargetExpands2["Capabilities"] = 2] = "Capabilities";
      DeploymentTargetExpands2[DeploymentTargetExpands2["AssignedRequest"] = 4] = "AssignedRequest";
      DeploymentTargetExpands2[DeploymentTargetExpands2["LastCompletedRequest"] = 8] = "LastCompletedRequest";
    })(DeploymentTargetExpands = exports2.DeploymentTargetExpands || (exports2.DeploymentTargetExpands = {}));
    var ElasticAgentState;
    (function(ElasticAgentState2) {
      ElasticAgentState2[ElasticAgentState2["None"] = 0] = "None";
      ElasticAgentState2[ElasticAgentState2["Enabled"] = 1] = "Enabled";
      ElasticAgentState2[ElasticAgentState2["Online"] = 2] = "Online";
      ElasticAgentState2[ElasticAgentState2["Assigned"] = 4] = "Assigned";
    })(ElasticAgentState = exports2.ElasticAgentState || (exports2.ElasticAgentState = {}));
    var ElasticComputeState;
    (function(ElasticComputeState2) {
      ElasticComputeState2[ElasticComputeState2["None"] = 0] = "None";
      ElasticComputeState2[ElasticComputeState2["Healthy"] = 1] = "Healthy";
      ElasticComputeState2[ElasticComputeState2["Creating"] = 2] = "Creating";
      ElasticComputeState2[ElasticComputeState2["Deleting"] = 3] = "Deleting";
      ElasticComputeState2[ElasticComputeState2["Failed"] = 4] = "Failed";
      ElasticComputeState2[ElasticComputeState2["Stopped"] = 5] = "Stopped";
      ElasticComputeState2[ElasticComputeState2["Reimaging"] = 6] = "Reimaging";
      ElasticComputeState2[ElasticComputeState2["UnhealthyVm"] = 7] = "UnhealthyVm";
      ElasticComputeState2[ElasticComputeState2["UnhealthyVmssVm"] = 8] = "UnhealthyVmssVm";
    })(ElasticComputeState = exports2.ElasticComputeState || (exports2.ElasticComputeState = {}));
    var ElasticNodeState;
    (function(ElasticNodeState2) {
      ElasticNodeState2[ElasticNodeState2["None"] = 0] = "None";
      ElasticNodeState2[ElasticNodeState2["New"] = 1] = "New";
      ElasticNodeState2[ElasticNodeState2["CreatingCompute"] = 2] = "CreatingCompute";
      ElasticNodeState2[ElasticNodeState2["StartingAgent"] = 3] = "StartingAgent";
      ElasticNodeState2[ElasticNodeState2["Idle"] = 4] = "Idle";
      ElasticNodeState2[ElasticNodeState2["Assigned"] = 5] = "Assigned";
      ElasticNodeState2[ElasticNodeState2["Offline"] = 6] = "Offline";
      ElasticNodeState2[ElasticNodeState2["PendingReimage"] = 7] = "PendingReimage";
      ElasticNodeState2[ElasticNodeState2["PendingDelete"] = 8] = "PendingDelete";
      ElasticNodeState2[ElasticNodeState2["Saved"] = 9] = "Saved";
      ElasticNodeState2[ElasticNodeState2["DeletingCompute"] = 10] = "DeletingCompute";
      ElasticNodeState2[ElasticNodeState2["Deleted"] = 11] = "Deleted";
      ElasticNodeState2[ElasticNodeState2["Lost"] = 12] = "Lost";
      ElasticNodeState2[ElasticNodeState2["ReimagingCompute"] = 13] = "ReimagingCompute";
      ElasticNodeState2[ElasticNodeState2["RestartingAgent"] = 14] = "RestartingAgent";
      ElasticNodeState2[ElasticNodeState2["FailedToStartPendingDelete"] = 15] = "FailedToStartPendingDelete";
      ElasticNodeState2[ElasticNodeState2["FailedToRestartPendingDelete"] = 16] = "FailedToRestartPendingDelete";
      ElasticNodeState2[ElasticNodeState2["FailedVMPendingDelete"] = 17] = "FailedVMPendingDelete";
      ElasticNodeState2[ElasticNodeState2["AssignedPendingDelete"] = 18] = "AssignedPendingDelete";
      ElasticNodeState2[ElasticNodeState2["RetryDelete"] = 19] = "RetryDelete";
      ElasticNodeState2[ElasticNodeState2["UnhealthyVm"] = 20] = "UnhealthyVm";
      ElasticNodeState2[ElasticNodeState2["UnhealthyVmPendingDelete"] = 21] = "UnhealthyVmPendingDelete";
      ElasticNodeState2[ElasticNodeState2["PendingReimageCandidate"] = 22] = "PendingReimageCandidate";
    })(ElasticNodeState = exports2.ElasticNodeState || (exports2.ElasticNodeState = {}));
    var ElasticPoolState;
    (function(ElasticPoolState2) {
      ElasticPoolState2[ElasticPoolState2["Online"] = 0] = "Online";
      ElasticPoolState2[ElasticPoolState2["Offline"] = 1] = "Offline";
      ElasticPoolState2[ElasticPoolState2["Unhealthy"] = 2] = "Unhealthy";
      ElasticPoolState2[ElasticPoolState2["New"] = 3] = "New";
    })(ElasticPoolState = exports2.ElasticPoolState || (exports2.ElasticPoolState = {}));
    var EnvironmentActionFilter;
    (function(EnvironmentActionFilter2) {
      EnvironmentActionFilter2[EnvironmentActionFilter2["None"] = 0] = "None";
      EnvironmentActionFilter2[EnvironmentActionFilter2["Manage"] = 2] = "Manage";
      EnvironmentActionFilter2[EnvironmentActionFilter2["Use"] = 16] = "Use";
    })(EnvironmentActionFilter = exports2.EnvironmentActionFilter || (exports2.EnvironmentActionFilter = {}));
    var EnvironmentExpands;
    (function(EnvironmentExpands2) {
      EnvironmentExpands2[EnvironmentExpands2["None"] = 0] = "None";
      EnvironmentExpands2[EnvironmentExpands2["ResourceReferences"] = 1] = "ResourceReferences";
    })(EnvironmentExpands = exports2.EnvironmentExpands || (exports2.EnvironmentExpands = {}));
    var EnvironmentResourceType;
    (function(EnvironmentResourceType2) {
      EnvironmentResourceType2[EnvironmentResourceType2["Undefined"] = 0] = "Undefined";
      EnvironmentResourceType2[EnvironmentResourceType2["Generic"] = 1] = "Generic";
      EnvironmentResourceType2[EnvironmentResourceType2["VirtualMachine"] = 2] = "VirtualMachine";
      EnvironmentResourceType2[EnvironmentResourceType2["Kubernetes"] = 4] = "Kubernetes";
    })(EnvironmentResourceType = exports2.EnvironmentResourceType || (exports2.EnvironmentResourceType = {}));
    var ExclusiveLockType;
    (function(ExclusiveLockType2) {
      ExclusiveLockType2[ExclusiveLockType2["RunLatest"] = 0] = "RunLatest";
      ExclusiveLockType2[ExclusiveLockType2["Sequential"] = 1] = "Sequential";
      ExclusiveLockType2[ExclusiveLockType2["BranchRunLatest"] = 2] = "BranchRunLatest";
      ExclusiveLockType2[ExclusiveLockType2["Parallel"] = 3] = "Parallel";
    })(ExclusiveLockType = exports2.ExclusiveLockType || (exports2.ExclusiveLockType = {}));
    var IssueType;
    (function(IssueType2) {
      IssueType2[IssueType2["Error"] = 1] = "Error";
      IssueType2[IssueType2["Warning"] = 2] = "Warning";
    })(IssueType = exports2.IssueType || (exports2.IssueType = {}));
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Error"] = 0] = "Error";
      LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
    })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
    var MachineGroupActionFilter;
    (function(MachineGroupActionFilter2) {
      MachineGroupActionFilter2[MachineGroupActionFilter2["None"] = 0] = "None";
      MachineGroupActionFilter2[MachineGroupActionFilter2["Manage"] = 2] = "Manage";
      MachineGroupActionFilter2[MachineGroupActionFilter2["Use"] = 16] = "Use";
    })(MachineGroupActionFilter = exports2.MachineGroupActionFilter || (exports2.MachineGroupActionFilter = {}));
    var MaskType;
    (function(MaskType2) {
      MaskType2[MaskType2["Variable"] = 1] = "Variable";
      MaskType2[MaskType2["Regex"] = 2] = "Regex";
    })(MaskType = exports2.MaskType || (exports2.MaskType = {}));
    var OperatingSystemType;
    (function(OperatingSystemType2) {
      OperatingSystemType2[OperatingSystemType2["Windows"] = 0] = "Windows";
      OperatingSystemType2[OperatingSystemType2["Linux"] = 1] = "Linux";
    })(OperatingSystemType = exports2.OperatingSystemType || (exports2.OperatingSystemType = {}));
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["ConfigurationJob"] = 0] = "ConfigurationJob";
      OperationType2[OperationType2["SizingJob"] = 1] = "SizingJob";
      OperationType2[OperationType2["IncreaseCapacity"] = 2] = "IncreaseCapacity";
      OperationType2[OperationType2["Reimage"] = 3] = "Reimage";
      OperationType2[OperationType2["DeleteVMs"] = 4] = "DeleteVMs";
    })(OperationType = exports2.OperationType || (exports2.OperationType = {}));
    var OrchestrationType;
    (function(OrchestrationType2) {
      OrchestrationType2[OrchestrationType2["Uniform"] = 0] = "Uniform";
      OrchestrationType2[OrchestrationType2["Flexible"] = 1] = "Flexible";
    })(OrchestrationType = exports2.OrchestrationType || (exports2.OrchestrationType = {}));
    var PlanGroupStatus;
    (function(PlanGroupStatus2) {
      PlanGroupStatus2[PlanGroupStatus2["Running"] = 1] = "Running";
      PlanGroupStatus2[PlanGroupStatus2["Queued"] = 2] = "Queued";
      PlanGroupStatus2[PlanGroupStatus2["All"] = 3] = "All";
    })(PlanGroupStatus = exports2.PlanGroupStatus || (exports2.PlanGroupStatus = {}));
    var PlanGroupStatusFilter;
    (function(PlanGroupStatusFilter2) {
      PlanGroupStatusFilter2[PlanGroupStatusFilter2["Running"] = 1] = "Running";
      PlanGroupStatusFilter2[PlanGroupStatusFilter2["Queued"] = 2] = "Queued";
      PlanGroupStatusFilter2[PlanGroupStatusFilter2["All"] = 3] = "All";
    })(PlanGroupStatusFilter = exports2.PlanGroupStatusFilter || (exports2.PlanGroupStatusFilter = {}));
    var ResourceLockStatus;
    (function(ResourceLockStatus2) {
      ResourceLockStatus2[ResourceLockStatus2["Queued"] = 0] = "Queued";
      ResourceLockStatus2[ResourceLockStatus2["InUse"] = 1] = "InUse";
      ResourceLockStatus2[ResourceLockStatus2["Finished"] = 2] = "Finished";
      ResourceLockStatus2[ResourceLockStatus2["TimedOut"] = 3] = "TimedOut";
      ResourceLockStatus2[ResourceLockStatus2["Canceled"] = 4] = "Canceled";
      ResourceLockStatus2[ResourceLockStatus2["Abandoned"] = 5] = "Abandoned";
      ResourceLockStatus2[ResourceLockStatus2["WaitingOnChecks"] = 6] = "WaitingOnChecks";
    })(ResourceLockStatus = exports2.ResourceLockStatus || (exports2.ResourceLockStatus = {}));
    var SecureFileActionFilter;
    (function(SecureFileActionFilter2) {
      SecureFileActionFilter2[SecureFileActionFilter2["None"] = 0] = "None";
      SecureFileActionFilter2[SecureFileActionFilter2["Manage"] = 2] = "Manage";
      SecureFileActionFilter2[SecureFileActionFilter2["Use"] = 16] = "Use";
    })(SecureFileActionFilter = exports2.SecureFileActionFilter || (exports2.SecureFileActionFilter = {}));
    var StageTriggerType;
    (function(StageTriggerType2) {
      StageTriggerType2[StageTriggerType2["Automatic"] = 0] = "Automatic";
      StageTriggerType2[StageTriggerType2["Manual"] = 1] = "Manual";
    })(StageTriggerType = exports2.StageTriggerType || (exports2.StageTriggerType = {}));
    var TaskAgentJobResultFilter;
    (function(TaskAgentJobResultFilter2) {
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["Failed"] = 1] = "Failed";
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["Passed"] = 2] = "Passed";
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["NeverDeployed"] = 4] = "NeverDeployed";
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["All"] = 7] = "All";
    })(TaskAgentJobResultFilter = exports2.TaskAgentJobResultFilter || (exports2.TaskAgentJobResultFilter = {}));
    var TaskAgentJobStepType;
    (function(TaskAgentJobStepType2) {
      TaskAgentJobStepType2[TaskAgentJobStepType2["Task"] = 1] = "Task";
      TaskAgentJobStepType2[TaskAgentJobStepType2["Action"] = 2] = "Action";
    })(TaskAgentJobStepType = exports2.TaskAgentJobStepType || (exports2.TaskAgentJobStepType = {}));
    var TaskAgentPoolActionFilter;
    (function(TaskAgentPoolActionFilter2) {
      TaskAgentPoolActionFilter2[TaskAgentPoolActionFilter2["None"] = 0] = "None";
      TaskAgentPoolActionFilter2[TaskAgentPoolActionFilter2["Manage"] = 2] = "Manage";
      TaskAgentPoolActionFilter2[TaskAgentPoolActionFilter2["Use"] = 16] = "Use";
    })(TaskAgentPoolActionFilter = exports2.TaskAgentPoolActionFilter || (exports2.TaskAgentPoolActionFilter = {}));
    var TaskAgentPoolMaintenanceJobResult;
    (function(TaskAgentPoolMaintenanceJobResult2) {
      TaskAgentPoolMaintenanceJobResult2[TaskAgentPoolMaintenanceJobResult2["Succeeded"] = 1] = "Succeeded";
      TaskAgentPoolMaintenanceJobResult2[TaskAgentPoolMaintenanceJobResult2["Failed"] = 2] = "Failed";
      TaskAgentPoolMaintenanceJobResult2[TaskAgentPoolMaintenanceJobResult2["Canceled"] = 4] = "Canceled";
    })(TaskAgentPoolMaintenanceJobResult = exports2.TaskAgentPoolMaintenanceJobResult || (exports2.TaskAgentPoolMaintenanceJobResult = {}));
    var TaskAgentPoolMaintenanceJobStatus;
    (function(TaskAgentPoolMaintenanceJobStatus2) {
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["InProgress"] = 1] = "InProgress";
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["Completed"] = 2] = "Completed";
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["Cancelling"] = 4] = "Cancelling";
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["Queued"] = 8] = "Queued";
    })(TaskAgentPoolMaintenanceJobStatus = exports2.TaskAgentPoolMaintenanceJobStatus || (exports2.TaskAgentPoolMaintenanceJobStatus = {}));
    var TaskAgentPoolMaintenanceScheduleDays;
    (function(TaskAgentPoolMaintenanceScheduleDays2) {
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["None"] = 0] = "None";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Monday"] = 1] = "Monday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Tuesday"] = 2] = "Tuesday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Wednesday"] = 4] = "Wednesday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Thursday"] = 8] = "Thursday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Friday"] = 16] = "Friday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Saturday"] = 32] = "Saturday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Sunday"] = 64] = "Sunday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["All"] = 127] = "All";
    })(TaskAgentPoolMaintenanceScheduleDays = exports2.TaskAgentPoolMaintenanceScheduleDays || (exports2.TaskAgentPoolMaintenanceScheduleDays = {}));
    var TaskAgentPoolOptions;
    (function(TaskAgentPoolOptions2) {
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["None"] = 0] = "None";
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["ElasticPool"] = 1] = "ElasticPool";
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["SingleUseAgents"] = 2] = "SingleUseAgents";
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["PreserveAgentOnJobFailure"] = 4] = "PreserveAgentOnJobFailure";
    })(TaskAgentPoolOptions = exports2.TaskAgentPoolOptions || (exports2.TaskAgentPoolOptions = {}));
    var TaskAgentPoolType;
    (function(TaskAgentPoolType2) {
      TaskAgentPoolType2[TaskAgentPoolType2["Automation"] = 1] = "Automation";
      TaskAgentPoolType2[TaskAgentPoolType2["Deployment"] = 2] = "Deployment";
    })(TaskAgentPoolType = exports2.TaskAgentPoolType || (exports2.TaskAgentPoolType = {}));
    var TaskAgentQueueActionFilter;
    (function(TaskAgentQueueActionFilter2) {
      TaskAgentQueueActionFilter2[TaskAgentQueueActionFilter2["None"] = 0] = "None";
      TaskAgentQueueActionFilter2[TaskAgentQueueActionFilter2["Manage"] = 2] = "Manage";
      TaskAgentQueueActionFilter2[TaskAgentQueueActionFilter2["Use"] = 16] = "Use";
    })(TaskAgentQueueActionFilter = exports2.TaskAgentQueueActionFilter || (exports2.TaskAgentQueueActionFilter = {}));
    var TaskAgentRequestUpdateOptions;
    (function(TaskAgentRequestUpdateOptions2) {
      TaskAgentRequestUpdateOptions2[TaskAgentRequestUpdateOptions2["None"] = 0] = "None";
      TaskAgentRequestUpdateOptions2[TaskAgentRequestUpdateOptions2["BumpRequestToTop"] = 1] = "BumpRequestToTop";
    })(TaskAgentRequestUpdateOptions = exports2.TaskAgentRequestUpdateOptions || (exports2.TaskAgentRequestUpdateOptions = {}));
    var TaskAgentStatus;
    (function(TaskAgentStatus2) {
      TaskAgentStatus2[TaskAgentStatus2["Offline"] = 1] = "Offline";
      TaskAgentStatus2[TaskAgentStatus2["Online"] = 2] = "Online";
    })(TaskAgentStatus = exports2.TaskAgentStatus || (exports2.TaskAgentStatus = {}));
    var TaskAgentStatusFilter;
    (function(TaskAgentStatusFilter2) {
      TaskAgentStatusFilter2[TaskAgentStatusFilter2["Offline"] = 1] = "Offline";
      TaskAgentStatusFilter2[TaskAgentStatusFilter2["Online"] = 2] = "Online";
      TaskAgentStatusFilter2[TaskAgentStatusFilter2["All"] = 3] = "All";
    })(TaskAgentStatusFilter = exports2.TaskAgentStatusFilter || (exports2.TaskAgentStatusFilter = {}));
    var TaskAgentUpdateReasonType;
    (function(TaskAgentUpdateReasonType2) {
      TaskAgentUpdateReasonType2[TaskAgentUpdateReasonType2["Manual"] = 1] = "Manual";
      TaskAgentUpdateReasonType2[TaskAgentUpdateReasonType2["MinAgentVersionRequired"] = 2] = "MinAgentVersionRequired";
      TaskAgentUpdateReasonType2[TaskAgentUpdateReasonType2["Downgrade"] = 3] = "Downgrade";
    })(TaskAgentUpdateReasonType = exports2.TaskAgentUpdateReasonType || (exports2.TaskAgentUpdateReasonType = {}));
    var TaskCommandMode;
    (function(TaskCommandMode2) {
      TaskCommandMode2[TaskCommandMode2["Any"] = 0] = "Any";
      TaskCommandMode2[TaskCommandMode2["Restricted"] = 1] = "Restricted";
    })(TaskCommandMode = exports2.TaskCommandMode || (exports2.TaskCommandMode = {}));
    var TaskDefinitionStatus;
    (function(TaskDefinitionStatus2) {
      TaskDefinitionStatus2[TaskDefinitionStatus2["Preinstalled"] = 1] = "Preinstalled";
      TaskDefinitionStatus2[TaskDefinitionStatus2["ReceivedInstallOrUpdate"] = 2] = "ReceivedInstallOrUpdate";
      TaskDefinitionStatus2[TaskDefinitionStatus2["Installed"] = 3] = "Installed";
      TaskDefinitionStatus2[TaskDefinitionStatus2["ReceivedUninstall"] = 4] = "ReceivedUninstall";
      TaskDefinitionStatus2[TaskDefinitionStatus2["Uninstalled"] = 5] = "Uninstalled";
      TaskDefinitionStatus2[TaskDefinitionStatus2["RequestedUpdate"] = 6] = "RequestedUpdate";
      TaskDefinitionStatus2[TaskDefinitionStatus2["Updated"] = 7] = "Updated";
      TaskDefinitionStatus2[TaskDefinitionStatus2["AlreadyUpToDate"] = 8] = "AlreadyUpToDate";
      TaskDefinitionStatus2[TaskDefinitionStatus2["InlineUpdateReceived"] = 9] = "InlineUpdateReceived";
    })(TaskDefinitionStatus = exports2.TaskDefinitionStatus || (exports2.TaskDefinitionStatus = {}));
    var TaskGroupExpands;
    (function(TaskGroupExpands2) {
      TaskGroupExpands2[TaskGroupExpands2["None"] = 0] = "None";
      TaskGroupExpands2[TaskGroupExpands2["Tasks"] = 2] = "Tasks";
    })(TaskGroupExpands = exports2.TaskGroupExpands || (exports2.TaskGroupExpands = {}));
    var TaskGroupQueryOrder;
    (function(TaskGroupQueryOrder2) {
      TaskGroupQueryOrder2[TaskGroupQueryOrder2["CreatedOnAscending"] = 0] = "CreatedOnAscending";
      TaskGroupQueryOrder2[TaskGroupQueryOrder2["CreatedOnDescending"] = 1] = "CreatedOnDescending";
    })(TaskGroupQueryOrder = exports2.TaskGroupQueryOrder || (exports2.TaskGroupQueryOrder = {}));
    var TaskOrchestrationItemType;
    (function(TaskOrchestrationItemType2) {
      TaskOrchestrationItemType2[TaskOrchestrationItemType2["Container"] = 0] = "Container";
      TaskOrchestrationItemType2[TaskOrchestrationItemType2["Job"] = 1] = "Job";
    })(TaskOrchestrationItemType = exports2.TaskOrchestrationItemType || (exports2.TaskOrchestrationItemType = {}));
    var TaskOrchestrationPlanState;
    (function(TaskOrchestrationPlanState2) {
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["InProgress"] = 1] = "InProgress";
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["Queued"] = 2] = "Queued";
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["Completed"] = 4] = "Completed";
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["Throttled"] = 8] = "Throttled";
    })(TaskOrchestrationPlanState = exports2.TaskOrchestrationPlanState || (exports2.TaskOrchestrationPlanState = {}));
    var TaskResult2;
    (function(TaskResult3) {
      TaskResult3[TaskResult3["Succeeded"] = 0] = "Succeeded";
      TaskResult3[TaskResult3["SucceededWithIssues"] = 1] = "SucceededWithIssues";
      TaskResult3[TaskResult3["Failed"] = 2] = "Failed";
      TaskResult3[TaskResult3["Canceled"] = 3] = "Canceled";
      TaskResult3[TaskResult3["Skipped"] = 4] = "Skipped";
      TaskResult3[TaskResult3["Abandoned"] = 5] = "Abandoned";
      TaskResult3[TaskResult3["ManuallyQueued"] = 6] = "ManuallyQueued";
      TaskResult3[TaskResult3["DependentOnManualQueue"] = 7] = "DependentOnManualQueue";
    })(TaskResult2 = exports2.TaskResult || (exports2.TaskResult = {}));
    var TimelineRecordState;
    (function(TimelineRecordState2) {
      TimelineRecordState2[TimelineRecordState2["Pending"] = 0] = "Pending";
      TimelineRecordState2[TimelineRecordState2["InProgress"] = 1] = "InProgress";
      TimelineRecordState2[TimelineRecordState2["Completed"] = 2] = "Completed";
    })(TimelineRecordState = exports2.TimelineRecordState || (exports2.TimelineRecordState = {}));
    var VariableGroupActionFilter;
    (function(VariableGroupActionFilter2) {
      VariableGroupActionFilter2[VariableGroupActionFilter2["None"] = 0] = "None";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Manage"] = 2] = "Manage";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Use"] = 16] = "Use";
    })(VariableGroupActionFilter = exports2.VariableGroupActionFilter || (exports2.VariableGroupActionFilter = {}));
    var VariableGroupQueryOrder;
    (function(VariableGroupQueryOrder2) {
      VariableGroupQueryOrder2[VariableGroupQueryOrder2["IdAscending"] = 0] = "IdAscending";
      VariableGroupQueryOrder2[VariableGroupQueryOrder2["IdDescending"] = 1] = "IdDescending";
    })(VariableGroupQueryOrder = exports2.VariableGroupQueryOrder || (exports2.VariableGroupQueryOrder = {}));
    exports2.TypeInfo = {
      AadLoginPromptOption: {
        enumValues: {
          "noOption": 0,
          "login": 1,
          "selectAccount": 2,
          "freshLogin": 3,
          "freshLoginWithMfa": 4
        }
      },
      AgentChangeEvent: {},
      AgentJobRequestMessage: {},
      AgentPoolEvent: {},
      AgentQueueEvent: {},
      AgentQueuesEvent: {},
      AuditAction: {
        enumValues: {
          "add": 1,
          "update": 2,
          "delete": 3,
          "undelete": 4
        }
      },
      AzureKeyVaultVariableGroupProviderData: {},
      AzureKeyVaultVariableValue: {},
      DemandMinimumVersion: {},
      DemandSource: {},
      DemandSourceType: {
        enumValues: {
          "task": 0,
          "feature": 1
        }
      },
      DeploymentGroup: {},
      DeploymentGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      DeploymentGroupExpands: {
        enumValues: {
          "none": 0,
          "machines": 2,
          "tags": 4
        }
      },
      DeploymentGroupMetrics: {},
      DeploymentGroupReference: {},
      DeploymentMachine: {},
      DeploymentMachineChangedData: {},
      DeploymentMachineExpands: {
        enumValues: {
          "none": 0,
          "capabilities": 2,
          "assignedRequest": 4
        }
      },
      DeploymentMachineGroup: {},
      DeploymentMachineGroupReference: {},
      DeploymentMachinesChangeEvent: {},
      DeploymentPoolSummary: {},
      DeploymentPoolSummaryExpands: {
        enumValues: {
          "none": 0,
          "deploymentGroups": 2,
          "resource": 4
        }
      },
      DeploymentTargetExpands: {
        enumValues: {
          "none": 0,
          "capabilities": 2,
          "assignedRequest": 4,
          "lastCompletedRequest": 8
        }
      },
      ElasticAgentState: {
        enumValues: {
          "none": 0,
          "enabled": 1,
          "online": 2,
          "assigned": 4
        }
      },
      ElasticComputeState: {
        enumValues: {
          "none": 0,
          "healthy": 1,
          "creating": 2,
          "deleting": 3,
          "failed": 4,
          "stopped": 5,
          "reimaging": 6,
          "unhealthyVm": 7,
          "unhealthyVmssVm": 8
        }
      },
      ElasticNode: {},
      ElasticNodeSettings: {},
      ElasticNodeState: {
        enumValues: {
          "none": 0,
          "new": 1,
          "creatingCompute": 2,
          "startingAgent": 3,
          "idle": 4,
          "assigned": 5,
          "offline": 6,
          "pendingReimage": 7,
          "pendingDelete": 8,
          "saved": 9,
          "deletingCompute": 10,
          "deleted": 11,
          "lost": 12,
          "reimagingCompute": 13,
          "restartingAgent": 14,
          "failedToStartPendingDelete": 15,
          "failedToRestartPendingDelete": 16,
          "failedVMPendingDelete": 17,
          "assignedPendingDelete": 18,
          "retryDelete": 19,
          "unhealthyVm": 20,
          "unhealthyVmPendingDelete": 21,
          "pendingReimageCandidate": 22
        }
      },
      ElasticPool: {},
      ElasticPoolCreationResult: {},
      ElasticPoolLog: {},
      ElasticPoolSettings: {},
      ElasticPoolState: {
        enumValues: {
          "online": 0,
          "offline": 1,
          "unhealthy": 2,
          "new": 3
        }
      },
      EnvironmentActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      EnvironmentDeploymentExecutionRecord: {},
      EnvironmentExpands: {
        enumValues: {
          "none": 0,
          "resourceReferences": 1
        }
      },
      EnvironmentInstance: {},
      EnvironmentResource: {},
      EnvironmentResourceDeploymentExecutionRecord: {},
      EnvironmentResourceReference: {},
      EnvironmentResourceType: {
        enumValues: {
          "undefined": 0,
          "generic": 1,
          "virtualMachine": 2,
          "kubernetes": 4
        }
      },
      ExclusiveLockType: {
        enumValues: {
          "runLatest": 0,
          "sequential": 1,
          "branchRunLatest": 2,
          "parallel": 3
        }
      },
      Issue: {},
      IssueType: {
        enumValues: {
          "error": 1,
          "warning": 2
        }
      },
      JobAssignedEvent: {},
      JobCompletedEvent: {},
      JobEnvironment: {},
      JobRequestMessage: {},
      KubernetesResource: {},
      KubernetesResourceCreateParametersNewEndpoint: {},
      LogLevel: {
        enumValues: {
          "error": 0,
          "warning": 1,
          "info": 2
        }
      },
      MachineGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      MaskHint: {},
      MaskType: {
        enumValues: {
          "variable": 1,
          "regex": 2
        }
      },
      OperatingSystemType: {
        enumValues: {
          "windows": 0,
          "linux": 1
        }
      },
      OperationType: {
        enumValues: {
          "configurationJob": 0,
          "sizingJob": 1,
          "increaseCapacity": 2,
          "reimage": 3,
          "deleteVMs": 4
        }
      },
      OrchestrationType: {
        enumValues: {
          "uniform": 0,
          "flexible": 1
        }
      },
      PackageMetadata: {},
      PlanEnvironment: {},
      PlanGroupStatus: {
        enumValues: {
          "running": 1,
          "queued": 2,
          "all": 3
        }
      },
      PlanGroupStatusFilter: {
        enumValues: {
          "running": 1,
          "queued": 2,
          "all": 3
        }
      },
      ResourceLockRequest: {},
      ResourceLockStatus: {
        enumValues: {
          "queued": 0,
          "inUse": 1,
          "finished": 2,
          "timedOut": 3,
          "canceled": 4,
          "abandoned": 5,
          "waitingOnChecks": 6
        }
      },
      ResourceUsage: {},
      SecureFile: {},
      SecureFileActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      SecureFileEvent: {},
      ServerTaskRequestMessage: {},
      ServiceEndpoint: {},
      ServiceEndpointAuthenticationScheme: {},
      ServiceEndpointExecutionData: {},
      ServiceEndpointExecutionRecord: {},
      ServiceEndpointExecutionRecordsInput: {},
      ServiceEndpointRequestResult: {},
      ServiceEndpointType: {},
      StageTriggerType: {
        enumValues: {
          "automatic": 0,
          "manual": 1
        }
      },
      TaskAgent: {},
      TaskAgentCloudRequest: {},
      TaskAgentCloudType: {},
      TaskAgentDowngrade: {},
      TaskAgentJob: {},
      TaskAgentJobRequest: {},
      TaskAgentJobResultFilter: {
        enumValues: {
          "failed": 1,
          "passed": 2,
          "neverDeployed": 4,
          "all": 7
        }
      },
      TaskAgentJobStep: {},
      TaskAgentJobStepType: {
        enumValues: {
          "task": 1,
          "action": 2
        }
      },
      TaskAgentManualUpdate: {},
      TaskAgentMinAgentVersionRequiredUpdate: {},
      TaskAgentPool: {},
      TaskAgentPoolActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      TaskAgentPoolMaintenanceDefinition: {},
      TaskAgentPoolMaintenanceJob: {},
      TaskAgentPoolMaintenanceJobResult: {
        enumValues: {
          "succeeded": 1,
          "failed": 2,
          "canceled": 4
        }
      },
      TaskAgentPoolMaintenanceJobStatus: {
        enumValues: {
          "inProgress": 1,
          "completed": 2,
          "cancelling": 4,
          "queued": 8
        }
      },
      TaskAgentPoolMaintenanceJobTargetAgent: {},
      TaskAgentPoolMaintenanceSchedule: {},
      TaskAgentPoolMaintenanceScheduleDays: {
        enumValues: {
          "none": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 4,
          "thursday": 8,
          "friday": 16,
          "saturday": 32,
          "sunday": 64,
          "all": 127
        }
      },
      TaskAgentPoolOptions: {
        enumValues: {
          "none": 0,
          "elasticPool": 1,
          "singleUseAgents": 2,
          "preserveAgentOnJobFailure": 4
        }
      },
      TaskAgentPoolReference: {},
      TaskAgentPoolStatus: {},
      TaskAgentPoolSummary: {},
      TaskAgentPoolType: {
        enumValues: {
          "automation": 1,
          "deployment": 2
        }
      },
      TaskAgentQueue: {},
      TaskAgentQueueActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      TaskAgentReference: {},
      TaskAgentRequestUpdateOptions: {
        enumValues: {
          "none": 0,
          "bumpRequestToTop": 1
        }
      },
      TaskAgentSession: {},
      TaskAgentStatus: {
        enumValues: {
          "offline": 1,
          "online": 2
        }
      },
      TaskAgentStatusFilter: {
        enumValues: {
          "offline": 1,
          "online": 2,
          "all": 3
        }
      },
      TaskAgentUpdate: {},
      TaskAgentUpdateReason: {},
      TaskAgentUpdateReasonType: {
        enumValues: {
          "manual": 1,
          "minAgentVersionRequired": 2,
          "downgrade": 3
        }
      },
      TaskAttachment: {},
      TaskCommandMode: {
        enumValues: {
          "any": 0,
          "restricted": 1
        }
      },
      TaskCommandRestrictions: {},
      TaskCompletedEvent: {},
      TaskDefinition: {},
      TaskDefinitionStatus: {
        enumValues: {
          "preinstalled": 1,
          "receivedInstallOrUpdate": 2,
          "installed": 3,
          "receivedUninstall": 4,
          "uninstalled": 5,
          "requestedUpdate": 6,
          "updated": 7,
          "alreadyUpToDate": 8,
          "inlineUpdateReceived": 9
        }
      },
      TaskGroup: {},
      TaskGroupExpands: {
        enumValues: {
          "none": 0,
          "tasks": 2
        }
      },
      TaskGroupQueryOrder: {
        enumValues: {
          "createdOnAscending": 0,
          "createdOnDescending": 1
        }
      },
      TaskGroupRevision: {},
      TaskLog: {},
      TaskOrchestrationContainer: {},
      TaskOrchestrationItem: {},
      TaskOrchestrationItemType: {
        enumValues: {
          "container": 0,
          "job": 1
        }
      },
      TaskOrchestrationJob: {},
      TaskOrchestrationPlan: {},
      TaskOrchestrationPlanGroup: {},
      TaskOrchestrationPlanGroupsQueueMetrics: {},
      TaskOrchestrationPlanState: {
        enumValues: {
          "inProgress": 1,
          "queued": 2,
          "completed": 4,
          "throttled": 8
        }
      },
      TaskOrchestrationQueuedPlan: {},
      TaskOrchestrationQueuedPlanGroup: {},
      TaskRestrictions: {},
      TaskResult: {
        enumValues: {
          "succeeded": 0,
          "succeededWithIssues": 1,
          "failed": 2,
          "canceled": 3,
          "skipped": 4,
          "abandoned": 5,
          "manuallyQueued": 6,
          "dependentOnManualQueue": 7
        }
      },
      Timeline: {},
      TimelineRecord: {},
      TimelineRecordReference: {},
      TimelineRecordState: {
        enumValues: {
          "pending": 0,
          "inProgress": 1,
          "completed": 2
        }
      },
      VariableGroup: {},
      VariableGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      VariableGroupQueryOrder: {
        enumValues: {
          "idAscending": 0,
          "idDescending": 1
        }
      },
      VirtualMachine: {},
      VirtualMachineGroup: {},
      VirtualMachineResource: {},
      VirtualMachineResourceCreateParameters: {}
    };
    exports2.TypeInfo.AgentChangeEvent.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.AgentJobRequestMessage.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.JobEnvironment
      },
      lockedUntil: {
        isDate: true
      }
    };
    exports2.TypeInfo.AgentPoolEvent.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPool
      }
    };
    exports2.TypeInfo.AgentQueueEvent.fields = {
      queue: {
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      }
    };
    exports2.TypeInfo.AgentQueuesEvent.fields = {
      queues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableGroupProviderData.fields = {
      lastRefreshedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableValue.fields = {
      expires: {
        isDate: true
      }
    };
    exports2.TypeInfo.DemandMinimumVersion.fields = {
      source: {
        typeInfo: exports2.TypeInfo.DemandSource
      }
    };
    exports2.TypeInfo.DemandSource.fields = {
      sourceType: {
        enumType: exports2.TypeInfo.DemandSourceType
      }
    };
    exports2.TypeInfo.DeploymentGroup.fields = {
      machines: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentMachine
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentGroupMetrics.fields = {
      deploymentGroup: {
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      }
    };
    exports2.TypeInfo.DeploymentGroupReference.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentMachine.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      }
    };
    exports2.TypeInfo.DeploymentMachineChangedData.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      }
    };
    exports2.TypeInfo.DeploymentMachineGroup.fields = {
      machines: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentMachine
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentMachineGroupReference.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentMachinesChangeEvent.fields = {
      machineGroupReference: {
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      },
      machines: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentMachineChangedData
      }
    };
    exports2.TypeInfo.DeploymentPoolSummary.fields = {
      deploymentGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      resource: {
        typeInfo: exports2.TypeInfo.EnvironmentResourceReference
      }
    };
    exports2.TypeInfo.ElasticNode.fields = {
      agentState: {
        enumType: exports2.TypeInfo.ElasticAgentState
      },
      computeState: {
        enumType: exports2.TypeInfo.ElasticComputeState
      },
      desiredState: {
        enumType: exports2.TypeInfo.ElasticNodeState
      },
      state: {
        enumType: exports2.TypeInfo.ElasticNodeState
      },
      stateChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.ElasticNodeSettings.fields = {
      state: {
        enumType: exports2.TypeInfo.ElasticNodeState
      }
    };
    exports2.TypeInfo.ElasticPool.fields = {
      offlineSince: {
        isDate: true
      },
      orchestrationType: {
        enumType: exports2.TypeInfo.OrchestrationType
      },
      osType: {
        enumType: exports2.TypeInfo.OperatingSystemType
      },
      state: {
        enumType: exports2.TypeInfo.ElasticPoolState
      }
    };
    exports2.TypeInfo.ElasticPoolCreationResult.fields = {
      agentPool: {
        typeInfo: exports2.TypeInfo.TaskAgentPool
      },
      agentQueue: {
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      },
      elasticPool: {
        typeInfo: exports2.TypeInfo.ElasticPool
      }
    };
    exports2.TypeInfo.ElasticPoolLog.fields = {
      level: {
        enumType: exports2.TypeInfo.LogLevel
      },
      operation: {
        enumType: exports2.TypeInfo.OperationType
      },
      timestamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ElasticPoolSettings.fields = {
      orchestrationType: {
        enumType: exports2.TypeInfo.OrchestrationType
      },
      osType: {
        enumType: exports2.TypeInfo.OperatingSystemType
      }
    };
    exports2.TypeInfo.EnvironmentDeploymentExecutionRecord.fields = {
      finishTime: {
        isDate: true
      },
      queueTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.EnvironmentInstance.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      resources: {
        isArray: true,
        typeInfo: exports2.TypeInfo.EnvironmentResourceReference
      }
    };
    exports2.TypeInfo.EnvironmentResource.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.EnvironmentResourceDeploymentExecutionRecord.fields = {
      finishTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.EnvironmentResourceReference.fields = {
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.Issue.fields = {
      type: {
        enumType: exports2.TypeInfo.IssueType
      }
    };
    exports2.TypeInfo.JobAssignedEvent.fields = {
      request: {
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      }
    };
    exports2.TypeInfo.JobCompletedEvent.fields = {
      result: {
        enumType: exports2.TypeInfo.TaskResult
      }
    };
    exports2.TypeInfo.JobEnvironment.fields = {
      endpoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ServiceEndpoint
      },
      mask: {
        isArray: true,
        typeInfo: exports2.TypeInfo.MaskHint
      },
      secureFiles: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SecureFile
      },
      systemConnection: {
        typeInfo: exports2.TypeInfo.ServiceEndpoint
      }
    };
    exports2.TypeInfo.JobRequestMessage.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.JobEnvironment
      }
    };
    exports2.TypeInfo.KubernetesResource.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.KubernetesResourceCreateParametersNewEndpoint.fields = {
      endpoint: {
        typeInfo: exports2.TypeInfo.ServiceEndpoint
      }
    };
    exports2.TypeInfo.MaskHint.fields = {
      type: {
        enumType: exports2.TypeInfo.MaskType
      }
    };
    exports2.TypeInfo.PackageMetadata.fields = {
      createdOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.PlanEnvironment.fields = {
      mask: {
        isArray: true,
        typeInfo: exports2.TypeInfo.MaskHint
      }
    };
    exports2.TypeInfo.ResourceLockRequest.fields = {
      assignTime: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      lockType: {
        enumType: exports2.TypeInfo.ExclusiveLockType
      },
      queueTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ResourceLockStatus
      }
    };
    exports2.TypeInfo.ResourceUsage.fields = {
      runningRequests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      }
    };
    exports2.TypeInfo.SecureFile.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.SecureFileEvent.fields = {
      secureFiles: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SecureFile
      }
    };
    exports2.TypeInfo.ServerTaskRequestMessage.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.JobEnvironment
      },
      taskDefinition: {
        typeInfo: exports2.TypeInfo.TaskDefinition
      }
    };
    exports2.TypeInfo.ServiceEndpoint.fields = {
      creationDate: {
        isDate: true
      },
      modificationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ServiceEndpointAuthenticationScheme.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.ServiceEndpointExecutionData.fields = {
      finishTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.ServiceEndpointExecutionRecord.fields = {
      data: {
        typeInfo: exports2.TypeInfo.ServiceEndpointExecutionData
      }
    };
    exports2.TypeInfo.ServiceEndpointExecutionRecordsInput.fields = {
      data: {
        typeInfo: exports2.TypeInfo.ServiceEndpointExecutionData
      }
    };
    exports2.TypeInfo.ServiceEndpointRequestResult.fields = {};
    exports2.TypeInfo.ServiceEndpointType.fields = {
      authenticationSchemes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ServiceEndpointAuthenticationScheme
      },
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.TaskAgent.fields = {
      assignedAgentCloudRequest: {
        typeInfo: exports2.TypeInfo.TaskAgentCloudRequest
      },
      assignedRequest: {
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      },
      createdOn: {
        isDate: true
      },
      lastCompletedRequest: {
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      },
      pendingUpdate: {
        typeInfo: exports2.TypeInfo.TaskAgentUpdate
      },
      status: {
        enumType: exports2.TypeInfo.TaskAgentStatus
      },
      statusChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskAgentCloudRequest.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      agentConnectedTime: {
        isDate: true
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      provisionedTime: {
        isDate: true
      },
      provisionRequestTime: {
        isDate: true
      },
      releaseRequestTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskAgentCloudType.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.TaskAgentDowngrade.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAgentJob.fields = {
      steps: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentJobStep
      }
    };
    exports2.TypeInfo.TaskAgentJobRequest.fields = {
      assignTime: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      lockedUntil: {
        isDate: true
      },
      matchedAgents: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      queueTime: {
        isDate: true
      },
      receiveTime: {
        isDate: true
      },
      reservedAgent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      }
    };
    exports2.TypeInfo.TaskAgentJobStep.fields = {
      type: {
        enumType: exports2.TypeInfo.TaskAgentJobStepType
      }
    };
    exports2.TypeInfo.TaskAgentManualUpdate.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAgentMinAgentVersionRequiredUpdate.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAgentPool.fields = {
      createdOn: {
        isDate: true
      },
      options: {
        enumType: exports2.TypeInfo.TaskAgentPoolOptions
      },
      poolType: {
        enumType: exports2.TypeInfo.TaskAgentPoolType
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceDefinition.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      scheduleSetting: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolMaintenanceSchedule
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceJob.fields = {
      finishTime: {
        isDate: true
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      queueTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobResult
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobStatus
      },
      targetAgents: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentPoolMaintenanceJobTargetAgent
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceJobTargetAgent.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      result: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobResult
      },
      status: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobStatus
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceSchedule.fields = {
      daysToBuild: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceScheduleDays
      }
    };
    exports2.TypeInfo.TaskAgentPoolReference.fields = {
      options: {
        enumType: exports2.TypeInfo.TaskAgentPoolOptions
      },
      poolType: {
        enumType: exports2.TypeInfo.TaskAgentPoolType
      }
    };
    exports2.TypeInfo.TaskAgentPoolStatus.fields = {
      options: {
        enumType: exports2.TypeInfo.TaskAgentPoolOptions
      },
      poolType: {
        enumType: exports2.TypeInfo.TaskAgentPoolType
      }
    };
    exports2.TypeInfo.TaskAgentPoolSummary.fields = {
      deploymentGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      queues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      }
    };
    exports2.TypeInfo.TaskAgentQueue.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.TaskAgentReference.fields = {
      status: {
        enumType: exports2.TypeInfo.TaskAgentStatus
      }
    };
    exports2.TypeInfo.TaskAgentSession.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      }
    };
    exports2.TypeInfo.TaskAgentUpdate.fields = {
      reason: {
        typeInfo: exports2.TypeInfo.TaskAgentUpdateReason
      },
      requestTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskAgentUpdateReason.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAttachment.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskCommandRestrictions.fields = {
      mode: {
        enumType: exports2.TypeInfo.TaskCommandMode
      }
    };
    exports2.TypeInfo.TaskCompletedEvent.fields = {
      result: {
        enumType: exports2.TypeInfo.TaskResult
      }
    };
    exports2.TypeInfo.TaskDefinition.fields = {
      restrictions: {
        typeInfo: exports2.TypeInfo.TaskRestrictions
      }
    };
    exports2.TypeInfo.TaskGroup.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      },
      restrictions: {
        typeInfo: exports2.TypeInfo.TaskRestrictions
      }
    };
    exports2.TypeInfo.TaskGroupRevision.fields = {
      changedDate: {
        isDate: true
      },
      changeType: {
        enumType: exports2.TypeInfo.AuditAction
      }
    };
    exports2.TypeInfo.TaskLog.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskOrchestrationContainer.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskOrchestrationItem
      },
      itemType: {
        enumType: exports2.TypeInfo.TaskOrchestrationItemType
      },
      rollback: {
        typeInfo: exports2.TypeInfo.TaskOrchestrationContainer
      }
    };
    exports2.TypeInfo.TaskOrchestrationItem.fields = {
      itemType: {
        enumType: exports2.TypeInfo.TaskOrchestrationItemType
      }
    };
    exports2.TypeInfo.TaskOrchestrationJob.fields = {
      itemType: {
        enumType: exports2.TypeInfo.TaskOrchestrationItemType
      }
    };
    exports2.TypeInfo.TaskOrchestrationPlan.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.PlanEnvironment
      },
      finishTime: {
        isDate: true
      },
      implementation: {
        typeInfo: exports2.TypeInfo.TaskOrchestrationContainer
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TaskOrchestrationPlanState
      }
    };
    exports2.TypeInfo.TaskOrchestrationPlanGroup.fields = {
      runningRequests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      }
    };
    exports2.TypeInfo.TaskOrchestrationPlanGroupsQueueMetrics.fields = {
      status: {
        enumType: exports2.TypeInfo.PlanGroupStatus
      }
    };
    exports2.TypeInfo.TaskOrchestrationQueuedPlan.fields = {
      assignTime: {
        isDate: true
      },
      queueTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskOrchestrationQueuedPlanGroup.fields = {
      plans: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskOrchestrationQueuedPlan
      }
    };
    exports2.TypeInfo.TaskRestrictions.fields = {
      commands: {
        typeInfo: exports2.TypeInfo.TaskCommandRestrictions
      }
    };
    exports2.TypeInfo.Timeline.fields = {
      lastChangedOn: {
        isDate: true
      },
      records: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.TimelineRecord.fields = {
      finishTime: {
        isDate: true
      },
      issues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Issue
      },
      lastModified: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TimelineRecordState
      }
    };
    exports2.TypeInfo.TimelineRecordReference.fields = {
      state: {
        enumType: exports2.TypeInfo.TimelineRecordState
      }
    };
    exports2.TypeInfo.VariableGroup.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.VirtualMachine.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      }
    };
    exports2.TypeInfo.VirtualMachineGroup.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.VirtualMachineResource.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      },
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.VirtualMachineResourceCreateParameters.fields = {
      virtualMachineResource: {
        typeInfo: exports2.TypeInfo.VirtualMachineResource
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/TaskAgentApiBase.js
var require_TaskAgentApiBase = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/TaskAgentApiBase.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskAgentApiBase = void 0;
    var basem = require_ClientApiBases();
    var TaskAgentInterfaces = require_TaskAgentInterfaces();
    var TaskAgentApiBase = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-TaskAgent-api", options2);
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentCloud} agentCloud
       */
      addAgentCloud(agentCloud) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, agentCloud, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} agentCloudId
       */
      deleteAgentCloud(agentCloudId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} agentCloudId
       */
      getAgentCloud(agentCloudId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getAgentClouds() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentCloud} updatedCloud
       * @param {number} agentCloudId
       */
      updateAgentCloud(updatedCloud, agentCloudId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updatedCloud, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get agent cloud types.
       *
       */
      getAgentCloudTypes() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "5932e193-f376-469d-9c3e-e5588ce12cb5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentCloudType, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} queueId
       * @param {number} top
       * @param {string} continuationToken
       */
      getAgentRequestsForQueue(project, queueId, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (top == null) {
            throw new TypeError("top can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            let queryValues = {
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f5f81ffb-f396-498d-85b1-5ada145e648a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentJobRequest} request
       * @param {string} project - Project ID or project name
       * @param {number} queueId
       */
      queueAgentRequest(request, project, queueId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f5f81ffb-f396-498d-85b1-5ada145e648a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds an agent to a pool.  You probably don't want to call this endpoint directly. Instead, [configure an agent](https://docs.microsoft.com/azure/devops/pipelines/agents/agents) using the agent download package.
       *
       * @param {TaskAgentInterfaces.TaskAgent} agent - Details about the agent being added
       * @param {number} poolId - The agent pool in which to add the agent
       */
      addAgent(agent, poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, agent, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete an agent.  You probably don't want to call this endpoint directly. Instead, [use the agent configuration script](https://docs.microsoft.com/azure/devops/pipelines/agents/agents) to remove an agent from your organization.
       *
       * @param {number} poolId - The pool ID to remove the agent from
       * @param {number} agentId - The agent ID to remove
       */
      deleteAgent(poolId, agentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get information about an agent.
       *
       * @param {number} poolId - The agent pool containing the agent
       * @param {number} agentId - The agent ID to get information about
       * @param {boolean} includeCapabilities - Whether to include the agent's capabilities in the response
       * @param {boolean} includeAssignedRequest - Whether to include details about the agent's current work
       * @param {boolean} includeLastCompletedRequest - Whether to include details about the agents' most recent completed work
       * @param {string[]} propertyFilters - Filter which custom properties will be returned
       */
      getAgent(poolId, agentId, includeCapabilities, includeAssignedRequest, includeLastCompletedRequest, propertyFilters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            let queryValues = {
              includeCapabilities,
              includeAssignedRequest,
              includeLastCompletedRequest,
              propertyFilters: propertyFilters && propertyFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agents.
       *
       * @param {number} poolId - The agent pool containing the agents
       * @param {string} agentName - Filter on agent name
       * @param {boolean} includeCapabilities - Whether to include the agents' capabilities in the response
       * @param {boolean} includeAssignedRequest - Whether to include details about the agents' current work
       * @param {boolean} includeLastCompletedRequest - Whether to include details about the agents' most recent completed work
       * @param {string[]} propertyFilters - Filter which custom properties will be returned
       * @param {string[]} demands - Filter by demands the agents can satisfy
       */
      getAgents(poolId, agentName, includeCapabilities, includeAssignedRequest, includeLastCompletedRequest, propertyFilters, demands) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentName,
              includeCapabilities,
              includeAssignedRequest,
              includeLastCompletedRequest,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              demands: demands && demands.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace an agent.  You probably don't want to call this endpoint directly. Instead, [use the agent configuration script](https://docs.microsoft.com/azure/devops/pipelines/agents/agents) to remove and reconfigure an agent from your organization.
       *
       * @param {TaskAgentInterfaces.TaskAgent} agent - Updated details about the replacing agent
       * @param {number} poolId - The agent pool to use
       * @param {number} agentId - The agent to replace
       */
      replaceAgent(agent, poolId, agentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, agent, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update agent details.
       *
       * @param {TaskAgentInterfaces.TaskAgent} agent - Updated details about the agent
       * @param {number} poolId - The agent pool to use
       * @param {number} agentId - The agent to update
       */
      updateAgent(agent, poolId, agentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, agent, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns list of azure subscriptions
       *
       */
      getAzureManagementGroups() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "39fe3bf2-7ee0-4198-a469-4a29929afa9c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns list of azure subscriptions
       *
       */
      getAzureSubscriptions() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bcd6189c-0303-471f-a8e1-acb22b74d700", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET a PAT token for managing (configuring, removing, tagging) deployment targets in a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment targets are managed.
       */
      generateDeploymentGroupAccessToken(project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "3d197ba2-c3e9-4253-882f-0ee2440f8174", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a deployment group.
       *
       * @param {TaskAgentInterfaces.DeploymentGroupCreateParameter} deploymentGroup - Deployment group to create.
       * @param {string} project - Project ID or project name
       */
      addDeploymentGroup(deploymentGroup, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, deploymentGroup, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to be deleted.
       */
      deleteDeploymentGroup(project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a deployment group by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       * @param {TaskAgentInterfaces.DeploymentGroupActionFilter} actionFilter - Get the deployment group only if this action can be performed on it.
       * @param {TaskAgentInterfaces.DeploymentGroupExpands} expand - Include these additional details in the returned object.
       */
      getDeploymentGroup(project, deploymentGroupId, actionFilter, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              actionFilter,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment groups by name or IDs.
       *
       * @param {string} project - Project ID or project name
       * @param {string} name - Name of the deployment group.
       * @param {TaskAgentInterfaces.DeploymentGroupActionFilter} actionFilter - Get only deployment groups on which this action can be performed.
       * @param {TaskAgentInterfaces.DeploymentGroupExpands} expand - Include these additional details in the returned objects.
       * @param {string} continuationToken - Get deployment groups with names greater than this continuationToken lexicographically.
       * @param {number} top - Maximum number of deployment groups to return. Default is **1000**.
       * @param {number[]} ids - Comma separated list of IDs of the deployment groups.
       */
      getDeploymentGroups(project, name, actionFilter, expand, continuationToken, top, ids) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              actionFilter,
              "$expand": expand,
              continuationToken,
              "$top": top,
              ids: ids && ids.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a deployment group.
       *
       * @param {TaskAgentInterfaces.DeploymentGroupUpdateParameter} deploymentGroup - Deployment group to update.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       */
      updateDeploymentGroup(deploymentGroup, project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, deploymentGroup, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment group metrics.
       *
       * @param {string} project - Project ID or project name
       * @param {string} deploymentGroupName - Name of the deployment group.
       * @param {string} continuationToken - Get metrics for deployment groups with names greater than this continuationToken lexicographically.
       * @param {number} top - Maximum number of deployment group metrics to return. Default is **50**.
       */
      getDeploymentGroupsMetrics(project, deploymentGroupName, continuationToken, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              deploymentGroupName,
              continuationToken,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "281c6308-427a-49e1-b83a-dac0f4862189", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroupMetrics, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       * @param {number} completedRequestCount
       */
      getAgentRequestsForDeploymentMachine(project, deploymentGroupId, machineId, completedRequestCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (machineId == null) {
            throw new TypeError("machineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              machineId,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a3540e5b-f0dc-4668-963b-b752459be545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number[]} machineIds
       * @param {number} completedRequestCount
       */
      getAgentRequestsForDeploymentMachines(project, deploymentGroupId, machineIds, completedRequestCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              machineIds: machineIds && machineIds.join(","),
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a3540e5b-f0dc-4668-963b-b752459be545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       */
      refreshDeploymentMachines(project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "91006ac4-0f68-4d82-a2bc-540676bd73ce", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET a PAT token for managing (configuring, removing, tagging) deployment agents in a deployment pool.
       *
       * @param {number} poolId - ID of the deployment pool in which deployment agents are managed.
       */
      generateDeploymentPoolAccessToken(poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e077ee4a-399b-420b-841f-c43fbc058e0b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment pool summaries.
       *
       * @param {string} poolName - Name of the deployment pool.
       * @param {TaskAgentInterfaces.DeploymentPoolSummaryExpands} expands - Include these additional details in the returned objects.
       * @param {number[]} poolIds - List of deployment pool ids.
       */
      getDeploymentPoolsSummary(poolName, expands, poolIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              poolName,
              expands,
              poolIds: poolIds && poolIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6525d6c6-258f-40e0-a1a9-8a24a3957625", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentPoolSummary, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get agent requests for a deployment target.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which the target belongs.
       * @param {number} targetId - ID of the deployment target.
       * @param {number} completedRequestCount - Maximum number of completed requests to return. Default is **50**
       */
      getAgentRequestsForDeploymentTarget(project, deploymentGroupId, targetId, completedRequestCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (targetId == null) {
            throw new TypeError("targetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              targetId,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2fac0be3-8c8f-4473-ab93-c1389b08a2c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get agent requests for a list deployment targets.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which the targets belong.
       * @param {number[]} targetIds - Comma separated list of IDs of the deployment targets.
       * @param {number} ownerId - Id of owner of agent job request.
       * @param {Date} completedOn - Datetime to return request after this time.
       * @param {number} completedRequestCount - Maximum number of completed requests to return for each target. Default is **50**
       */
      getAgentRequestsForDeploymentTargets(project, deploymentGroupId, targetIds, ownerId, completedOn, completedRequestCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              targetIds: targetIds && targetIds.join(","),
              ownerId,
              completedOn,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2fac0be3-8c8f-4473-ab93-c1389b08a2c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Upgrade the deployment targets in a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       */
      refreshDeploymentTargets(project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "1c1a817f-f23d-41c6-bf8d-14b638f64152", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Proxy for a GET request defined by an 'endpoint'. The request is authorized using a service connection. The response is filtered using an XPath/Json based selector.
       *
       * @param {TaskAgentInterfaces.TaskDefinitionEndpoint} endpoint - Describes the URL to fetch.
       */
      queryEndpoint(endpoint) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f223b809-8c33-4b7d-b53f-07232569b5d6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, endpoint, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get environment deployment execution history
       *
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {string} continuationToken
       * @param {number} top
       */
      getEnvironmentDeploymentExecutionRecords(project, environmentId, continuationToken, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            let queryValues = {
              continuationToken,
              top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "51bb5d21-4305-4ea6-9dbb-b7488af73334", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentDeploymentExecutionRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an environment.
       *
       * @param {TaskAgentInterfaces.EnvironmentCreateParameter} environmentCreateParameter - Environment to create.
       * @param {string} project - Project ID or project name
       */
      addEnvironment(environmentCreateParameter, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, environmentCreateParameter, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete the specified environment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} environmentId - ID of the environment.
       */
      deleteEnvironment(project, environmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an environment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} environmentId - ID of the environment.
       * @param {TaskAgentInterfaces.EnvironmentExpands} expands - Include these additional details in the returned objects.
       */
      getEnvironmentById(project, environmentId, expands) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            let queryValues = {
              expands
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all environments.
       *
       * @param {string} project - Project ID or project name
       * @param {string} name
       * @param {string} continuationToken
       * @param {number} top
       */
      getEnvironments(project, name, continuationToken, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              continuationToken,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the specified environment.
       *
       * @param {TaskAgentInterfaces.EnvironmentUpdateParameter} environmentUpdateParameter - Environment data to update.
       * @param {string} project - Project ID or project name
       * @param {number} environmentId - ID of the environment.
       */
      updateEnvironment(environmentUpdateParameter, project, environmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, environmentUpdateParameter, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} hubName
       * @param {boolean} includeEnterpriseUsersCount
       * @param {boolean} includeHostedAgentMinutesCount
       */
      getTaskHubLicenseDetails(hubName, includeEnterpriseUsersCount, includeHostedAgentMinutesCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              hubName
            };
            let queryValues = {
              includeEnterpriseUsersCount,
              includeHostedAgentMinutesCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "distributedtask", "f9f0f436-b8a1-4475-9041-1ccdbf8f0128", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskHubLicenseDetails} taskHubLicenseDetails
       * @param {string} hubName
       */
      updateTaskHubLicenseDetails(taskHubLicenseDetails, hubName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              hubName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "distributedtask", "f9f0f436-b8a1-4475-9041-1ccdbf8f0128", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, taskHubLicenseDetails, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.InputValidationRequest} inputValidationRequest
       */
      validateInputs(inputValidationRequest) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "58475b1e-adaf-4155-9bc1-e04bf1fff4c2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, inputValidationRequest, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} requestId
       * @param {string} lockToken
       * @param {TaskAgentInterfaces.TaskResult} result
       * @param {boolean} agentShuttingDown
       */
      deleteAgentRequest(poolId, requestId, lockToken, result2, agentShuttingDown) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (lockToken == null) {
            throw new TypeError("lockToken can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              requestId
            };
            let queryValues = {
              lockToken,
              result: result2,
              agentShuttingDown
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} requestId
       * @param {boolean} includeStatus
       */
      getAgentRequest(poolId, requestId, includeStatus) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              requestId
            };
            let queryValues = {
              includeStatus
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} top
       * @param {string} continuationToken
       */
      getAgentRequests(poolId, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (top == null) {
            throw new TypeError("top can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} agentId
       * @param {number} completedRequestCount
       */
      getAgentRequestsForAgent(poolId, agentId, completedRequestCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (agentId == null) {
            throw new TypeError("agentId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentId,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number[]} agentIds
       * @param {number} completedRequestCount
       */
      getAgentRequestsForAgents(poolId, agentIds, completedRequestCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentIds: agentIds && agentIds.join(","),
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {string} planId
       * @param {string} jobId
       */
      getAgentRequestsForPlan(poolId, planId, jobId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (planId == null) {
            throw new TypeError("planId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              planId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentJobRequest} request
       * @param {number} poolId
       */
      queueAgentRequestByPool(request, poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentJobRequest} request
       * @param {number} poolId
       * @param {number} requestId
       * @param {string} lockToken
       * @param {TaskAgentInterfaces.TaskAgentRequestUpdateOptions} updateOptions
       */
      updateAgentRequest(request, poolId, requestId, lockToken, updateOptions) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (lockToken == null) {
            throw new TypeError("lockToken can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              requestId
            };
            let queryValues = {
              lockToken,
              updateOptions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, request, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.KubernetesResourceCreateParameters} createParameters
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       */
      addKubernetesResource(createParameters, project, environmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "73fba52f-15ab-42b3-a538-ce67a9223a04", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createParameters, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.KubernetesResource, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      deleteKubernetesResource(project, environmentId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "73fba52f-15ab-42b3-a538-ce67a9223a04", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      getKubernetesResource(project, environmentId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "73fba52f-15ab-42b3-a538-ce67a9223a04", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.KubernetesResource, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      generateDeploymentMachineGroupAccessToken(project, machineGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f8c7c0de-ac0d-469b-9cb1-c21f72d67693", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachineGroup} machineGroup
       * @param {string} project - Project ID or project name
       */
      addDeploymentMachineGroup(machineGroup, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, machineGroup, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      deleteDeploymentMachineGroup(project, machineGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       * @param {TaskAgentInterfaces.MachineGroupActionFilter} actionFilter
       */
      getDeploymentMachineGroup(project, machineGroupId, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            let queryValues = {
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} machineGroupName
       * @param {TaskAgentInterfaces.MachineGroupActionFilter} actionFilter
       */
      getDeploymentMachineGroups(project, machineGroupName, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              machineGroupName,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachineGroup} machineGroup
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      updateDeploymentMachineGroup(machineGroup, project, machineGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machineGroup, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       * @param {string[]} tagFilters
       */
      getDeploymentMachineGroupMachines(project, machineGroupId, tagFilters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            let queryValues = {
              tagFilters: tagFilters && tagFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "966c3874-c347-4b18-a90c-d509116717fd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine[]} deploymentMachines
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      updateDeploymentMachineGroupMachines(deploymentMachines, project, machineGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "966c3874-c347-4b18-a90c-d509116717fd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, deploymentMachines, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine} machine
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       */
      addDeploymentMachine(machine, project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, machine, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       */
      deleteDeploymentMachine(project, deploymentGroupId, machineId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       * @param {TaskAgentInterfaces.DeploymentMachineExpands} expand
       */
      getDeploymentMachine(project, deploymentGroupId, machineId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {string[]} tags
       * @param {string} name
       * @param {TaskAgentInterfaces.DeploymentMachineExpands} expand
       */
      getDeploymentMachines(project, deploymentGroupId, tags, name, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              tags: tags && tags.join(","),
              name,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine} machine
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       */
      replaceDeploymentMachine(machine, project, deploymentGroupId, machineId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, machine, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine} machine
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       */
      updateDeploymentMachine(machine, project, deploymentGroupId, machineId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machine, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine[]} machines
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       */
      updateDeploymentMachines(machines, project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machines, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceDefinition} definition
       * @param {number} poolId
       */
      createAgentPoolMaintenanceDefinition(definition, poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, definition, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} definitionId
       */
      deleteAgentPoolMaintenanceDefinition(poolId, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} definitionId
       */
      getAgentPoolMaintenanceDefinition(poolId, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       */
      getAgentPoolMaintenanceDefinitions(poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceDefinition} definition
       * @param {number} poolId
       * @param {number} definitionId
       */
      updateAgentPoolMaintenanceDefinition(definition, poolId, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, definition, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} jobId
       */
      deleteAgentPoolMaintenanceJob(poolId, jobId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} jobId
       */
      getAgentPoolMaintenanceJob(poolId, jobId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} jobId
       */
      getAgentPoolMaintenanceJobLogs(poolId, jobId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} definitionId
       */
      getAgentPoolMaintenanceJobs(poolId, definitionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceJob} job
       * @param {number} poolId
       */
      queueAgentPoolMaintenanceJob(job, poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, job, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceJob} job
       * @param {number} poolId
       * @param {number} jobId
       */
      updateAgentPoolMaintenanceJob(job, poolId, jobId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, job, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} messageId
       * @param {string} sessionId
       */
      deleteMessage(poolId, messageId, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (sessionId == null) {
            throw new TypeError("sessionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              messageId
            };
            let queryValues = {
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {string} sessionId
       * @param {number} lastMessageId
       */
      getMessage(poolId, sessionId, lastMessageId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (sessionId == null) {
            throw new TypeError("sessionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              sessionId,
              lastMessageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} agentId
       */
      refreshAgent(poolId, agentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (agentId == null) {
            throw new TypeError("agentId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       */
      refreshAgents(poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentMessage} message
       * @param {number} poolId
       * @param {number} requestId
       */
      sendMessage(message, poolId, requestId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (requestId == null) {
            throw new TypeError("requestId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              requestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, message, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} packageType
       * @param {string} platform
       * @param {string} version
       */
      getPackage(packageType, platform, version) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              packageType,
              platform,
              version
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "8ffcd551-079c-493a-9c02-54346299d144", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.PackageMetadata, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} packageType
       * @param {string} platform
       * @param {number} top
       */
      getPackages(packageType, platform, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              packageType,
              platform
            };
            let queryValues = {
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "8ffcd551-079c-493a-9c02-54346299d144", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.PackageMetadata, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       */
      getAgentPoolMetadata(poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0d62f887-9f53-48b9-9161-4c35d5735b0f", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} agentPoolMetadata
       * @param {number} poolId
       */
      setAgentPoolMetadata(customHeaders, agentPoolMetadata, poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0d62f887-9f53-48b9-9161-4c35d5735b0f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.replace(url, agentPoolMetadata, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Checks if current identity has passed permissions on a pool.
       *
       * @param {number} poolId - Id of the pool to check
       * @param {number} permissions - Permissions to check. Multiple permissions might be merged into single value using bitwise OR operator (e.g. AgentPoolPermissions.Manage | AgentPoolPermissions.View)
       */
      hasPoolPermissions(poolId, permissions) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              permissions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "162778f3-4b48-48f3-9d58-436fb9c407bc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an agent pool.
       *
       * @param {TaskAgentInterfaces.TaskAgentPool} pool - Details about the new agent pool
       */
      addAgentPool(pool) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, pool, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete an agent pool.
       *
       * @param {number} poolId - ID of the agent pool to delete
       */
      deleteAgentPool(poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get information about an agent pool.
       *
       * @param {number} poolId - An agent pool ID
       * @param {string[]} properties - Agent pool properties (comma-separated)
       * @param {TaskAgentInterfaces.TaskAgentPoolActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentPool(poolId, properties, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              properties: properties && properties.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent pools.
       *
       * @param {string} poolName - Filter by name
       * @param {string[]} properties - Filter by agent pool properties (comma-separated)
       * @param {TaskAgentInterfaces.TaskAgentPoolType} poolType - Filter by pool type
       * @param {TaskAgentInterfaces.TaskAgentPoolActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentPools(poolName, properties, poolType, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              poolName,
              properties: properties && properties.join(","),
              poolType,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent pools.
       *
       * @param {number[]} poolIds - pool Ids to fetch
       * @param {TaskAgentInterfaces.TaskAgentPoolActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentPoolsByIds(poolIds, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (poolIds == null) {
            throw new TypeError("poolIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              poolIds: poolIds && poolIds.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update properties on an agent pool
       *
       * @param {TaskAgentInterfaces.TaskAgentPool} pool - Updated agent pool details
       * @param {number} poolId - The agent pool to update
       */
      updateAgentPool(pool, poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, pool, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new agent queue to connect a project to an agent pool.
       *
       * @param {TaskAgentInterfaces.TaskAgentQueue} queue - Details about the queue to create
       * @param {string} project - Project ID or project name
       * @param {boolean} authorizePipelines - Automatically authorize this queue when using YAML
       */
      addAgentQueue(queue, project, authorizePipelines) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              authorizePipelines
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queue, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new team project.
       *
       * @param {string} project - Project ID or project name
       */
      createTeamProject(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes an agent queue from a project.
       *
       * @param {number} queueId - The agent queue to remove
       * @param {string} project - Project ID or project name
       */
      deleteAgentQueue(queueId, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get information about an agent queue.
       *
       * @param {number} queueId - The agent queue to get information about
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueue(queueId, project, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            let queryValues = {
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues.
       *
       * @param {string} project - Project ID or project name
       * @param {string} queueName - Filter on the agent queue name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueues(project, queueName, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              queueName,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues by their IDs
       *
       * @param {number[]} queueIds - A comma-separated list of agent queue IDs to retrieve
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueuesByIds(queueIds, project, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (queueIds == null) {
            throw new TypeError("queueIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              queueIds: queueIds && queueIds.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues by their names
       *
       * @param {string[]} queueNames - A comma-separated list of agent names to retrieve
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueuesByNames(queueNames, project, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (queueNames == null) {
            throw new TypeError("queueNames can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              queueNames: queueNames && queueNames.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues by pool ids
       *
       * @param {number[]} poolIds - A comma-separated list of pool ids to get the corresponding queues for
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueuesForPools(poolIds, project, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (poolIds == null) {
            throw new TypeError("poolIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              poolIds: poolIds && poolIds.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} agentCloudId
       */
      getAgentCloudRequests(agentCloudId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "20189bd7-5134-49c2-b8e9-f9e856eea2b2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentCloudRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getResourceLimits() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "1f1f0557-c445-42a6-b4a0-0df605a3a0f8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} parallelismTag
       * @param {boolean} poolIsHosted
       * @param {boolean} includeRunningRequests
       */
      getResourceUsage(parallelismTag, poolIsHosted, includeRunningRequests) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              parallelismTag,
              poolIsHosted,
              includeRunningRequests
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "eae1d376-a8b1-4475-9041-1dfdbe8f0143", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.ResourceUsage, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       */
      getTaskGroupHistory(project, taskGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "100cc92a-b255-47fa-9ab3-e44a2985a3ac", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroupRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a secure file
       *
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       */
      deleteSecureFile(project, secureFileId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a secure file by Id
       *
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       * @param {string} ticket - A valid download ticket
       * @param {boolean} download - If download is true, the file is sent as attachement in the response body. If download is false, the response body contains the file stream.
       */
      downloadSecureFile(project, secureFileId, ticket, download) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (ticket == null) {
            throw new TypeError("ticket can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            let queryValues = {
              ticket,
              download
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a secure file
       *
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       * @param {boolean} includeDownloadTicket - If includeDownloadTicket is true and the caller has permissions, a download ticket is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter
       */
      getSecureFile(project, secureFileId, includeDownloadTicket, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            let queryValues = {
              includeDownloadTicket,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get secure files
       *
       * @param {string} project - Project ID or project name
       * @param {string} namePattern - Name of the secure file to match. Can include wildcards to match multiple files.
       * @param {boolean} includeDownloadTickets - If includeDownloadTickets is true and the caller has permissions, a download ticket for each secure file is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter - Filter by secure file permissions for View, Manage or Use action. Defaults to View.
       */
      getSecureFiles(project, namePattern, includeDownloadTickets, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              namePattern,
              includeDownloadTickets,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get secure files
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} secureFileIds - A list of secure file Ids
       * @param {boolean} includeDownloadTickets - If includeDownloadTickets is true and the caller has permissions, a download ticket for each secure file is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter
       */
      getSecureFilesByIds(project, secureFileIds, includeDownloadTickets, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (secureFileIds == null) {
            throw new TypeError("secureFileIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              secureFileIds: secureFileIds && secureFileIds.join(","),
              includeDownloadTickets,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get secure files
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} secureFileNames - A list of secure file Ids
       * @param {boolean} includeDownloadTickets - If includeDownloadTickets is true and the caller has permissions, a download ticket for each secure file is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter
       */
      getSecureFilesByNames(project, secureFileNames, includeDownloadTickets, actionFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (secureFileNames == null) {
            throw new TypeError("secureFileNames can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              secureFileNames: secureFileNames && secureFileNames.join(","),
              includeDownloadTickets,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query secure files using a name pattern and a condition on file properties.
       *
       * @param {string} condition - The main condition syntax is described [here](https://go.microsoft.com/fwlink/?linkid=842996). Use the *property('property-name')* function to access the value of the specified property of a secure file. It returns null if the property is not set. E.g. ``` and( eq( property('devices'), '2' ), in( property('provisioning profile type'), 'ad hoc', 'development' ) ) ```
       * @param {string} project - Project ID or project name
       * @param {string} namePattern - Name of the secure file to match. Can include wildcards to match multiple files.
       */
      querySecureFilesByProperties(condition, project, namePattern) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              namePattern
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, condition, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the name or properties of an existing secure file
       *
       * @param {TaskAgentInterfaces.SecureFile} secureFile - The secure file with updated name and/or properties
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       */
      updateSecureFile(secureFile, project, secureFileId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, secureFile, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update properties and/or names of a set of secure files. Files are identified by their IDs. Properties provided override the existing one entirely, i.e. do not merge.
       *
       * @param {TaskAgentInterfaces.SecureFile[]} secureFiles - A list of secure file objects. Only three field must be populated Id, Name, and Properties. The rest of fields in the object are ignored.
       * @param {string} project - Project ID or project name
       */
      updateSecureFiles(secureFiles, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, secureFiles, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Upload a secure file, include the file stream in the request body
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} project - Project ID or project name
       * @param {string} name - Name of the file to upload
       * @param {boolean} authorizePipelines - If authorizePipelines is true, then the secure file is authorized for use by all pipelines in the project.
       */
      uploadSecureFile(customHeaders, contentStream, project, name, authorizePipelines) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (name == null) {
            throw new TypeError("name can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              authorizePipelines
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentSession} session
       * @param {number} poolId
       */
      createAgentSession(session, poolId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "134e239e-2df3-4794-a6f6-24f1f19ec8dc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, session, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentSession, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {string} sessionId
       */
      deleteAgentSession(poolId, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "134e239e-2df3-4794-a6f6-24f1f19ec8dc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Register a deployment target to a deployment group. Generally this is called by agent configuration tool.
       *
       * @param {TaskAgentInterfaces.DeploymentMachine} machine - Deployment target to register.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which the deployment target is registered.
       */
      addDeploymentTarget(machine, project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, machine, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a deployment target in a deployment group. This deletes the agent from associated deployment pool too.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment target is deleted.
       * @param {number} targetId - ID of the deployment target to delete.
       */
      deleteDeploymentTarget(project, deploymentGroupId, targetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a deployment target by its ID in a deployment group
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which deployment target belongs.
       * @param {number} targetId - ID of the deployment target to return.
       * @param {TaskAgentInterfaces.DeploymentTargetExpands} expand - Include these additional details in the returned objects.
       */
      getDeploymentTarget(project, deploymentGroupId, targetId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment targets in a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       * @param {string[]} tags - Get only the deployment targets that contain all these comma separted list of tags.
       * @param {string} name - Name pattern of the deployment targets to return.
       * @param {boolean} partialNameMatch - When set to true, treats **name** as pattern. Else treats it as absolute match. Default is **false**.
       * @param {TaskAgentInterfaces.DeploymentTargetExpands} expand - Include these additional details in the returned objects.
       * @param {TaskAgentInterfaces.TaskAgentStatusFilter} agentStatus - Get only deployment targets that have this status.
       * @param {TaskAgentInterfaces.TaskAgentJobResultFilter} agentJobResult - Get only deployment targets that have this last job result.
       * @param {string} continuationToken - Get deployment targets with names greater than this continuationToken lexicographically.
       * @param {number} top - Maximum number of deployment targets to return. Default is **1000**.
       * @param {boolean} enabled - Get only deployment targets that are enabled or disabled. Default is 'null' which returns all the targets.
       * @param {string[]} propertyFilters
       */
      getDeploymentTargets(project, deploymentGroupId, tags, name, partialNameMatch, expand, agentStatus, agentJobResult, continuationToken, top, enabled, propertyFilters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              tags: tags && tags.join(","),
              name,
              partialNameMatch,
              "$expand": expand,
              agentStatus,
              agentJobResult,
              continuationToken,
              "$top": top,
              enabled,
              propertyFilters: propertyFilters && propertyFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace a deployment target in a deployment group. Generally this is called by agent configuration tool.
       *
       * @param {TaskAgentInterfaces.DeploymentMachine} machine - New deployment target.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment target is replaced.
       * @param {number} targetId - ID of the deployment target to replace.
       */
      replaceDeploymentTarget(machine, project, deploymentGroupId, targetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, machine, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a deployment target and its agent properties in a deployment group. Generally this is called by agent configuration tool.
       *
       * @param {TaskAgentInterfaces.DeploymentMachine} machine - Deployment target to update.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment target is updated.
       * @param {number} targetId - ID of the deployment target to update.
       */
      updateDeploymentTarget(machine, project, deploymentGroupId, targetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machine, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update tags of a list of deployment targets in a deployment group.
       *
       * @param {TaskAgentInterfaces.DeploymentTargetUpdateParameter[]} machines - Deployment targets with tags to udpdate.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment targets are updated.
       */
      updateDeploymentTargets(machines, project, deploymentGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machines, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a task group.
       *
       * @param {TaskAgentInterfaces.TaskGroupCreateParameter} taskGroup - Task group object to create.
       * @param {string} project - Project ID or project name
       */
      addTaskGroup(taskGroup, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, taskGroup, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a task group.
       *
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group to be deleted.
       * @param {string} comment - Comments to delete.
       */
      deleteTaskGroup(project, taskGroupId, comment) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              comment
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get task group.
       *
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group.
       * @param {string} versionSpec - version specification of the task group. examples: 1, 1.0.
       * @param {TaskAgentInterfaces.TaskGroupExpands} expand - The properties that should be expanded. example $expand=Tasks will expand nested task groups.
       */
      getTaskGroup(project, taskGroupId, versionSpec, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (versionSpec == null) {
            throw new TypeError("versionSpec can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              versionSpec,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       * @param {number} revision
       */
      getTaskGroupRevision(project, taskGroupId, revision) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (revision == null) {
            throw new TypeError("revision can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List task groups.
       *
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group.
       * @param {boolean} expanded - 'true' to recursively expand task groups. Default is 'false'.
       * @param {string} taskIdFilter - Guid of the taskId to filter.
       * @param {boolean} deleted - 'true'to include deleted task groups. Default is 'false'.
       * @param {number} top - Number of task groups to get.
       * @param {Date} continuationToken - Gets the task groups after the continuation token provided.
       * @param {TaskAgentInterfaces.TaskGroupQueryOrder} queryOrder - Gets the results in the defined order. Default is 'CreatedOnDescending'.
       */
      getTaskGroups(project, taskGroupId, expanded, taskIdFilter, deleted, top, continuationToken, queryOrder) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              expanded,
              taskIdFilter,
              deleted,
              "$top": top,
              continuationToken,
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.PublishTaskGroupMetadata} taskGroupMetadata
       * @param {string} project - Project ID or project name
       * @param {string} parentTaskGroupId
       */
      publishTaskGroup(taskGroupMetadata, project, parentTaskGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (parentTaskGroupId == null) {
            throw new TypeError("parentTaskGroupId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              parentTaskGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, taskGroupMetadata, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskGroup} taskGroup
       * @param {string} project - Project ID or project name
       */
      undeleteTaskGroup(taskGroup, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, taskGroup, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a task group.
       *
       * @param {TaskAgentInterfaces.TaskGroupUpdateParameter} taskGroup - Task group to update.
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group to update.
       */
      updateTaskGroup(taskGroup, project, taskGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, taskGroup, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskGroupUpdatePropertiesBase} taskGroupUpdateProperties
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       * @param {boolean} disablePriorVersions
       */
      updateTaskGroupProperties(taskGroupUpdateProperties, project, taskGroupId, disablePriorVersions) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              disablePriorVersions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, taskGroupUpdateProperties, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       */
      deleteTaskDefinition(taskId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              taskId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       */
      getTaskContentZip(taskId, versionString, visibility, scopeLocal) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (versionString == null) {
            throw new TypeError("versionString can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              taskId
            };
            let queryValues = {
              versionString,
              visibility,
              scopeLocal
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       */
      getTaskDefinition(taskId, versionString, visibility, scopeLocal) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (versionString == null) {
            throw new TypeError("versionString can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              taskId
            };
            let queryValues = {
              versionString,
              visibility,
              scopeLocal
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param {boolean} allVersions
       */
      getTaskDefinitions(taskId, visibility, scopeLocal, allVersions) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              taskId
            };
            let queryValues = {
              visibility,
              scopeLocal,
              allVersions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} agentId
       * @param {string} currentState
       */
      updateAgentUpdateState(poolId, agentId, currentState) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (currentState == null) {
            throw new TypeError("currentState can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            let queryValues = {
              currentState
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8cc1b02b-ae49-4516-b5ad-4f9b29967c30", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {{ [key: string] : string; }} userCapabilities
       * @param {number} poolId
       * @param {number} agentId
       */
      updateAgentUserCapabilities(userCapabilities, poolId, agentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "30ba3ada-fedf-4da8-bbb5-dacf2f82e176", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, userCapabilities, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a variable group.
       *
       * @param {TaskAgentInterfaces.VariableGroupParameters} variableGroupParameters
       */
      addVariableGroup(variableGroupParameters) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, variableGroupParameters, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a variable group
       *
       * @param {number} groupId - Id of the variable group.
       * @param {string[]} projectIds
       */
      deleteVariableGroup(groupId, projectIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (projectIds == null) {
            throw new TypeError("projectIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              groupId
            };
            let queryValues = {
              projectIds: projectIds && projectIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a variable group.
       *
       * @param {TaskAgentInterfaces.VariableGroupProjectReference[]} variableGroupProjectReferences
       * @param {number} variableGroupId
       */
      shareVariableGroup(variableGroupProjectReferences, variableGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (variableGroupId == null) {
            throw new TypeError("variableGroupId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              variableGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, variableGroupProjectReferences, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a variable group.
       *
       * @param {TaskAgentInterfaces.VariableGroupParameters} variableGroupParameters
       * @param {number} groupId - Id of the variable group to update.
       */
      updateVariableGroup(variableGroupParameters, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, variableGroupParameters, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a variable group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} groupId - Id of the variable group.
       */
      getVariableGroup(project, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "f5b09dd5-9d54-45a1-8b5a-1c8287d634cc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get variable groups.
       *
       * @param {string} project - Project ID or project name
       * @param {string} groupName - Name of variable group.
       * @param {TaskAgentInterfaces.VariableGroupActionFilter} actionFilter - Action filter for the variable group. It specifies the action which can be performed on the variable groups.
       * @param {number} top - Number of variable groups to get.
       * @param {number} continuationToken - Gets the variable groups after the continuation token provided.
       * @param {TaskAgentInterfaces.VariableGroupQueryOrder} queryOrder - Gets the results in the defined order. Default is 'IdDescending'.
       */
      getVariableGroups(project, groupName, actionFilter, top, continuationToken, queryOrder) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              groupName,
              actionFilter,
              "$top": top,
              continuationToken,
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "f5b09dd5-9d54-45a1-8b5a-1c8287d634cc", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get variable groups by ids.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} groupIds - Comma separated list of Ids of variable groups.
       * @param {boolean} loadSecrets - Flag indicating if the secrets within variable groups should be loaded.
       */
      getVariableGroupsById(project, groupIds, loadSecrets) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (groupIds == null) {
            throw new TypeError("groupIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              groupIds: groupIds && groupIds.join(","),
              loadSecrets
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "f5b09dd5-9d54-45a1-8b5a-1c8287d634cc", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.VirtualMachineGroupCreateParameters} createParameters
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       */
      addVirtualMachineGroup(createParameters, project, environmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createParameters, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      deleteVirtualMachineGroup(project, environmentId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      getVirtualMachineGroup(project, environmentId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.VirtualMachineGroup} resource
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       */
      updateVirtualMachineGroup(resource, project, environmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, resource, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       * @param {string} continuationToken
       * @param {string} name
       * @param {boolean} partialNameMatch
       * @param {string[]} tags
       * @param {number} top
       */
      getVirtualMachines(project, environmentId, resourceId, continuationToken, name, partialNameMatch, tags, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            let queryValues = {
              continuationToken,
              name,
              partialNameMatch,
              tags: tags && tags.join(","),
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "48700676-2ba5-4282-8ec8-083280d169c7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.VirtualMachine[]} machines
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      updateVirtualMachines(machines, project, environmentId, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "48700676-2ba5-4282-8ec8-083280d169c7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machines, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} tenantId
       * @param {string} redirectUri
       * @param {TaskAgentInterfaces.AadLoginPromptOption} promptOption
       * @param {string} completeCallbackPayload
       * @param {boolean} completeCallbackByAuthCode
       */
      createAadOAuthRequest(tenantId, redirectUri, promptOption, completeCallbackPayload, completeCallbackByAuthCode) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (tenantId == null) {
            throw new TypeError("tenantId can not be null or undefined");
          }
          if (redirectUri == null) {
            throw new TypeError("redirectUri can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              tenantId,
              redirectUri,
              promptOption,
              completeCallbackPayload,
              completeCallbackByAuthCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9c63205e-3a0f-42a0-ad88-095200f13607", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getVstsAadTenantId() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9c63205e-3a0f-42a0-ad88-095200f13607", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET the Yaml schema used for Yaml file validation.
       *
       * @param {boolean} validateTaskNames - Whether the schema should validate that tasks are actually installed (useful for offline tools where you don't want validation).
       */
      getYamlSchema(validateTaskNames) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              validateTaskNames
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "1f9990b9-1dba-441f-9c2e-6485888c42b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TaskAgentApiBase = TaskAgentApiBase;
    TaskAgentApiBase.RESOURCE_AREA_ID = "a85b8835-c1a1-4aac-ae97-1c3d0ba72dbd";
  }
});

// packages/core/node_modules/azure-devops-node-api/TaskAgentApi.js
var require_TaskAgentApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/TaskAgentApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskAgentApi = void 0;
    var taskagentbasem = require_TaskAgentApiBase();
    var url = require("url");
    var TaskAgentApi = class _TaskAgentApi extends taskagentbasem.TaskAgentApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, options2, userAgent);
        this._handlers = handlers;
        this._options = options2;
      }
      /**
       * @param {string} taskId
       * @param onResult callback function
       */
      deleteTaskDefinition(taskId) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.deleteTaskDefinition(taskId);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.deleteTaskDefinition(taskId);
            }
          }
        });
        return promise;
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param onResult callback function with the resulting ArrayBuffer
       */
      getTaskContentZip(taskId, versionString, visibility, scopeLocal) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.getTaskContentZip(taskId, versionString, visibility, scopeLocal);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.getTaskContentZip(taskId, versionString, visibility, scopeLocal);
            }
          }
        });
        return promise;
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param onResult callback function with the resulting TaskAgentInterfaces.TaskDefinition
       */
      getTaskDefinition(taskId, versionString, visibility, scopeLocal) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.getTaskDefinition(taskId, versionString, visibility, scopeLocal);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.getTaskDefinition(taskId, versionString, visibility, scopeLocal);
            }
          }
        });
        return promise;
      }
      /**
       * @param {string} taskId
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param onResult callback function with the resulting TaskAgentInterfaces.TaskDefinition[]
       */
      getTaskDefinitions(taskId, visibility, scopeLocal) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.getTaskDefinitions(taskId, visibility, scopeLocal);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.getTaskDefinitions(taskId, visibility, scopeLocal);
            }
          }
        });
        return promise;
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream
       * @param {string} taskId
       * @param {boolean} overwrite
       * @param onResult callback function
       */
      uploadTaskDefinition(customHeaders, contentStream, taskId, overwrite) {
        return __awaiter3(this, void 0, void 0, function* () {
          let routeValues = {
            taskId
          };
          let queryValues = {
            overwrite
          };
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url2 = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url2, contentStream, options2);
              resolve(res.result);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      _getFallbackClient(baseUrl) {
        if (!this._fallbackClient) {
          var accountUrl = this._getAccountUrl(baseUrl);
          if (accountUrl) {
            this._fallbackClient = new _TaskAgentApi(accountUrl, this._handlers, this._options);
          }
        }
        return this._fallbackClient;
      }
      _getAccountUrl(collectionUrl) {
        var purl = url.parse(collectionUrl);
        if (!purl.protocol || !purl.host) {
          return null;
        }
        var accountUrl = purl.protocol + "//" + purl.host;
        var splitPath = purl.path.split("/").slice(1);
        if (splitPath.length === 0 || splitPath.length === 1 && splitPath[0] === "") {
          return null;
        }
        if (splitPath[0] === "tfs" && (splitPath.length === 2 || splitPath.length === 3 && splitPath[2].length === 0)) {
          accountUrl += "/tfs";
        } else if (splitPath.length === 2 && splitPath[0] === "") {
          return accountUrl;
        } else if (splitPath.length > 1) {
          return null;
        }
        return accountUrl;
      }
    };
    exports2.TaskAgentApi = TaskAgentApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/TaskApi.js
var require_TaskApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/TaskApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskApi = void 0;
    var basem = require_ClientApiBases();
    var TaskAgentInterfaces = require_TaskAgentInterfaces();
    var TaskApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Task-api", options2);
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} type
       */
      getPlanAttachments(scopeIdentifier, hubName, planId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "eb55e5d6-2f30-4295-b5ed-38da50b1fc52", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       */
      createAttachment(customHeaders, contentStream, scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       * @param {string} artifactHash
       * @param {number} length
       */
      createAttachmentFromArtifact(scopeIdentifier, hubName, planId, timelineId, recordId, type, name, artifactHash, length) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactHash == null) {
            throw new TypeError("artifactHash can not be null or undefined");
          }
          if (length == null) {
            throw new TypeError("length can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            let queryValues = {
              artifactHash,
              length
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       */
      getAttachment(scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       */
      getAttachmentContent(scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       */
      getAttachments(scopeIdentifier, hubName, planId, timelineId, recordId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Append content to timeline record feed.
       *
       * @param {TaskAgentInterfaces.TimelineRecordFeedLinesWrapper} lines - Content to be appended to the timeline record feed.
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - ID of the plan.
       * @param {string} timelineId - ID of the task's timeline.
       * @param {string} recordId - ID of the timeline record.
       */
      appendTimelineRecordFeed(lines, scopeIdentifier, hubName, planId, timelineId, recordId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "858983e4-19bd-4c5e-864c-507b59b58b12", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, lines, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} stepId
       * @param {number} endLine
       * @param {number} takeCount
       * @param {string} continuationToken
       */
      getLines(scopeIdentifier, hubName, planId, timelineId, recordId, stepId, endLine, takeCount, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (stepId == null) {
            throw new TypeError("stepId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId
            };
            let queryValues = {
              stepId,
              endLine,
              takeCount,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "858983e4-19bd-4c5e-864c-507b59b58b12", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} orchestrationId
       */
      getJobInstance(scopeIdentifier, hubName, orchestrationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              orchestrationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0a1efd25-abda-43bd-9629-6c7bdd2e0d60", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Append a log to a task's log. The log should be sent in the body of the request as a TaskLog object stream.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - The ID of the plan.
       * @param {number} logId - The ID of the log.
       */
      appendLogContent(customHeaders, contentStream, scopeIdentifier, hubName, planId, logId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              logId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {number} logId
       * @param {string} serializedBlobId
       * @param {number} lineCount
       */
      associateLog(scopeIdentifier, hubName, planId, logId, serializedBlobId, lineCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (serializedBlobId == null) {
            throw new TypeError("serializedBlobId can not be null or undefined");
          }
          if (lineCount == null) {
            throw new TypeError("lineCount can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              logId
            };
            let queryValues = {
              serializedBlobId,
              lineCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a log and connect it to a pipeline run's execution plan.
       *
       * @param {TaskAgentInterfaces.TaskLog} log - An object that contains information about log's path.
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - The ID of the plan.
       */
      createLog(log, scopeIdentifier, hubName, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, log, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {number} logId
       * @param {number} startLine
       * @param {number} endLine
       */
      getLog(scopeIdentifier, hubName, planId, logId, startLine, endLine) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      getLogs(scopeIdentifier, hubName, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       */
      getPlanGroupsQueueMetrics(scopeIdentifier, hubName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "038fd4d5-cda7-44ca-92c0-935843fee1a7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationPlanGroupsQueueMetrics, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {{ [key: string] : string; }} claims
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} jobId
       * @param {string} serviceConnectionId
       */
      createOidcToken(claims, scopeIdentifier, hubName, planId, jobId, serviceConnectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              jobId
            };
            let queryValues = {
              serviceConnectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "69a319f4-28c1-4bfd-93e6-ea0ff5c6f1a2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, claims, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {TaskAgentInterfaces.PlanGroupStatus} statusFilter
       * @param {number} count
       */
      getQueuedPlanGroups(scopeIdentifier, hubName, statusFilter, count) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName
            };
            let queryValues = {
              statusFilter,
              count
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0dd73091-3e36-4f43-b443-1b76dd426d84", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationQueuedPlanGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planGroup
       */
      getQueuedPlanGroup(scopeIdentifier, hubName, planGroup) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planGroup
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "65fd0708-bc1e-447b-a731-0587c5464e5b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationQueuedPlanGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      getPlan(scopeIdentifier, hubName, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "5cecd946-d704-471e-a45f-3b4064fcfaba", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {number} changeId
       */
      getRecords(scopeIdentifier, hubName, planId, timelineId, changeId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            let queryValues = {
              changeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TimelineRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update timeline records if they already exist, otherwise create new ones for the same timeline.
       *
       * @param {VSSInterfaces.VssJsonCollectionWrapperV<TaskAgentInterfaces.TimelineRecord[]>} records - The array of timeline records to be updated.
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - The ID of the plan.
       * @param {string} timelineId - The ID of the timeline.
       */
      updateRecords(records, scopeIdentifier, hubName, planId, timelineId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, records, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TimelineRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.Timeline} timeline
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      createTimeline(timeline, scopeIdentifier, hubName, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, timeline, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.Timeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       */
      deleteTimeline(scopeIdentifier, hubName, planId, timelineId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {number} changeId
       * @param {boolean} includeRecords
       */
      getTimeline(scopeIdentifier, hubName, planId, timelineId, changeId, includeRecords) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            let queryValues = {
              changeId,
              includeRecords
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.Timeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      getTimelines(scopeIdentifier, hubName, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.Timeline, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TaskApi = TaskApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/TestApi.js
var require_TestApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/TestApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestApi = void 0;
    var basem = require_ClientApiBases();
    var TestInterfaces = require_TestInterfaces();
    var TestApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Test-api", options2);
      }
      /**
       * Attach a file to test step result
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment details TestAttachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result that contains the iteration
       * @param {number} iterationId - ID of the test result iteration.
       * @param {string} actionPath - Hex value of test result action path.
       */
      createTestIterationResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, iterationId, actionPath) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              iterationId,
              actionPath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a file to a test result.
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment details TestAttachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result against which attachment has to be uploaded.
       */
      createTestResultAttachment(attachmentRequestModel, project, runId, testCaseResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a file to a test result
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment Request Model.
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} testSubResultId - ID of the test sub results against which attachment has to be uploaded.
       */
      createTestSubResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test result attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the testCaseResultId.
       * @param {number} testCaseResultId - ID of the test result whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded.
       */
      getTestResultAttachmentContent(project, runId, testCaseResultId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test result attachments reference.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result.
       */
      getTestResultAttachments(project, runId, testCaseResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test result attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the testCaseResultId.
       * @param {number} testCaseResultId - ID of the test result whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded.
       */
      getTestResultAttachmentZip(project, runId, testCaseResultId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded
       * @param {number} testSubResultId - ID of the test sub result whose attachment has to be downloaded
       */
      getTestSubResultAttachmentContent(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test sub result attachments
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} testSubResultId - ID of the test sub result whose attachment has to be downloaded
       */
      getTestSubResultAttachments(project, runId, testCaseResultId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded
       * @param {number} testSubResultId - ID of the test sub result whose attachment has to be downloaded
       */
      getTestSubResultAttachmentZip(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a file to a test run.
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment details TestAttachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run against which attachment has to be uploaded.
       */
      createTestRunAttachment(attachmentRequestModel, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test run attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test run attachment to be downloaded.
       */
      getTestRunAttachmentContent(project, runId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test run attachments reference.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run.
       */
      getTestRunAttachments(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test run attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test run attachment to be downloaded.
       */
      getTestRunAttachmentZip(project, runId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getBugsLinkedToTestResult(project, runId, testCaseResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "6de20ca2-67de-4faf-97fa-38c5d585eb00", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get code coverage data for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - ID of the build for which code coverage data needs to be fetched.
       * @param {number} flags - Value of flags determine the level of code coverage details to be fetched. Flags are additive. Expected Values are 1 for Modules, 2 for Functions, 4 for BlockData.
       */
      getBuildCodeCoverage(project, buildId, flags) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "77560e8a-4e8c-4d59-894e-a5f264c24444", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.BuildCoverage, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Code Coverage Summary for Build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - ID of the build for which code coverage data needs to be fetched.
       * @param {number} deltaBuildId - Delta Build id (optional)
       */
      getCodeCoverageSummary(project, buildId, deltaBuildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              deltaBuildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "77560e8a-4e8c-4d59-894e-a5f264c24444", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.CodeCoverageSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * http://(tfsserver):8080/tfs/DefaultCollection/_apis/test/CodeCoverage?buildId=10 Request: Json of code coverage summary
       *
       * @param {TestInterfaces.CodeCoverageData} coverageData
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       */
      updateCodeCoverageSummary(coverageData, project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "77560e8a-4e8c-4d59-894e-a5f264c24444", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, coverageData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get code coverage data for a test run
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run for which code coverage data needs to be fetched.
       * @param {number} flags - Value of flags determine the level of code coverage details to be fetched. Flags are additive. Expected Values are 1 for Modules, 2 for Functions, 4 for BlockData.
       */
      getTestRunCodeCoverage(project, runId, flags) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "9629116f-3b89-4ed8-b358-d4694efda160", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.CustomTestFieldDefinition[]} newFields
       * @param {string} project - Project ID or project name
       */
      addCustomFields(newFields, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8ce1923b-f4c7-4e22-b93b-f6284e525ec2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newFields, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {TestInterfaces.CustomTestFieldScope} scopeFilter
       */
      queryCustomFields(project, scopeFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (scopeFilter == null) {
            throw new TypeError("scopeFilter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopeFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8ce1923b-f4c7-4e22-b93b-f6284e525ec2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.ResultsFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryTestResultHistory(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "234616f5-429c-4e7b-9192-affd76731dfd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultHistory, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get iteration for a result
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result that contains the iterations.
       * @param {number} iterationId - Id of the test results Iteration.
       * @param {boolean} includeActionResults - Include result details for each action performed in the test iteration. ActionResults refer to outcome (pass/fail) of test steps that are executed as part of a running a manual test. Including the ActionResults flag gets the outcome of test steps in the actionResults section and test parameters in the parameters section for each test iteration.
       */
      getTestIteration(project, runId, testCaseResultId, iterationId, includeActionResults) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              iterationId
            };
            let queryValues = {
              includeActionResults
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "73eb9074-3446-4c44-8296-2f811950ff8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestIterationDetailsModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get iterations for a result
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result that contains the iterations.
       * @param {boolean} includeActionResults - Include result details for each action performed in the test iteration. ActionResults refer to outcome (pass/fail) of test steps that are executed as part of a running a manual test. Including the ActionResults flag gets the outcome of test steps in the actionResults section and test parameters in the parameters section for each test iteration.
       */
      getTestIterations(project, runId, testCaseResultId, includeActionResults) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              includeActionResults
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "73eb9074-3446-4c44-8296-2f811950ff8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestIterationDetailsModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.LinkedWorkItemsQuery} workItemQuery
       * @param {string} project - Project ID or project name
       */
      getLinkedWorkItemsByQuery(workItemQuery, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a4dcb25b-9878-49ea-abfd-e440bd9b1dcd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemQuery, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run message logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunLogs(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a1e55200-637e-42e9-a7c0-7e5bfdedb1b3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestMessageLogDetails, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test point.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan.
       * @param {number} suiteId - ID of the suite that contains the point.
       * @param {number} pointIds - ID of the test point to get.
       * @param {string} witFields - Comma-separated list of work item field names.
       */
      getPoint(project, planId, suiteId, pointIds, witFields) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId,
              pointIds
            };
            let queryValues = {
              witFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "3bcfd5c8-be62-488e-b1da-b8289ce9299c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPoint, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test points.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan.
       * @param {number} suiteId - ID of the suite that contains the points.
       * @param {string} witFields - Comma-separated list of work item field names.
       * @param {string} configurationId - Get test points for specific configuration.
       * @param {string} testCaseId - Get test points for a specific test case, valid when configurationId is not set.
       * @param {string} testPointIds - Get test points for comma-separated list of test point IDs, valid only when configurationId and testCaseId are not set.
       * @param {boolean} includePointDetails - Include all properties for the test point.
       * @param {number} skip - Number of test points to skip..
       * @param {number} top - Number of test points to return.
       */
      getPoints(project, planId, suiteId, witFields, configurationId, testCaseId, testPointIds, includePointDetails, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              witFields,
              configurationId,
              testCaseId,
              testPointIds,
              includePointDetails,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "3bcfd5c8-be62-488e-b1da-b8289ce9299c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test points.
       *
       * @param {TestInterfaces.PointUpdateModel} pointUpdateModel - Data to update.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan.
       * @param {number} suiteId - ID of the suite that contains the points.
       * @param {string} pointIds - ID of the test point to get. Use a comma-separated list of IDs to update multiple test points.
       */
      updateTestPoints(pointUpdateModel, project, planId, suiteId, pointIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId,
              pointIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "3bcfd5c8-be62-488e-b1da-b8289ce9299c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, pointUpdateModel, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test points using query.
       *
       * @param {TestInterfaces.TestPointsQuery} query - TestPointsQuery to get test points.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Number of test points to skip..
       * @param {number} top - Number of test points to return.
       */
      getPointsByQuery(query, project, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "b4264fd0-a5d1-43e2-82a5-b9c46b7da9ce", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPointsQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForBuild(project, buildId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "efb387b0-10d5-42e7-be40-95e06ee9430f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForRelease(project, releaseId, releaseEnvId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "b834ec7e-35bb-450f-a3c8-802e70ca40dd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultDocument} document
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      publishTestResultDocument(document, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "370ca04b-8eec-4ca8-8ba3-d24dca228791", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, document, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByBuild(project, buildId, publishContext, fields, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "d279d052-c55a-4204-b913-42f733b52958", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} publishContext
       * @param {number} releaseEnvId
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByRelease(project, releaseId, publishContext, releaseEnvId, fields, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              publishContext,
              releaseEnvId,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "ef5ce5d4-a4e5-47ee-804c-354518f8d03f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test Result meta data details for corresponding testcasereferenceId
       *
       * @param {string[]} testReferenceIds - TestCaseReference Ids of the test Result to be queried, comma separated list of valid ids (limit no. of ids 200).
       * @param {string} project - Project ID or project name
       */
      queryTestResultsMetaData(testReferenceIds, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "afa7830e-67a7-4336-8090-2b448ca80295", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testReferenceIds, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test result retention settings
       *
       * @param {string} project - Project ID or project name
       */
      getResultRetentionSettings(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a3206d9e-fa8d-42d3-88cb-f75c51e69cde", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.ResultRetentionSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test result retention settings
       *
       * @param {TestInterfaces.ResultRetentionSettings} retentionSettings - Test result retention settings details to be updated
       * @param {string} project - Project ID or project name
       */
      updateResultRetentionSettings(retentionSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a3206d9e-fa8d-42d3-88cb-f75c51e69cde", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, retentionSettings, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.ResultRetentionSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add test results to a test run.
       *
       * @param {TestInterfaces.TestCaseResult[]} results - List of test results to add.
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID into which test results to add.
       */
      addTestResultsToTestRun(results, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, results, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test result for a test run.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID of a test result to fetch.
       * @param {number} testCaseResultId - Test result ID.
       * @param {TestInterfaces.ResultDetails} detailsToInclude - Details to include with test results. Default is None. Other values are Iterations, WorkItems and SubResults.
       */
      getTestResultById(project, runId, testCaseResultId, detailsToInclude) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              detailsToInclude
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test results for a test run.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID of test results to fetch.
       * @param {TestInterfaces.ResultDetails} detailsToInclude - Details to include with test results. Default is None. Other values are Iterations and WorkItems.
       * @param {number} skip - Number of test results to skip from beginning.
       * @param {number} top - Number of test results to return. Maximum is 1000 when detailsToInclude is None and 200 otherwise.
       * @param {TestInterfaces.TestOutcome[]} outcomes - Comma separated list of test outcomes to filter test results.
       */
      getTestResults(project, runId, detailsToInclude, skip, top, outcomes) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              detailsToInclude,
              "$skip": skip,
              "$top": top,
              outcomes: outcomes && outcomes.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test results in a test run.
       *
       * @param {TestInterfaces.TestCaseResult[]} results - List of test results to update.
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID whose test results to update.
       */
      updateTestResults(results, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, results, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This API will return results by Ids with fields specified/trend for particular automated test method. We are still improving this API and have not finalized proper signature and contract.
       *
       * @param {TestInterfaces.TestResultsQuery} query
       * @param {string} project - Project ID or project name
       */
      getTestResultsByQuery(query, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "6711da49-8e6f-4d35-9f73-cef7a3c81a5b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultsQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {TestInterfaces.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByBuild(project, buildId, publishContext, outcomes, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "3c191b88-615b-4be2-b7d9-5ff9141e91d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvid
       * @param {string} publishContext
       * @param {TestInterfaces.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByRelease(project, releaseId, releaseEnvid, publishContext, outcomes, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvid,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "ce01820b-83f3-4c15-a583-697a43292c4e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {TestInterfaces.BuildReference} buildToCompare
       */
      queryTestResultsReportForBuild(project, buildId, publishContext, includeFailureDetails, buildToCompare) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              includeFailureDetails,
              buildToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "000ef77b-fea2-498d-a10d-ad1a037f559f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {TestInterfaces.ReleaseReference} releaseToCompare
       */
      queryTestResultsReportForRelease(project, releaseId, releaseEnvId, publishContext, includeFailureDetails, releaseToCompare) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              includeFailureDetails,
              releaseToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "85765790-ac68-494e-b268-af36c3929744", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.ReleaseReference[]} releases
       * @param {string} project - Project ID or project name
       */
      queryTestResultsSummaryForReleases(releases, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "85765790-ac68-494e-b268-af36c3929744", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releases, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultSummary, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultsContext} resultsContext
       * @param {string} project - Project ID or project name
       * @param {number[]} workItemIds
       */
      queryTestSummaryByRequirement(resultsContext, project, workItemIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemIds: workItemIds && workItemIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "cd08294e-308d-4460-a46e-4cfdefba0b4b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, resultsContext, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSummaryForWorkItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForBuild(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "fbc82a85-0786-4442-88bb-eb0fda6b01b0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForRelease(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "dd178e93-d8dd-4887-9635-d6b9560b7b6e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run statistics , used when we want to get summary of a run by outcome.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunStatistics(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "0a42c424-d764-4a16-a2d5-5c85f87d0ae8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRunStatistic, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create new test run.
       *
       * @param {TestInterfaces.RunCreateModel} testRun - Run details RunCreateModel
       * @param {string} project - Project ID or project name
       */
      createTestRun(testRun, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testRun, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test run by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to delete.
       */
      deleteTestRun(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test run by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       * @param {boolean} includeDetails - Default value is true. It includes details like run statistics, release, build, test environment, post process state, and more.
       */
      getTestRunById(project, runId, includeDetails) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              includeDetails
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test runs.
       *
       * @param {string} project - Project ID or project name
       * @param {string} buildUri - URI of the build that the runs used.
       * @param {string} owner - Team foundation ID of the owner of the runs.
       * @param {string} tmiRunId
       * @param {number} planId - ID of the test plan that the runs are a part of.
       * @param {boolean} includeRunDetails - If true, include all the properties of the runs.
       * @param {boolean} automated - If true, only returns automated runs.
       * @param {number} skip - Number of test runs to skip.
       * @param {number} top - Number of test runs to return.
       */
      getTestRuns(project, buildUri, owner, tmiRunId, planId, includeRunDetails, automated, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildUri,
              owner,
              tmiRunId,
              planId,
              includeRunDetails,
              automated,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query Test Runs based on filters. Mandatory fields are minLastUpdatedDate and maxLastUpdatedDate.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} minLastUpdatedDate - Minimum Last Modified Date of run to be queried (Mandatory).
       * @param {Date} maxLastUpdatedDate - Maximum Last Modified Date of run to be queried (Mandatory, difference between min and max date can be atmost 7 days).
       * @param {TestInterfaces.TestRunState} state - Current state of the Runs to be queried.
       * @param {number[]} planIds - Plan Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {boolean} isAutomated - Automation type of the Runs to be queried.
       * @param {TestInterfaces.TestRunPublishContext} publishContext - PublishContext of the Runs to be queried.
       * @param {number[]} buildIds - Build Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} buildDefIds - Build Definition Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {string} branchName - Source Branch name of the Runs to be queried.
       * @param {number[]} releaseIds - Release Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} releaseDefIds - Release Definition Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} releaseEnvIds - Release Environment Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} releaseEnvDefIds - Release Environment Definition Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {string} runTitle - Run Title of the Runs to be queried.
       * @param {number} top - Number of runs to be queried. Limit is 100
       * @param {string} continuationToken - continuationToken received from previous batch or null for first batch. It is not supposed to be created (or altered, if received from last batch) by user.
       */
      queryTestRuns(project, minLastUpdatedDate, maxLastUpdatedDate, state, planIds, isAutomated, publishContext, buildIds, buildDefIds, branchName, releaseIds, releaseDefIds, releaseEnvIds, releaseEnvDefIds, runTitle, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (minLastUpdatedDate == null) {
            throw new TypeError("minLastUpdatedDate can not be null or undefined");
          }
          if (maxLastUpdatedDate == null) {
            throw new TypeError("maxLastUpdatedDate can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              minLastUpdatedDate,
              maxLastUpdatedDate,
              state,
              planIds: planIds && planIds.join(","),
              isAutomated,
              publishContext,
              buildIds: buildIds && buildIds.join(","),
              buildDefIds: buildDefIds && buildDefIds.join(","),
              branchName,
              releaseIds: releaseIds && releaseIds.join(","),
              releaseDefIds: releaseDefIds && releaseDefIds.join(","),
              releaseEnvIds: releaseEnvIds && releaseEnvIds.join(","),
              releaseEnvDefIds: releaseEnvDefIds && releaseEnvDefIds.join(","),
              runTitle,
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test run by its ID.
       *
       * @param {TestInterfaces.RunUpdateModel} runUpdateModel - Run details RunUpdateModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to update.
       */
      updateTestRun(runUpdateModel, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, runUpdateModel, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a test session
       *
       * @param {TestInterfaces.TestSession} testSession - Test session details for creation
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      createTestSession(testSession, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "1500b4b4-6c69-4ca6-9b18-35e9e97fe2ac", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSession, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSession, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test sessions
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {number} period - Period in days from now, for which test sessions are fetched.
       * @param {boolean} allSessions - If false, returns test sessions for current user. Otherwise, it returns test sessions for all users
       * @param {boolean} includeAllProperties - If true, it returns all properties of the test sessions. Otherwise, it returns the skinny version.
       * @param {TestInterfaces.TestSessionSource} source - Source of the test session.
       * @param {boolean} includeOnlyCompletedSessions - If true, it returns test sessions in completed state. Otherwise, it returns test sessions for all states
       */
      getTestSessions(teamContext, period, allSessions, includeAllProperties, source, includeOnlyCompletedSessions) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              period,
              allSessions,
              includeAllProperties,
              source,
              includeOnlyCompletedSessions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "1500b4b4-6c69-4ca6-9b18-35e9e97fe2ac", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSession, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test session
       *
       * @param {TestInterfaces.TestSession} testSession - Test session details for update
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTestSession(testSession, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "1500b4b4-6c69-4ca6-9b18-35e9e97fe2ac", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testSession, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSession, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} sharedParameterId
       */
      deleteSharedParameter(project, sharedParameterId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sharedParameterId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8300eeca-0f8c-4eff-a089-d2dda409c41f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} sharedStepId
       */
      deleteSharedStep(project, sharedStepId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sharedStepId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "fabb3cc9-e3f8-40b7-8b62-24cc4b73fccf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add test cases to suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the test suite to which the test cases must be added.
       * @param {string} testCaseIds - IDs of the test cases to add to the suite. Ids are specified in comma separated format.
       */
      addTestCasesToSuite(project, planId, suiteId, testCaseIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific test case in a test suite with test case id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the suite that contains the test case.
       * @param {number} testCaseIds - ID of the test case to get.
       */
      getTestCaseById(project, planId, suiteId, testCaseIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all test cases in a suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the suite to get.
       */
      getTestCases(project, planId, suiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * The test points associated with the test cases are removed from the test suite. The test case work item is not deleted from the system. See test cases resource to delete a test case permanently.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the suite to get.
       * @param {string} testCaseIds - IDs of the test cases to remove from the suite.
       */
      removeTestCasesFromSuiteUrl(project, planId, suiteId, testCaseIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the properties of the test case association in a suite.
       *
       * @param {TestInterfaces.SuiteTestCaseUpdateModel} suiteTestCaseUpdateModel - Model for updation of the properties of test case suite association.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the test suite to which the test cases must be added.
       * @param {string} testCaseIds - IDs of the test cases to add to the suite. Ids are specified in comma separated format.
       */
      updateSuiteTestCases(suiteTestCaseUpdateModel, project, planId, suiteId, testCaseIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, suiteTestCaseUpdateModel, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test case.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testCaseId - Id of test case to delete.
       */
      deleteTestCase(project, testCaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testCaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4d472e0f-e32c-4ef8-adf4-a4078772889c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get history of a test method using TestHistoryQuery
       *
       * @param {TestInterfaces.TestHistoryQuery} filter - TestHistoryQuery to get history
       * @param {string} project - Project ID or project name
       */
      queryTestHistory(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "929fd86c-3e38-4d8c-b4b6-90df256e5971", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestHistoryQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestSettings} testSettings
       * @param {string} project - Project ID or project name
       */
      createTestSettings(testSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8133ce14-962f-42af-a5f9-6aa9defcb9c8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      deleteTestSettings(project, testSettingsId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8133ce14-962f-42af-a5f9-6aa9defcb9c8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      getTestSettingsById(project, testSettingsId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8133ce14-962f-42af-a5f9-6aa9defcb9c8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.WorkItemToTestLinks} workItemToTestLinks
       * @param {string} project - Project ID or project name
       */
      addWorkItemToTestLinks(workItemToTestLinks, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "371b1655-ce05-412e-a113-64cc77bb78d2", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemToTestLinks, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.WorkItemToTestLinks, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       * @param {number} workItemId
       */
      deleteTestMethodToWorkItemLink(project, testName, workItemId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          if (workItemId == null) {
            throw new TypeError("workItemId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "7b0bdee3-a354-47f9-a42c-89018d7808d5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       */
      queryTestMethodLinkedWorkItems(project, testName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "7b0bdee3-a354-47f9-a42c-89018d7808d5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestToWorkItemLinks, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} workItemCategory
       * @param {string} automatedTestName
       * @param {number} testCaseId
       * @param {Date} maxCompleteDate
       * @param {number} days
       * @param {number} workItemCount
       */
      queryTestResultWorkItems(project, workItemCategory, automatedTestName, testCaseId, maxCompleteDate, days, workItemCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (workItemCategory == null) {
            throw new TypeError("workItemCategory can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemCategory,
              automatedTestName,
              testCaseId,
              maxCompleteDate,
              days,
              "$workItemCount": workItemCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "926ff5dc-137f-45f0-bd51-9412fa9810ce", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TestApi = TestApi;
    TestApi.RESOURCE_AREA_ID = "c2aa639c-3ccc-4740-b3b6-ce2a1e1d984e";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/TestPlanInterfaces.js
var require_TestPlanInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/TestPlanInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.UserFriendlyTestOutcome = exports2.TestSuiteType = exports2.TestPlansLibraryWorkItemFilterMode = exports2.TestPlansLibraryQuery = exports2.TestEntityTypes = exports2.SuiteExpand = exports2.SuiteEntryTypes = exports2.ResultState = exports2.PointState = exports2.Outcome = exports2.LibraryTestCasesDataReturnCode = exports2.LastResolutionState = exports2.FailureType = exports2.ExcludeFlags = void 0;
    var TFS_TestManagement_Contracts = require_TestInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var ExcludeFlags;
    (function(ExcludeFlags2) {
      ExcludeFlags2[ExcludeFlags2["None"] = 0] = "None";
      ExcludeFlags2[ExcludeFlags2["PointAssignments"] = 1] = "PointAssignments";
      ExcludeFlags2[ExcludeFlags2["ExtraInformation"] = 2] = "ExtraInformation";
    })(ExcludeFlags = exports2.ExcludeFlags || (exports2.ExcludeFlags = {}));
    var FailureType;
    (function(FailureType2) {
      FailureType2[FailureType2["None"] = 0] = "None";
      FailureType2[FailureType2["Regression"] = 1] = "Regression";
      FailureType2[FailureType2["New_Issue"] = 2] = "New_Issue";
      FailureType2[FailureType2["Known_Issue"] = 3] = "Known_Issue";
      FailureType2[FailureType2["Unknown"] = 4] = "Unknown";
      FailureType2[FailureType2["Null_Value"] = 5] = "Null_Value";
      FailureType2[FailureType2["MaxValue"] = 5] = "MaxValue";
    })(FailureType = exports2.FailureType || (exports2.FailureType = {}));
    var LastResolutionState;
    (function(LastResolutionState2) {
      LastResolutionState2[LastResolutionState2["None"] = 0] = "None";
      LastResolutionState2[LastResolutionState2["NeedsInvestigation"] = 1] = "NeedsInvestigation";
      LastResolutionState2[LastResolutionState2["TestIssue"] = 2] = "TestIssue";
      LastResolutionState2[LastResolutionState2["ProductIssue"] = 3] = "ProductIssue";
      LastResolutionState2[LastResolutionState2["ConfigurationIssue"] = 4] = "ConfigurationIssue";
      LastResolutionState2[LastResolutionState2["NullValue"] = 5] = "NullValue";
      LastResolutionState2[LastResolutionState2["MaxValue"] = 5] = "MaxValue";
    })(LastResolutionState = exports2.LastResolutionState || (exports2.LastResolutionState = {}));
    var LibraryTestCasesDataReturnCode;
    (function(LibraryTestCasesDataReturnCode2) {
      LibraryTestCasesDataReturnCode2[LibraryTestCasesDataReturnCode2["Success"] = 0] = "Success";
      LibraryTestCasesDataReturnCode2[LibraryTestCasesDataReturnCode2["Error"] = 1] = "Error";
    })(LibraryTestCasesDataReturnCode = exports2.LibraryTestCasesDataReturnCode || (exports2.LibraryTestCasesDataReturnCode = {}));
    var Outcome;
    (function(Outcome2) {
      Outcome2[Outcome2["Unspecified"] = 0] = "Unspecified";
      Outcome2[Outcome2["None"] = 1] = "None";
      Outcome2[Outcome2["Passed"] = 2] = "Passed";
      Outcome2[Outcome2["Failed"] = 3] = "Failed";
      Outcome2[Outcome2["Inconclusive"] = 4] = "Inconclusive";
      Outcome2[Outcome2["Timeout"] = 5] = "Timeout";
      Outcome2[Outcome2["Aborted"] = 6] = "Aborted";
      Outcome2[Outcome2["Blocked"] = 7] = "Blocked";
      Outcome2[Outcome2["NotExecuted"] = 8] = "NotExecuted";
      Outcome2[Outcome2["Warning"] = 9] = "Warning";
      Outcome2[Outcome2["Error"] = 10] = "Error";
      Outcome2[Outcome2["NotApplicable"] = 11] = "NotApplicable";
      Outcome2[Outcome2["Paused"] = 12] = "Paused";
      Outcome2[Outcome2["InProgress"] = 13] = "InProgress";
      Outcome2[Outcome2["NotImpacted"] = 14] = "NotImpacted";
      Outcome2[Outcome2["MaxValue"] = 14] = "MaxValue";
    })(Outcome = exports2.Outcome || (exports2.Outcome = {}));
    var PointState;
    (function(PointState2) {
      PointState2[PointState2["None"] = 0] = "None";
      PointState2[PointState2["Ready"] = 1] = "Ready";
      PointState2[PointState2["Completed"] = 2] = "Completed";
      PointState2[PointState2["NotReady"] = 3] = "NotReady";
      PointState2[PointState2["InProgress"] = 4] = "InProgress";
      PointState2[PointState2["MaxValue"] = 4] = "MaxValue";
    })(PointState = exports2.PointState || (exports2.PointState = {}));
    var ResultState;
    (function(ResultState2) {
      ResultState2[ResultState2["Unspecified"] = 0] = "Unspecified";
      ResultState2[ResultState2["Pending"] = 1] = "Pending";
      ResultState2[ResultState2["Queued"] = 2] = "Queued";
      ResultState2[ResultState2["InProgress"] = 3] = "InProgress";
      ResultState2[ResultState2["Paused"] = 4] = "Paused";
      ResultState2[ResultState2["Completed"] = 5] = "Completed";
      ResultState2[ResultState2["MaxValue"] = 5] = "MaxValue";
    })(ResultState = exports2.ResultState || (exports2.ResultState = {}));
    var SuiteEntryTypes;
    (function(SuiteEntryTypes2) {
      SuiteEntryTypes2[SuiteEntryTypes2["TestCase"] = 0] = "TestCase";
      SuiteEntryTypes2[SuiteEntryTypes2["Suite"] = 1] = "Suite";
    })(SuiteEntryTypes = exports2.SuiteEntryTypes || (exports2.SuiteEntryTypes = {}));
    var SuiteExpand;
    (function(SuiteExpand2) {
      SuiteExpand2[SuiteExpand2["None"] = 0] = "None";
      SuiteExpand2[SuiteExpand2["Children"] = 1] = "Children";
      SuiteExpand2[SuiteExpand2["DefaultTesters"] = 2] = "DefaultTesters";
    })(SuiteExpand = exports2.SuiteExpand || (exports2.SuiteExpand = {}));
    var TestEntityTypes;
    (function(TestEntityTypes2) {
      TestEntityTypes2[TestEntityTypes2["TestCase"] = 0] = "TestCase";
      TestEntityTypes2[TestEntityTypes2["TestPoint"] = 1] = "TestPoint";
    })(TestEntityTypes = exports2.TestEntityTypes || (exports2.TestEntityTypes = {}));
    var TestPlansLibraryQuery;
    (function(TestPlansLibraryQuery2) {
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["None"] = 0] = "None";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["AllTestCases"] = 1] = "AllTestCases";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["TestCasesWithActiveBugs"] = 2] = "TestCasesWithActiveBugs";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["TestCasesNotLinkedToRequirements"] = 3] = "TestCasesNotLinkedToRequirements";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["TestCasesLinkedToRequirements"] = 4] = "TestCasesLinkedToRequirements";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["AllSharedSteps"] = 11] = "AllSharedSteps";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["SharedStepsNotLinkedToRequirement"] = 12] = "SharedStepsNotLinkedToRequirement";
    })(TestPlansLibraryQuery = exports2.TestPlansLibraryQuery || (exports2.TestPlansLibraryQuery = {}));
    var TestPlansLibraryWorkItemFilterMode;
    (function(TestPlansLibraryWorkItemFilterMode2) {
      TestPlansLibraryWorkItemFilterMode2[TestPlansLibraryWorkItemFilterMode2["Or"] = 0] = "Or";
      TestPlansLibraryWorkItemFilterMode2[TestPlansLibraryWorkItemFilterMode2["And"] = 1] = "And";
    })(TestPlansLibraryWorkItemFilterMode = exports2.TestPlansLibraryWorkItemFilterMode || (exports2.TestPlansLibraryWorkItemFilterMode = {}));
    var TestSuiteType;
    (function(TestSuiteType2) {
      TestSuiteType2[TestSuiteType2["None"] = 0] = "None";
      TestSuiteType2[TestSuiteType2["DynamicTestSuite"] = 1] = "DynamicTestSuite";
      TestSuiteType2[TestSuiteType2["StaticTestSuite"] = 2] = "StaticTestSuite";
      TestSuiteType2[TestSuiteType2["RequirementTestSuite"] = 3] = "RequirementTestSuite";
    })(TestSuiteType = exports2.TestSuiteType || (exports2.TestSuiteType = {}));
    var UserFriendlyTestOutcome;
    (function(UserFriendlyTestOutcome2) {
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["InProgress"] = 0] = "InProgress";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Blocked"] = 1] = "Blocked";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Failed"] = 2] = "Failed";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Passed"] = 3] = "Passed";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Ready"] = 4] = "Ready";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["NotApplicable"] = 5] = "NotApplicable";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Paused"] = 6] = "Paused";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Timeout"] = 7] = "Timeout";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Warning"] = 8] = "Warning";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Error"] = 9] = "Error";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["NotExecuted"] = 10] = "NotExecuted";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Inconclusive"] = 11] = "Inconclusive";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Aborted"] = 12] = "Aborted";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["None"] = 13] = "None";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["NotImpacted"] = 14] = "NotImpacted";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Unspecified"] = 15] = "Unspecified";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["MaxValue"] = 15] = "MaxValue";
    })(UserFriendlyTestOutcome = exports2.UserFriendlyTestOutcome || (exports2.UserFriendlyTestOutcome = {}));
    exports2.TypeInfo = {
      CloneOperationCommonResponse: {},
      CloneTestCaseOperationInformation: {},
      CloneTestPlanOperationInformation: {},
      CloneTestPlanParams: {},
      CloneTestSuiteOperationInformation: {},
      DestinationTestPlanCloneParams: {},
      ExcludeFlags: {
        enumValues: {
          "none": 0,
          "pointAssignments": 1,
          "extraInformation": 2
        }
      },
      FailureType: {
        enumValues: {
          "none": 0,
          "regression": 1,
          "new_Issue": 2,
          "known_Issue": 3,
          "unknown": 4,
          "null_Value": 5,
          "maxValue": 5
        }
      },
      LastResolutionState: {
        enumValues: {
          "none": 0,
          "needsInvestigation": 1,
          "testIssue": 2,
          "productIssue": 3,
          "configurationIssue": 4,
          "nullValue": 5,
          "maxValue": 5
        }
      },
      LibraryTestCasesDataReturnCode: {
        enumValues: {
          "success": 0,
          "error": 1
        }
      },
      LibraryWorkItemsData: {},
      LibraryWorkItemsDataProviderRequest: {},
      Outcome: {
        enumValues: {
          "unspecified": 0,
          "none": 1,
          "passed": 2,
          "failed": 3,
          "inconclusive": 4,
          "timeout": 5,
          "aborted": 6,
          "blocked": 7,
          "notExecuted": 8,
          "warning": 9,
          "error": 10,
          "notApplicable": 11,
          "paused": 12,
          "inProgress": 13,
          "notImpacted": 14,
          "maxValue": 14
        }
      },
      PointState: {
        enumValues: {
          "none": 0,
          "ready": 1,
          "completed": 2,
          "notReady": 3,
          "inProgress": 4,
          "maxValue": 4
        }
      },
      Results: {},
      ResultState: {
        enumValues: {
          "unspecified": 0,
          "pending": 1,
          "queued": 2,
          "inProgress": 3,
          "paused": 4,
          "completed": 5,
          "maxValue": 5
        }
      },
      SourceTestplanResponse: {},
      SourceTestSuiteResponse: {},
      SuiteEntry: {},
      SuiteEntryTypes: {
        enumValues: {
          "testCase": 0,
          "suite": 1
        }
      },
      SuiteEntryUpdateParams: {},
      SuiteExpand: {
        enumValues: {
          "none": 0,
          "children": 1,
          "defaultTesters": 2
        }
      },
      TestCase: {},
      TestCaseAssociatedResult: {},
      TestCaseAssociatedResultExtended: {},
      TestCaseResultsData: {},
      TestCaseResultsDataExtended: {},
      TestConfiguration: {},
      TestConfigurationCreateUpdateParameters: {},
      TestEntityTypes: {
        enumValues: {
          "testCase": 0,
          "testPoint": 1
        }
      },
      TestPlan: {},
      TestPlanCreateParams: {},
      TestPlanDetailedReference: {},
      TestPlansHubRefreshData: {},
      TestPlansLibraryQuery: {
        enumValues: {
          "none": 0,
          "allTestCases": 1,
          "testCasesWithActiveBugs": 2,
          "testCasesNotLinkedToRequirements": 3,
          "testCasesLinkedToRequirements": 4,
          "allSharedSteps": 11,
          "sharedStepsNotLinkedToRequirement": 12
        }
      },
      TestPlansLibraryWorkItemFilter: {},
      TestPlansLibraryWorkItemFilterMode: {
        enumValues: {
          "or": 0,
          "and": 1
        }
      },
      TestPlanUpdateParams: {},
      TestPoint: {},
      TestPointResults: {},
      TestPointUpdateParams: {},
      TestSuite: {},
      TestSuiteCreateParams: {},
      TestSuiteReferenceWithProject: {},
      TestSuiteType: {
        enumValues: {
          "none": 0,
          "dynamicTestSuite": 1,
          "staticTestSuite": 2,
          "requirementTestSuite": 3
        }
      },
      TestVariable: {},
      UserFriendlyTestOutcome: {
        enumValues: {
          "inProgress": 0,
          "blocked": 1,
          "failed": 2,
          "passed": 3,
          "ready": 4,
          "notApplicable": 5,
          "paused": 6,
          "timeout": 7,
          "warning": 8,
          "error": 9,
          "notExecuted": 10,
          "inconclusive": 11,
          "aborted": 12,
          "none": 13,
          "notImpacted": 14,
          "unspecified": 15,
          "maxValue": 15
        }
      }
    };
    exports2.TypeInfo.CloneOperationCommonResponse.fields = {
      completionDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      state: {
        enumType: TFS_TestManagement_Contracts.TypeInfo.CloneOperationState
      }
    };
    exports2.TypeInfo.CloneTestCaseOperationInformation.fields = {
      cloneOperationResponse: {
        typeInfo: exports2.TypeInfo.CloneOperationCommonResponse
      },
      destinationTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      },
      sourceTestSuite: {
        typeInfo: exports2.TypeInfo.SourceTestSuiteResponse
      }
    };
    exports2.TypeInfo.CloneTestPlanOperationInformation.fields = {
      cloneOperationResponse: {
        typeInfo: exports2.TypeInfo.CloneOperationCommonResponse
      },
      destinationTestPlan: {
        typeInfo: exports2.TypeInfo.TestPlan
      },
      sourceTestPlan: {
        typeInfo: exports2.TypeInfo.SourceTestplanResponse
      }
    };
    exports2.TypeInfo.CloneTestPlanParams.fields = {
      destinationTestPlan: {
        typeInfo: exports2.TypeInfo.DestinationTestPlanCloneParams
      }
    };
    exports2.TypeInfo.CloneTestSuiteOperationInformation.fields = {
      clonedTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      },
      cloneOperationResponse: {
        typeInfo: exports2.TypeInfo.CloneOperationCommonResponse
      },
      destinationTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      },
      sourceTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      }
    };
    exports2.TypeInfo.DestinationTestPlanCloneParams.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.LibraryWorkItemsData.fields = {
      returnCode: {
        enumType: exports2.TypeInfo.LibraryTestCasesDataReturnCode
      }
    };
    exports2.TypeInfo.LibraryWorkItemsDataProviderRequest.fields = {
      filterValues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPlansLibraryWorkItemFilter
      },
      libraryQueryType: {
        enumType: exports2.TypeInfo.TestPlansLibraryQuery
      }
    };
    exports2.TypeInfo.Results.fields = {
      outcome: {
        enumType: exports2.TypeInfo.Outcome
      }
    };
    exports2.TypeInfo.SourceTestplanResponse.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.SourceTestSuiteResponse.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.SuiteEntry.fields = {
      suiteEntryType: {
        enumType: exports2.TypeInfo.SuiteEntryTypes
      }
    };
    exports2.TypeInfo.SuiteEntryUpdateParams.fields = {
      suiteEntryType: {
        enumType: exports2.TypeInfo.SuiteEntryTypes
      }
    };
    exports2.TypeInfo.TestCase.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.TestCaseAssociatedResult.fields = {
      completedDate: {
        isDate: true
      },
      outcome: {
        enumType: exports2.TypeInfo.UserFriendlyTestOutcome
      }
    };
    exports2.TypeInfo.TestCaseAssociatedResultExtended.fields = {
      completedDate: {
        isDate: true
      },
      outcome: {
        enumType: exports2.TypeInfo.UserFriendlyTestOutcome
      }
    };
    exports2.TypeInfo.TestCaseResultsData.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseAssociatedResult
      }
    };
    exports2.TypeInfo.TestCaseResultsDataExtended.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseAssociatedResultExtended
      }
    };
    exports2.TypeInfo.TestConfiguration.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      state: {
        enumType: TFS_TestManagement_Contracts.TypeInfo.TestConfigurationState
      }
    };
    exports2.TypeInfo.TestConfigurationCreateUpdateParameters.fields = {
      state: {
        enumType: TFS_TestManagement_Contracts.TypeInfo.TestConfigurationState
      }
    };
    exports2.TypeInfo.TestPlan.fields = {
      endDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      startDate: {
        isDate: true
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlanCreateParams.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlanDetailedReference.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlansHubRefreshData.fields = {
      testCases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCase
      },
      testPlan: {
        typeInfo: exports2.TypeInfo.TestPlanDetailedReference
      },
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPoint
      },
      testSuites: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      }
    };
    exports2.TypeInfo.TestPlansLibraryWorkItemFilter.fields = {
      filterMode: {
        enumType: exports2.TypeInfo.TestPlansLibraryWorkItemFilterMode
      }
    };
    exports2.TypeInfo.TestPlanUpdateParams.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPoint.fields = {
      lastResetToActive: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      results: {
        typeInfo: exports2.TypeInfo.TestPointResults
      }
    };
    exports2.TypeInfo.TestPointResults.fields = {
      failureType: {
        enumType: exports2.TypeInfo.FailureType
      },
      lastResolutionState: {
        enumType: exports2.TypeInfo.LastResolutionState
      },
      lastResultDetails: {
        typeInfo: TFS_TestManagement_Contracts.TypeInfo.LastResultDetails
      },
      lastResultState: {
        enumType: exports2.TypeInfo.ResultState
      },
      outcome: {
        enumType: exports2.TypeInfo.Outcome
      },
      state: {
        enumType: exports2.TypeInfo.PointState
      }
    };
    exports2.TypeInfo.TestPointUpdateParams.fields = {
      results: {
        typeInfo: exports2.TypeInfo.Results
      }
    };
    exports2.TypeInfo.TestSuite.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      },
      lastPopulatedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      suiteType: {
        enumType: exports2.TypeInfo.TestSuiteType
      }
    };
    exports2.TypeInfo.TestSuiteCreateParams.fields = {
      suiteType: {
        enumType: exports2.TypeInfo.TestSuiteType
      }
    };
    exports2.TypeInfo.TestSuiteReferenceWithProject.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.TestVariable.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/TestPlanApi.js
var require_TestPlanApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/TestPlanApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestPlanApi = void 0;
    var basem = require_ClientApiBases();
    var TestPlanInterfaces = require_TestPlanInterfaces();
    var TestPlanApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-TestPlan-api", options2);
      }
      /**
       * Create a test configuration.
       *
       * @param {TestPlanInterfaces.TestConfigurationCreateUpdateParameters} testConfigurationCreateUpdateParameters - TestConfigurationCreateUpdateParameters
       * @param {string} project - Project ID or project name
       */
      createTestConfiguration(testConfigurationCreateUpdateParameters, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testConfigurationCreateUpdateParameters, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test configuration by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testConfiguartionId - ID of the test configuration to delete.
       */
      deleteTestConfguration(project, testConfiguartionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testConfiguartionId == null) {
            throw new TypeError("testConfiguartionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testConfiguartionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test configuration
       *
       * @param {string} project - Project ID or project name
       * @param {number} testConfigurationId - ID of the test configuration to get.
       */
      getTestConfigurationById(project, testConfigurationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testConfigurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test configurations.
       *
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken - If the list of configurations returned is not complete, a continuation token to query next batch of configurations is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test configurations.
       */
      getTestConfigurations(project, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test configuration by its ID.
       *
       * @param {TestPlanInterfaces.TestConfigurationCreateUpdateParameters} testConfigurationCreateUpdateParameters - TestConfigurationCreateUpdateParameters
       * @param {string} project - Project ID or project name
       * @param {number} testConfiguartionId - ID of the test configuration to update.
       */
      updateTestConfiguration(testConfigurationCreateUpdateParameters, project, testConfiguartionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testConfiguartionId == null) {
            throw new TypeError("testConfiguartionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testConfiguartionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testConfigurationCreateUpdateParameters, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} planId
       * @param {string} states
       * @param {TestPlanInterfaces.UserFriendlyTestOutcome} outcome
       * @param {string} configurations
       * @param {string} testers
       * @param {string} assignedTo
       * @param {TestPlanInterfaces.TestEntityTypes} entity
       */
      getTestEntityCountByPlanId(project, planId, states, outcome, configurations, testers, assignedTo, entity) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            let queryValues = {
              states,
              outcome,
              configurations,
              testers,
              assignedTo,
              entity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "300578da-7b40-4c1e-9542-7aed6029e504", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a test plan.
       *
       * @param {TestPlanInterfaces.TestPlanCreateParams} testPlanCreateParams - A testPlanCreateParams object.TestPlanCreateParams
       * @param {string} project - Project ID or project name
       */
      createTestPlan(testPlanCreateParams, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testPlanCreateParams, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test plan.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to be deleted.
       */
      deleteTestPlan(project, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test plan by Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to get.
       */
      getTestPlanById(project, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test plans
       *
       * @param {string} project - Project ID or project name
       * @param {string} owner - Filter for test plan by owner ID or name
       * @param {string} continuationToken - If the list of plans returned is not complete, a continuation token to query next batch of plans is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test plans.
       * @param {boolean} includePlanDetails - Get all properties of the test plan
       * @param {boolean} filterActivePlans - Get just the active plans
       */
      getTestPlans(project, owner, continuationToken, includePlanDetails, filterActivePlans) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              owner,
              continuationToken,
              includePlanDetails,
              filterActivePlans
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test plan.
       *
       * @param {TestPlanInterfaces.TestPlanUpdateParams} testPlanUpdateParams - A testPlanUpdateParams object.TestPlanUpdateParams
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to be updated.
       */
      updateTestPlan(testPlanUpdateParams, project, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testPlanUpdateParams, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test suite entries in the test suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} suiteId - Id of the parent suite.
       * @param {TestPlanInterfaces.SuiteEntryTypes} suiteEntryType
       */
      getSuiteEntries(project, suiteId, suiteEntryType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              suiteId
            };
            let queryValues = {
              suiteEntryType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "d6733edf-72f1-4252-925b-c560dfe9b75a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.SuiteEntry, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reorder test suite entries in the test suite.
       *
       * @param {TestPlanInterfaces.SuiteEntryUpdateParams[]} suiteEntries - List of SuiteEntry to reorder.
       * @param {string} project - Project ID or project name
       * @param {number} suiteId - Id of the parent test suite.
       */
      reorderSuiteEntries(suiteEntries, project, suiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "d6733edf-72f1-4252-925b-c560dfe9b75a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, suiteEntries, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.SuiteEntry, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create bulk requirement based test suites.
       *
       * @param {TestPlanInterfaces.TestSuiteCreateParams[]} testSuiteCreateParams - Parameters for suite creation
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan where requirement based suites need to be created.
       * @param {number} parentSuiteId - ID of the parent suite under which requirement based suites will be created
       */
      createBulkTestSuites(testSuiteCreateParams, project, planId, parentSuiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              parentSuiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1e58fbe6-1761-43ce-97f6-5492ec9d438e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSuiteCreateParams, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create test suite.
       *
       * @param {TestPlanInterfaces.TestSuiteCreateParams} testSuiteCreateParams - Parameters for suite creation
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       */
      createTestSuite(testSuiteCreateParams, project, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSuiteCreateParams, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete test suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the test suite to delete.
       */
      deleteTestSuite(project, planId, suiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test suite by suite id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the suite to get.
       * @param {TestPlanInterfaces.SuiteExpand} expand - Include the children suites and testers details
       */
      getTestSuiteById(project, planId, suiteId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test suites for plan.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which suites are requested.
       * @param {TestPlanInterfaces.SuiteExpand} expand - Include the children suites and testers details.
       * @param {string} continuationToken - If the list of suites returned is not complete, a continuation token to query next batch of suites is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test suites.
       * @param {boolean} asTreeView - If the suites returned should be in a tree structure.
       */
      getTestSuitesForPlan(project, planId, expand, continuationToken, asTreeView) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            let queryValues = {
              expand,
              continuationToken,
              asTreeView
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test suite.
       *
       * @param {TestPlanInterfaces.TestSuiteUpdateParams} testSuiteUpdateParams - Parameters for suite updation
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the parent suite.
       */
      updateTestSuite(testSuiteUpdateParams, project, planId, suiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testSuiteUpdateParams, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Find the list of all test suites in which a given test case is present. This is helpful if you need to find out which test suites are using a test case, when you need to make changes to a test case.
       *
       * @param {number} testCaseId - ID of the test case for which suites need to be fetched.
       */
      getSuitesByTestCaseId(testCaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testCaseId == null) {
            throw new TypeError("testCaseId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              testCaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "a4080e84-f17b-4fad-84f1-7960b6525bf2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add test cases to a suite with specified configurations
       *
       * @param {TestPlanInterfaces.SuiteTestCaseCreateUpdateParameters[]} suiteTestCaseCreateUpdateParameters - SuiteTestCaseCreateUpdateParameters object.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to which test cases are to be added.
       * @param {number} suiteId - ID of the test suite to which test cases are to be added.
       */
      addTestCasesToSuite(suiteTestCaseCreateUpdateParameters, project, planId, suiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, suiteTestCaseCreateUpdateParameters, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a particular Test Case from a Suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test cases are requested.
       * @param {number} suiteId - ID of the test suite for which test cases are requested.
       * @param {string} testCaseId - Test Case Id to be fetched.
       * @param {string} witFields - Get the list of witFields.
       * @param {boolean} returnIdentityRef - If set to true, returns all identity fields, like AssignedTo, ActivatedBy etc., as IdentityRef objects. If set to false, these fields are returned as unique names in string format. This is false by default.
       */
      getTestCase(project, planId, suiteId, testCaseId, witFields, returnIdentityRef) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId,
              testCaseId
            };
            let queryValues = {
              witFields,
              returnIdentityRef
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Test Case List return those test cases which have all the configuration Ids as mentioned in the optional parameter. If configuration Ids is null, it return all the test cases
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test cases are requested.
       * @param {number} suiteId - ID of the test suite for which test cases are requested.
       * @param {string} testIds - Test Case Ids to be fetched.
       * @param {string} configurationIds - Fetch Test Cases which contains all the configuration Ids specified.
       * @param {string} witFields - Get the list of witFields.
       * @param {string} continuationToken - If the list of test cases returned is not complete, a continuation token to query next batch of test cases is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test cases.
       * @param {boolean} returnIdentityRef - If set to true, returns all identity fields, like AssignedTo, ActivatedBy etc., as IdentityRef objects. If set to false, these fields are returned as unique names in string format. This is false by default.
       * @param {boolean} expand - If set to false, will get a smaller payload containing only basic details about the suite test case object
       * @param {TestPlanInterfaces.ExcludeFlags} excludeFlags - Flag to exclude various values from payload. For example to remove point assignments pass exclude = 1. To remove extra information (links, test plan , test suite) pass exclude = 2. To remove both extra information and point assignments pass exclude = 3 (1 + 2).
       * @param {boolean} isRecursive
       */
      getTestCaseList(project, planId, suiteId, testIds, configurationIds, witFields, continuationToken, returnIdentityRef, expand, excludeFlags, isRecursive) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testIds,
              configurationIds,
              witFields,
              continuationToken,
              returnIdentityRef,
              expand,
              excludeFlags,
              isRecursive
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes test cases from a suite based on the list of test case Ids provided.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan from which test cases are to be removed.
       * @param {number} suiteId - ID of the test suite from which test cases are to be removed.
       * @param {string} testCaseIds - Test Case Ids to be removed.
       */
      removeTestCasesFromSuite(project, planId, suiteId, testCaseIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testCaseIds == null) {
            throw new TypeError("testCaseIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes test cases from a suite based on the list of test case Ids provided. This API can be used to remove a larger number of test cases.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan from which test cases are to be removed.
       * @param {number} suiteId - ID of the test suite from which test cases are to be removed.
       * @param {string} testIds - Comma separated string of Test Case Ids to be removed.
       */
      removeTestCasesListFromSuite(project, planId, suiteId, testIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testIds == null) {
            throw new TypeError("testIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the configurations for test cases
       *
       * @param {TestPlanInterfaces.SuiteTestCaseCreateUpdateParameters[]} suiteTestCaseCreateUpdateParameters - A SuiteTestCaseCreateUpdateParameters object.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to which test cases are to be updated.
       * @param {number} suiteId - ID of the test suite to which test cases are to be updated.
       */
      updateSuiteTestCases(suiteTestCaseCreateUpdateParameters, project, planId, suiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, suiteTestCaseCreateUpdateParameters, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestPlanInterfaces.CloneTestCaseParams} cloneRequestBody
       * @param {string} project - Project ID or project name
       */
      cloneTestCase(cloneRequestBody, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "529b2b8d-82f4-4893-b1e4-1e74ea534673", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cloneRequestBody, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestCaseOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get clone information.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cloneOperationId - Operation ID returned when we queue a clone operation
       */
      getTestCaseCloneInformation(project, cloneOperationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cloneOperationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "529b2b8d-82f4-4893-b1e4-1e74ea534673", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestCaseOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Exports a set of test cases from a suite to a file. Currently supported  formats: xlsx
       *
       * @param {TestPlanInterfaces.ExportTestCaseParams} exportTestCaseRequestBody - A ExportTestCaseParams object.ExportTestCaseParams
       * @param {string} project - Project ID or project name
       */
      exportTestCases(exportTestCaseRequestBody, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "3b9d1c87-6b1a-4e7d-9e7d-1a8e543112bb", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.post(url, JSON.stringify(exportTestCaseRequestBody), { "Accept": accept, "Content-Type": "application/json" })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test case.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testCaseId - Id of test case to be deleted.
       */
      deleteTestCase(project, testCaseId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testCaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "29006fb5-816b-4ff7-a329-599943569229", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deleted test plans
       *
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken - If the list of plans returned is not complete, a continuation token to query next batch of plans is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test plans.
       */
      getDeletedTestPlans(project, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "04c64b80-239e-426c-b79d-b1ca8951ce26", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Restores the deleted test plan
       *
       * @param {TestPlanInterfaces.TestPlanAndSuiteRestoreModel} restoreModel - The model containing the restore information
       * @param {string} project - Project ID or project name
       * @param {number} planId - The ID of the test plan to restore
       */
      restoreDeletedTestPlan(restoreModel, project, planId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "04c64b80-239e-426c-b79d-b1ca8951ce26", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, restoreModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Clone test plan
       *
       * @param {TestPlanInterfaces.CloneTestPlanParams} cloneRequestBody - Plan Clone Request Body detail TestPlanCloneRequest
       * @param {string} project - Project ID or project name
       * @param {boolean} deepClone - Clones all the associated test cases as well
       */
      cloneTestPlan(cloneRequestBody, project, deepClone) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              deepClone
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "e65df662-d8a3-46c7-ae1c-14e2d4df57e1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cloneRequestBody, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestPlanOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get clone information.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cloneOperationId - Operation ID returned when we queue a clone operation
       */
      getCloneInformation(project, cloneOperationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cloneOperationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "e65df662-d8a3-46c7-ae1c-14e2d4df57e1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestPlanOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a particular Test Point from a suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test points are requested.
       * @param {number} suiteId - ID of the test suite for which test points are requested.
       * @param {string} pointId - ID of test point to be fetched.
       * @param {boolean} returnIdentityRef - If set to true, returns the AssignedTo field in TestCaseReference as IdentityRef object.
       * @param {boolean} includePointDetails - If set to false, will get a smaller payload containing only basic details about the test point object
       */
      getPoints(project, planId, suiteId, pointId, returnIdentityRef, includePointDetails) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (pointId == null) {
            throw new TypeError("pointId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              pointId,
              returnIdentityRef,
              includePointDetails
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "52df686e-bae4-4334-b0ee-b6cf4e6f6b73", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the points inside a suite based on some filters
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test points are requested.
       * @param {number} suiteId - ID of the test suite for which test points are requested
       * @param {string} testPointIds - ID of test points to fetch.
       * @param {string} testCaseId - Get Test Points for specific test case Ids.
       * @param {string} continuationToken - If the list of test point returned is not complete, a continuation token to query next batch of test points is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test points.
       * @param {boolean} returnIdentityRef - If set to true, returns the AssignedTo field in TestCaseReference as IdentityRef object.
       * @param {boolean} includePointDetails - If set to false, will get a smaller payload containing only basic details about the test point object
       * @param {boolean} isRecursive - If set to true, will also fetch test points belonging to child suites recursively.
       */
      getPointsList(project, planId, suiteId, testPointIds, testCaseId, continuationToken, returnIdentityRef, includePointDetails, isRecursive) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testPointIds,
              testCaseId,
              continuationToken,
              returnIdentityRef,
              includePointDetails,
              isRecursive
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "52df686e-bae4-4334-b0ee-b6cf4e6f6b73", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update Test Points. This is used to Reset test point to active, update the outcome of a test point or update the tester of a test point
       *
       * @param {TestPlanInterfaces.TestPointUpdateParams[]} testPointUpdateParams - A TestPointUpdateParams Object.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test points are requested.
       * @param {number} suiteId - ID of the test suite for which test points are requested.
       * @param {boolean} includePointDetails - If set to false, will get a smaller payload containing only basic details about the test point object
       * @param {boolean} returnIdentityRef - If set to true, returns the AssignedTo field in TestCaseReference as IdentityRef object.
       */
      updateTestPoints(testPointUpdateParams, project, planId, suiteId, includePointDetails, returnIdentityRef) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              includePointDetails,
              returnIdentityRef
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "52df686e-bae4-4334-b0ee-b6cf4e6f6b73", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testPointUpdateParams, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Deleted Test Suites for a Test Plan.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which suites are requested.
       * @param {TestPlanInterfaces.SuiteExpand} expand - Include the children suites and testers details.
       * @param {string} continuationToken - If the list of suites returned is not complete, a continuation token to query next batch of suites is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test suites.
       * @param {boolean} asTreeView - If the suites returned should be in a tree structure.
       */
      getDeletedTestSuitesForPlan(project, planId, expand, continuationToken, asTreeView) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            let queryValues = {
              expand,
              continuationToken,
              asTreeView
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "d2f1e8a4-3b6e-4f8b-9c8e-2d4f6e4b5a7c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Deleted Test Suites within a Project.
       *
       * @param {string} project - Project ID or project name
       * @param {TestPlanInterfaces.SuiteExpand} expand - Include the children suites and testers details.
       * @param {string} continuationToken - If the list of suites returned is not complete, a continuation token to query next batch of suites is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test suites.
       * @param {boolean} asTreeView - If the suites returned should be in a tree structure.
       */
      getDeletedTestSuitesForProject(project, expand, continuationToken, asTreeView) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              expand,
              continuationToken,
              asTreeView
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "f40ae369-855d-4d5e-bee0-5e99c5c42fcb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Restores the deleted test suite
       *
       * @param {TestPlanInterfaces.TestPlanAndSuiteRestoreModel} payload - The model containing the restore information
       * @param {string} project - Project ID or project name
       * @param {number} suiteId - The ID of the test suite to restore
       */
      restoreDeletedTestSuite(payload, project, suiteId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "f40ae369-855d-4d5e-bee0-5e99c5c42fcb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, payload, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Clone test suite
       *
       * @param {TestPlanInterfaces.CloneTestSuiteParams} cloneRequestBody - Suite Clone Request Body detail TestSuiteCloneRequest
       * @param {string} project - Project ID or project name
       * @param {boolean} deepClone - Clones all the associated test cases as well
       */
      cloneTestSuite(cloneRequestBody, project, deepClone) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              deepClone
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "181d4c97-0e98-4ee2-ad6a-4cada675e555", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cloneRequestBody, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestSuiteOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get clone information.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cloneOperationId - Operation ID returned when we queue a clone operation
       */
      getSuiteCloneInformation(project, cloneOperationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cloneOperationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "181d4c97-0e98-4ee2-ad6a-4cada675e555", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestSuiteOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a test variable.
       *
       * @param {TestPlanInterfaces.TestVariableCreateUpdateParameters} testVariableCreateUpdateParameters - TestVariableCreateUpdateParameters
       * @param {string} project - Project ID or project name
       */
      createTestVariable(testVariableCreateUpdateParameters, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testVariableCreateUpdateParameters, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test variable by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testVariableId - ID of the test variable to delete.
       */
      deleteTestVariable(project, testVariableId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testVariableId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test variable by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testVariableId - ID of the test variable to get.
       */
      getTestVariableById(project, testVariableId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testVariableId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test variables.
       *
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken - If the list of variables returned is not complete, a continuation token to query next batch of variables is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test variables.
       */
      getTestVariables(project, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test variable by its ID.
       *
       * @param {TestPlanInterfaces.TestVariableCreateUpdateParameters} testVariableCreateUpdateParameters - TestVariableCreateUpdateParameters
       * @param {string} project - Project ID or project name
       * @param {number} testVariableId - ID of the test variable to update.
       */
      updateTestVariable(testVariableCreateUpdateParameters, project, testVariableId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testVariableId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testVariableCreateUpdateParameters, options2);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TestPlanApi = TestPlanApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/TestResultsApi.js
var require_TestResultsApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/TestResultsApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestResultsApi = void 0;
    var basem = require_ClientApiBases();
    var Contracts = require_TestInterfaces();
    var TestResultsApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-testResults-api", options2);
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} iterationId
       * @param {string} actionPath
       */
      createTestIterationResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, iterationId, actionPath) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              iterationId,
              actionPath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      createTestResultAttachment(attachmentRequestModel, project, runId, testCaseResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} testSubResultId
       */
      createTestSubResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       */
      deleteTestResultAttachment(project, runId, testCaseResultId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test iteration attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} iterationId
       */
      getTestIterationAttachmentContent(project, runId, testCaseResultId, attachmentId, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test iteration attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} iterationId
       */
      getTestIterationAttachmentZip(project, runId, testCaseResultId, attachmentId, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       */
      getTestResultAttachmentContent(project, runId, testCaseResultId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getTestResultAttachments(project, runId, testCaseResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       */
      getTestResultAttachmentZip(project, runId, testCaseResultId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} testSubResultId
       */
      getTestSubResultAttachmentContent(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns attachment references for test sub result.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} testSubResultId
       */
      getTestSubResultAttachments(project, runId, testCaseResultId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} testSubResultId
       */
      getTestSubResultAttachmentZip(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      createTestRunAttachment(attachmentRequestModel, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} attachmentId
       */
      deleteTestRunAttachment(project, runId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test run attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} attachmentId
       */
      getTestRunAttachmentContent(project, runId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      getTestRunAttachments(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test run attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} attachmentId
       */
      getTestRunAttachmentZip(project, runId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getBugsLinkedToTestResult(project, runId, testCaseResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "d8dbf98f-eb34-4f8d-8365-47972af34f29", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       */
      fetchSourceCodeCoverageReport(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "a459e10b-d703-4193-b3c1-60f2287918b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.SourceViewBuildCoverage, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {number} flags
       */
      getBuildCodeCoverage(project, buildId, flags) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "9b3e1ece-c6ab-4fbb-8167-8a32a0c92216", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.BuildCoverage, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * http://(tfsserver):8080/tfs/DefaultCollection/_apis/test/CodeCoverage?buildId=10&deltaBuildId=9 Request: build id and delta build id (optional)
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {number} deltaBuildId
       */
      getCodeCoverageSummary(project, buildId, deltaBuildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              deltaBuildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "9b3e1ece-c6ab-4fbb-8167-8a32a0c92216", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.CodeCoverageSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * http://(tfsserver):8080/tfs/DefaultCollection/_apis/test/CodeCoverage?buildId=10 Request: Json of code coverage summary
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {Contracts.CodeCoverageData} coverageData
       */
      updateCodeCoverageSummary(project, buildId, coverageData) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "9b3e1ece-c6ab-4fbb-8167-8a32a0c92216", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, coverageData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} flags
       */
      getTestRunCodeCoverage(project, runId, flags) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "5641efbc-6f9b-401a-baeb-d3da22489e5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates custom test fields based on the data provided.
       *
       * @param {Contracts.CustomTestFieldDefinition[]} newFields - NewFields is an array of type CustomTestFieldDefinition.
       * @param {string} project - Project ID or project name
       */
      addCustomFields(newFields, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b67d46d8-b70e-4dcc-a98c-7f74b52ba82f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newFields, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns List of custom test fields for the given custom test field scope.
       *
       * @param {string} project - Project ID or project name
       * @param {Contracts.CustomTestFieldScope} scopeFilter - Scope of custom test fields which are to be returned.
       */
      queryCustomFields(project, scopeFilter) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (scopeFilter == null) {
            throw new TypeError("scopeFilter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopeFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b67d46d8-b70e-4dcc-a98c-7f74b52ba82f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns details of the custom test field for the specified testExtensionFieldId.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testExtensionFieldId - Custom test field id which has to be deleted.
       */
      deleteCustomFieldById(project, testExtensionFieldId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testExtensionFieldId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "75653fea-8649-4e07-b296-ca20e1bb5633", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns details of the custom test field which is updated.
       *
       * @param {Contracts.CustomTestFieldUpdateDefinition} updateCustomTestField - Custom test field which has to be updated.
       * @param {string} project - Project ID or project name
       */
      updateCustomField(updateCustomTestField, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "75653fea-8649-4e07-b296-ca20e1bb5633", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateCustomTestField, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.CustomTestFieldDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get file coverage for the specified file
       *
       * @param {Contracts.FileCoverageRequest} fileCoverageRequest - File details with pull request iteration context
       * @param {string} project - Project ID or project name
       */
      getFileLevelCodeCoverage(fileCoverageRequest, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "4a6d0c46-51ca-45aa-9163-249cee3289b7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.post(url, JSON.stringify(fileCoverageRequest), { "Accept": accept, "Content-Type": "application/json" })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildDefinitionId
       * @param {Date} minBuildCreatedDate
       */
      getFlakyTestResultsByBuildDefinitionId(project, buildDefinitionId, minBuildCreatedDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildDefinitionId == null) {
            throw new TypeError("buildDefinitionId can not be null or undefined");
          }
          if (minBuildCreatedDate == null) {
            throw new TypeError("minBuildCreatedDate can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildDefinitionId,
              minBuildCreatedDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "8ed3cf63-7153-4722-a107-c49dae996143", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      getFlakyTestResultsByTestRun(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "31cc4b31-416f-45cd-9b45-39534279e10c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.ResultsFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryTestResultHistory(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "bdf7a97b-0395-4da8-9d5d-f957619327d1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultHistory, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run message logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunMessageLogs(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "e9ab0c6a-1984-418b-87c0-ee4202318ba3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestMessageLogDetails, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get summary of test results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {Contracts.Metrics[]} metricNames
       * @param {boolean} groupByNode - Group summary for each node of the pipleine heirarchy
       */
      getTestPipelineMetrics(project, pipelineId, stageName, phaseName, jobName, metricNames, groupByNode) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              metricNames: metricNames && metricNames.join(","),
              groupByNode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "65f35817-86a1-4131-b38b-3ec2d4744e53", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.PipelineTestMetrics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForBuild(project, buildId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "a518c749-4524-45b2-a7ef-1ac009b312cd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForRelease(project, releaseId, releaseEnvId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "19a8183a-69fb-47d7-bfbf-1b6b0d921294", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultDocument} document
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      publishTestResultDocument(document, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "74838649-b038-42f1-a0e7-6deb3973bf14", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, document, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByBuild(project, buildId, publishContext, fields, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "e49244d1-c49f-49ad-a717-3bbaefe6a201", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} publishContext
       * @param {number} releaseEnvId
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByRelease(project, releaseId, publishContext, releaseEnvId, fields, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              publishContext,
              releaseEnvId,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "3c2b6bb0-0620-434a-a5c3-26aa0fcfda15", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test Result meta data details for corresponding testcasereferenceId
       *
       * @param {string[]} testCaseReferenceIds - TestCaseReference Ids of the test Result to be queried, comma separated list of valid ids (limit no. of ids 200).
       * @param {string} project - Project ID or project name
       * @param {Contracts.ResultMetaDataDetails} detailsToInclude - Details to include with test results metadata. Default is None. Other values are FlakyIdentifiers.
       */
      queryTestResultsMetaData(testCaseReferenceIds, project, detailsToInclude) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              detailsToInclude
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "testresults", "b72ff4c0-4341-4213-ba27-f517cf341c95", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testCaseReferenceIds, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update properties of test result meta data
       *
       * @param {Contracts.TestResultMetaDataUpdateInput} testResultMetaDataUpdateInput - TestResultMetaData update input TestResultMetaDataUpdateInput
       * @param {string} project - Project ID or project name
       * @param {number} testCaseReferenceId - TestCaseReference Id of Test Result to be updated.
       */
      updateTestResultsMetaData(testResultMetaDataUpdateInput, project, testCaseReferenceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testCaseReferenceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "testresults", "b72ff4c0-4341-4213-ba27-f517cf341c95", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testResultMetaDataUpdateInput, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultsQuery} query
       * @param {string} project - Project ID or project name
       */
      getTestResultsByQuery(query, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "14033a2c-af25-4af1-9e39-8ef6900482e3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.QueryModel} queryModel
       * @param {string} project - Project ID or project name
       * @param {boolean} includeResultDetails
       * @param {boolean} includeIterationDetails
       * @param {number} skip
       * @param {number} top
       */
      getTestResultsByQueryWiql(queryModel, project, includeResultDetails, includeIterationDetails, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeResultDetails,
              includeIterationDetails,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "5ea78be3-2f5a-4110-8034-c27f24c62db1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queryModel, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestCaseResult[]} results
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      addTestResultsToTestRun(results, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, results, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testResultId
       * @param {Contracts.ResultDetails} detailsToInclude
       */
      getTestResultById(project, runId, testResultId, detailsToInclude) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testResultId
            };
            let queryValues = {
              detailsToInclude
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {Contracts.ResultDetails} detailsToInclude
       * @param {number} skip
       * @param {number} top
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {boolean} newTestsOnly
       */
      getTestResults(project, runId, detailsToInclude, skip, top, outcomes, newTestsOnly) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              detailsToInclude,
              "$skip": skip,
              "$top": top,
              outcomes: outcomes && outcomes.join(","),
              "$newTestsOnly": newTestsOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestCaseResult[]} results
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      updateTestResults(results, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, results, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByBuild(project, buildId, publishContext, outcomes, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f48cc885-dbc4-4efc-ab19-ae8c19d1e02a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {Contracts.TestOutcome[]} outcomes - List of outcome of results
       * @param {boolean} includeAllBuildRuns - Whether to include Test Runs from from all the build runs or not.
       * @param {number} top - Maximum number of results to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestResultsByPipeline(customHeaders, project, pipelineId, stageName, phaseName, jobName, outcomes, includeAllBuildRuns, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              outcomes: outcomes && outcomes.join(","),
              includeAllBuildRuns,
              "$top": top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "80169dc2-30c3-4c25-84b2-dd67d7ff1f52", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvid
       * @param {string} publishContext
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByRelease(project, releaseId, releaseEnvid, publishContext, outcomes, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvid,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "3994b949-77e5-495d-8034-edf80d95b84e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the available groups details and for these groups get failed and aborted results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {boolean} shouldIncludeFailedAndAbortedResults - If true, it will return Ids of failed and aborted results for each test group
       * @param {boolean} queryGroupSummaryForInProgress - If true, it will calculate summary for InProgress runs as well.
       */
      testResultsGroupDetails(project, pipelineId, stageName, phaseName, jobName, shouldIncludeFailedAndAbortedResults, queryGroupSummaryForInProgress) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              shouldIncludeFailedAndAbortedResults,
              queryGroupSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f903b850-06af-4b50-a344-d7bbfb19e93b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {Contracts.BuildReference} buildToCompare
       */
      queryTestResultsReportForBuild(project, buildId, publishContext, includeFailureDetails, buildToCompare) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              includeFailureDetails,
              buildToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "e009fa95-95a5-4ad4-9681-590043ce2423", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get summary of test results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {boolean} includeFailureDetails - If true returns failure insights
       */
      queryTestResultsReportForPipeline(project, pipelineId, stageName, phaseName, jobName, includeFailureDetails) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              includeFailureDetails
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "71f746a1-7d68-40fe-b705-9d821a73dff2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {Contracts.ReleaseReference} releaseToCompare
       */
      queryTestResultsReportForRelease(project, releaseId, releaseEnvId, publishContext, includeFailureDetails, releaseToCompare) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              includeFailureDetails,
              releaseToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f10f9577-2c04-45ab-8c99-b26567a7cd55", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.ReleaseReference[]} releases
       * @param {string} project - Project ID or project name
       */
      queryTestResultsSummaryForReleases(releases, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f10f9577-2c04-45ab-8c99-b26567a7cd55", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releases, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultsContext} resultsContext
       * @param {string} project - Project ID or project name
       * @param {number[]} workItemIds
       */
      queryTestSummaryByRequirement(resultsContext, project, workItemIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemIds: workItemIds && workItemIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "3b7fd26f-c335-4e55-afc1-a588f5e2af3c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, resultsContext, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestSummaryForWorkItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForBuild(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "0886a7ae-315a-4dba-9122-bcce93301f3a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForRelease(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "107f23c3-359a-460a-a70c-63ee739f9f9a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.RunCreateModel} testRun
       * @param {string} project - Project ID or project name
       */
      createTestRun(testRun, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testRun, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      deleteTestRun(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {boolean} includeDetails
       * @param {boolean} includeTags
       */
      getTestRunById(project, runId, includeDetails, includeTags) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              includeDetails,
              includeTags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} buildUri
       * @param {string} owner
       * @param {string} tmiRunId
       * @param {number} planId
       * @param {boolean} includeRunDetails
       * @param {boolean} automated
       * @param {number} skip
       * @param {number} top
       */
      getTestRuns(project, buildUri, owner, tmiRunId, planId, includeRunDetails, automated, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildUri,
              owner,
              tmiRunId,
              planId,
              includeRunDetails,
              automated,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query Test Runs based on filters. Mandatory fields are minLastUpdatedDate and maxLastUpdatedDate.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} minLastUpdatedDate - Minimum Last Modified Date of run to be queried (Mandatory).
       * @param {Date} maxLastUpdatedDate - Maximum Last Modified Date of run to be queried (Mandatory, difference between min and max date can be atmost 7 days).
       * @param {Contracts.TestRunState} state - Current state of the Runs to be queried.
       * @param {number[]} planIds - Plan Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {boolean} isAutomated - Automation type of the Runs to be queried.
       * @param {Contracts.TestRunPublishContext} publishContext - PublishContext of the Runs to be queried.
       * @param {number[]} buildIds - Build Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} buildDefIds - Build Definition Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {string} branchName - Source Branch name of the Runs to be queried.
       * @param {number[]} releaseIds - Release Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} releaseDefIds - Release Definition Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} releaseEnvIds - Release Environment Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} releaseEnvDefIds - Release Environment Definition Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {string} runTitle - Run Title of the Runs to be queried.
       * @param {number} top - Number of runs to be queried. Limit is 100
       * @param {string} continuationToken - continuationToken received from previous batch or null for first batch. It is not supposed to be created (or altered, if received from last batch) by user.
       */
      queryTestRuns(project, minLastUpdatedDate, maxLastUpdatedDate, state, planIds, isAutomated, publishContext, buildIds, buildDefIds, branchName, releaseIds, releaseDefIds, releaseEnvIds, releaseEnvDefIds, runTitle, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (minLastUpdatedDate == null) {
            throw new TypeError("minLastUpdatedDate can not be null or undefined");
          }
          if (maxLastUpdatedDate == null) {
            throw new TypeError("maxLastUpdatedDate can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              minLastUpdatedDate,
              maxLastUpdatedDate,
              state,
              planIds: planIds && planIds.join(","),
              isAutomated,
              publishContext,
              buildIds: buildIds && buildIds.join(","),
              buildDefIds: buildDefIds && buildDefIds.join(","),
              branchName,
              releaseIds: releaseIds && releaseIds.join(","),
              releaseDefIds: releaseDefIds && releaseDefIds.join(","),
              releaseEnvIds: releaseEnvIds && releaseEnvIds.join(","),
              releaseEnvDefIds: releaseEnvDefIds && releaseEnvDefIds.join(","),
              runTitle,
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.RunUpdateModel} runUpdateModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      updateTestRun(runUpdateModel, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, runUpdateModel, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run summary, used when we want to get summary of a run by outcome. Test run should be in completed state.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunSummaryByOutcome(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "5c6a250c-53b7-4851-990c-42a7a00c8b39", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRunStatistic, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get TestResultsSettings data
       *
       * @param {string} project - Project ID or project name
       * @param {Contracts.TestResultsSettingsType} settingsType
       */
      getTestResultsSettings(project, settingsType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              settingsType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testresults", "7319952e-e5a9-4e19-a006-84f3be8b7c68", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update project settings of test results
       *
       * @param {Contracts.TestResultsUpdateSettings} testResultsUpdateSettings
       * @param {string} project - Project ID or project name
       */
      updatePipelinesTestSettings(testResultsUpdateSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testresults", "7319952e-e5a9-4e19-a006-84f3be8b7c68", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testResultsUpdateSettings, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the list of results whose failure matches with the provided one.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - id of test run
       * @param {number} testResultId - id of test result inside a test run
       * @param {number} testSubResultId - id of subresult inside a test result
       * @param {number} top - Maximum number of results to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getSimilarTestResults(customHeaders, project, runId, testResultId, testSubResultId, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testResultId
            };
            let queryValues = {
              testSubResultId,
              "$top": top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "67d0a074-b255-4902-a639-e3e6de7a3de6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run statistics , used when we want to get summary of a run by outcome.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunStatistics(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "82b986e8-ca9e-4a89-b39e-f65c69bc104a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRunStatistic, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * <p>Gets the coverage status for the last successful build of a definition, optionally scoped to a specific branch</p>
       *
       * @param {string} project - Project ID or project name
       * @param {string} definition - The ID or name of the definition.
       * @param {string} branchName - The branch name.
       * @param {string} label - The String to replace the default text on the left side of the badge.
       */
      getCoverageStatusBadge(project, definition, branchName, label) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definition
            };
            let queryValues = {
              branchName,
              label
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "73b7c9d8-defb-4b60-b3d6-2162d60d6b13", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Build ID
       */
      getTestTagsForBuild(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "52ee2057-4b54-41a6-a18c-ed4375a00f8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Release ID
       * @param {number} releaseEnvId - Release environment ID
       */
      getTestTagsForRelease(project, releaseId, releaseEnvId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "52ee2057-4b54-41a6-a18c-ed4375a00f8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update tags of a run, Tags can be Added and Deleted
       *
       * @param {Contracts.TestTagsUpdateModel} testTagsUpdateModel - TestTagsUpdateModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - RunId of the run
       */
      updateTestRunTags(testTagsUpdateModel, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "a5e2f411-2b43-45f3-989c-05b71339f5b8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testTagsUpdateModel, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Build ID
       */
      getTestTagSummaryForBuild(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "655a8f6b-fec7-4b46-b672-68b44141b498", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Release ID
       * @param {number} releaseEnvId - Release environment ID
       */
      getTestTagSummaryForRelease(project, releaseId, releaseEnvId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "655a8f6b-fec7-4b46-b672-68b44141b498", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates an attachment in the LogStore for the specified buildId.
       *
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel - Contains attachment info like stream, filename, comment, attachmentType
       * @param {string} project - Project ID or project name
       * @param {number} buildId - BuildId
       */
      createBuildAttachmentInLogStore(attachmentRequestModel, project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "6f747e16-18c2-435a-b4fb-fa05d6845fee", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates an attachment in the LogStore for the specified runId.
       *
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel - Contains attachment info like stream, filename, comment, attachmentType
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       */
      createTestRunLogStoreAttachment(attachmentRequestModel, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the attachment with the specified filename for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       * @param {string} filename - Attachment FileName
       */
      deleteTestRunLogStoreAttachment(project, runId, filename) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (filename == null) {
            throw new TypeError("filename can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the attachment with the specified filename for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       * @param {string} filename - Attachment FileName
       */
      getTestRunLogStoreAttachmentContent(project, runId, filename) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (filename == null) {
            throw new TypeError("filename can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of attachments for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       */
      getTestRunLogStoreAttachments(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the attachment with the specified filename for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       * @param {string} filename - Attachment FileName
       */
      getTestRunLogStoreAttachmentZip(project, runId, filename) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (filename == null) {
            throw new TypeError("filename can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new test failure type
       *
       * @param {Contracts.TestResultFailureTypeRequestModel} testResultFailureType
       * @param {string} project - Project ID or project name
       */
      createFailureType(testResultFailureType, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "c4ac0486-830c-4a2a-9ef9-e8a1791a70fd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testResultFailureType, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a test failure type with specified failureTypeId
       *
       * @param {string} project - Project ID or project name
       * @param {number} failureTypeId
       */
      deleteFailureType(project, failureTypeId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              failureTypeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "c4ac0486-830c-4a2a-9ef9-e8a1791a70fd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of test failure types.
       *
       * @param {string} project - Project ID or project name
       */
      getFailureTypes(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "c4ac0486-830c-4a2a-9ef9-e8a1791a70fd", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get history of a test method using TestHistoryQuery
       *
       * @param {Contracts.TestHistoryQuery} filter - TestHistoryQuery to get history
       * @param {string} project - Project ID or project name
       */
      queryTestHistory(filter2, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "2a41bd6a-8118-4403-b74e-5ba7492aed9d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestHistoryQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of build attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Id of the build to get
       * @param {Contracts.TestLogType} type - type of the attachment to get
       * @param {string} directoryPath - directory path for which attachments are needed
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachment
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Number of test attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestLogsForBuild(customHeaders, project, buildId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "dff8ce3a-e539-4817-a405-d968491a88f1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test result attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains the result
       * @param {number} resultId - Id of the test result
       * @param {Contracts.TestLogType} type - type of attachments to get
       * @param {string} directoryPath - directory path of attachments to get
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachment
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Numbe of attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestResultLogs(customHeaders, project, runId, resultId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "714caaac-ae1e-4869-8323-9bc0f5120dbf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test subresult attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains the results
       * @param {number} resultId - Id of the test result that contains subresult
       * @param {number} subResultId - Id of the test subresult
       * @param {Contracts.TestLogType} type - type of the attachments to get
       * @param {string} directoryPath - directory path of the attachment to get
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachments
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Number of attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestSubResultLogs(customHeaders, project, runId, resultId, subResultId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (subResultId == null) {
            throw new TypeError("subResultId can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              subResultId,
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "714caaac-ae1e-4869-8323-9bc0f5120dbf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test run attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run
       * @param {Contracts.TestLogType} type - type of the attachments to get
       * @param {string} directoryPath - directory path for which attachments are needed
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachment
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Number of attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestRunLogs(customHeaders, project, runId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "5b47b946-e875-4c9a-acdc-2a20996caebe", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a build attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} build - Id of the build to get
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForBuildLog(project, build, type, filePath) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (build == null) {
            throw new TypeError("build can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              build,
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "39b09be7-f0c9-4a83-a513-9ae31b45c56f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create and Get sas uri of the build container
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Id of the build to get
       * @param {Contracts.TestLogStoreOperationType} testLogStoreOperationType - Type of operation to perform using sas uri
       */
      testLogStoreEndpointDetailsForBuild(project, buildId, testLogStoreOperationType) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (testLogStoreOperationType == null) {
            throw new TypeError("testLogStoreOperationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              testLogStoreOperationType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "39b09be7-f0c9-4a83-a513-9ae31b45c56f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a test results attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains result
       * @param {number} resultId - Id of the test result whose files need to be downloaded
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForResultLog(project, runId, resultId, type, filePath) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "da630b37-1236-45b5-945e-1d7bdb673850", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a test subresults attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains result
       * @param {number} resultId - Id of the test result that contains subresult
       * @param {number} subResultId - Id of the test subresult whose file sas uri is needed
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForSubResultLog(project, runId, resultId, subResultId, type, filePath) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (subResultId == null) {
            throw new TypeError("subResultId can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              subResultId,
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "da630b37-1236-45b5-945e-1d7bdb673850", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create empty file for a result and Get Sas uri for the file
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains the result
       * @param {number} resultId - Id of the test results that contains sub result
       * @param {number} subResultId - Id of the test sub result whose file sas uri is needed
       * @param {string} filePath - file path inside the sub result for which sas uri is needed
       * @param {Contracts.TestLogType} type - Type of the file for download
       */
      testLogStoreEndpointDetailsForResult(project, runId, resultId, subResultId, filePath, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (subResultId == null) {
            throw new TypeError("subResultId can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              subResultId,
              filePath,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "da630b37-1236-45b5-945e-1d7bdb673850", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a test run attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run whose file has to be downloaded
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForRunLog(project, runId, type, filePath) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "67eb3f92-6c97-4fd9-8b63-6cbdc7e526ea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create empty file for a run and Get Sas uri for the file
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the run to get endpoint details
       * @param {Contracts.TestLogStoreOperationType} testLogStoreOperationType - Type of operation to perform using sas uri
       * @param {string} filePath - file path to create an empty file
       * @param {Contracts.TestLogType} type - Default is GeneralAttachment, type of empty file to be created
       */
      testLogStoreEndpointDetailsForRun(project, runId, testLogStoreOperationType, filePath, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testLogStoreOperationType == null) {
            throw new TypeError("testLogStoreOperationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              testLogStoreOperationType,
              filePath,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "67eb3f92-6c97-4fd9-8b63-6cbdc7e526ea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates TestResultsSession object in TCM data store
       *
       * @param {Contracts.TestResultsSession} session - Received session object.
       * @param {string} project - Project ID or project name
       */
      createTestSession(session, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "531e61ce-580d-4962-8591-0b2942b6bf78", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, session, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves TestResultsSession metadata object in TCM data store
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       */
      getTestSession(project, buildId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "531e61ce-580d-4962-8591-0b2942b6bf78", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsSession, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves TestResultsSession Layout object in TCM data store
       *
       * @param {string} project - Project ID or project name
       * @param {string} sessionId
       */
      getTestSessionLayout(project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "531e61ce-580d-4962-8591-0b2942b6bf78", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates Test session object associated to a sessionId
       *
       * @param {Contracts.TestResultsSession} session - Update Session object
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - Id of TestResults session to update Test session object for.
       */
      updateTestSession(session, project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "531e61ce-580d-4962-8591-0b2942b6bf78", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, session, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates Session Analysis object in TCM data store for a given session
       *
       * @param {Contracts.TestSessionAnalysis[]} analysis - Session Analysis details
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - ID of Session to add Notification
       */
      createAnalysis(analysis, project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "c83eaf52-edf3-4034-ae11-17d38f25404c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, analysis, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates Environment object in TCM data store
       *
       * @param {Contracts.TestSessionEnvironment[]} environments - Received Environment object.
       * @param {string} project - Project ID or project name
       */
      createEnvironment(environments, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "f9c2e9e4-9c9a-4c1d-9a7d-2b4c8a6f0d5f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, environments, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * For the provided sessionId, creates environment, configuration, and machine objects in TCM data store
       *
       * @param {Contracts.SessionEnvironmentAndMachine} sessionEnvironmentAndMachine
       * @param {string} project - Project ID or project name
       * @param {number} sessionId
       */
      createEnvironmentAndMachine(sessionEnvironmentAndMachine, project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "502ab173-18a6-427a-bee1-4068126b3e9b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, sessionEnvironmentAndMachine, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves TestResultsSession Layout object in TCM data store
       *
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - Retrieve session object.
       */
      getTestSessionLayoutBySessionId(project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "815d3979-81bd-4018-94fd-62000fc43163", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates Notification object in TCM data store for a given session
       *
       * @param {Contracts.TestSessionNotification[]} notifications - Notification(s) to add for the specified sessionId
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - ID of Session to add Notification
       */
      createNotification(notifications, project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "ebff1c56-2188-4082-9d0e-1838a396f0c8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notifications, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves TestResultsSession Notification objects in TCM data store
       *
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - Id of TestResults session to obtain Notifications for.
       */
      getSessionNotifications(project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "ebff1c56-2188-4082-9d0e-1838a396f0c8", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add Test Results to test run session
       *
       * @param {Contracts.TestCaseResult[]} results
       * @param {string} project - Project ID or project name
       * @param {number} runId - RunId of test run
       */
      addTestResultsToTestRunSession(results, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "ee6d95bf-7506-4c47-8100-9fed82cdc2f7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, results, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {Contracts.ResultDetails} detailsToInclude
       * @param {number} skip
       * @param {number} top
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {boolean} newTestsOnly
       */
      getTestSessionResults(project, runId, detailsToInclude, skip, top, outcomes, newTestsOnly) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              detailsToInclude,
              "$skip": skip,
              "$top": top,
              outcomes: outcomes && outcomes.join(","),
              "$newTestsOnly": newTestsOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "ee6d95bf-7506-4c47-8100-9fed82cdc2f7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates TestResultsMRX objects in TCM data store for existing test results
       *
       * @param {Contracts.TestCaseResult[]} results - Results object with only test results MRX properties and existing testResultId
       * @param {string} project - Project ID or project name
       * @param {number} runId - RunId of test run
       */
      updateTestResultsToTestRunSession(results, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "ee6d95bf-7506-4c47-8100-9fed82cdc2f7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, results, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates test result machines for the provided TestRunId
       *
       * @param {Contracts.TestResultMachine[]} testResultMachines - List of machines for test results in the run
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the TestRun to add machines for
       */
      createTestResultMachines(testResultMachines, project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "6485f27f-50a7-401e-828f-a8ee90978817", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testResultMachines, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets test result machines for the provided TestRunId
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the TestRun to add machines for
       */
      getTestResultMachines(project, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "6485f27f-50a7-401e-828f-a8ee90978817", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets full TestCaseResult objects with 1MRX details for the provided pipelineId
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {Contracts.TestOutcome[]} outcomes - List of outcome of results
       * @param {boolean} includeAllBuildRuns - Whether to include Test Runs from from all the build runs or not. Defaults to false.
       * @param {number} top - Maximum number of results to return. Defaults to 10000.
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestResultsByPipelineMRX(customHeaders, project, pipelineId, stageName, phaseName, jobName, outcomes, includeAllBuildRuns, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              outcomes: outcomes && outcomes.join(","),
              includeAllBuildRuns,
              "$top": top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "607f51d4-91a2-4ea4-a496-b3d58a7baea1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves Test runs associated to a session
       *
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - Id of TestResults session to obtain Test Runs for.
       */
      getTestRunsBySessionId(project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "6efc2c12-d4bf-4e86-ae37-b502e57a84c7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates Test runs associated to a session
       *
       * @param {Contracts.TestSessionTestRun} testRunIds
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - Id of TestResults session to update Test Runs for.
       */
      updateTestRunsBySessionId(testRunIds, project, sessionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "6efc2c12-d4bf-4e86-ae37-b502e57a84c7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testRunIds, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestSettings} testSettings
       * @param {string} project - Project ID or project name
       */
      createTestSettings(testSettings, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "930bad47-f826-4099-9597-f44d0a9c735c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      deleteTestSettings(project, testSettingsId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSettingsId == null) {
            throw new TypeError("testSettingsId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "930bad47-f826-4099-9597-f44d0a9c735c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      getTestSettingsById(project, testSettingsId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testSettingsId == null) {
            throw new TypeError("testSettingsId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "930bad47-f826-4099-9597-f44d0a9c735c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.WorkItemToTestLinks} workItemToTestLinks
       * @param {string} project - Project ID or project name
       */
      addWorkItemToTestLinks(workItemToTestLinks, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "4e3abe63-ca46-4fe0-98b2-363f7ec7aa5f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemToTestLinks, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.WorkItemToTestLinks, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       * @param {number} workItemId
       */
      deleteTestMethodToWorkItemLink(project, testName, workItemId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          if (workItemId == null) {
            throw new TypeError("workItemId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "cbd50bd7-f7ed-4e35-b127-4408ae6bfa2c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       */
      queryTestMethodLinkedWorkItems(project, testName) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "cbd50bd7-f7ed-4e35-b127-4408ae6bfa2c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestToWorkItemLinks, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getTestResultWorkItemsById(project, runId, testCaseResultId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "3d032fd6-e7a0-468b-b105-75d206f99aad", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query Test Result WorkItems based on filter
       *
       * @param {string} project - Project ID or project name
       * @param {string} workItemCategory - can take values Microsoft.BugCategory or all(for getting all workitems)
       * @param {string} automatedTestName
       * @param {number} testCaseId
       * @param {Date} maxCompleteDate
       * @param {number} days
       * @param {number} workItemCount
       */
      queryTestResultWorkItems(project, workItemCategory, automatedTestName, testCaseId, maxCompleteDate, days, workItemCount) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (workItemCategory == null) {
            throw new TypeError("workItemCategory can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemCategory,
              automatedTestName,
              testCaseId,
              maxCompleteDate,
              days,
              "$workItemCount": workItemCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "f7401a26-331b-44fe-a470-f7ed35138e4a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TestResultsApi = TestResultsApi;
    TestResultsApi.RESOURCE_AREA_ID = "c83eaf52-edf3-4034-ae11-17d38f25404c";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/TfvcInterfaces.js
var require_TfvcInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/TfvcInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VersionControlRecursionType = exports2.VersionControlChangeType = exports2.TfvcVersionType = exports2.TfvcVersionOption = exports2.ItemContentType = void 0;
    var TfsCoreInterfaces = require_CoreInterfaces();
    var ItemContentType;
    (function(ItemContentType2) {
      ItemContentType2[ItemContentType2["RawText"] = 0] = "RawText";
      ItemContentType2[ItemContentType2["Base64Encoded"] = 1] = "Base64Encoded";
    })(ItemContentType = exports2.ItemContentType || (exports2.ItemContentType = {}));
    var TfvcVersionOption;
    (function(TfvcVersionOption2) {
      TfvcVersionOption2[TfvcVersionOption2["None"] = 0] = "None";
      TfvcVersionOption2[TfvcVersionOption2["Previous"] = 1] = "Previous";
      TfvcVersionOption2[TfvcVersionOption2["UseRename"] = 2] = "UseRename";
    })(TfvcVersionOption = exports2.TfvcVersionOption || (exports2.TfvcVersionOption = {}));
    var TfvcVersionType;
    (function(TfvcVersionType2) {
      TfvcVersionType2[TfvcVersionType2["None"] = 0] = "None";
      TfvcVersionType2[TfvcVersionType2["Changeset"] = 1] = "Changeset";
      TfvcVersionType2[TfvcVersionType2["Shelveset"] = 2] = "Shelveset";
      TfvcVersionType2[TfvcVersionType2["Change"] = 3] = "Change";
      TfvcVersionType2[TfvcVersionType2["Date"] = 4] = "Date";
      TfvcVersionType2[TfvcVersionType2["Latest"] = 5] = "Latest";
      TfvcVersionType2[TfvcVersionType2["Tip"] = 6] = "Tip";
      TfvcVersionType2[TfvcVersionType2["MergeSource"] = 7] = "MergeSource";
    })(TfvcVersionType = exports2.TfvcVersionType || (exports2.TfvcVersionType = {}));
    var VersionControlChangeType;
    (function(VersionControlChangeType2) {
      VersionControlChangeType2[VersionControlChangeType2["None"] = 0] = "None";
      VersionControlChangeType2[VersionControlChangeType2["Add"] = 1] = "Add";
      VersionControlChangeType2[VersionControlChangeType2["Edit"] = 2] = "Edit";
      VersionControlChangeType2[VersionControlChangeType2["Encoding"] = 4] = "Encoding";
      VersionControlChangeType2[VersionControlChangeType2["Rename"] = 8] = "Rename";
      VersionControlChangeType2[VersionControlChangeType2["Delete"] = 16] = "Delete";
      VersionControlChangeType2[VersionControlChangeType2["Undelete"] = 32] = "Undelete";
      VersionControlChangeType2[VersionControlChangeType2["Branch"] = 64] = "Branch";
      VersionControlChangeType2[VersionControlChangeType2["Merge"] = 128] = "Merge";
      VersionControlChangeType2[VersionControlChangeType2["Lock"] = 256] = "Lock";
      VersionControlChangeType2[VersionControlChangeType2["Rollback"] = 512] = "Rollback";
      VersionControlChangeType2[VersionControlChangeType2["SourceRename"] = 1024] = "SourceRename";
      VersionControlChangeType2[VersionControlChangeType2["TargetRename"] = 2048] = "TargetRename";
      VersionControlChangeType2[VersionControlChangeType2["Property"] = 4096] = "Property";
      VersionControlChangeType2[VersionControlChangeType2["All"] = 8191] = "All";
    })(VersionControlChangeType = exports2.VersionControlChangeType || (exports2.VersionControlChangeType = {}));
    var VersionControlRecursionType;
    (function(VersionControlRecursionType2) {
      VersionControlRecursionType2[VersionControlRecursionType2["None"] = 0] = "None";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevel"] = 1] = "OneLevel";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevelPlusNestedEmptyFolders"] = 4] = "OneLevelPlusNestedEmptyFolders";
      VersionControlRecursionType2[VersionControlRecursionType2["Full"] = 120] = "Full";
    })(VersionControlRecursionType = exports2.VersionControlRecursionType || (exports2.VersionControlRecursionType = {}));
    exports2.TypeInfo = {
      Change: {},
      GitRepository: {},
      GitRepositoryRef: {},
      ItemContent: {},
      ItemContentType: {
        enumValues: {
          "rawText": 0,
          "base64Encoded": 1
        }
      },
      TfvcBranch: {},
      TfvcBranchRef: {},
      TfvcChange: {},
      TfvcChangeset: {},
      TfvcChangesetRef: {},
      TfvcItem: {},
      TfvcItemDescriptor: {},
      TfvcItemRequestData: {},
      TfvcLabel: {},
      TfvcLabelRef: {},
      TfvcShelveset: {},
      TfvcShelvesetRef: {},
      TfvcVersionDescriptor: {},
      TfvcVersionOption: {
        enumValues: {
          "none": 0,
          "previous": 1,
          "useRename": 2
        }
      },
      TfvcVersionType: {
        enumValues: {
          "none": 0,
          "changeset": 1,
          "shelveset": 2,
          "change": 3,
          "date": 4,
          "latest": 5,
          "tip": 6,
          "mergeSource": 7
        }
      },
      VersionControlChangeType: {
        enumValues: {
          "none": 0,
          "add": 1,
          "edit": 2,
          "encoding": 4,
          "rename": 8,
          "delete": 16,
          "undelete": 32,
          "branch": 64,
          "merge": 128,
          "lock": 256,
          "rollback": 512,
          "sourceRename": 1024,
          "targetRename": 2048,
          "property": 4096,
          "all": 8191
        }
      },
      VersionControlProjectInfo: {},
      VersionControlRecursionType: {
        enumValues: {
          "none": 0,
          "oneLevel": 1,
          "oneLevelPlusNestedEmptyFolders": 4,
          "full": 120
        }
      }
    };
    exports2.TypeInfo.Change.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.GitRepository.fields = {
      creationDate: {
        isDate: true
      },
      parentRepository: {
        typeInfo: exports2.TypeInfo.GitRepositoryRef
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitRepositoryRef.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.ItemContent.fields = {
      contentType: {
        enumType: exports2.TypeInfo.ItemContentType
      }
    };
    exports2.TypeInfo.TfvcBranch.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcBranch
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcBranchRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.TfvcChangeset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChangesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItem.fields = {
      changeDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItemDescriptor.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      },
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.TfvcItemRequestData.fields = {
      itemDescriptors: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItemDescriptor
      }
    };
    exports2.TypeInfo.TfvcLabel.fields = {
      items: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItem
      },
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcLabelRef.fields = {
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelveset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelvesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcVersionDescriptor.fields = {
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.VersionControlProjectInfo.fields = {
      defaultSourceControlType: {
        enumType: TfsCoreInterfaces.TypeInfo.SourceControlTypes
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/TfvcApi.js
var require_TfvcApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/TfvcApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TfvcApi = void 0;
    var basem = require_ClientApiBases();
    var TfvcInterfaces = require_TfvcInterfaces();
    var TfvcApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Tfvc-api", options2);
      }
      /**
       * Get a single branch hierarchy at the given path with parents or children as specified.
       *
       * @param {string} path - Full path to the branch.  Default: $/ Examples: $/, $/MyProject, $/MyProject/SomeFolder.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeParent - Return the parent branch, if there is one. Default: False
       * @param {boolean} includeChildren - Return child branches, if there are any. Default: False
       */
      getBranch(path10, project, includeParent, includeChildren) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10,
              includeParent,
              includeChildren
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "bc1f417e-239d-42e7-85e1-76e80cb2d6eb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcBranch, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of branch roots -- first-level children, branches with no parents.
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} includeParent - Return the parent branch, if there is one. Default: False
       * @param {boolean} includeChildren - Return the child branches for each root branch. Default: False
       * @param {boolean} includeDeleted - Return deleted branches. Default: False
       * @param {boolean} includeLinks - Return links. Default: False
       */
      getBranches(project, includeParent, includeChildren, includeDeleted, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeParent,
              includeChildren,
              includeDeleted,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "bc1f417e-239d-42e7-85e1-76e80cb2d6eb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcBranch, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get branch hierarchies below the specified scopePath
       *
       * @param {string} scopePath - Full path to the branch.  Default: $/ Examples: $/, $/MyProject, $/MyProject/SomeFolder.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeDeleted - Return deleted branches. Default: False
       * @param {boolean} includeLinks - Return links. Default: False
       */
      getBranchRefs(scopePath, project, includeDeleted, includeLinks) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (scopePath == null) {
            throw new TypeError("scopePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopePath,
              includeDeleted,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "bc1f417e-239d-42e7-85e1-76e80cb2d6eb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcBranchRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve Tfvc changes for a given changeset.
       *
       * @param {number} id - ID of the changeset. Default: null
       * @param {number} skip - Number of results to skip. Default: null
       * @param {number} top - The maximum number of results to return. Default: null
       */
      getChangesetChanges(id, skip, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "f32b86f2-15b9-4fe6-81b1-6f8938617ee5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChange, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new changeset.
       *
       * @param {TfvcInterfaces.TfvcChangeset} changeset
       * @param {string} project - Project ID or project name
       */
      createChangeset(changeset, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "tfvc", "0bc8f0a4-6bfb-42a9-ba84-139da7b99c49", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, changeset, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangesetRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a Tfvc Changeset
       *
       * @param {number} id - Changeset Id to retrieve.
       * @param {string} project - Project ID or project name
       * @param {number} maxChangeCount - Number of changes to return (maximum 100 changes) Default: 0
       * @param {boolean} includeDetails - Include policy details and check-in notes in the response. Default: false
       * @param {boolean} includeWorkItems - Include workitems. Default: false
       * @param {number} maxCommentLength - Include details about associated work items in the response. Default: null
       * @param {boolean} includeSourceRename - Include renames.  Default: false
       * @param {number} skip - Number of results to skip. Default: null
       * @param {number} top - The maximum number of results to return. Default: null
       * @param {string} orderby - Results are sorted by ID in descending order by default. Use id asc to sort by ID in ascending order.
       * @param {TfvcInterfaces.TfvcChangesetSearchCriteria} searchCriteria - Following criteria available (.itemPath, .version, .versionType, .versionOption, .author, .fromId, .toId, .fromDate, .toDate) Default: null
       */
      getChangeset(id, project, maxChangeCount, includeDetails, includeWorkItems, maxCommentLength, includeSourceRename, skip, top, orderby, searchCriteria) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              maxChangeCount,
              includeDetails,
              includeWorkItems,
              maxCommentLength,
              includeSourceRename,
              "$skip": skip,
              "$top": top,
              "$orderby": orderby,
              searchCriteria
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "tfvc", "0bc8f0a4-6bfb-42a9-ba84-139da7b99c49", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangeset, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve Tfvc Changesets
       *
       * @param {string} project - Project ID or project name
       * @param {number} maxCommentLength - Include details about associated work items in the response. Default: null
       * @param {number} skip - Number of results to skip. Default: null
       * @param {number} top - The maximum number of results to return. Default: null
       * @param {string} orderby - Results are sorted by ID in descending order by default. Use id asc to sort by ID in ascending order.
       * @param {TfvcInterfaces.TfvcChangesetSearchCriteria} searchCriteria - Following criteria available (.itemPath, .version, .versionType, .versionOption, .author, .fromId, .toId, .fromDate, .toDate) Default: null
       */
      getChangesets(project, maxCommentLength, skip, top, orderby, searchCriteria) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              maxCommentLength,
              "$skip": skip,
              "$top": top,
              "$orderby": orderby,
              searchCriteria
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "tfvc", "0bc8f0a4-6bfb-42a9-ba84-139da7b99c49", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangesetRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns changesets for a given list of changeset Ids.
       *
       * @param {TfvcInterfaces.TfvcChangesetsRequestData} changesetsRequestData - List of changeset IDs.
       */
      getBatchedChangesets(changesetsRequestData) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "b7e7c173-803c-4fea-9ec8-31ee35c5502a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, changesetsRequestData, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangesetRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves the work items associated with a particular changeset.
       *
       * @param {number} id - ID of the changeset.
       */
      getChangesetWorkItems(id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "64ae0bea-1d71-47c9-a9e5-fe73f5ea0ff4", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Post for retrieving a set of items given a list of paths or a long path. Allows for specifying the recursionLevel and version descriptors for each path.
       *
       * @param {TfvcInterfaces.TfvcItemRequestData} itemRequestData
       * @param {string} project - Project ID or project name
       */
      getItemsBatch(itemRequestData, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "fe6f827b-5f64-480f-b8af-1eca3b80e833", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, itemRequestData, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Post for retrieving a set of items given a list of paths or a long path. Allows for specifying the recursionLevel and version descriptors for each path.
       *
       * @param {TfvcInterfaces.TfvcItemRequestData} itemRequestData
       * @param {string} project - Project ID or project name
       */
      getItemsBatchZip(itemRequestData, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "fe6f827b-5f64-480f-b8af-1eca3b80e833", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.post(url, JSON.stringify(itemRequestData), { "Accept": accept, "Content-Type": "application/json" })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItem(path10, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItemContent(path10, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of Tfvc items
       *
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {boolean} includeLinks - True to include links.
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor
       */
      getItems(project, scopePath, recursionLevel, includeLinks, versionDescriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopePath,
              recursionLevel,
              includeLinks,
              versionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItemText(path10, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItemZip(path10, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path10,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get items under a label.
       *
       * @param {string} labelId - Unique identifier of label
       * @param {number} top - Max number of items to return
       * @param {number} skip - Number of items to skip
       */
      getLabelItems(labelId, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              labelId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "06166e34-de17-4b60-8cd1-23182a346fda", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single deep label.
       *
       * @param {string} labelId - Unique identifier of label
       * @param {TfvcInterfaces.TfvcLabelRequestData} requestData - maxItemCount
       * @param {string} project - Project ID or project name
       */
      getLabel(labelId, requestData, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (requestData == null) {
            throw new TypeError("requestData can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              labelId
            };
            let queryValues = {
              requestData
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "a5d9bd7f-b661-4d0e-b9be-d9c16affae54", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcLabel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of shallow label references.
       *
       * @param {TfvcInterfaces.TfvcLabelRequestData} requestData - labelScope, name, owner, and itemLabelFilter
       * @param {string} project - Project ID or project name
       * @param {number} top - Max number of labels to return, defaults to 100 when undefined
       * @param {number} skip - Number of labels to skip
       */
      getLabels(requestData, project, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (requestData == null) {
            throw new TypeError("requestData can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              requestData,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "a5d9bd7f-b661-4d0e-b9be-d9c16affae54", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcLabelRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get changes included in a shelveset.
       *
       * @param {string} shelvesetId - Shelveset's unique ID
       * @param {number} top - Max number of changes to return
       * @param {number} skip - Number of changes to skip
       */
      getShelvesetChanges(shelvesetId, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (shelvesetId == null) {
            throw new TypeError("shelvesetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              shelvesetId,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "dbaf075b-0445-4c34-9e5b-82292f856522", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChange, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single deep shelveset.
       *
       * @param {string} shelvesetId - Shelveset's unique ID
       * @param {TfvcInterfaces.TfvcShelvesetRequestData} requestData - includeDetails, includeWorkItems, maxChangeCount, and maxCommentLength
       */
      getShelveset(shelvesetId, requestData) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (shelvesetId == null) {
            throw new TypeError("shelvesetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              shelvesetId,
              requestData
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "e36d44fb-e907-4b0a-b194-f83f1ed32ad3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcShelveset, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Return a collection of shallow shelveset references.
       *
       * @param {TfvcInterfaces.TfvcShelvesetRequestData} requestData - name, owner, and maxCommentLength
       * @param {number} top - Max number of shelvesets to return
       * @param {number} skip - Number of shelvesets to skip
       */
      getShelvesets(requestData, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              requestData,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "e36d44fb-e907-4b0a-b194-f83f1ed32ad3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcShelvesetRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get work items associated with a shelveset.
       *
       * @param {string} shelvesetId - Shelveset's unique ID
       */
      getShelvesetWorkItems(shelvesetId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (shelvesetId == null) {
            throw new TypeError("shelvesetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              shelvesetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "a7a0c1c1-373e-425a-b031-a519474d743d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Provides File Count and Uncompressed Bytes for a Collection/Project at a particular scope for TFVC.
       *
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - '$/' for collection, '$/project' for specific project
       */
      getTfvcStatistics(project, scopePath) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "e15c74c0-3605-40e0-aed4-4cc61e549ed8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TfvcApi = TfvcApi;
    TfvcApi.RESOURCE_AREA_ID = "8aa40520-446d-40e6-89f6-9c9f9ce44c48";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/CommentsInterfaces.js
var require_CommentsInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/CommentsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.CommentState = exports2.CommentSortOrder = exports2.CommentReactionType = exports2.CommentMentionType = exports2.CommentFormat = exports2.CommentExpandOptions = void 0;
    var CommentExpandOptions;
    (function(CommentExpandOptions2) {
      CommentExpandOptions2[CommentExpandOptions2["None"] = 0] = "None";
      CommentExpandOptions2[CommentExpandOptions2["Reactions"] = 1] = "Reactions";
      CommentExpandOptions2[CommentExpandOptions2["RenderedText"] = 8] = "RenderedText";
      CommentExpandOptions2[CommentExpandOptions2["RenderedTextOnly"] = 16] = "RenderedTextOnly";
      CommentExpandOptions2[CommentExpandOptions2["Children"] = 32] = "Children";
      CommentExpandOptions2[CommentExpandOptions2["All"] = -17] = "All";
    })(CommentExpandOptions = exports2.CommentExpandOptions || (exports2.CommentExpandOptions = {}));
    var CommentFormat;
    (function(CommentFormat2) {
      CommentFormat2[CommentFormat2["Markdown"] = 0] = "Markdown";
      CommentFormat2[CommentFormat2["Html"] = 1] = "Html";
    })(CommentFormat = exports2.CommentFormat || (exports2.CommentFormat = {}));
    var CommentMentionType;
    (function(CommentMentionType2) {
      CommentMentionType2[CommentMentionType2["Person"] = 0] = "Person";
      CommentMentionType2[CommentMentionType2["WorkItem"] = 1] = "WorkItem";
      CommentMentionType2[CommentMentionType2["PullRequest"] = 2] = "PullRequest";
    })(CommentMentionType = exports2.CommentMentionType || (exports2.CommentMentionType = {}));
    var CommentReactionType;
    (function(CommentReactionType2) {
      CommentReactionType2[CommentReactionType2["Like"] = 0] = "Like";
      CommentReactionType2[CommentReactionType2["Dislike"] = 1] = "Dislike";
      CommentReactionType2[CommentReactionType2["Heart"] = 2] = "Heart";
      CommentReactionType2[CommentReactionType2["Hooray"] = 3] = "Hooray";
      CommentReactionType2[CommentReactionType2["Smile"] = 4] = "Smile";
      CommentReactionType2[CommentReactionType2["Confused"] = 5] = "Confused";
    })(CommentReactionType = exports2.CommentReactionType || (exports2.CommentReactionType = {}));
    var CommentSortOrder;
    (function(CommentSortOrder2) {
      CommentSortOrder2[CommentSortOrder2["Asc"] = 1] = "Asc";
      CommentSortOrder2[CommentSortOrder2["Desc"] = 2] = "Desc";
    })(CommentSortOrder = exports2.CommentSortOrder || (exports2.CommentSortOrder = {}));
    var CommentState;
    (function(CommentState2) {
      CommentState2[CommentState2["Active"] = 0] = "Active";
      CommentState2[CommentState2["Resolved"] = 1] = "Resolved";
      CommentState2[CommentState2["Closed"] = 2] = "Closed";
    })(CommentState = exports2.CommentState || (exports2.CommentState = {}));
    exports2.TypeInfo = {
      Comment: {},
      CommentAttachment: {},
      CommentExpandOptions: {
        enumValues: {
          "none": 0,
          "reactions": 1,
          "renderedText": 8,
          "renderedTextOnly": 16,
          "children": 32,
          "all": -17
        }
      },
      CommentFormat: {
        enumValues: {
          "markdown": 0,
          "html": 1
        }
      },
      CommentList: {},
      CommentMention: {},
      CommentMentionType: {
        enumValues: {
          "person": 0,
          "workItem": 1,
          "pullRequest": 2
        }
      },
      CommentReaction: {},
      CommentReactionType: {
        enumValues: {
          "like": 0,
          "dislike": 1,
          "heart": 2,
          "hooray": 3,
          "smile": 4,
          "confused": 5
        }
      },
      CommentSortOrder: {
        enumValues: {
          "asc": 1,
          "desc": 2
        }
      },
      CommentState: {
        enumValues: {
          "active": 0,
          "resolved": 1,
          "closed": 2
        }
      },
      CommentUpdateParameters: {},
      CommentVersion: {}
    };
    exports2.TypeInfo.Comment.fields = {
      createdDate: {
        isDate: true
      },
      mentions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CommentMention
      },
      modifiedDate: {
        isDate: true
      },
      reactions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CommentReaction
      },
      replies: {
        typeInfo: exports2.TypeInfo.CommentList
      },
      state: {
        enumType: exports2.TypeInfo.CommentState
      }
    };
    exports2.TypeInfo.CommentAttachment.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CommentList.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      }
    };
    exports2.TypeInfo.CommentMention.fields = {
      type: {
        enumType: exports2.TypeInfo.CommentMentionType
      }
    };
    exports2.TypeInfo.CommentReaction.fields = {
      type: {
        enumType: exports2.TypeInfo.CommentReactionType
      }
    };
    exports2.TypeInfo.CommentUpdateParameters.fields = {
      state: {
        enumType: exports2.TypeInfo.CommentState
      }
    };
    exports2.TypeInfo.CommentVersion.fields = {
      createdDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.CommentState
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/WikiInterfaces.js
var require_WikiInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/WikiInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WikiType = void 0;
    var GitInterfaces = require_GitInterfaces();
    var WikiType;
    (function(WikiType2) {
      WikiType2[WikiType2["ProjectWiki"] = 0] = "ProjectWiki";
      WikiType2[WikiType2["CodeWiki"] = 1] = "CodeWiki";
    })(WikiType = exports2.WikiType || (exports2.WikiType = {}));
    exports2.TypeInfo = {
      Wiki: {},
      WikiCreateBaseParameters: {},
      WikiCreateParametersV2: {},
      WikiPageDetail: {},
      WikiPageStat: {},
      WikiPageViewStats: {},
      WikiType: {
        enumValues: {
          "projectWiki": 0,
          "codeWiki": 1
        }
      },
      WikiUpdateParameters: {},
      WikiV2: {}
    };
    exports2.TypeInfo.Wiki.fields = {
      repository: {
        typeInfo: GitInterfaces.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.WikiCreateBaseParameters.fields = {
      type: {
        enumType: exports2.TypeInfo.WikiType
      }
    };
    exports2.TypeInfo.WikiCreateParametersV2.fields = {
      type: {
        enumType: exports2.TypeInfo.WikiType
      },
      version: {
        typeInfo: GitInterfaces.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.WikiPageDetail.fields = {
      viewStats: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WikiPageStat
      }
    };
    exports2.TypeInfo.WikiPageStat.fields = {
      day: {
        isDate: true
      }
    };
    exports2.TypeInfo.WikiPageViewStats.fields = {
      lastViewedTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.WikiUpdateParameters.fields = {
      versions: {
        isArray: true,
        typeInfo: GitInterfaces.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.WikiV2.fields = {
      type: {
        enumType: exports2.TypeInfo.WikiType
      },
      versions: {
        isArray: true,
        typeInfo: GitInterfaces.TypeInfo.GitVersionDescriptor
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/WikiApi.js
var require_WikiApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/WikiApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WikiApi = void 0;
    var basem = require_ClientApiBases();
    var Comments_Contracts = require_CommentsInterfaces();
    var WikiInterfaces = require_WikiInterfaces();
    var WikiApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Wiki-api", options2);
      }
      /**
       * Uploads an attachment on a comment on a wiki page.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       */
      createCommentAttachment(customHeaders, contentStream, project, wikiIdentifier, pageId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "5100d976-363d-42e7-a19d-4171ecb44782", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Downloads an attachment on a comment on a wiki page.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {string} attachmentId - Attachment ID.
       */
      getAttachmentContent(project, wikiIdentifier, pageId, attachmentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "5100d976-363d-42e7-a19d-4171ecb44782", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a reaction on a wiki page comment.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name
       * @param {number} pageId - Wiki page ID
       * @param {number} commentId - ID of the associated comment
       * @param {Comments_Contracts.CommentReactionType} type - Type of the reaction being added
       */
      addCommentReaction(project, wikiIdentifier, pageId, commentId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              commentId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "7a5bc693-aab7-4d48-8f34-36f373022063", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a reaction on a wiki page comment.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or name
       * @param {number} pageId - Wiki page ID
       * @param {number} commentId - ID of the associated comment
       * @param {Comments_Contracts.CommentReactionType} type - Type of the reaction being deleted
       */
      deleteCommentReaction(project, wikiIdentifier, pageId, commentId, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              commentId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "7a5bc693-aab7-4d48-8f34-36f373022063", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of users who have reacted for the given wiki comment with a given reaction type. Supports paging, with a default page size of 100 users at a time.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} commentId - ID of the associated comment
       * @param {Comments_Contracts.CommentReactionType} type - Type of the reaction for which the engaged users are being requested
       * @param {number} top - Number of enagaged users to be returned in a given page. Optional, defaults to 100
       * @param {number} skip - Number of engaged users to be skipped to page the next set of engaged users, defaults to 0
       */
      getEngagedUsers(project, wikiIdentifier, pageId, commentId, type, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              commentId,
              type
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "598a5268-41a7-4162-b7dc-344131e4d1fa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a comment on a wiki page.
       *
       * @param {Comments_Contracts.CommentCreateParameters} request - Comment create request.
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       */
      addComment(request, project, wikiIdentifier, pageId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options2);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a comment on a wiki page.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} id - Comment ID.
       */
      deleteComment(project, wikiIdentifier, pageId, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a comment associated with the Wiki Page.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} id - ID of the comment to return.
       * @param {boolean} excludeDeleted - Specify if the deleted comment should be skipped.
       * @param {Comments_Contracts.CommentExpandOptions} expand - Specifies the additional data retrieval options for comments.
       */
      getComment(project, wikiIdentifier, pageId, id, excludeDeleted, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              id
            };
            let queryValues = {
              excludeDeleted,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a pageable list of comments.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} top - Max number of comments to return.
       * @param {string} continuationToken - Used to query for the next page of comments.
       * @param {boolean} excludeDeleted - Specify if the deleted comments should be skipped.
       * @param {Comments_Contracts.CommentExpandOptions} expand - Specifies the additional data retrieval options for comments.
       * @param {Comments_Contracts.CommentSortOrder} order - Order in which the comments should be returned.
       * @param {number} parentId - CommentId of the parent comment.
       */
      listComments(project, wikiIdentifier, pageId, top, continuationToken, excludeDeleted, expand, order, parentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            let queryValues = {
              "$top": top,
              continuationToken,
              excludeDeleted,
              "$expand": expand,
              order,
              parentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentList, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a comment on a wiki page.
       *
       * @param {Comments_Contracts.CommentUpdateParameters} comment - Comment update request.
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} id - Comment ID.
       */
      updateComment(comment, project, wikiIdentifier, pageId, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, comment, options2);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided path. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} path - Wiki page path.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - GitVersionDescriptor for the page. Defaults to the default branch (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageText(project, wikiIdentifier, path10, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              path: path10,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "25d3fbc7-fe3d-46cb-b5a5-0b6f79caf27b", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided path. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} path - Wiki page path.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - GitVersionDescriptor for the page. Defaults to the default branch (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageZip(project, wikiIdentifier, path10, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              path: path10,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "25d3fbc7-fe3d-46cb-b5a5-0b6f79caf27b", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided page id. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name..
       * @param {number} id - Wiki page ID.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageByIdText(project, wikiIdentifier, id, recursionLevel, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              id
            };
            let queryValues = {
              recursionLevel,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "ceddcf75-1068-452d-8b13-2d4d76e1f970", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided page id. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name..
       * @param {number} id - Wiki page ID.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageByIdZip(project, wikiIdentifier, id, recursionLevel, includeContent) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              id
            };
            let queryValues = {
              recursionLevel,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "ceddcf75-1068-452d-8b13-2d4d76e1f970", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns pageable list of Wiki Pages
       *
       * @param {WikiInterfaces.WikiPagesBatchRequest} pagesBatchRequest - Wiki batch page request.
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - GitVersionDescriptor for the page. (Optional in case of ProjectWiki).
       */
      getPagesBatch(pagesBatchRequest, project, wikiIdentifier, versionDescriptor) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              versionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "71323c46-2592-4398-8771-ced73dd87207", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, pagesBatchRequest, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiPageDetail, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns page detail corresponding to Page ID.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} pageViewsForDays - last N days from the current day for which page views is to be returned. It's inclusive of current day.
       */
      getPageData(project, wikiIdentifier, pageId, pageViewsForDays) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            let queryValues = {
              pageViewsForDays
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "81c4e0fe-7663-4d62-ad46-6ab78459f274", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiPageDetail, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new page view stats resource or updates an existing page view stats resource.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {GitInterfaces.GitVersionDescriptor} wikiVersion - Wiki version.
       * @param {string} path - Wiki page path.
       * @param {string} oldPath - Old page path. This is optional and required to rename path in existing page view stats.
       */
      createOrUpdatePageViewStats(project, wikiIdentifier, wikiVersion, path10, oldPath) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (wikiVersion == null) {
            throw new TypeError("wikiVersion can not be null or undefined");
          }
          if (path10 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              wikiVersion,
              path: path10,
              oldPath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "1087b746-5d15-41b9-bea6-14e325e7f880", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiPageViewStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates the wiki resource.
       *
       * @param {WikiInterfaces.WikiCreateParametersV2} wikiCreateParams - Parameters for the wiki creation.
       * @param {string} project - Project ID or project name
       */
      createWiki(wikiCreateParams, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, wikiCreateParams, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the wiki corresponding to the wiki ID or wiki name provided.
       *
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} project - Project ID or project name
       */
      deleteWiki(wikiIdentifier, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all wikis in a project or collection.
       *
       * @param {string} project - Project ID or project name
       */
      getAllWikis(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the wiki corresponding to the wiki ID or wiki name provided.
       *
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} project - Project ID or project name
       */
      getWiki(wikiIdentifier, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the wiki corresponding to the wiki ID or wiki name provided using the update parameters.
       *
       * @param {WikiInterfaces.WikiUpdateParameters} updateParameters - Update parameters.
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} project - Project ID or project name
       */
      updateWiki(updateParameters, wikiIdentifier, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options2);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WikiApi = WikiApi;
    WikiApi.RESOURCE_AREA_ID = "bf7d82a0-8aa5-4613-94ef-6172a5ea01f3";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/common/System.js
var require_System = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/common/System.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.DayOfWeek = void 0;
    var DayOfWeek;
    (function(DayOfWeek2) {
      DayOfWeek2[DayOfWeek2["Sunday"] = 0] = "Sunday";
      DayOfWeek2[DayOfWeek2["Monday"] = 1] = "Monday";
      DayOfWeek2[DayOfWeek2["Tuesday"] = 2] = "Tuesday";
      DayOfWeek2[DayOfWeek2["Wednesday"] = 3] = "Wednesday";
      DayOfWeek2[DayOfWeek2["Thursday"] = 4] = "Thursday";
      DayOfWeek2[DayOfWeek2["Friday"] = 5] = "Friday";
      DayOfWeek2[DayOfWeek2["Saturday"] = 6] = "Saturday";
    })(DayOfWeek = exports2.DayOfWeek || (exports2.DayOfWeek = {}));
    exports2.TypeInfo = {
      DayOfWeek: {
        enumValues: {
          "sunday": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 3,
          "thursday": 4,
          "friday": 5,
          "saturday": 6
        }
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/WorkInterfaces.js
var require_WorkInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/WorkInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.TimelineTeamStatusCode = exports2.TimelineIterationStatusCode = exports2.TimelineCriteriaStatusCode = exports2.TimeFrame = exports2.PlanUserPermissions = exports2.PlanType = exports2.IdentityDisplayFormat = exports2.FieldType = exports2.BugsBehavior = exports2.BoardColumnType = exports2.BoardBadgeColumnOptions = exports2.BacklogType = void 0;
    var SystemInterfaces = require_System();
    var BacklogType;
    (function(BacklogType2) {
      BacklogType2[BacklogType2["Portfolio"] = 0] = "Portfolio";
      BacklogType2[BacklogType2["Requirement"] = 1] = "Requirement";
      BacklogType2[BacklogType2["Task"] = 2] = "Task";
    })(BacklogType = exports2.BacklogType || (exports2.BacklogType = {}));
    var BoardBadgeColumnOptions;
    (function(BoardBadgeColumnOptions2) {
      BoardBadgeColumnOptions2[BoardBadgeColumnOptions2["InProgressColumns"] = 0] = "InProgressColumns";
      BoardBadgeColumnOptions2[BoardBadgeColumnOptions2["AllColumns"] = 1] = "AllColumns";
      BoardBadgeColumnOptions2[BoardBadgeColumnOptions2["CustomColumns"] = 2] = "CustomColumns";
    })(BoardBadgeColumnOptions = exports2.BoardBadgeColumnOptions || (exports2.BoardBadgeColumnOptions = {}));
    var BoardColumnType;
    (function(BoardColumnType2) {
      BoardColumnType2[BoardColumnType2["Incoming"] = 0] = "Incoming";
      BoardColumnType2[BoardColumnType2["InProgress"] = 1] = "InProgress";
      BoardColumnType2[BoardColumnType2["Outgoing"] = 2] = "Outgoing";
    })(BoardColumnType = exports2.BoardColumnType || (exports2.BoardColumnType = {}));
    var BugsBehavior;
    (function(BugsBehavior2) {
      BugsBehavior2[BugsBehavior2["Off"] = 0] = "Off";
      BugsBehavior2[BugsBehavior2["AsRequirements"] = 1] = "AsRequirements";
      BugsBehavior2[BugsBehavior2["AsTasks"] = 2] = "AsTasks";
    })(BugsBehavior = exports2.BugsBehavior || (exports2.BugsBehavior = {}));
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 0] = "String";
      FieldType2[FieldType2["PlainText"] = 1] = "PlainText";
      FieldType2[FieldType2["Integer"] = 2] = "Integer";
      FieldType2[FieldType2["DateTime"] = 3] = "DateTime";
      FieldType2[FieldType2["TreePath"] = 4] = "TreePath";
      FieldType2[FieldType2["Boolean"] = 5] = "Boolean";
      FieldType2[FieldType2["Double"] = 6] = "Double";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var IdentityDisplayFormat;
    (function(IdentityDisplayFormat2) {
      IdentityDisplayFormat2[IdentityDisplayFormat2["AvatarOnly"] = 0] = "AvatarOnly";
      IdentityDisplayFormat2[IdentityDisplayFormat2["FullName"] = 1] = "FullName";
      IdentityDisplayFormat2[IdentityDisplayFormat2["AvatarAndFullName"] = 2] = "AvatarAndFullName";
    })(IdentityDisplayFormat = exports2.IdentityDisplayFormat || (exports2.IdentityDisplayFormat = {}));
    var PlanType;
    (function(PlanType2) {
      PlanType2[PlanType2["DeliveryTimelineView"] = 0] = "DeliveryTimelineView";
    })(PlanType = exports2.PlanType || (exports2.PlanType = {}));
    var PlanUserPermissions;
    (function(PlanUserPermissions2) {
      PlanUserPermissions2[PlanUserPermissions2["None"] = 0] = "None";
      PlanUserPermissions2[PlanUserPermissions2["View"] = 1] = "View";
      PlanUserPermissions2[PlanUserPermissions2["Edit"] = 2] = "Edit";
      PlanUserPermissions2[PlanUserPermissions2["Delete"] = 4] = "Delete";
      PlanUserPermissions2[PlanUserPermissions2["Manage"] = 8] = "Manage";
      PlanUserPermissions2[PlanUserPermissions2["AllPermissions"] = 15] = "AllPermissions";
    })(PlanUserPermissions = exports2.PlanUserPermissions || (exports2.PlanUserPermissions = {}));
    var TimeFrame;
    (function(TimeFrame2) {
      TimeFrame2[TimeFrame2["Past"] = 0] = "Past";
      TimeFrame2[TimeFrame2["Current"] = 1] = "Current";
      TimeFrame2[TimeFrame2["Future"] = 2] = "Future";
    })(TimeFrame = exports2.TimeFrame || (exports2.TimeFrame = {}));
    var TimelineCriteriaStatusCode;
    (function(TimelineCriteriaStatusCode2) {
      TimelineCriteriaStatusCode2[TimelineCriteriaStatusCode2["OK"] = 0] = "OK";
      TimelineCriteriaStatusCode2[TimelineCriteriaStatusCode2["InvalidFilterClause"] = 1] = "InvalidFilterClause";
      TimelineCriteriaStatusCode2[TimelineCriteriaStatusCode2["Unknown"] = 2] = "Unknown";
    })(TimelineCriteriaStatusCode = exports2.TimelineCriteriaStatusCode || (exports2.TimelineCriteriaStatusCode = {}));
    var TimelineIterationStatusCode;
    (function(TimelineIterationStatusCode2) {
      TimelineIterationStatusCode2[TimelineIterationStatusCode2["OK"] = 0] = "OK";
      TimelineIterationStatusCode2[TimelineIterationStatusCode2["IsOverlapping"] = 1] = "IsOverlapping";
    })(TimelineIterationStatusCode = exports2.TimelineIterationStatusCode || (exports2.TimelineIterationStatusCode = {}));
    var TimelineTeamStatusCode;
    (function(TimelineTeamStatusCode2) {
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["OK"] = 0] = "OK";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["DoesntExistOrAccessDenied"] = 1] = "DoesntExistOrAccessDenied";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["MaxTeamsExceeded"] = 2] = "MaxTeamsExceeded";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["MaxTeamFieldsExceeded"] = 3] = "MaxTeamFieldsExceeded";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["BacklogInError"] = 4] = "BacklogInError";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["MissingTeamFieldValue"] = 5] = "MissingTeamFieldValue";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["NoIterationsExist"] = 6] = "NoIterationsExist";
    })(TimelineTeamStatusCode = exports2.TimelineTeamStatusCode || (exports2.TimelineTeamStatusCode = {}));
    exports2.TypeInfo = {
      BacklogConfiguration: {},
      BacklogLevelConfiguration: {},
      BacklogType: {
        enumValues: {
          "portfolio": 0,
          "requirement": 1,
          "task": 2
        }
      },
      Board: {},
      BoardBadgeColumnOptions: {
        enumValues: {
          "inProgressColumns": 0,
          "allColumns": 1,
          "customColumns": 2
        }
      },
      BoardColumn: {},
      BoardColumnType: {
        enumValues: {
          "incoming": 0,
          "inProgress": 1,
          "outgoing": 2
        }
      },
      BugsBehavior: {
        enumValues: {
          "off": 0,
          "asRequirements": 1,
          "asTasks": 2
        }
      },
      CapacityContractBase: {},
      CapacityPatch: {},
      CardFieldSettings: {},
      CardSettings: {},
      CreatePlan: {},
      DateRange: {},
      DeliveryViewData: {},
      DeliveryViewPropertyCollection: {},
      FieldInfo: {},
      FieldType: {
        enumValues: {
          "string": 0,
          "plainText": 1,
          "integer": 2,
          "dateTime": 3,
          "treePath": 4,
          "boolean": 5,
          "double": 6
        }
      },
      IdentityDisplayFormat: {
        enumValues: {
          "avatarOnly": 0,
          "fullName": 1,
          "avatarAndFullName": 2
        }
      },
      Marker: {},
      Plan: {},
      PlanMetadata: {},
      PlanType: {
        enumValues: {
          "deliveryTimelineView": 0
        }
      },
      PlanUserPermissions: {
        enumValues: {
          "none": 0,
          "view": 1,
          "edit": 2,
          "delete": 4,
          "manage": 8,
          "allPermissions": 15
        }
      },
      TeamCapacity: {},
      TeamIterationAttributes: {},
      TeamMemberCapacity: {},
      TeamMemberCapacityIdentityRef: {},
      TeamSetting: {},
      TeamSettingsDaysOff: {},
      TeamSettingsDaysOffPatch: {},
      TeamSettingsIteration: {},
      TeamSettingsPatch: {},
      TimeFrame: {
        enumValues: {
          "past": 0,
          "current": 1,
          "future": 2
        }
      },
      TimelineCriteriaStatus: {},
      TimelineCriteriaStatusCode: {
        enumValues: {
          "ok": 0,
          "invalidFilterClause": 1,
          "unknown": 2
        }
      },
      TimelineIterationStatus: {},
      TimelineIterationStatusCode: {
        enumValues: {
          "ok": 0,
          "isOverlapping": 1
        }
      },
      TimelineTeamData: {},
      TimelineTeamIteration: {},
      TimelineTeamStatus: {},
      TimelineTeamStatusCode: {
        enumValues: {
          "ok": 0,
          "doesntExistOrAccessDenied": 1,
          "maxTeamsExceeded": 2,
          "maxTeamFieldsExceeded": 3,
          "backlogInError": 4,
          "missingTeamFieldValue": 5,
          "noIterationsExist": 6
        }
      },
      UpdatePlan: {}
    };
    exports2.TypeInfo.BacklogConfiguration.fields = {
      bugsBehavior: {
        enumType: exports2.TypeInfo.BugsBehavior
      },
      portfolioBacklogs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BacklogLevelConfiguration
      },
      requirementBacklog: {
        typeInfo: exports2.TypeInfo.BacklogLevelConfiguration
      },
      taskBacklog: {
        typeInfo: exports2.TypeInfo.BacklogLevelConfiguration
      }
    };
    exports2.TypeInfo.BacklogLevelConfiguration.fields = {
      type: {
        enumType: exports2.TypeInfo.BacklogType
      }
    };
    exports2.TypeInfo.Board.fields = {
      columns: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BoardColumn
      }
    };
    exports2.TypeInfo.BoardColumn.fields = {
      columnType: {
        enumType: exports2.TypeInfo.BoardColumnType
      }
    };
    exports2.TypeInfo.CapacityContractBase.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.CapacityPatch.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.CardFieldSettings.fields = {
      additionalFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.FieldInfo
      },
      assignedToDisplayFormat: {
        enumType: exports2.TypeInfo.IdentityDisplayFormat
      },
      coreFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.FieldInfo
      }
    };
    exports2.TypeInfo.CardSettings.fields = {
      fields: {
        typeInfo: exports2.TypeInfo.CardFieldSettings
      }
    };
    exports2.TypeInfo.CreatePlan.fields = {
      type: {
        enumType: exports2.TypeInfo.PlanType
      }
    };
    exports2.TypeInfo.DateRange.fields = {
      end: {
        isDate: true
      },
      start: {
        isDate: true
      }
    };
    exports2.TypeInfo.DeliveryViewData.fields = {
      criteriaStatus: {
        typeInfo: exports2.TypeInfo.TimelineCriteriaStatus
      },
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      teams: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineTeamData
      }
    };
    exports2.TypeInfo.DeliveryViewPropertyCollection.fields = {
      cardSettings: {
        typeInfo: exports2.TypeInfo.CardSettings
      },
      markers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Marker
      }
    };
    exports2.TypeInfo.FieldInfo.fields = {
      fieldType: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.Marker.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.Plan.fields = {
      createdDate: {
        isDate: true
      },
      lastAccessed: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.PlanType
      },
      userPermissions: {
        enumType: exports2.TypeInfo.PlanUserPermissions
      }
    };
    exports2.TypeInfo.PlanMetadata.fields = {
      modifiedDate: {
        isDate: true
      },
      userPermissions: {
        enumType: exports2.TypeInfo.PlanUserPermissions
      }
    };
    exports2.TypeInfo.TeamCapacity.fields = {
      teamMembers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TeamMemberCapacityIdentityRef
      }
    };
    exports2.TypeInfo.TeamIterationAttributes.fields = {
      finishDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      timeFrame: {
        enumType: exports2.TypeInfo.TimeFrame
      }
    };
    exports2.TypeInfo.TeamMemberCapacity.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamMemberCapacityIdentityRef.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamSetting.fields = {
      backlogIteration: {
        typeInfo: exports2.TypeInfo.TeamSettingsIteration
      },
      bugsBehavior: {
        enumType: exports2.TypeInfo.BugsBehavior
      },
      defaultIteration: {
        typeInfo: exports2.TypeInfo.TeamSettingsIteration
      },
      workingDays: {
        isArray: true,
        enumType: SystemInterfaces.TypeInfo.DayOfWeek
      }
    };
    exports2.TypeInfo.TeamSettingsDaysOff.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamSettingsDaysOffPatch.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamSettingsIteration.fields = {
      attributes: {
        typeInfo: exports2.TypeInfo.TeamIterationAttributes
      }
    };
    exports2.TypeInfo.TeamSettingsPatch.fields = {
      bugsBehavior: {
        enumType: exports2.TypeInfo.BugsBehavior
      },
      workingDays: {
        isArray: true,
        enumType: SystemInterfaces.TypeInfo.DayOfWeek
      }
    };
    exports2.TypeInfo.TimelineCriteriaStatus.fields = {
      type: {
        enumType: exports2.TypeInfo.TimelineCriteriaStatusCode
      }
    };
    exports2.TypeInfo.TimelineIterationStatus.fields = {
      type: {
        enumType: exports2.TypeInfo.TimelineIterationStatusCode
      }
    };
    exports2.TypeInfo.TimelineTeamData.fields = {
      iterations: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineTeamIteration
      },
      status: {
        typeInfo: exports2.TypeInfo.TimelineTeamStatus
      }
    };
    exports2.TypeInfo.TimelineTeamIteration.fields = {
      finishDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      status: {
        typeInfo: exports2.TypeInfo.TimelineIterationStatus
      }
    };
    exports2.TypeInfo.TimelineTeamStatus.fields = {
      type: {
        enumType: exports2.TypeInfo.TimelineTeamStatusCode
      }
    };
    exports2.TypeInfo.UpdatePlan.fields = {
      type: {
        enumType: exports2.TypeInfo.PlanType
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/WorkApi.js
var require_WorkApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/WorkApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkApi = void 0;
    var basem = require_ClientApiBases();
    var WorkInterfaces = require_WorkInterfaces();
    var WorkApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Work-api", options2);
      }
      /**
       * Creates/updates an automation rules settings
       *
       * @param {WorkInterfaces.TeamAutomationRulesSettingsRequestModel} ruleRequestModel - Required parameters to create/update an automation rules settings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateAutomationRule(ruleRequestModel, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "2882c15d-0cb3-43b5-8fb7-db62e09a79db", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, ruleRequestModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets backlog configuration for a team
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getBacklogConfigurations(teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "7799f497-3cb5-4f16-ad4f-5cd06012db64", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BacklogConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of work items within a backlog level
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} backlogId
       */
      getBacklogLevelWorkItems(teamContext, backlogId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              backlogId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "7c468d96-ab1d-4294-a360-92f07e9ccd98", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a backlog level
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - The id of the backlog level
       */
      getBacklog(teamContext, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "a93726f9-7867-4e38-b4f2-0bfafc2f6a94", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BacklogLevelConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List all backlog levels
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getBacklogs(teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "a93726f9-7867-4e38-b4f2-0bfafc2f6a94", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BacklogLevelConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that displays the status of columns on the board.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - The id of the board.
       * @param {WorkInterfaces.BoardBadgeColumnOptions} columnOptions - Determines what columns to show.
       * @param {string[]} columns - If columnOptions is set to custom, specify the list of column names.
       */
      getBoardBadge(teamContext, id, columnOptions, columns) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            let queryValues = {
              columnOptions,
              columns: columns && columns.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0120b002-ab6c-4ca0-98cf-a8d7492f865c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that displays the status of columns on the board.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - The id of the board.
       * @param {WorkInterfaces.BoardBadgeColumnOptions} columnOptions - Determines what columns to show.
       * @param {string[]} columns - If columnOptions is set to custom, specify the list of column names.
       */
      getBoardBadgeData(teamContext, id, columnOptions, columns) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            let queryValues = {
              columnOptions,
              columns: columns && columns.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0120b002-ab6c-4ca0-98cf-a8d7492f865c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get available board columns in a project
       *
       * @param {string} project - Project ID or project name
       */
      getColumnSuggestedValues(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "eb7ec5a3-1ba3-4fd1-b834-49a5a387e57d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of parent field filter model for the given list of workitem ids
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} childBacklogContextCategoryRefName
       * @param {number[]} workitemIds
       */
      getBoardMappingParentItems(teamContext, childBacklogContextCategoryRefName, workitemIds) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (childBacklogContextCategoryRefName == null) {
            throw new TypeError("childBacklogContextCategoryRefName can not be null or undefined");
          }
          if (workitemIds == null) {
            throw new TypeError("workitemIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              childBacklogContextCategoryRefName,
              workitemIds: workitemIds && workitemIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "186abea3-5c35-432f-9e28-7a15b4312a0e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get available board rows in a project
       *
       * @param {string} project - Project ID or project name
       */
      getRowSuggestedValues(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "bb494cc6-a0f5-4c6c-8dca-ea6912e79eb9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - identifier for board, either board's backlog level name (Eg:"Stories") or Id
       */
      getBoard(teamContext, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "23ad19fc-3b8e-4877-8462-b3f92bc06b40", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Board, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get boards
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getBoards(teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "23ad19fc-3b8e-4877-8462-b3f92bc06b40", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board options
       *
       * @param {{ [key: string] : string; }} options - options to updated
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - identifier for board, either category plural name (Eg:"Stories") or guid
       */
      setBoardOptions(options2, teamContext, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "23ad19fc-3b8e-4877-8462-b3f92bc06b40", routeValues);
              let url = verData.requestUrl;
              let options3 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, options3, options3);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board user settings for a board id
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Board ID or Name
       */
      getBoardUserSettings(teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "b30d9f58-1891-4b0a-b168-c46408f919b0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board user settings for the board id
       *
       * @param {{ [key: string] : string; }} boardUserSettings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      updateBoardUserSettings(boardUserSettings, teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "b30d9f58-1891-4b0a-b168-c46408f919b0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, boardUserSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team's capacity including total capacity and days off
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      getCapacitiesWithIdentityRefAndTotals(teamContext, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamCapacity, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team member's capacity
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       * @param {string} teamMemberId - ID of the team member
       */
      getCapacityWithIdentityRef(teamContext, iterationId, teamMemberId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId,
              teamMemberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamMemberCapacityIdentityRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace a team's capacity
       *
       * @param {WorkInterfaces.TeamMemberCapacityIdentityRef[]} capacities - Team capacity to replace
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      replaceCapacitiesWithIdentityRef(capacities, teamContext, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, capacities, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamMemberCapacityIdentityRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a team member's capacity
       *
       * @param {WorkInterfaces.CapacityPatch} patch - Updated capacity
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       * @param {string} teamMemberId - ID of the team member
       */
      updateCapacityWithIdentityRef(patch, teamContext, iterationId, teamMemberId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId,
              teamMemberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, patch, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamMemberCapacityIdentityRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board card Rule settings for the board id or board by name
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      getBoardCardRuleSettings(teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "b044a3d9-02ea-49c7-91a1-b730949cc896", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board card Rule settings for the board id or board by name
       *
       * @param {WorkInterfaces.BoardCardRuleSettings} boardCardRuleSettings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      updateBoardCardRuleSettings(boardCardRuleSettings, teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "b044a3d9-02ea-49c7-91a1-b730949cc896", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, boardCardRuleSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update taskboard card Rule settings
       *
       * @param {WorkInterfaces.BoardCardRuleSettings} boardCardRuleSettings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTaskboardCardRuleSettings(boardCardRuleSettings, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "3f84a8d1-1aab-423e-a94b-6dcbdcca511f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, boardCardRuleSettings, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board card settings for the board id or board by name
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      getBoardCardSettings(teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "07c3b467-bc60-4f05-8e34-599ce288fafc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board card settings for the board id or board by name
       *
       * @param {WorkInterfaces.BoardCardSettings} boardCardSettingsToSave
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      updateBoardCardSettings(boardCardSettingsToSave, teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "07c3b467-bc60-4f05-8e34-599ce288fafc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardCardSettingsToSave, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update taskboard card settings
       *
       * @param {WorkInterfaces.BoardCardSettings} boardCardSettingsToSave
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTaskboardCardSettings(boardCardSettingsToSave, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "0d63745f-31f3-4cf3-9056-2a064e567637", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardCardSettingsToSave, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a board chart
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Identifier for board, either board's backlog level name (Eg:"Stories") or Id
       * @param {string} name - The chart name
       */
      getBoardChart(teamContext, board, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "45fe888c-239e-49fd-958c-df1a1ab21d97", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board charts
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Identifier for board, either board's backlog level name (Eg:"Stories") or Id
       */
      getBoardCharts(teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "45fe888c-239e-49fd-958c-df1a1ab21d97", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a board chart
       *
       * @param {WorkInterfaces.BoardChart} chart
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Identifier for board, either board's backlog level name (Eg:"Stories") or Id
       * @param {string} name - The chart name
       */
      updateBoardChart(chart, teamContext, board, name) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "45fe888c-239e-49fd-958c-df1a1ab21d97", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, chart, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get columns on a board
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      getBoardColumns(teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c555d7ff-84e1-47df-9923-a3fe0cd8751b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BoardColumn, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update columns on a board
       *
       * @param {WorkInterfaces.BoardColumn[]} boardColumns - List of board columns to update
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      updateBoardColumns(boardColumns, teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c555d7ff-84e1-47df-9923-a3fe0cd8751b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardColumns, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BoardColumn, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Delivery View Data
       *
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier for delivery view
       * @param {number} revision - Revision of the plan for which you want data. If the current plan is a different revision you will get an ViewRevisionMismatchException exception. If you do not supply a revision you will get data for the latest revision.
       * @param {Date} startDate - The start date of timeline
       * @param {Date} endDate - The end date of timeline
       */
      getDeliveryTimelineData(project, id, revision, startDate, endDate) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              revision,
              startDate,
              endDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "bdd0834e-101f-49f0-a6ae-509f384a12b4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.DeliveryViewData, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an iteration's capacity for all teams in iteration
       *
       * @param {string} project - Project ID or project name
       * @param {string} iterationId - ID of the iteration
       */
      getTotalIterationCapacities(project, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1e385ce0-396b-4273-8171-d64562c18d37", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a team's iteration by iterationId
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - ID of the iteration
       */
      deleteTeamIteration(teamContext, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get team's iteration by iterationId
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - ID of the iteration
       */
      getTeamIteration(teamContext, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsIteration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team's iterations using timeframe filter
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} timeframe - A filter for which iterations are returned based on relative time. Only Current is supported currently.
       */
      getTeamIterations(teamContext, timeframe) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              "$timeframe": timeframe
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsIteration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add an iteration to the team
       *
       * @param {WorkInterfaces.TeamSettingsIteration} iteration - Iteration to add
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      postTeamIteration(iteration, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, iteration, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsIteration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a new plan for the team
       *
       * @param {WorkInterfaces.CreatePlan} postedPlan - Plan definition
       * @param {string} project - Project ID or project name
       */
      createPlan(postedPlan, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, postedPlan, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete the specified plan
       *
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier of the plan
       */
      deletePlan(project, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the information for the specified plan
       *
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier of the plan
       */
      getPlan(project, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the information for all the plans configured for the given team
       *
       * @param {string} project - Project ID or project name
       */
      getPlans(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the information for the specified plan
       *
       * @param {WorkInterfaces.UpdatePlan} updatedPlan - Plan definition to be updated
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier of the plan
       */
      updatePlan(updatedPlan, project, id) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, updatedPlan, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves the set of known queries
       *
       * @param {string} project - Project ID or project name
       */
      getPredefinedQueries(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "9cbba37c-6cc6-4f70-b903-709be86acbf0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves the specified predefined query including the query results
       *
       * @param {string} project - Project ID or project name
       * @param {string} id - Id of the query to run
       * @param {number} top - The maximum number of items to return
       * @param {boolean} includeCompleted - Whether or not to retrieve the 'completed' work items (work items in the 'completed' meta state)
       */
      getPredefinedQueryResults(project, id, top, includeCompleted) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              "$top": top,
              includeCompleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "9cbba37c-6cc6-4f70-b903-709be86acbf0", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get process configuration
       *
       * @param {string} project - Project ID or project name
       */
      getProcessConfiguration(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "f901ba42-86d2-4b0c-89c1-3f86d06daa84", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get rows on a board
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      getBoardRows(teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0863355d-aefd-4d63-8669-984c9b7b0e78", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update rows on a board
       *
       * @param {WorkInterfaces.BoardRow[]} boardRows - List of board rows to update
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      updateBoardRows(boardRows, teamContext, board) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0863355d-aefd-4d63-8669-984c9b7b0e78", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardRows, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getColumns(teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c6815dbe-8e7e-4ffe-9a79-e83ee712aa92", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {WorkInterfaces.UpdateTaskboardColumn[]} updateColumns
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateColumns(updateColumns, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c6815dbe-8e7e-4ffe-9a79-e83ee712aa92", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, updateColumns, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId
       */
      getWorkItemColumns(teamContext, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1be23c36-8872-4abc-b57d-402cd6c669d9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {WorkInterfaces.UpdateTaskboardWorkItemColumn} updateColumn
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId
       * @param {number} workItemId
       */
      updateWorkItemColumn(updateColumn, teamContext, iterationId, workItemId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1be23c36-8872-4abc-b57d-402cd6c669d9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateColumn, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get team's days off for an iteration
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      getTeamDaysOff(teamContext, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "2d4faa2e-9150-4cbf-a47a-932b1b4a0773", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsDaysOff, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set a team's days off for an iteration
       *
       * @param {WorkInterfaces.TeamSettingsDaysOffPatch} daysOffPatch - Team's days off patch containing a list of start and end dates
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      updateTeamDaysOff(daysOffPatch, teamContext, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "2d4faa2e-9150-4cbf-a47a-932b1b4a0773", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, daysOffPatch, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsDaysOff, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of team field values
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getTeamFieldValues(teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "07ced576-58ed-49e6-9c1e-5cb53ab8bf2a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update team field values
       *
       * @param {WorkInterfaces.TeamFieldValuesPatch} patch
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTeamFieldValues(patch, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "07ced576-58ed-49e6-9c1e-5cb53ab8bf2a", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, patch, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team's settings
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getTeamSettings(teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c3c1012b-bea7-49d7-b45e-1664e566f84c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSetting, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a team's settings
       *
       * @param {WorkInterfaces.TeamSettingsPatch} teamSettingsPatch - TeamSettings changes
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTeamSettings(teamSettingsPatch, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c3c1012b-bea7-49d7-b45e-1664e566f84c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, teamSettingsPatch, options2);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSetting, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get work items for iteration
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      getIterationWorkItems(teamContext, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "5b3ef1a6-d3ab-44cd-bafd-c7f45db850fa", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reorder Product Backlog/Boards Work Items
       *
       * @param {WorkInterfaces.ReorderOperation} operation
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      reorderBacklogWorkItems(operation, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1c22b714-e7e4-41b9-85e0-56ee13ef55ed", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, operation, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reorder Sprint Backlog/Taskboard Work Items
       *
       * @param {WorkInterfaces.ReorderOperation} operation
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - The id of the iteration
       */
      reorderIterationWorkItems(operation, teamContext, iterationId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "47755db2-d7eb-405a-8c25-675401525fc9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, operation, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkApi = WorkApi;
    WorkApi.RESOURCE_AREA_ID = "1d4f49f9-02b9-4e26-b826-2cdb6195f2a9";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/PipelinesInterfaces.js
var require_PipelinesInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/PipelinesInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.RunState = exports2.RunResult = exports2.RepositoryType = exports2.GetLogExpandOptions = exports2.GetArtifactExpandOptions = exports2.ConfigurationType = void 0;
    var VSSInterfaces = require_VSSInterfaces();
    var ConfigurationType;
    (function(ConfigurationType2) {
      ConfigurationType2[ConfigurationType2["Unknown"] = 0] = "Unknown";
      ConfigurationType2[ConfigurationType2["Yaml"] = 1] = "Yaml";
      ConfigurationType2[ConfigurationType2["DesignerJson"] = 2] = "DesignerJson";
      ConfigurationType2[ConfigurationType2["JustInTime"] = 3] = "JustInTime";
      ConfigurationType2[ConfigurationType2["DesignerHyphenJson"] = 2] = "DesignerHyphenJson";
    })(ConfigurationType = exports2.ConfigurationType || (exports2.ConfigurationType = {}));
    var GetArtifactExpandOptions;
    (function(GetArtifactExpandOptions2) {
      GetArtifactExpandOptions2[GetArtifactExpandOptions2["None"] = 0] = "None";
      GetArtifactExpandOptions2[GetArtifactExpandOptions2["SignedContent"] = 1] = "SignedContent";
    })(GetArtifactExpandOptions = exports2.GetArtifactExpandOptions || (exports2.GetArtifactExpandOptions = {}));
    var GetLogExpandOptions;
    (function(GetLogExpandOptions2) {
      GetLogExpandOptions2[GetLogExpandOptions2["None"] = 0] = "None";
      GetLogExpandOptions2[GetLogExpandOptions2["SignedContent"] = 1] = "SignedContent";
    })(GetLogExpandOptions = exports2.GetLogExpandOptions || (exports2.GetLogExpandOptions = {}));
    var RepositoryType;
    (function(RepositoryType2) {
      RepositoryType2[RepositoryType2["Unknown"] = 0] = "Unknown";
      RepositoryType2[RepositoryType2["GitHub"] = 1] = "GitHub";
      RepositoryType2[RepositoryType2["AzureReposGit"] = 2] = "AzureReposGit";
      RepositoryType2[RepositoryType2["GitHubEnterprise"] = 3] = "GitHubEnterprise";
      RepositoryType2[RepositoryType2["BitBucket"] = 4] = "BitBucket";
      RepositoryType2[RepositoryType2["AzureReposGitHyphenated"] = 2] = "AzureReposGitHyphenated";
    })(RepositoryType = exports2.RepositoryType || (exports2.RepositoryType = {}));
    var RunResult;
    (function(RunResult2) {
      RunResult2[RunResult2["Unknown"] = 0] = "Unknown";
      RunResult2[RunResult2["Succeeded"] = 1] = "Succeeded";
      RunResult2[RunResult2["Failed"] = 2] = "Failed";
      RunResult2[RunResult2["Canceled"] = 4] = "Canceled";
    })(RunResult = exports2.RunResult || (exports2.RunResult = {}));
    var RunState;
    (function(RunState2) {
      RunState2[RunState2["Unknown"] = 0] = "Unknown";
      RunState2[RunState2["InProgress"] = 1] = "InProgress";
      RunState2[RunState2["Canceling"] = 2] = "Canceling";
      RunState2[RunState2["Completed"] = 4] = "Completed";
    })(RunState = exports2.RunState || (exports2.RunState = {}));
    exports2.TypeInfo = {
      Artifact: {},
      ConfigurationType: {
        enumValues: {
          "unknown": 0,
          "yaml": 1,
          "designerJson": 2,
          "justInTime": 3,
          "designerHyphenJson": 2
        }
      },
      CreatePipelineConfigurationParameters: {},
      CreatePipelineParameters: {},
      GetArtifactExpandOptions: {
        enumValues: {
          "none": 0,
          "signedContent": 1
        }
      },
      GetLogExpandOptions: {
        enumValues: {
          "none": 0,
          "signedContent": 1
        }
      },
      Log: {},
      LogCollection: {},
      Pipeline: {},
      PipelineConfiguration: {},
      Repository: {},
      RepositoryResource: {},
      RepositoryType: {
        enumValues: {
          "unknown": 0,
          "gitHub": 1,
          "azureReposGit": 2,
          "gitHubEnterprise": 3,
          "bitBucket": 4,
          "azureReposGitHyphenated": 2
        }
      },
      Run: {},
      RunResources: {},
      RunResult: {
        enumValues: {
          "unknown": 0,
          "succeeded": 1,
          "failed": 2,
          "canceled": 4
        }
      },
      RunState: {
        enumValues: {
          "unknown": 0,
          "inProgress": 1,
          "canceling": 2,
          "completed": 4
        }
      },
      SignalRConnection: {}
    };
    exports2.TypeInfo.Artifact.fields = {
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
    exports2.TypeInfo.CreatePipelineConfigurationParameters.fields = {
      type: {
        enumType: exports2.TypeInfo.ConfigurationType
      }
    };
    exports2.TypeInfo.CreatePipelineParameters.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.CreatePipelineConfigurationParameters
      }
    };
    exports2.TypeInfo.Log.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      },
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
    exports2.TypeInfo.LogCollection.fields = {
      logs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Log
      },
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
    exports2.TypeInfo.Pipeline.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.PipelineConfiguration
      }
    };
    exports2.TypeInfo.PipelineConfiguration.fields = {
      type: {
        enumType: exports2.TypeInfo.ConfigurationType
      }
    };
    exports2.TypeInfo.Repository.fields = {
      type: {
        enumType: exports2.TypeInfo.RepositoryType
      }
    };
    exports2.TypeInfo.RepositoryResource.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.Repository
      }
    };
    exports2.TypeInfo.Run.fields = {
      createdDate: {
        isDate: true
      },
      finishedDate: {
        isDate: true
      },
      resources: {
        typeInfo: exports2.TypeInfo.RunResources
      },
      result: {
        enumType: exports2.TypeInfo.RunResult
      },
      state: {
        enumType: exports2.TypeInfo.RunState
      }
    };
    exports2.TypeInfo.RunResources.fields = {
      repositories: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.RepositoryResource
      }
    };
    exports2.TypeInfo.SignalRConnection.fields = {
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/PipelinesApi.js
var require_PipelinesApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/PipelinesApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PipelinesApi = void 0;
    var basem = require_ClientApiBases();
    var PipelinesInterfaces = require_PipelinesInterfaces();
    var PipelinesApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Pipelines-api", options2);
      }
      /**
       * Get a specific artifact from a pipeline run
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - ID of the pipeline.
       * @param {number} runId - ID of the run of that pipeline.
       * @param {string} artifactName - Name of the artifact.
       * @param {PipelinesInterfaces.GetArtifactExpandOptions} expand - Expand options. Default is None.
       */
      getArtifact(project, pipelineId, runId, artifactName, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId
            };
            let queryValues = {
              artifactName,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "85023071-bd5e-4438-89b0-2a5bf362a19d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Artifact, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific log from a pipeline run
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - ID of the pipeline.
       * @param {number} runId - ID of the run of that pipeline.
       * @param {number} logId - ID of the log.
       * @param {PipelinesInterfaces.GetLogExpandOptions} expand - Expand options. Default is None.
       */
      getLog(project, pipelineId, runId, logId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId,
              logId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "fb1b6d27-3957-43d5-a14b-a2d70403e545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Log, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of logs from a pipeline run.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - ID of the pipeline.
       * @param {number} runId - ID of the run of that pipeline.
       * @param {PipelinesInterfaces.GetLogExpandOptions} expand - Expand options. Default is None.
       */
      listLogs(project, pipelineId, runId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "fb1b6d27-3957-43d5-a14b-a2d70403e545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.LogCollection, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pipeline.
       *
       * @param {PipelinesInterfaces.CreatePipelineParameters} inputParameters - Input parameters.
       * @param {string} project - Project ID or project name
       */
      createPipeline(inputParameters, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "28e1305e-2afe-47bf-abaf-cbb0e6a91988", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, inputParameters, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Pipeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a pipeline, optionally at the specified version
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline ID
       * @param {number} pipelineVersion - The pipeline version
       */
      getPipeline(project, pipelineId, pipelineVersion) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            let queryValues = {
              pipelineVersion
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "28e1305e-2afe-47bf-abaf-cbb0e6a91988", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Pipeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of pipelines.
       *
       * @param {string} project - Project ID or project name
       * @param {string} orderBy - A sort expression. Defaults to "name asc"
       * @param {number} top - The maximum number of pipelines to return
       * @param {string} continuationToken - A continuation token from a previous request, to retrieve the next page of results
       */
      listPipelines(project, orderBy, top, continuationToken) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              orderBy,
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "28e1305e-2afe-47bf-abaf-cbb0e6a91988", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Pipeline, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a dry run of the pipeline and returns an object containing the final yaml.
       *
       * @param {PipelinesInterfaces.RunPipelineParameters} runParameters - Optional additional parameters for this run.
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline ID.
       * @param {number} pipelineVersion - The pipeline version.
       */
      preview(runParameters, project, pipelineId, pipelineVersion) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            let queryValues = {
              pipelineVersion
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "53df2d18-29ea-46a9-bee0-933540f80abf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, runParameters, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a run for a particular pipeline.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline id
       * @param {number} runId - The run id
       */
      getRun(project, pipelineId, runId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "7859261e-d2e9-4a68-b820-a5d84cc5bb3d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Run, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets top 10000 runs for a particular pipeline.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline id
       */
      listRuns(project, pipelineId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "7859261e-d2e9-4a68-b820-a5d84cc5bb3d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Run, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Runs a pipeline.
       *
       * @param {PipelinesInterfaces.RunPipelineParameters} runParameters - Optional additional parameters for this run.
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline ID.
       * @param {number} pipelineVersion - The pipeline version.
       */
      runPipeline(runParameters, project, pipelineId, pipelineVersion) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            let queryValues = {
              pipelineVersion
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "7859261e-d2e9-4a68-b820-a5d84cc5bb3d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, runParameters, options2);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Run, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.PipelinesApi = PipelinesApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/CIXApi.js
var require_CIXApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/CIXApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CixApi = void 0;
    var basem = require_ClientApiBases();
    var CixApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-Pipelines-api", options2);
      }
      /**
       * Gets a list of existing configuration files for the given repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryType - The type of the repository such as GitHub, TfsGit (i.e. Azure Repos), Bitbucket, etc.
       * @param {string} repositoryId - The vendor-specific identifier or the name of the repository, e.g. Microsoft/vscode (GitHub) or e9d82045-ddba-4e01-a63d-2ab9f040af62 (Azure Repos)
       * @param {string} branch - The repository branch where to look for the configuration file.
       * @param {string} serviceConnectionId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TfsGit (i.e. Azure Repos).
       */
      getConfigurations(project, repositoryType, repositoryId, branch, serviceConnectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              repositoryType,
              repositoryId,
              branch,
              serviceConnectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "8fc87684-9ebc-4c37-ab92-f4ac4a58cb3a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new Pipeline connection between the provider installation and the specified project. Returns the PipelineConnection object created.
       *
       * @param {CIXInterfaces.CreatePipelineConnectionInputs} createConnectionInputs
       * @param {string} project
       */
      createProjectConnection(createConnectionInputs, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (project == null) {
            throw new TypeError("project can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "00df4879-9216-45d5-b38d-4a487b626b2c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createConnectionInputs, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of build frameworks that best match the given repository based on its contents.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryType - The type of the repository such as GitHub, TfsGit (i.e. Azure Repos), Bitbucket, etc.
       * @param {string} repositoryId - The vendor-specific identifier or the name of the repository, e.g. Microsoft/vscode (GitHub) or e9d82045-ddba-4e01-a63d-2ab9f040af62 (Azure Repos)
       * @param {string} branch - The repository branch to detect build frameworks for.
       * @param {CIXInterfaces.BuildFrameworkDetectionType} detectionType
       * @param {string} serviceConnectionId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TfsGit (i.e. Azure Repos).
       */
      getDetectedBuildFrameworks(project, repositoryType, repositoryId, branch, detectionType, serviceConnectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              repositoryType,
              repositoryId,
              branch,
              detectionType,
              serviceConnectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "29a30bab-9efb-4652-bf1b-9269baca0980", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {{ [key: string] : CIXInterfaces.ResourceCreationParameter; }} creationParameters
       * @param {string} project - Project ID or project name
       */
      createResources(creationParameters, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "43201899-7690-4870-9c79-ab69605f21ed", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, creationParameters, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.CixApi = CixApi;
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js
var require_WorkItemTrackingInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkItemTypeFieldsExpandLevel = exports2.WorkItemRecentActivityType = exports2.WorkItemExpand = exports2.WorkItemErrorPolicy = exports2.TreeStructureGroup = exports2.TreeNodeStructureType = exports2.TemplateType = exports2.ReportingRevisionsExpand = exports2.QueryType = exports2.QueryResultType = exports2.QueryRecursionOption = exports2.QueryOption = exports2.QueryExpand = exports2.QueryErrorPolicy = exports2.ProvisioningActionType = exports2.LogicalOperation = exports2.LinkQueryMode = exports2.GetFieldsExpand = exports2.FieldUsage = exports2.FieldType = exports2.CommentSortOrder = exports2.CommentReactionType = exports2.CommentFormat = exports2.CommentExpandOptions = exports2.ClassificationNodesErrorPolicy = void 0;
    var ClassificationNodesErrorPolicy;
    (function(ClassificationNodesErrorPolicy2) {
      ClassificationNodesErrorPolicy2[ClassificationNodesErrorPolicy2["Fail"] = 1] = "Fail";
      ClassificationNodesErrorPolicy2[ClassificationNodesErrorPolicy2["Omit"] = 2] = "Omit";
    })(ClassificationNodesErrorPolicy = exports2.ClassificationNodesErrorPolicy || (exports2.ClassificationNodesErrorPolicy = {}));
    var CommentExpandOptions;
    (function(CommentExpandOptions2) {
      CommentExpandOptions2[CommentExpandOptions2["None"] = 0] = "None";
      CommentExpandOptions2[CommentExpandOptions2["Reactions"] = 1] = "Reactions";
      CommentExpandOptions2[CommentExpandOptions2["RenderedText"] = 8] = "RenderedText";
      CommentExpandOptions2[CommentExpandOptions2["RenderedTextOnly"] = 16] = "RenderedTextOnly";
      CommentExpandOptions2[CommentExpandOptions2["All"] = -17] = "All";
    })(CommentExpandOptions = exports2.CommentExpandOptions || (exports2.CommentExpandOptions = {}));
    var CommentFormat;
    (function(CommentFormat2) {
      CommentFormat2[CommentFormat2["Markdown"] = 0] = "Markdown";
      CommentFormat2[CommentFormat2["Html"] = 1] = "Html";
    })(CommentFormat = exports2.CommentFormat || (exports2.CommentFormat = {}));
    var CommentReactionType;
    (function(CommentReactionType2) {
      CommentReactionType2[CommentReactionType2["Like"] = 0] = "Like";
      CommentReactionType2[CommentReactionType2["Dislike"] = 1] = "Dislike";
      CommentReactionType2[CommentReactionType2["Heart"] = 2] = "Heart";
      CommentReactionType2[CommentReactionType2["Hooray"] = 3] = "Hooray";
      CommentReactionType2[CommentReactionType2["Smile"] = 4] = "Smile";
      CommentReactionType2[CommentReactionType2["Confused"] = 5] = "Confused";
    })(CommentReactionType = exports2.CommentReactionType || (exports2.CommentReactionType = {}));
    var CommentSortOrder;
    (function(CommentSortOrder2) {
      CommentSortOrder2[CommentSortOrder2["Asc"] = 1] = "Asc";
      CommentSortOrder2[CommentSortOrder2["Desc"] = 2] = "Desc";
    })(CommentSortOrder = exports2.CommentSortOrder || (exports2.CommentSortOrder = {}));
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 0] = "String";
      FieldType2[FieldType2["Integer"] = 1] = "Integer";
      FieldType2[FieldType2["DateTime"] = 2] = "DateTime";
      FieldType2[FieldType2["PlainText"] = 3] = "PlainText";
      FieldType2[FieldType2["Html"] = 4] = "Html";
      FieldType2[FieldType2["TreePath"] = 5] = "TreePath";
      FieldType2[FieldType2["History"] = 6] = "History";
      FieldType2[FieldType2["Double"] = 7] = "Double";
      FieldType2[FieldType2["Guid"] = 8] = "Guid";
      FieldType2[FieldType2["Boolean"] = 9] = "Boolean";
      FieldType2[FieldType2["Identity"] = 10] = "Identity";
      FieldType2[FieldType2["PicklistString"] = 11] = "PicklistString";
      FieldType2[FieldType2["PicklistInteger"] = 12] = "PicklistInteger";
      FieldType2[FieldType2["PicklistDouble"] = 13] = "PicklistDouble";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var FieldUsage;
    (function(FieldUsage2) {
      FieldUsage2[FieldUsage2["None"] = 0] = "None";
      FieldUsage2[FieldUsage2["WorkItem"] = 1] = "WorkItem";
      FieldUsage2[FieldUsage2["WorkItemLink"] = 2] = "WorkItemLink";
      FieldUsage2[FieldUsage2["Tree"] = 3] = "Tree";
      FieldUsage2[FieldUsage2["WorkItemTypeExtension"] = 4] = "WorkItemTypeExtension";
    })(FieldUsage = exports2.FieldUsage || (exports2.FieldUsage = {}));
    var GetFieldsExpand;
    (function(GetFieldsExpand2) {
      GetFieldsExpand2[GetFieldsExpand2["None"] = 0] = "None";
      GetFieldsExpand2[GetFieldsExpand2["ExtensionFields"] = 1] = "ExtensionFields";
      GetFieldsExpand2[GetFieldsExpand2["IncludeDeleted"] = 2] = "IncludeDeleted";
    })(GetFieldsExpand = exports2.GetFieldsExpand || (exports2.GetFieldsExpand = {}));
    var LinkQueryMode;
    (function(LinkQueryMode2) {
      LinkQueryMode2[LinkQueryMode2["WorkItems"] = 0] = "WorkItems";
      LinkQueryMode2[LinkQueryMode2["LinksOneHopMustContain"] = 1] = "LinksOneHopMustContain";
      LinkQueryMode2[LinkQueryMode2["LinksOneHopMayContain"] = 2] = "LinksOneHopMayContain";
      LinkQueryMode2[LinkQueryMode2["LinksOneHopDoesNotContain"] = 3] = "LinksOneHopDoesNotContain";
      LinkQueryMode2[LinkQueryMode2["LinksRecursiveMustContain"] = 4] = "LinksRecursiveMustContain";
      LinkQueryMode2[LinkQueryMode2["LinksRecursiveMayContain"] = 5] = "LinksRecursiveMayContain";
      LinkQueryMode2[LinkQueryMode2["LinksRecursiveDoesNotContain"] = 6] = "LinksRecursiveDoesNotContain";
    })(LinkQueryMode = exports2.LinkQueryMode || (exports2.LinkQueryMode = {}));
    var LogicalOperation;
    (function(LogicalOperation2) {
      LogicalOperation2[LogicalOperation2["NONE"] = 0] = "NONE";
      LogicalOperation2[LogicalOperation2["AND"] = 1] = "AND";
      LogicalOperation2[LogicalOperation2["OR"] = 2] = "OR";
    })(LogicalOperation = exports2.LogicalOperation || (exports2.LogicalOperation = {}));
    var ProvisioningActionType;
    (function(ProvisioningActionType2) {
      ProvisioningActionType2[ProvisioningActionType2["Import"] = 0] = "Import";
      ProvisioningActionType2[ProvisioningActionType2["Validate"] = 1] = "Validate";
    })(ProvisioningActionType = exports2.ProvisioningActionType || (exports2.ProvisioningActionType = {}));
    var QueryErrorPolicy;
    (function(QueryErrorPolicy2) {
      QueryErrorPolicy2[QueryErrorPolicy2["Fail"] = 1] = "Fail";
      QueryErrorPolicy2[QueryErrorPolicy2["Omit"] = 2] = "Omit";
    })(QueryErrorPolicy = exports2.QueryErrorPolicy || (exports2.QueryErrorPolicy = {}));
    var QueryExpand;
    (function(QueryExpand2) {
      QueryExpand2[QueryExpand2["None"] = 0] = "None";
      QueryExpand2[QueryExpand2["Wiql"] = 1] = "Wiql";
      QueryExpand2[QueryExpand2["Clauses"] = 2] = "Clauses";
      QueryExpand2[QueryExpand2["All"] = 3] = "All";
      QueryExpand2[QueryExpand2["Minimal"] = 4] = "Minimal";
    })(QueryExpand = exports2.QueryExpand || (exports2.QueryExpand = {}));
    var QueryOption;
    (function(QueryOption2) {
      QueryOption2[QueryOption2["Doing"] = 1] = "Doing";
      QueryOption2[QueryOption2["Done"] = 2] = "Done";
      QueryOption2[QueryOption2["Followed"] = 3] = "Followed";
    })(QueryOption = exports2.QueryOption || (exports2.QueryOption = {}));
    var QueryRecursionOption;
    (function(QueryRecursionOption2) {
      QueryRecursionOption2[QueryRecursionOption2["ParentFirst"] = 0] = "ParentFirst";
      QueryRecursionOption2[QueryRecursionOption2["ChildFirst"] = 1] = "ChildFirst";
    })(QueryRecursionOption = exports2.QueryRecursionOption || (exports2.QueryRecursionOption = {}));
    var QueryResultType;
    (function(QueryResultType2) {
      QueryResultType2[QueryResultType2["WorkItem"] = 1] = "WorkItem";
      QueryResultType2[QueryResultType2["WorkItemLink"] = 2] = "WorkItemLink";
    })(QueryResultType = exports2.QueryResultType || (exports2.QueryResultType = {}));
    var QueryType;
    (function(QueryType2) {
      QueryType2[QueryType2["Flat"] = 1] = "Flat";
      QueryType2[QueryType2["Tree"] = 2] = "Tree";
      QueryType2[QueryType2["OneHop"] = 3] = "OneHop";
    })(QueryType = exports2.QueryType || (exports2.QueryType = {}));
    var ReportingRevisionsExpand;
    (function(ReportingRevisionsExpand2) {
      ReportingRevisionsExpand2[ReportingRevisionsExpand2["None"] = 0] = "None";
      ReportingRevisionsExpand2[ReportingRevisionsExpand2["Fields"] = 1] = "Fields";
    })(ReportingRevisionsExpand = exports2.ReportingRevisionsExpand || (exports2.ReportingRevisionsExpand = {}));
    var TemplateType;
    (function(TemplateType2) {
      TemplateType2[TemplateType2["WorkItemType"] = 0] = "WorkItemType";
      TemplateType2[TemplateType2["GlobalWorkflow"] = 1] = "GlobalWorkflow";
    })(TemplateType = exports2.TemplateType || (exports2.TemplateType = {}));
    var TreeNodeStructureType;
    (function(TreeNodeStructureType2) {
      TreeNodeStructureType2[TreeNodeStructureType2["Area"] = 0] = "Area";
      TreeNodeStructureType2[TreeNodeStructureType2["Iteration"] = 1] = "Iteration";
    })(TreeNodeStructureType = exports2.TreeNodeStructureType || (exports2.TreeNodeStructureType = {}));
    var TreeStructureGroup;
    (function(TreeStructureGroup2) {
      TreeStructureGroup2[TreeStructureGroup2["Areas"] = 0] = "Areas";
      TreeStructureGroup2[TreeStructureGroup2["Iterations"] = 1] = "Iterations";
    })(TreeStructureGroup = exports2.TreeStructureGroup || (exports2.TreeStructureGroup = {}));
    var WorkItemErrorPolicy;
    (function(WorkItemErrorPolicy2) {
      WorkItemErrorPolicy2[WorkItemErrorPolicy2["Fail"] = 1] = "Fail";
      WorkItemErrorPolicy2[WorkItemErrorPolicy2["Omit"] = 2] = "Omit";
    })(WorkItemErrorPolicy = exports2.WorkItemErrorPolicy || (exports2.WorkItemErrorPolicy = {}));
    var WorkItemExpand;
    (function(WorkItemExpand2) {
      WorkItemExpand2[WorkItemExpand2["None"] = 0] = "None";
      WorkItemExpand2[WorkItemExpand2["Relations"] = 1] = "Relations";
      WorkItemExpand2[WorkItemExpand2["Fields"] = 2] = "Fields";
      WorkItemExpand2[WorkItemExpand2["Links"] = 3] = "Links";
      WorkItemExpand2[WorkItemExpand2["All"] = 4] = "All";
    })(WorkItemExpand = exports2.WorkItemExpand || (exports2.WorkItemExpand = {}));
    var WorkItemRecentActivityType;
    (function(WorkItemRecentActivityType2) {
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Visited"] = 0] = "Visited";
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Edited"] = 1] = "Edited";
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Deleted"] = 2] = "Deleted";
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Restored"] = 3] = "Restored";
    })(WorkItemRecentActivityType = exports2.WorkItemRecentActivityType || (exports2.WorkItemRecentActivityType = {}));
    var WorkItemTypeFieldsExpandLevel;
    (function(WorkItemTypeFieldsExpandLevel2) {
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["None"] = 0] = "None";
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["AllowedValues"] = 1] = "AllowedValues";
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["DependentFields"] = 2] = "DependentFields";
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["All"] = 3] = "All";
    })(WorkItemTypeFieldsExpandLevel = exports2.WorkItemTypeFieldsExpandLevel || (exports2.WorkItemTypeFieldsExpandLevel = {}));
    exports2.TypeInfo = {
      AccountMyWorkResult: {},
      AccountRecentActivityWorkItemModel: {},
      AccountRecentActivityWorkItemModel2: {},
      AccountRecentActivityWorkItemModelBase: {},
      AccountRecentMentionWorkItemModel: {},
      AccountWorkWorkItemModel: {},
      ClassificationNodesErrorPolicy: {
        enumValues: {
          "fail": 1,
          "omit": 2
        }
      },
      Comment: {},
      CommentExpandOptions: {
        enumValues: {
          "none": 0,
          "reactions": 1,
          "renderedText": 8,
          "renderedTextOnly": 16,
          "all": -17
        }
      },
      CommentFormat: {
        enumValues: {
          "markdown": 0,
          "html": 1
        }
      },
      CommentList: {},
      CommentReaction: {},
      CommentReactionType: {
        enumValues: {
          "like": 0,
          "dislike": 1,
          "heart": 2,
          "hooray": 3,
          "smile": 4,
          "confused": 5
        }
      },
      CommentSortOrder: {
        enumValues: {
          "asc": 1,
          "desc": 2
        }
      },
      CommentVersion: {},
      ExternalDeployment: {},
      FieldType: {
        enumValues: {
          "string": 0,
          "integer": 1,
          "dateTime": 2,
          "plainText": 3,
          "html": 4,
          "treePath": 5,
          "history": 6,
          "double": 7,
          "guid": 8,
          "boolean": 9,
          "identity": 10,
          "picklistString": 11,
          "picklistInteger": 12,
          "picklistDouble": 13
        }
      },
      FieldUsage: {
        enumValues: {
          "none": 0,
          "workItem": 1,
          "workItemLink": 2,
          "tree": 3,
          "workItemTypeExtension": 4
        }
      },
      GetFieldsExpand: {
        enumValues: {
          "none": 0,
          "extensionFields": 1,
          "includeDeleted": 2
        }
      },
      LinkQueryMode: {
        enumValues: {
          "workItems": 0,
          "linksOneHopMustContain": 1,
          "linksOneHopMayContain": 2,
          "linksOneHopDoesNotContain": 3,
          "linksRecursiveMustContain": 4,
          "linksRecursiveMayContain": 5,
          "linksRecursiveDoesNotContain": 6
        }
      },
      LogicalOperation: {
        enumValues: {
          "none": 0,
          "and": 1,
          "or": 2
        }
      },
      ProvisioningActionType: {
        enumValues: {
          "import": 0,
          "validate": 1
        }
      },
      QueryBatchGetRequest: {},
      QueryErrorPolicy: {
        enumValues: {
          "fail": 1,
          "omit": 2
        }
      },
      QueryExpand: {
        enumValues: {
          "none": 0,
          "wiql": 1,
          "clauses": 2,
          "all": 3,
          "minimal": 4
        }
      },
      QueryHierarchyItem: {},
      QueryHierarchyItemsResult: {},
      QueryOption: {
        enumValues: {
          "doing": 1,
          "done": 2,
          "followed": 3
        }
      },
      QueryRecursionOption: {
        enumValues: {
          "parentFirst": 0,
          "childFirst": 1
        }
      },
      QueryResultType: {
        enumValues: {
          "workItem": 1,
          "workItemLink": 2
        }
      },
      QueryType: {
        enumValues: {
          "flat": 1,
          "tree": 2,
          "oneHop": 3
        }
      },
      ReportingRevisionsExpand: {
        enumValues: {
          "none": 0,
          "fields": 1
        }
      },
      TemplateType: {
        enumValues: {
          "workItemType": 0,
          "globalWorkflow": 1
        }
      },
      TreeNodeStructureType: {
        enumValues: {
          "area": 0,
          "iteration": 1
        }
      },
      TreeStructureGroup: {
        enumValues: {
          "areas": 0,
          "iterations": 1
        }
      },
      WorkItemBatchGetRequest: {},
      WorkItemClassificationNode: {},
      WorkItemComment: {},
      WorkItemComments: {},
      WorkItemErrorPolicy: {
        enumValues: {
          "fail": 1,
          "omit": 2
        }
      },
      WorkItemExpand: {
        enumValues: {
          "none": 0,
          "relations": 1,
          "fields": 2,
          "links": 3,
          "all": 4
        }
      },
      WorkItemField: {},
      WorkItemField2: {},
      WorkItemHistory: {},
      WorkItemQueryClause: {},
      WorkItemQueryResult: {},
      WorkItemRecentActivityType: {
        enumValues: {
          "visited": 0,
          "edited": 1,
          "deleted": 2,
          "restored": 3
        }
      },
      WorkItemTagDefinition: {},
      WorkItemTypeFieldsExpandLevel: {
        enumValues: {
          "none": 0,
          "allowedValues": 1,
          "dependentFields": 2,
          "all": 3
        }
      },
      WorkItemTypeTemplateUpdateModel: {},
      WorkItemUpdate: {}
    };
    exports2.TypeInfo.AccountMyWorkResult.fields = {
      workItemDetails: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AccountWorkWorkItemModel
      }
    };
    exports2.TypeInfo.AccountRecentActivityWorkItemModel.fields = {
      activityDate: {
        isDate: true
      },
      activityType: {
        enumType: exports2.TypeInfo.WorkItemRecentActivityType
      },
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountRecentActivityWorkItemModel2.fields = {
      activityDate: {
        isDate: true
      },
      activityType: {
        enumType: exports2.TypeInfo.WorkItemRecentActivityType
      },
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountRecentActivityWorkItemModelBase.fields = {
      activityDate: {
        isDate: true
      },
      activityType: {
        enumType: exports2.TypeInfo.WorkItemRecentActivityType
      },
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountRecentMentionWorkItemModel.fields = {
      mentionedDateField: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountWorkWorkItemModel.fields = {
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Comment.fields = {
      createdDate: {
        isDate: true
      },
      createdOnBehalfDate: {
        isDate: true
      },
      format: {
        enumType: exports2.TypeInfo.CommentFormat
      },
      modifiedDate: {
        isDate: true
      },
      reactions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CommentReaction
      }
    };
    exports2.TypeInfo.CommentList.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      }
    };
    exports2.TypeInfo.CommentReaction.fields = {
      type: {
        enumType: exports2.TypeInfo.CommentReactionType
      }
    };
    exports2.TypeInfo.CommentVersion.fields = {
      createdDate: {
        isDate: true
      },
      createdOnBehalfDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExternalDeployment.fields = {
      statusDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.QueryBatchGetRequest.fields = {
      $expand: {
        enumType: exports2.TypeInfo.QueryExpand
      },
      errorPolicy: {
        enumType: exports2.TypeInfo.QueryErrorPolicy
      }
    };
    exports2.TypeInfo.QueryHierarchyItem.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryHierarchyItem
      },
      clauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      createdDate: {
        isDate: true
      },
      filterOptions: {
        enumType: exports2.TypeInfo.LinkQueryMode
      },
      lastExecutedDate: {
        isDate: true
      },
      lastModifiedDate: {
        isDate: true
      },
      linkClauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      queryRecursionOption: {
        enumType: exports2.TypeInfo.QueryRecursionOption
      },
      queryType: {
        enumType: exports2.TypeInfo.QueryType
      },
      sourceClauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      targetClauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      }
    };
    exports2.TypeInfo.QueryHierarchyItemsResult.fields = {
      value: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryHierarchyItem
      }
    };
    exports2.TypeInfo.WorkItemBatchGetRequest.fields = {
      $expand: {
        enumType: exports2.TypeInfo.WorkItemExpand
      },
      asOf: {
        isDate: true
      },
      errorPolicy: {
        enumType: exports2.TypeInfo.WorkItemErrorPolicy
      }
    };
    exports2.TypeInfo.WorkItemClassificationNode.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemClassificationNode
      },
      structureType: {
        enumType: exports2.TypeInfo.TreeNodeStructureType
      }
    };
    exports2.TypeInfo.WorkItemComment.fields = {
      format: {
        enumType: exports2.TypeInfo.CommentFormat
      },
      revisedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.WorkItemComments.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemComment
      }
    };
    exports2.TypeInfo.WorkItemField.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      },
      usage: {
        enumType: exports2.TypeInfo.FieldUsage
      }
    };
    exports2.TypeInfo.WorkItemField2.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      },
      usage: {
        enumType: exports2.TypeInfo.FieldUsage
      }
    };
    exports2.TypeInfo.WorkItemHistory.fields = {
      revisedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.WorkItemQueryClause.fields = {
      clauses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      logicalOperator: {
        enumType: exports2.TypeInfo.LogicalOperation
      }
    };
    exports2.TypeInfo.WorkItemQueryResult.fields = {
      asOf: {
        isDate: true
      },
      queryResultType: {
        enumType: exports2.TypeInfo.QueryResultType
      },
      queryType: {
        enumType: exports2.TypeInfo.QueryType
      }
    };
    exports2.TypeInfo.WorkItemTagDefinition.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.WorkItemTypeTemplateUpdateModel.fields = {
      actionType: {
        enumType: exports2.TypeInfo.ProvisioningActionType
      },
      templateType: {
        enumType: exports2.TypeInfo.TemplateType
      }
    };
    exports2.TypeInfo.WorkItemUpdate.fields = {
      revisedDate: {
        isDate: true
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/WorkItemTrackingApi.js
var require_WorkItemTrackingApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/WorkItemTrackingApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkItemTrackingApi = void 0;
    var basem = require_ClientApiBases();
    var WorkItemTrackingInterfaces = require_WorkItemTrackingInterfaces();
    var WorkItemTrackingApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-WorkItemTracking-api", options2);
      }
      /**
       * INTERNAL ONLY: USED BY ACCOUNT MY WORK PAGE. This returns Doing, Done, Follows and activity work items details.
       *
       * @param {WorkItemTrackingInterfaces.QueryOption} queryOption
       */
      getAccountMyWorkData(queryOption) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$queryOption": queryOption
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "def3d688-ddf5-4096-9024-69beea15cdbd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.AccountMyWorkResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets recent work item activities
       *
       */
      getRecentActivityData() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "1bc988f4-c15f-4072-ad35-497c87e3a909", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.AccountRecentActivityWorkItemModel2, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: USED BY ACCOUNT MY WORK PAGE.
       *
       */
      getRecentMentions() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "d60eeb6e-e18c-4478-9e94-a0094e28f41c", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.AccountRecentMentionWorkItemModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the list of work item tracking outbound artifact link types.
       *
       */
      getWorkArtifactLinkTypes() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "1a31de40-e318-41cd-a6c6-881077df52e3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queries work items linked to a given list of artifact URI.
       *
       * @param {WorkItemTrackingInterfaces.ArtifactUriQuery} artifactUriQuery - Defines a list of artifact URI for querying work items.
       * @param {string} project - Project ID or project name
       */
      queryWorkItemsForArtifactUris(artifactUriQuery, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "a9a9aa7a-8c09-44d3-ad1b-46e855c1e3d3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, artifactUriQuery, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Uploads an attachment.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} fileName - The name of the file
       * @param {string} uploadType - Attachment upload type: Simple or Chunked
       * @param {string} project - Project ID or project name
       * @param {string} areaPath - Target project Area Path
       */
      createAttachment(customHeaders, contentStream, fileName, uploadType, project, areaPath) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fileName,
              uploadType,
              areaPath
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "e07b5fa4-1499-494d-a496-64b860fd64ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Downloads an attachment.
       *
       * @param {string} id - Attachment ID
       * @param {string} fileName - Name of the file
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If set to <c>true</c> always download attachment
       */
      getAttachmentContent(id, fileName, project, download) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              fileName,
              download
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "e07b5fa4-1499-494d-a496-64b860fd64ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Downloads an attachment.
       *
       * @param {string} id - Attachment ID
       * @param {string} fileName - Name of the file
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If set to <c>true</c> always download attachment
       */
      getAttachmentZip(id, fileName, project, download) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              fileName,
              download
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "e07b5fa4-1499-494d-a496-64b860fd64ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets root classification nodes or list of classification nodes for a given list of nodes ids, for a given project. In case ids parameter is supplied you will  get list of classification nodes for those ids. Otherwise you will get root classification nodes for this project.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} ids - Comma separated integer classification nodes ids. It's not required, if you want root nodes.
       * @param {number} depth - Depth of children to fetch.
       * @param {WorkItemTrackingInterfaces.ClassificationNodesErrorPolicy} errorPolicy - Flag to handle errors in getting some nodes. Possible options are Fail and Omit.
       */
      getClassificationNodes(project, ids, depth, errorPolicy) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(","),
              "$depth": depth,
              errorPolicy
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a70579d1-f53a-48ee-a5be-7be8659023b9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets root classification nodes under the project.
       *
       * @param {string} project - Project ID or project name
       * @param {number} depth - Depth of children to fetch.
       */
      getRootNodes(project, depth) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$depth": depth
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a70579d1-f53a-48ee-a5be-7be8659023b9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create new or update an existing classification node.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemClassificationNode} postedNode - Node to create or update.
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       */
      createOrUpdateClassificationNode(postedNode, project, structureGroup, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, postedNode, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete an existing classification node.
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       * @param {number} reclassifyId - Id of the target classification node for reclassification.
       */
      deleteClassificationNode(project, structureGroup, path10, reclassifyId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path10
            };
            let queryValues = {
              "$reclassifyId": reclassifyId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the classification node for a given node path.
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       * @param {number} depth - Depth of children to fetch.
       */
      getClassificationNode(project, structureGroup, path10, depth) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path10
            };
            let queryValues = {
              "$depth": depth
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an existing classification node.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemClassificationNode} postedNode - Node to create or update.
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       */
      updateClassificationNode(postedNode, project, structureGroup, path10) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path10
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, postedNode, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get users who reacted on the comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID.
       * @param {number} commentId - Comment ID.
       * @param {WorkItemTrackingInterfaces.CommentReactionType} reactionType - Type of the reaction.
       * @param {number} top
       * @param {number} skip
       */
      getEngagedUsers(project, workItemId, commentId, reactionType, top, skip) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              reactionType
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "e33ca5e0-2349-4285-af3d-d72d86781c35", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a comment on a work item.
       *
       * @param {WorkItemTrackingInterfaces.CommentCreate} request - Comment create request.
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item.
       */
      addComment(request, project, workItemId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a comment on a work item.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item.
       * @param {number} commentId
       */
      deleteComment(project, workItemId, commentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a work item comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item to get the comment.
       * @param {number} commentId - Id of the comment to return.
       * @param {boolean} includeDeleted - Specify if the deleted comment should be retrieved.
       * @param {WorkItemTrackingInterfaces.CommentExpandOptions} expand - Specifies the additional data retrieval options for work item comments.
       */
      getComment(project, workItemId, commentId, includeDeleted, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            let queryValues = {
              includeDeleted,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of work item comments, pageable.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item to get comments for.
       * @param {number} top - Max number of comments to return.
       * @param {string} continuationToken - Used to query for the next page of comments.
       * @param {boolean} includeDeleted - Specify if the deleted comments should be retrieved.
       * @param {WorkItemTrackingInterfaces.CommentExpandOptions} expand - Specifies the additional data retrieval options for work item comments.
       * @param {WorkItemTrackingInterfaces.CommentSortOrder} order - Order in which the comments should be returned.
       */
      getComments(project, workItemId, top, continuationToken, includeDeleted, expand, order) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId
            };
            let queryValues = {
              "$top": top,
              continuationToken,
              includeDeleted,
              "$expand": expand,
              order
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentList, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of work item comments by ids.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item to get comments for.
       * @param {number[]} ids - Comma-separated list of comment ids to return.
       * @param {boolean} includeDeleted - Specify if the deleted comments should be retrieved.
       * @param {WorkItemTrackingInterfaces.CommentExpandOptions} expand - Specifies the additional data retrieval options for work item comments.
       */
      getCommentsBatch(project, workItemId, ids, includeDeleted, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId
            };
            let queryValues = {
              ids: ids && ids.join(","),
              includeDeleted,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentList, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a comment on a work item.
       *
       * @param {WorkItemTrackingInterfaces.CommentUpdate} request - Comment update request.
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item.
       * @param {number} commentId
       */
      updateComment(request, project, workItemId, commentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, request, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a new reaction to a comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID
       * @param {number} commentId - Comment ID
       * @param {WorkItemTrackingInterfaces.CommentReactionType} reactionType - Type of the reaction
       */
      createCommentReaction(project, workItemId, commentId, reactionType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              reactionType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f6cb3f27-1028-4851-af96-887e570dc21f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes an existing reaction on a comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID
       * @param {number} commentId - Comment ID
       * @param {WorkItemTrackingInterfaces.CommentReactionType} reactionType - Type of the reaction
       */
      deleteCommentReaction(project, workItemId, commentId, reactionType) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              reactionType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f6cb3f27-1028-4851-af96-887e570dc21f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets reactions of a comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID
       * @param {number} commentId - Comment ID
       */
      getCommentReactions(project, workItemId, commentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f6cb3f27-1028-4851-af96-887e570dc21f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentReaction, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} workItemId
       * @param {number} commentId
       * @param {number} version
       */
      getCommentVersion(project, workItemId, commentId, version) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              version
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "49e03b34-3be0-42e3-8a5d-e8dfb88ac954", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentVersion, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} workItemId
       * @param {number} commentId
       */
      getCommentVersions(project, workItemId, commentId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "49e03b34-3be0-42e3-8a5d-e8dfb88ac954", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentVersion, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new field.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemField} workItemField - New field definition
       * @param {string} project - Project ID or project name
       */
      createField(workItemField, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemField, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the field. To undelete a filed, see "Update Field" API.
       *
       * @param {string} fieldNameOrRefName - Field simple name or reference name
       * @param {string} project - Project ID or project name
       */
      deleteField(fieldNameOrRefName, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fieldNameOrRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets information on a specific field.
       *
       * @param {string} fieldNameOrRefName - Field simple name or reference name
       * @param {string} project - Project ID or project name
       */
      getField(fieldNameOrRefName, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fieldNameOrRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns information for all fields. The project ID/name parameter is optional.
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.GetFieldsExpand} expand - Use ExtensionFields to include extension fields, otherwise exclude them. Unless the feature flag for this parameter is enabled, extension fields are always included.
       */
      getFields(project, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a field.
       *
       * @param {WorkItemTrackingInterfaces.UpdateWorkItemField} payload - Payload contains desired value of the field's properties
       * @param {string} fieldNameOrRefName - Name/reference name of the field to be updated
       * @param {string} project - Project ID or project name
       */
      updateField(payload, fieldNameOrRefName, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fieldNameOrRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, payload, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Migrates a project to a different process within the same OOB type. For example, you can only migrate a project from agile/custom-agile to agile/custom-agile.
       *
       * @param {WorkItemTrackingInterfaces.ProcessIdModel} newProcess
       * @param {string} project - Project ID or project name
       */
      migrateProjectsProcess(newProcess, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "19801631-d4e5-47e9-8166-0330de0ff1e6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newProcess, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a query, or moves a query.
       *
       * @param {WorkItemTrackingInterfaces.QueryHierarchyItem} postedQuery - The query to create.
       * @param {string} project - Project ID or project name
       * @param {string} query - The parent id or path under which the query is to be created.
       * @param {boolean} validateWiqlOnly - If you only want to validate your WIQL query without actually creating one, set it to true. Default is false.
       */
      createQuery(postedQuery, project, query, validateWiqlOnly) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            let queryValues = {
              validateWiqlOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, postedQuery, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a query or a folder. This deletes any permission change on the deleted query or folder and any of its descendants if it is a folder. It is important to note that the deleted permission changes cannot be recovered upon undeleting the query or folder.
       *
       * @param {string} project - Project ID or project name
       * @param {string} query - ID or path of the query or folder to delete.
       */
      deleteQuery(project, query) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the root queries and their children
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.QueryExpand} expand - Include the query string (wiql), clauses, query result columns, and sort options in the results.
       * @param {number} depth - In the folder of queries, return child queries and folders to this depth.
       * @param {boolean} includeDeleted - Include deleted queries and folders
       */
      getQueries(project, expand, depth, includeDeleted) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$expand": expand,
              "$depth": depth,
              "$includeDeleted": includeDeleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves an individual query and its children
       *
       * @param {string} project - Project ID or project name
       * @param {string} query - ID or path of the query.
       * @param {WorkItemTrackingInterfaces.QueryExpand} expand - Include the query string (wiql), clauses, query result columns, and sort options in the results.
       * @param {number} depth - In the folder of queries, return child queries and folders to this depth.
       * @param {boolean} includeDeleted - Include deleted queries and folders
       * @param {boolean} useIsoDateFormat - DateTime query clauses will be formatted using a ISO 8601 compliant format
       */
      getQuery(project, query, expand, depth, includeDeleted, useIsoDateFormat) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            let queryValues = {
              "$expand": expand,
              "$depth": depth,
              "$includeDeleted": includeDeleted,
              "$useIsoDateFormat": useIsoDateFormat
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Searches all queries the user has access to in the current project
       *
       * @param {string} project - Project ID or project name
       * @param {string} filter - The text to filter the queries with.
       * @param {number} top - The number of queries to return (Default is 50 and maximum is 200).
       * @param {WorkItemTrackingInterfaces.QueryExpand} expand
       * @param {boolean} includeDeleted - Include deleted queries and folders
       */
      searchQueries(project, filter2, top, expand, includeDeleted) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (filter2 == null) {
            throw new TypeError("filter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$filter": filter2,
              "$top": top,
              "$expand": expand,
              "$includeDeleted": includeDeleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItemsResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a query or a folder. This allows you to update, rename and move queries and folders.
       *
       * @param {WorkItemTrackingInterfaces.QueryHierarchyItem} queryUpdate - The query to update.
       * @param {string} project - Project ID or project name
       * @param {string} query - The ID or path for the query to update.
       * @param {boolean} undeleteDescendants - Undelete the children of this folder. It is important to note that this will not bring back the permission changes that were previously applied to the descendants.
       */
      updateQuery(queryUpdate, project, query, undeleteDescendants) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            let queryValues = {
              "$undeleteDescendants": undeleteDescendants
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, queryUpdate, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of queries by ids (Maximum 1000)
       *
       * @param {WorkItemTrackingInterfaces.QueryBatchGetRequest} queryGetRequest
       * @param {string} project - Project ID or project name
       */
      getQueriesBatch(queryGetRequest, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "549816f9-09b0-4e75-9e81-01fbfcd07426", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queryGetRequest, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Destroys the specified work item permanently from the Recycle Bin. This action can not be undone.
       *
       * @param {number} id - ID of the work item to be destroyed permanently
       * @param {string} project - Project ID or project name
       */
      destroyWorkItem(id, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a deleted work item from Recycle Bin.
       *
       * @param {number} id - ID of the work item to be returned
       * @param {string} project - Project ID or project name
       */
      getDeletedWorkItem(id, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work items from the recycle bin, whose IDs have been specified in the parameters
       *
       * @param {number[]} ids - Comma separated list of IDs of the deleted work items to be returned
       * @param {string} project - Project ID or project name
       */
      getDeletedWorkItems(ids, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of the IDs and the URLs of the deleted the work items in the Recycle Bin.
       *
       * @param {string} project - Project ID or project name
       */
      getDeletedWorkItemShallowReferences(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Restores the deleted work item from Recycle Bin.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemDeleteUpdate} payload - Paylod with instructions to update the IsDeleted flag to false
       * @param {number} id - ID of the work item to be restored
       * @param {string} project - Project ID or project name
       */
      restoreWorkItem(payload, id, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, payload, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a fully hydrated work item for the requested revision
       *
       * @param {number} id
       * @param {number} revisionNumber
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
       * @param {string} project - Project ID or project name
       */
      getRevision(id, revisionNumber, expand, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id,
              revisionNumber
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "a00c85a5-80fa-4565-99c3-bcd2181434bb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of fully hydrated work item revisions, paged.
       *
       * @param {number} id
       * @param {number} top
       * @param {number} skip
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
       * @param {string} project - Project ID or project name
       */
      getRevisions(id, top, skip, expand, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              "$top": top,
              "$skip": skip,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "a00c85a5-80fa-4565-99c3-bcd2181434bb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * RESTful method to send mail for selected/queried work items.
       *
       * @param {WorkItemTrackingInterfaces.SendMailBody} body
       * @param {string} project - Project ID or project name
       */
      sendMail(body, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "12438500-2f84-4fa7-9f1a-c31871b4959d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, body, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} tagIdOrName
       */
      deleteTag(project, tagIdOrName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tagIdOrName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} tagIdOrName
       */
      getTag(project, tagIdOrName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tagIdOrName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getTags(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {WorkItemTrackingInterfaces.WorkItemTagDefinition} tagData
       * @param {string} project - Project ID or project name
       * @param {string} tagIdOrName
       */
      updateTag(tagData, project, tagIdOrName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tagIdOrName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, tagData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a template
       *
       * @param {WorkItemTrackingInterfaces.WorkItemTemplate} template - Template contents
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      createTemplate(template2, teamContext) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "6a90345f-a676-4969-afce-8e163e1d5642", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, template2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets template
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} workitemtypename - Optional, When specified returns templates for given Work item type.
       */
      getTemplates(teamContext, workitemtypename) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              workitemtypename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "6a90345f-a676-4969-afce-8e163e1d5642", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the template with given id
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} templateId - Template id
       */
      deleteTemplate(teamContext, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "fb10264a-8836-48a0-8033-1b0ccd2748d5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the template with specified id
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} templateId - Template Id
       */
      getTemplate(teamContext, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "fb10264a-8836-48a0-8033-1b0ccd2748d5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace template contents
       *
       * @param {WorkItemTrackingInterfaces.WorkItemTemplate} templateContent - Template contents to replace with
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} templateId - Template id
       */
      replaceTemplate(templateContent, teamContext, templateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "fb10264a-8836-48a0-8033-1b0ccd2748d5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, templateContent, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single update for a work item
       *
       * @param {number} id
       * @param {number} updateNumber
       * @param {string} project - Project ID or project name
       */
      getUpdate(id, updateNumber, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id,
              updateNumber
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "6570bf97-d02c-4a91-8d93-3abe9895b1a9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemUpdate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a the deltas between work item revisions
       *
       * @param {number} id
       * @param {number} top
       * @param {number} skip
       * @param {string} project - Project ID or project name
       */
      getUpdates(id, top, skip, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "6570bf97-d02c-4a91-8d93-3abe9895b1a9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemUpdate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the results of the query given its WIQL.
       *
       * @param {WorkItemTrackingInterfaces.Wiql} wiql - The query containing the WIQL.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {boolean} timePrecision - Whether or not to use time precision.
       * @param {number} top - The max number of results to return.
       */
      queryByWiql(wiql, teamContext, timePrecision, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              timePrecision,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "1a9c53f7-f243-4447-b110-35ef023636e4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, wiql, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the results of the query given the query ID.
       *
       * @param {string} id - The query ID.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {boolean} timePrecision - Whether or not to use time precision.
       * @param {number} top - The max number of results to return.
       */
      queryById(id, teamContext, timePrecision, top) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            let queryValues = {
              timePrecision,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a02355f5-5f8a-4671-8e32-369d23aac83d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a work item icon given the friendly name and icon color.
       *
       * @param {string} icon - The name of the icon
       * @param {string} color - The 6-digit hex color for the icon
       * @param {number} v - The version of the icon (used only for cache invalidation)
       */
      getWorkItemIconJson(icon, color, v) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              icon
            };
            let queryValues = {
              color,
              v
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of all work item icons.
       *
       */
      getWorkItemIcons() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a work item icon given the friendly name and icon color.
       *
       * @param {string} icon - The name of the icon
       * @param {string} color - The 6-digit hex color for the icon
       * @param {number} v - The version of the icon (used only for cache invalidation)
       */
      getWorkItemIconSvg(icon, color, v) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              icon
            };
            let queryValues = {
              color,
              v
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("image/svg+xml", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a work item icon given the friendly name and icon color.
       *
       * @param {string} icon - The name of the icon
       * @param {string} color - The 6-digit hex color for the icon
       * @param {number} v - The version of the icon (used only for cache invalidation)
       */
      getWorkItemIconXaml(icon, color, v) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              icon
            };
            let queryValues = {
              color,
              v
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("image/xaml+xml", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a batch of work item links
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} linkTypes - A list of types to filter the results to specific link types. Omit this parameter to get work item links of all link types.
       * @param {string[]} types - A list of types to filter the results to specific work item types. Omit this parameter to get work item links of all work item types.
       * @param {string} continuationToken - Specifies the continuationToken to start the batch from. Omit this parameter to get the first batch of links.
       * @param {Date} startDateTime - Date/time to use as a starting point for link changes. Only link changes that occurred after that date/time will be returned. Cannot be used in conjunction with 'watermark' parameter.
       */
      getReportingLinksByLinkType(project, linkTypes, types, continuationToken, startDateTime) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              linkTypes: linkTypes && linkTypes.join(","),
              types: types && types.join(","),
              continuationToken,
              startDateTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "b5b5b6d0-0308-40a1-b3f4-b9bb3c66878f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work item relation type definition.
       *
       * @param {string} relation - The relation name
       */
      getRelationType(relation) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              relation
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f5d33bc9-5b49-4a3c-a9bd-f3cd46dd2165", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work item relation types.
       *
       */
      getRelationTypes() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f5d33bc9-5b49-4a3c-a9bd-f3cd46dd2165", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a batch of work item revisions with the option of including deleted items
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} fields - A list of fields to return in work item revisions. Omit this parameter to get all reportable fields.
       * @param {string[]} types - A list of types to filter the results to specific work item types. Omit this parameter to get work item revisions of all work item types.
       * @param {string} continuationToken - Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
       * @param {Date} startDateTime - Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with 'watermark' parameter.
       * @param {boolean} includeIdentityRef - Return an identity reference instead of a string value for identity fields.
       * @param {boolean} includeDeleted - Specify if the deleted item should be returned.
       * @param {boolean} includeTagRef - Specify if the tag objects should be returned for System.Tags field.
       * @param {boolean} includeLatestOnly - Return only the latest revisions of work items, skipping all historical revisions
       * @param {WorkItemTrackingInterfaces.ReportingRevisionsExpand} expand - Return all the fields in work item revisions, including long text fields which are not returned by default
       * @param {boolean} includeDiscussionChangesOnly - Return only the those revisions of work items, where only history field was changed
       * @param {number} maxPageSize - The maximum number of results to return in this batch
       */
      readReportingRevisionsGet(project, fields, types, continuationToken, startDateTime, includeIdentityRef, includeDeleted, includeTagRef, includeLatestOnly, expand, includeDiscussionChangesOnly, maxPageSize) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fields: fields && fields.join(","),
              types: types && types.join(","),
              continuationToken,
              startDateTime,
              includeIdentityRef,
              includeDeleted,
              includeTagRef,
              includeLatestOnly,
              "$expand": expand,
              includeDiscussionChangesOnly,
              "$maxPageSize": maxPageSize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f828fe59-dd87-495d-a17c-7a8d6211ca6c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a batch of work item revisions. This request may be used if your list of fields is large enough that it may run the URL over the length limit.
       *
       * @param {WorkItemTrackingInterfaces.ReportingWorkItemRevisionsFilter} filter - An object that contains request settings: field filter, type filter, identity format
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken - Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
       * @param {Date} startDateTime - Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with 'watermark' parameter.
       * @param {WorkItemTrackingInterfaces.ReportingRevisionsExpand} expand
       */
      readReportingRevisionsPost(filter2, project, continuationToken, startDateTime, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken,
              startDateTime,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f828fe59-dd87-495d-a17c-7a8d6211ca6c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken
       * @param {number} maxPageSize
       */
      readReportingDiscussions(project, continuationToken, maxPageSize) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken,
              "$maxPageSize": maxPageSize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4a644469-90c5-4fcc-9a9f-be0827d369ec", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a single work item.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - The JSON Patch document representing the work item
       * @param {string} project - Project ID or project name
       * @param {string} type - The work item type of the work item to create
       * @param {boolean} validateOnly - Indicate if you only want to validate the changes without saving the work item
       * @param {boolean} bypassRules - Do not enforce the work item type rules on this update
       * @param {boolean} suppressNotifications - Do not fire any notifications for this change
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       */
      createWorkItem(customHeaders, document, project, type, validateOnly, bypassRules, suppressNotifications, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              validateOnly,
              bypassRules,
              suppressNotifications,
              "$expand": expand
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "62d3d110-0047-428c-ad3c-4fe872c91c74", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.create(url, document, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single work item from a template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - The work item type name
       * @param {string} fields - Comma-separated list of requested fields
       * @param {Date} asOf - AsOf UTC date time string
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       */
      getWorkItemTemplate(project, type, fields, asOf, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              fields,
              asOf,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "62d3d110-0047-428c-ad3c-4fe872c91c74", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the specified work item and sends it to the Recycle Bin, so that it can be restored back, if required. Optionally, if the destroy parameter has been set to true, it destroys the work item permanently. WARNING: If the destroy parameter is set to true, work items deleted by this command will NOT go to recycle-bin and there is no way to restore/recover them after deletion. It is recommended NOT to use this parameter. If you do, please use this parameter with extreme caution.
       *
       * @param {number} id - ID of the work item to be deleted
       * @param {string} project - Project ID or project name
       * @param {boolean} destroy - Optional parameter, if set to true, the work item is deleted permanently. Please note: the destroy action is PERMANENT and cannot be undone.
       */
      deleteWorkItem(id, project, destroy) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              destroy
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single work item.
       *
       * @param {number} id - The work item id
       * @param {string[]} fields - Comma-separated list of requested fields
       * @param {Date} asOf - AsOf UTC date time string
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       * @param {string} project - Project ID or project name
       */
      getWorkItem(id, fields, asOf, expand, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              fields: fields && fields.join(","),
              asOf,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of work items (Maximum 200)
       *
       * @param {number[]} ids - The comma-separated list of requested work item ids. (Maximum 200 ids allowed).
       * @param {string[]} fields - Comma-separated list of requested fields
       * @param {Date} asOf - AsOf UTC date time string
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       * @param {WorkItemTrackingInterfaces.WorkItemErrorPolicy} errorPolicy - The flag to control error policy in a bulk get work items request. Possible options are {Fail, Omit}.
       * @param {string} project - Project ID or project name
       */
      getWorkItems(ids, fields, asOf, expand, errorPolicy, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(","),
              fields: fields && fields.join(","),
              asOf,
              "$expand": expand,
              errorPolicy
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a single work item.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - The JSON Patch document representing the update
       * @param {number} id - The id of the work item to update
       * @param {string} project - Project ID or project name
       * @param {boolean} validateOnly - Indicate if you only want to validate the changes without saving the work item
       * @param {boolean} bypassRules - Do not enforce the work item type rules on this update
       * @param {boolean} suppressNotifications - Do not fire any notifications for this change
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       */
      updateWorkItem(customHeaders, document, id, project, validateOnly, bypassRules, suppressNotifications, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              validateOnly,
              bypassRules,
              suppressNotifications,
              "$expand": expand
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              options2.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, document, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets work items for a list of work item ids (Maximum 200)
       *
       * @param {WorkItemTrackingInterfaces.WorkItemBatchGetRequest} workItemGetRequest
       * @param {string} project - Project ID or project name
       */
      getWorkItemsBatch(workItemGetRequest, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "908509b6-4248-4475-a1cd-829139ba419f", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemGetRequest, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: It will be used for My account work experience. Get the work item type state color for multiple projects
       *
       * @param {string[]} projectNames
       */
      getWorkItemStateColors(projectNames) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "0b83df8a-3496-4ddb-ba44-63634f4cda61", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectNames, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the next state on the given work item IDs.
       *
       * @param {number[]} ids - list of work item ids
       * @param {string} action - possible actions. Currently only supports checkin
       */
      getWorkItemNextStatesOnCheckinAction(ids, action) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              ids: ids && ids.join(","),
              action
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "afae844b-e2f6-44c2-8053-17b3bb936a40", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all work item type categories.
       *
       * @param {string} project - Project ID or project name
       */
      getWorkItemTypeCategories(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "9b9f5734-36c8-415e-ba67-f83b45c31408", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get specific work item type category by name.
       *
       * @param {string} project - Project ID or project name
       * @param {string} category - The category name
       */
      getWorkItemTypeCategory(project, category) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              category
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "9b9f5734-36c8-415e-ba67-f83b45c31408", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: It will be used for My account work experience. Get the wit type color for multiple projects
       *
       * @param {string[]} projectNames
       */
      getWorkItemTypeColors(projectNames) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "958fde80-115e-43fb-bd65-749c48057faf", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectNames, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: It is used for color and icon providers. Get the wit type color for multiple projects
       *
       * @param {string[]} projectNames
       */
      getWorkItemTypeColorAndIcons(projectNames) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f0f8dc62-3975-48ce-8051-f636b68b52e3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectNames, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a work item type definition.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - Work item type name
       */
      getWorkItemType(project, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "7c8d7a76-4a09-43e8-b5df-bd792f4ac6aa", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of work item types
       *
       * @param {string} project - Project ID or project name
       */
      getWorkItemTypes(project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "7c8d7a76-4a09-43e8-b5df-bd792f4ac6aa", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of fields for a work item type with detailed references.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - Work item type.
       * @param {WorkItemTrackingInterfaces.WorkItemTypeFieldsExpandLevel} expand - Expand level for the API response. Properties: to include allowedvalues, default value, isRequired etc. as a part of response; None: to skip these properties.
       */
      getWorkItemTypeFieldsWithReferences(project, type, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "bd293ce5-3d25-4192-8e67-e8092e879efb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a field for a work item type with detailed references.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - Work item type.
       * @param {string} field
       * @param {WorkItemTrackingInterfaces.WorkItemTypeFieldsExpandLevel} expand - Expand level for the API response. Properties: to include allowedvalues, default value, isRequired etc. as a part of response; None: to skip these properties.
       */
      getWorkItemTypeFieldWithReferences(project, type, field, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type,
              field
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "bd293ce5-3d25-4192-8e67-e8092e879efb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the state names and colors for a work item type.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - The state name
       */
      getWorkItemTypeStates(project, type) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "7c9d7a76-4a09-43e8-b5df-bd792f4ac6aa", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Export work item type
       *
       * @param {string} project - Project ID or project name
       * @param {string} type
       * @param {boolean} exportGlobalLists
       */
      exportWorkItemTypeDefinition(project, type, exportGlobalLists) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              exportGlobalLists
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "8637ac8b-5eb6-4f90-b3f7-4f2ff576a459", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add/updates a work item type
       *
       * @param {WorkItemTrackingInterfaces.WorkItemTypeTemplateUpdateModel} updateModel
       * @param {string} project - Project ID or project name
       */
      updateWorkItemTypeDefinition(updateModel, project) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "8637ac8b-5eb6-4f90-b3f7-4f2ff576a459", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, updateModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkItemTrackingApi = WorkItemTrackingApi;
    WorkItemTrackingApi.RESOURCE_AREA_ID = "5264459e-e5e0-4bd8-b118-0985e68a4ec5";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessInterfaces.js
var require_WorkItemTrackingProcessInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkItemTypeClass = exports2.RuleConditionType = exports2.RuleActionType = exports2.ProcessWorkItemTypeFieldsExpandLevel = exports2.ProcessClass = exports2.PageType = exports2.GetWorkItemTypeExpand = exports2.GetProcessExpandLevel = exports2.GetBehaviorsExpand = exports2.FieldType = exports2.CustomizationType = void 0;
    var CustomizationType;
    (function(CustomizationType2) {
      CustomizationType2[CustomizationType2["System"] = 1] = "System";
      CustomizationType2[CustomizationType2["Inherited"] = 2] = "Inherited";
      CustomizationType2[CustomizationType2["Custom"] = 3] = "Custom";
    })(CustomizationType = exports2.CustomizationType || (exports2.CustomizationType = {}));
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 1] = "String";
      FieldType2[FieldType2["Integer"] = 2] = "Integer";
      FieldType2[FieldType2["DateTime"] = 3] = "DateTime";
      FieldType2[FieldType2["PlainText"] = 5] = "PlainText";
      FieldType2[FieldType2["Html"] = 7] = "Html";
      FieldType2[FieldType2["TreePath"] = 8] = "TreePath";
      FieldType2[FieldType2["History"] = 9] = "History";
      FieldType2[FieldType2["Double"] = 10] = "Double";
      FieldType2[FieldType2["Guid"] = 11] = "Guid";
      FieldType2[FieldType2["Boolean"] = 12] = "Boolean";
      FieldType2[FieldType2["Identity"] = 13] = "Identity";
      FieldType2[FieldType2["PicklistInteger"] = 14] = "PicklistInteger";
      FieldType2[FieldType2["PicklistString"] = 15] = "PicklistString";
      FieldType2[FieldType2["PicklistDouble"] = 16] = "PicklistDouble";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var GetBehaviorsExpand;
    (function(GetBehaviorsExpand2) {
      GetBehaviorsExpand2[GetBehaviorsExpand2["None"] = 0] = "None";
      GetBehaviorsExpand2[GetBehaviorsExpand2["Fields"] = 1] = "Fields";
      GetBehaviorsExpand2[GetBehaviorsExpand2["CombinedFields"] = 2] = "CombinedFields";
    })(GetBehaviorsExpand = exports2.GetBehaviorsExpand || (exports2.GetBehaviorsExpand = {}));
    var GetProcessExpandLevel;
    (function(GetProcessExpandLevel2) {
      GetProcessExpandLevel2[GetProcessExpandLevel2["None"] = 0] = "None";
      GetProcessExpandLevel2[GetProcessExpandLevel2["Projects"] = 1] = "Projects";
    })(GetProcessExpandLevel = exports2.GetProcessExpandLevel || (exports2.GetProcessExpandLevel = {}));
    var GetWorkItemTypeExpand;
    (function(GetWorkItemTypeExpand2) {
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["None"] = 0] = "None";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["States"] = 1] = "States";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Behaviors"] = 2] = "Behaviors";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Layout"] = 4] = "Layout";
    })(GetWorkItemTypeExpand = exports2.GetWorkItemTypeExpand || (exports2.GetWorkItemTypeExpand = {}));
    var PageType;
    (function(PageType2) {
      PageType2[PageType2["Custom"] = 1] = "Custom";
      PageType2[PageType2["History"] = 2] = "History";
      PageType2[PageType2["Links"] = 3] = "Links";
      PageType2[PageType2["Attachments"] = 4] = "Attachments";
    })(PageType = exports2.PageType || (exports2.PageType = {}));
    var ProcessClass;
    (function(ProcessClass2) {
      ProcessClass2[ProcessClass2["System"] = 0] = "System";
      ProcessClass2[ProcessClass2["Derived"] = 1] = "Derived";
      ProcessClass2[ProcessClass2["Custom"] = 2] = "Custom";
    })(ProcessClass = exports2.ProcessClass || (exports2.ProcessClass = {}));
    var ProcessWorkItemTypeFieldsExpandLevel;
    (function(ProcessWorkItemTypeFieldsExpandLevel2) {
      ProcessWorkItemTypeFieldsExpandLevel2[ProcessWorkItemTypeFieldsExpandLevel2["None"] = 0] = "None";
      ProcessWorkItemTypeFieldsExpandLevel2[ProcessWorkItemTypeFieldsExpandLevel2["AllowedValues"] = 1] = "AllowedValues";
      ProcessWorkItemTypeFieldsExpandLevel2[ProcessWorkItemTypeFieldsExpandLevel2["All"] = 2] = "All";
    })(ProcessWorkItemTypeFieldsExpandLevel = exports2.ProcessWorkItemTypeFieldsExpandLevel || (exports2.ProcessWorkItemTypeFieldsExpandLevel = {}));
    var RuleActionType;
    (function(RuleActionType2) {
      RuleActionType2[RuleActionType2["MakeRequired"] = 1] = "MakeRequired";
      RuleActionType2[RuleActionType2["MakeReadOnly"] = 2] = "MakeReadOnly";
      RuleActionType2[RuleActionType2["SetDefaultValue"] = 3] = "SetDefaultValue";
      RuleActionType2[RuleActionType2["SetDefaultFromClock"] = 4] = "SetDefaultFromClock";
      RuleActionType2[RuleActionType2["SetDefaultFromCurrentUser"] = 5] = "SetDefaultFromCurrentUser";
      RuleActionType2[RuleActionType2["SetDefaultFromField"] = 6] = "SetDefaultFromField";
      RuleActionType2[RuleActionType2["CopyValue"] = 7] = "CopyValue";
      RuleActionType2[RuleActionType2["CopyFromClock"] = 8] = "CopyFromClock";
      RuleActionType2[RuleActionType2["CopyFromCurrentUser"] = 9] = "CopyFromCurrentUser";
      RuleActionType2[RuleActionType2["CopyFromField"] = 10] = "CopyFromField";
      RuleActionType2[RuleActionType2["SetValueToEmpty"] = 11] = "SetValueToEmpty";
      RuleActionType2[RuleActionType2["CopyFromServerClock"] = 12] = "CopyFromServerClock";
      RuleActionType2[RuleActionType2["CopyFromServerCurrentUser"] = 13] = "CopyFromServerCurrentUser";
      RuleActionType2[RuleActionType2["HideTargetField"] = 14] = "HideTargetField";
      RuleActionType2[RuleActionType2["DisallowValue"] = 15] = "DisallowValue";
    })(RuleActionType = exports2.RuleActionType || (exports2.RuleActionType = {}));
    var RuleConditionType;
    (function(RuleConditionType2) {
      RuleConditionType2[RuleConditionType2["When"] = 1] = "When";
      RuleConditionType2[RuleConditionType2["WhenNot"] = 2] = "WhenNot";
      RuleConditionType2[RuleConditionType2["WhenChanged"] = 3] = "WhenChanged";
      RuleConditionType2[RuleConditionType2["WhenNotChanged"] = 4] = "WhenNotChanged";
      RuleConditionType2[RuleConditionType2["WhenWas"] = 5] = "WhenWas";
      RuleConditionType2[RuleConditionType2["WhenStateChangedTo"] = 6] = "WhenStateChangedTo";
      RuleConditionType2[RuleConditionType2["WhenStateChangedFromAndTo"] = 7] = "WhenStateChangedFromAndTo";
      RuleConditionType2[RuleConditionType2["WhenWorkItemIsCreated"] = 8] = "WhenWorkItemIsCreated";
      RuleConditionType2[RuleConditionType2["WhenValueIsDefined"] = 9] = "WhenValueIsDefined";
      RuleConditionType2[RuleConditionType2["WhenValueIsNotDefined"] = 10] = "WhenValueIsNotDefined";
      RuleConditionType2[RuleConditionType2["WhenCurrentUserIsMemberOfGroup"] = 11] = "WhenCurrentUserIsMemberOfGroup";
      RuleConditionType2[RuleConditionType2["WhenCurrentUserIsNotMemberOfGroup"] = 12] = "WhenCurrentUserIsNotMemberOfGroup";
    })(RuleConditionType = exports2.RuleConditionType || (exports2.RuleConditionType = {}));
    var WorkItemTypeClass;
    (function(WorkItemTypeClass2) {
      WorkItemTypeClass2[WorkItemTypeClass2["System"] = 0] = "System";
      WorkItemTypeClass2[WorkItemTypeClass2["Derived"] = 1] = "Derived";
      WorkItemTypeClass2[WorkItemTypeClass2["Custom"] = 2] = "Custom";
    })(WorkItemTypeClass = exports2.WorkItemTypeClass || (exports2.WorkItemTypeClass = {}));
    exports2.TypeInfo = {
      CreateProcessRuleRequest: {},
      CustomizationType: {
        enumValues: {
          "system": 1,
          "inherited": 2,
          "custom": 3
        }
      },
      FieldModel: {},
      FieldType: {
        enumValues: {
          "string": 1,
          "integer": 2,
          "dateTime": 3,
          "plainText": 5,
          "html": 7,
          "treePath": 8,
          "history": 9,
          "double": 10,
          "guid": 11,
          "boolean": 12,
          "identity": 13,
          "picklistInteger": 14,
          "picklistString": 15,
          "picklistDouble": 16
        }
      },
      FormLayout: {},
      GetBehaviorsExpand: {
        enumValues: {
          "none": 0,
          "fields": 1,
          "combinedFields": 2
        }
      },
      GetProcessExpandLevel: {
        enumValues: {
          "none": 0,
          "projects": 1
        }
      },
      GetWorkItemTypeExpand: {
        enumValues: {
          "none": 0,
          "states": 1,
          "behaviors": 2,
          "layout": 4
        }
      },
      Page: {},
      PageType: {
        enumValues: {
          "custom": 1,
          "history": 2,
          "links": 3,
          "attachments": 4
        }
      },
      ProcessBehavior: {},
      ProcessClass: {
        enumValues: {
          "system": 0,
          "derived": 1,
          "custom": 2
        }
      },
      ProcessInfo: {},
      ProcessModel: {},
      ProcessProperties: {},
      ProcessRule: {},
      ProcessWorkItemType: {},
      ProcessWorkItemTypeField: {},
      ProcessWorkItemTypeFieldsExpandLevel: {
        enumValues: {
          "none": 0,
          "allowedValues": 1,
          "all": 2
        }
      },
      RuleAction: {},
      RuleActionType: {
        enumValues: {
          "makeRequired": 1,
          "makeReadOnly": 2,
          "setDefaultValue": 3,
          "setDefaultFromClock": 4,
          "setDefaultFromCurrentUser": 5,
          "setDefaultFromField": 6,
          "copyValue": 7,
          "copyFromClock": 8,
          "copyFromCurrentUser": 9,
          "copyFromField": 10,
          "setValueToEmpty": 11,
          "copyFromServerClock": 12,
          "copyFromServerCurrentUser": 13,
          "hideTargetField": 14,
          "disallowValue": 15
        }
      },
      RuleCondition: {},
      RuleConditionType: {
        enumValues: {
          "when": 1,
          "whenNot": 2,
          "whenChanged": 3,
          "whenNotChanged": 4,
          "whenWas": 5,
          "whenStateChangedTo": 6,
          "whenStateChangedFromAndTo": 7,
          "whenWorkItemIsCreated": 8,
          "whenValueIsDefined": 9,
          "whenValueIsNotDefined": 10,
          "whenCurrentUserIsMemberOfGroup": 11,
          "whenCurrentUserIsNotMemberOfGroup": 12
        }
      },
      UpdateProcessRuleRequest: {},
      WorkItemStateResultModel: {},
      WorkItemTypeClass: {
        enumValues: {
          "system": 0,
          "derived": 1,
          "custom": 2
        }
      },
      WorkItemTypeModel: {}
    };
    exports2.TypeInfo.CreateProcessRuleRequest.fields = {
      actions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleAction
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleCondition
      }
    };
    exports2.TypeInfo.FieldModel.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.FormLayout.fields = {
      pages: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Page
      }
    };
    exports2.TypeInfo.Page.fields = {
      pageType: {
        enumType: exports2.TypeInfo.PageType
      }
    };
    exports2.TypeInfo.ProcessBehavior.fields = {
      customization: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.ProcessInfo.fields = {
      customizationType: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.ProcessModel.fields = {
      properties: {
        typeInfo: exports2.TypeInfo.ProcessProperties
      }
    };
    exports2.TypeInfo.ProcessProperties.fields = {
      class: {
        enumType: exports2.TypeInfo.ProcessClass
      }
    };
    exports2.TypeInfo.ProcessRule.fields = {
      actions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleAction
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleCondition
      },
      customizationType: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.ProcessWorkItemType.fields = {
      customization: {
        enumType: exports2.TypeInfo.CustomizationType
      },
      layout: {
        typeInfo: exports2.TypeInfo.FormLayout
      },
      states: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemStateResultModel
      }
    };
    exports2.TypeInfo.ProcessWorkItemTypeField.fields = {
      customization: {
        enumType: exports2.TypeInfo.CustomizationType
      },
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.RuleAction.fields = {
      actionType: {
        enumType: exports2.TypeInfo.RuleActionType
      }
    };
    exports2.TypeInfo.RuleCondition.fields = {
      conditionType: {
        enumType: exports2.TypeInfo.RuleConditionType
      }
    };
    exports2.TypeInfo.UpdateProcessRuleRequest.fields = {
      actions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleAction
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleCondition
      }
    };
    exports2.TypeInfo.WorkItemStateResultModel.fields = {
      customizationType: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.WorkItemTypeModel.fields = {
      class: {
        enumType: exports2.TypeInfo.WorkItemTypeClass
      },
      layout: {
        typeInfo: exports2.TypeInfo.FormLayout
      },
      states: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemStateResultModel
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/WorkItemTrackingProcessApi.js
var require_WorkItemTrackingProcessApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/WorkItemTrackingProcessApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkItemTrackingProcessApi = void 0;
    var basem = require_ClientApiBases();
    var WorkItemTrackingProcessInterfaces = require_WorkItemTrackingProcessInterfaces();
    var WorkItemTrackingProcessApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-WorkItemTracking-api", options2);
      }
      /**
       * Creates a single behavior in the given process.
       *
       * @param {WorkItemTrackingProcessInterfaces.ProcessBehaviorCreateRequest} behavior
       * @param {string} processId - The ID of the process
       */
      createProcessBehavior(behavior, processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      deleteProcessBehavior(processId, behaviorRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a behavior of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorRefName - The reference name of the behavior
       * @param {WorkItemTrackingProcessInterfaces.GetBehaviorsExpand} expand
       */
      getProcessBehavior(processId, behaviorRefName, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {WorkItemTrackingProcessInterfaces.GetBehaviorsExpand} expand
       */
      getProcessBehaviors(processId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replaces a behavior in the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.ProcessBehaviorUpdateRequest} behaviorData
       * @param {string} processId - The ID of the process
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      updateProcessBehavior(behaviorData, processId, behaviorRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, behaviorData, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a control in a group.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control - The control.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group to add the control to.
       */
      createControlInGroup(control, processId, witRefName, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, control, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a control to a specified group.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control - The control.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group to move the control to.
       * @param {string} controlId - The ID of the control.
       * @param {string} removeFromGroupId - The group ID to remove the control from.
       */
      moveControlToGroup(control, processId, witRefName, groupId, controlId, removeFromGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            let queryValues = {
              removeFromGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, control, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a control from the work item form.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group.
       * @param {string} controlId - The ID of the control to remove.
       */
      removeControlFromGroup(processId, witRefName, groupId, controlId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a control on the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control - The updated control.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group.
       * @param {string} controlId - The ID of the control.
       */
      updateControl(control, processId, witRefName, groupId, controlId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, control, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a field to a work item type.
       *
       * @param {WorkItemTrackingProcessInterfaces.AddProcessWorkItemTypeFieldRequest} field
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      addFieldToWorkItemType(field, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, field, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all fields in a work item type.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      getAllWorkItemTypeFields(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a field in a work item type.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} fieldRefName - The reference name of the field.
       * @param {WorkItemTrackingProcessInterfaces.ProcessWorkItemTypeFieldsExpandLevel} expand
       */
      getWorkItemTypeField(processId, witRefName, fieldRefName, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              fieldRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a field from a work item type. Does not permanently delete the field.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} fieldRefName - The reference name of the field.
       */
      removeWorkItemTypeField(processId, witRefName, fieldRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a field in a work item type.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessWorkItemTypeFieldRequest} field
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} fieldRefName - The reference name of the field.
       */
      updateWorkItemTypeField(field, processId, witRefName, fieldRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, field, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a group to the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page to add the group to.
       * @param {string} sectionId - The ID of the section to add the group to.
       */
      addGroup(group2, processId, witRefName, pageId, sectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different page and section.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The updated group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page the group is in.
       * @param {string} sectionId - The ID of the section the group is i.n
       * @param {string} groupId - The ID of the group.
       * @param {string} removeFromPageId - ID of the page to remove the group from.
       * @param {string} removeFromSectionId - ID of the section to remove the group from.
       */
      moveGroupToPage(group2, processId, witRefName, pageId, sectionId, groupId, removeFromPageId, removeFromSectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (removeFromPageId == null) {
            throw new TypeError("removeFromPageId can not be null or undefined");
          }
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromPageId,
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different section.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The updated group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page the group is in.
       * @param {string} sectionId - The ID of the section the group is in.
       * @param {string} groupId - The ID of the group.
       * @param {string} removeFromSectionId - ID of the section to remove the group from.
       */
      moveGroupToSection(group2, processId, witRefName, pageId, sectionId, groupId, removeFromSectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a group from the work item form.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section to the group is in
       * @param {string} groupId - The ID of the group
       */
      removeGroup(processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a group in the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The updated group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page the group is in.
       * @param {string} sectionId - The ID of the section the group is in.
       * @param {string} groupId - The ID of the group.
       */
      updateGroup(group2, processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the form layout.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      getFormLayout(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "fa8646eb-43cd-4b71-9564-40106fd63e40", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.FormLayout, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a picklist.
       *
       * @param {WorkItemTrackingProcessInterfaces.PickList} picklist - Picklist
       */
      createList(picklist) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, picklist, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      deleteList(listId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      getList(listId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns meta data of the picklist.
       *
       */
      getListsMetadata() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a list.
       *
       * @param {WorkItemTrackingProcessInterfaces.PickList} picklist
       * @param {string} listId - The ID of the list
       */
      updateList(picklist, listId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, picklist, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a page to the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Page} page - The page.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      addPage(page, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1cc7b29f-6697-4d9d-b0a1-2650d3e1d584", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, page, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a page from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page
       */
      removePage(processId, witRefName, pageId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1cc7b29f-6697-4d9d-b0a1-2650d3e1d584", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a page on the work item form
       *
       * @param {WorkItemTrackingProcessInterfaces.Page} page - The page
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      updatePage(page, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1cc7b29f-6697-4d9d-b0a1-2650d3e1d584", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, page, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a process.
       *
       * @param {WorkItemTrackingProcessInterfaces.CreateProcessModel} createRequest - CreateProcessModel.
       */
      createNewProcess(createRequest) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createRequest, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a process of a specific ID.
       *
       * @param {string} processTypeId
       */
      deleteProcessById(processTypeId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processTypeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Edit a process of a specific ID.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessModel} updateRequest
       * @param {string} processTypeId
       */
      editProcess(updateRequest, processTypeId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processTypeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateRequest, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of all processes including system and inherited.
       *
       * @param {WorkItemTrackingProcessInterfaces.GetProcessExpandLevel} expand
       */
      getListOfProcesses(expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single process of a specified ID.
       *
       * @param {string} processTypeId
       * @param {WorkItemTrackingProcessInterfaces.GetProcessExpandLevel} expand
       */
      getProcessByItsId(processTypeId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processTypeId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a rule to work item type in the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.CreateProcessRuleRequest} processRuleCreate
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      addProcessWorkItemTypeRule(processRuleCreate, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, processRuleCreate, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a rule from the work item type in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} ruleId - The ID of the rule
       */
      deleteProcessWorkItemTypeRule(processId, witRefName, ruleId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              ruleId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single rule in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} ruleId - The ID of the rule
       */
      getProcessWorkItemTypeRule(processId, witRefName, ruleId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              ruleId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all rules in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getProcessWorkItemTypeRules(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a rule in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessRuleRequest} processRule
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} ruleId - The ID of the rule
       */
      updateProcessWorkItemTypeRule(processRule, processId, witRefName, ruleId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              ruleId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, processRule, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      createStateDefinition(stateModel, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, stateModel, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a state definition in the work item type of the process.
       *
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      deleteStateDefinition(processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single state definition in a work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      getStateDefinition(processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all state definitions in a work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getStateDefinitions(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Hides a state definition in the work item type of the process.Only states with customizationType:System can be hidden.
       *
       * @param {WorkItemTrackingProcessInterfaces.HideStateModel} hideStateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      hideStateDefinition(hideStateModel, processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, hideStateModel, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a given state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      updateStateDefinition(stateModel, processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, stateModel, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a system control modification on the work item form.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} controlId - The ID of the control.
       */
      deleteSystemControl(processId, witRefName, controlId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "ff9a3d2c-32b7-4c6c-991c-d5a251fb9098", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets edited system controls for a work item type in a process. To get all system controls (base + edited) use layout API(s)
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      getSystemControls(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "ff9a3d2c-32b7-4c6c-991c-d5a251fb9098", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates/adds a system control on the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} controlId - The ID of the control.
       */
      updateSystemControl(control, processId, witRefName, controlId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "ff9a3d2c-32b7-4c6c-991c-d5a251fb9098", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, control, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a work item type in the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.CreateProcessWorkItemTypeRequest} workItemType
       * @param {string} processId - The ID of the process on which to create work item type.
       */
      createProcessWorkItemType(workItemType, processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemType, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a work item type in the process.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      deleteProcessWorkItemType(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single work item type in a process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {WorkItemTrackingProcessInterfaces.GetWorkItemTypeExpand} expand - Flag to determine what properties of work item type to return
       */
      getProcessWorkItemType(processId, witRefName, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all work item types in a process.
       *
       * @param {string} processId - The ID of the process
       * @param {WorkItemTrackingProcessInterfaces.GetWorkItemTypeExpand} expand - Flag to determine what properties of work item type to return
       */
      getProcessWorkItemTypes(processId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessWorkItemTypeRequest} workItemTypeUpdate
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      updateProcessWorkItemType(workItemTypeUpdate, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, workItemTypeUpdate, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a behavior to the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      addBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      getBehaviorForWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      getBehaviorsForWorkItemType(processId, witRefNameForBehaviors) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      removeBehaviorFromWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a behavior for the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      updateBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, behavior, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkItemTrackingProcessApi = WorkItemTrackingProcessApi;
    WorkItemTrackingProcessApi.RESOURCE_AREA_ID = "5264459e-e5e0-4bd8-b118-0985e68a4ec5";
  }
});

// packages/core/node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessDefinitionsInterfaces.js
var require_WorkItemTrackingProcessDefinitionsInterfaces = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessDefinitionsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkItemTypeClass = exports2.PageType = exports2.GetWorkItemTypeExpand = exports2.FieldType = void 0;
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 1] = "String";
      FieldType2[FieldType2["Integer"] = 2] = "Integer";
      FieldType2[FieldType2["DateTime"] = 3] = "DateTime";
      FieldType2[FieldType2["PlainText"] = 5] = "PlainText";
      FieldType2[FieldType2["Html"] = 7] = "Html";
      FieldType2[FieldType2["TreePath"] = 8] = "TreePath";
      FieldType2[FieldType2["History"] = 9] = "History";
      FieldType2[FieldType2["Double"] = 10] = "Double";
      FieldType2[FieldType2["Guid"] = 11] = "Guid";
      FieldType2[FieldType2["Boolean"] = 12] = "Boolean";
      FieldType2[FieldType2["Identity"] = 13] = "Identity";
      FieldType2[FieldType2["PicklistInteger"] = 14] = "PicklistInteger";
      FieldType2[FieldType2["PicklistString"] = 15] = "PicklistString";
      FieldType2[FieldType2["PicklistDouble"] = 16] = "PicklistDouble";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var GetWorkItemTypeExpand;
    (function(GetWorkItemTypeExpand2) {
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["None"] = 0] = "None";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["States"] = 1] = "States";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Behaviors"] = 2] = "Behaviors";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Layout"] = 4] = "Layout";
    })(GetWorkItemTypeExpand = exports2.GetWorkItemTypeExpand || (exports2.GetWorkItemTypeExpand = {}));
    var PageType;
    (function(PageType2) {
      PageType2[PageType2["Custom"] = 1] = "Custom";
      PageType2[PageType2["History"] = 2] = "History";
      PageType2[PageType2["Links"] = 3] = "Links";
      PageType2[PageType2["Attachments"] = 4] = "Attachments";
    })(PageType = exports2.PageType || (exports2.PageType = {}));
    var WorkItemTypeClass;
    (function(WorkItemTypeClass2) {
      WorkItemTypeClass2[WorkItemTypeClass2["System"] = 0] = "System";
      WorkItemTypeClass2[WorkItemTypeClass2["Derived"] = 1] = "Derived";
      WorkItemTypeClass2[WorkItemTypeClass2["Custom"] = 2] = "Custom";
    })(WorkItemTypeClass = exports2.WorkItemTypeClass || (exports2.WorkItemTypeClass = {}));
    exports2.TypeInfo = {
      FieldModel: {},
      FieldType: {
        enumValues: {
          "string": 1,
          "integer": 2,
          "dateTime": 3,
          "plainText": 5,
          "html": 7,
          "treePath": 8,
          "history": 9,
          "double": 10,
          "guid": 11,
          "boolean": 12,
          "identity": 13,
          "picklistInteger": 14,
          "picklistString": 15,
          "picklistDouble": 16
        }
      },
      FormLayout: {},
      GetWorkItemTypeExpand: {
        enumValues: {
          "none": 0,
          "states": 1,
          "behaviors": 2,
          "layout": 4
        }
      },
      Page: {},
      PageType: {
        enumValues: {
          "custom": 1,
          "history": 2,
          "links": 3,
          "attachments": 4
        }
      },
      WorkItemTypeClass: {
        enumValues: {
          "system": 0,
          "derived": 1,
          "custom": 2
        }
      },
      WorkItemTypeFieldModel: {},
      WorkItemTypeFieldModel2: {},
      WorkItemTypeModel: {}
    };
    exports2.TypeInfo.FieldModel.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.FormLayout.fields = {
      pages: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Page
      }
    };
    exports2.TypeInfo.Page.fields = {
      pageType: {
        enumType: exports2.TypeInfo.PageType
      }
    };
    exports2.TypeInfo.WorkItemTypeFieldModel.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.WorkItemTypeFieldModel2.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.WorkItemTypeModel.fields = {
      class: {
        enumType: exports2.TypeInfo.WorkItemTypeClass
      },
      layout: {
        typeInfo: exports2.TypeInfo.FormLayout
      }
    };
  }
});

// packages/core/node_modules/azure-devops-node-api/WorkItemTrackingProcessDefinitionsApi.js
var require_WorkItemTrackingProcessDefinitionsApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/WorkItemTrackingProcessDefinitionsApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkItemTrackingProcessDefinitionsApi = void 0;
    var basem = require_ClientApiBases();
    var WorkItemTrackingProcessDefinitionsInterfaces = require_WorkItemTrackingProcessDefinitionsInterfaces();
    var WorkItemTrackingProcessDefinitionsApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options2, userAgent) {
        super(baseUrl, handlers, userAgent || "node-WorkItemTracking-api", options2);
      }
      /**
       * Creates a single behavior in the given process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.BehaviorCreateModel} behavior
       * @param {string} processId - The ID of the process
       */
      createBehavior(behavior, processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorId - The ID of the behavior
       */
      deleteBehavior(processId, behaviorId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single behavior in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorId - The ID of the behavior
       */
      getBehavior(processId, behaviorId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors in the process.
       *
       * @param {string} processId - The ID of the process
       */
      getBehaviors(processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replaces a behavior in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.BehaviorReplaceModel} behaviorData
       * @param {string} processId - The ID of the process
       * @param {string} behaviorId - The ID of the behavior
       */
      replaceBehavior(behaviorData, processId, behaviorId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, behaviorData, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a control in a group
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Control} control - The control
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group to add the control to
       */
      addControlToGroup(control, processId, witRefName, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, control, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a control on the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Control} control - The updated control
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group
       * @param {string} controlId - The ID of the control
       */
      editControl(control, processId, witRefName, groupId, controlId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, control, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a control from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group
       * @param {string} controlId - The ID of the control to remove
       */
      removeControlFromGroup(processId, witRefName, groupId, controlId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a control to a new group
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Control} control - The control
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group to move the control to
       * @param {string} controlId - The id of the control
       * @param {string} removeFromGroupId - The group to remove the control from
       */
      setControlInGroup(control, processId, witRefName, groupId, controlId, removeFromGroupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            let queryValues = {
              removeFromGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, control, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a single field in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.FieldModel} field
       * @param {string} processId - The ID of the process
       */
      createField(field, processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "f36c66c7-911d-4163-8938-d3c5d0d7f5aa", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, field, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.FieldModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a given field in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.FieldUpdate} field
       * @param {string} processId - The ID of the process
       */
      updateField(field, processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "f36c66c7-911d-4163-8938-d3c5d0d7f5aa", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, field, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.FieldModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a group to the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page to add the group to
       * @param {string} sectionId - The ID of the section to add the group to
       */
      addGroup(group2, processId, witRefName, pageId, sectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a group in the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The updated group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section the group is in
       * @param {string} groupId - The ID of the group
       */
      editGroup(group2, processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a group from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section to the group is in
       * @param {string} groupId - The ID of the group
       */
      removeGroup(processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different page and section
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The updated group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section the group is in
       * @param {string} groupId - The ID of the group
       * @param {string} removeFromPageId - ID of the page to remove the group from
       * @param {string} removeFromSectionId - ID of the section to remove the group from
       */
      setGroupInPage(group2, processId, witRefName, pageId, sectionId, groupId, removeFromPageId, removeFromSectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (removeFromPageId == null) {
            throw new TypeError("removeFromPageId can not be null or undefined");
          }
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromPageId,
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different section
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The updated group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section the group is in
       * @param {string} groupId - The ID of the group
       * @param {string} removeFromSectionId - ID of the section to remove the group from
       */
      setGroupInSection(group2, processId, witRefName, pageId, sectionId, groupId, removeFromSectionId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the form layout
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getFormLayout(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "3eacc80a-ddca-4404-857a-6331aac99063", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.FormLayout, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns meta data of the picklist.
       *
       */
      getListsMetadata() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "b45cc931-98e3-44a1-b1cd-2e8e9c6dc1c6", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a picklist.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.PickListModel} picklist
       */
      createList(picklist) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, picklist, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      deleteList(listId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      getList(listId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a list.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.PickListModel} picklist
       * @param {string} listId - The ID of the list
       */
      updateList(picklist, listId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, picklist, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a page to the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Page} page - The page
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      addPage(page, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1b4ac126-59b2-4f37-b4df-0a48ba807edb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, page, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a page on the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Page} page - The page
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      editPage(page, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1b4ac126-59b2-4f37-b4df-0a48ba807edb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, page, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a page from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page
       */
      removePage(processId, witRefName, pageId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1b4ac126-59b2-4f37-b4df-0a48ba807edb", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      createStateDefinition(stateModel, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, stateModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a state definition in the work item type of the process.
       *
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      deleteStateDefinition(processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a state definition in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      getStateDefinition(processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all state definitions in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getStateDefinitions(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Hides a state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.HideStateModel} hideStateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      hideStateDefinition(hideStateModel, processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, hideStateModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a given state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      updateStateDefinition(stateModel, processId, witRefName, stateId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, stateModel, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a behavior to the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      addBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      getBehaviorForWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      getBehaviorsForWorkItemType(processId, witRefNameForBehaviors) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      removeBehaviorFromWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates default work item type for the behavior of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      updateBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, behavior, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a work item type in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeModel} workItemType
       * @param {string} processId - The ID of the process
       */
      createWorkItemType(workItemType, processId) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemType, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a work item type in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      deleteWorkItemType(processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.GetWorkItemTypeExpand} expand
       */
      getWorkItemType(processId, witRefName, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all work item types in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.GetWorkItemTypeExpand} expand
       */
      getWorkItemTypes(processId, expand) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeUpdateModel} workItemTypeUpdate
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      updateWorkItemType(workItemTypeUpdate, processId, witRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, workItemTypeUpdate, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a field to the work item type in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeFieldModel2} field
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for the field
       */
      addFieldToWorkItemType(field, processId, witRefNameForFields) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, field, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single field in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       * @param {string} fieldRefName - The reference name of the field
       */
      getWorkItemTypeField(processId, witRefNameForFields, fieldRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all fields in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       */
      getWorkItemTypeFields(processId, witRefNameForFields) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a field in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       * @param {string} fieldRefName - The reference name of the field
       */
      removeFieldFromWorkItemType(processId, witRefNameForFields, fieldRefName) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options2);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a single field in the scope of the given process and work item type.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeFieldModel2} field - The model with which to update the field
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       */
      updateWorkItemTypeField(field, processId, witRefNameForFields) {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, field, options2);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkItemTrackingProcessDefinitionsApi = WorkItemTrackingProcessDefinitionsApi;
    WorkItemTrackingProcessDefinitionsApi.RESOURCE_AREA_ID = "5264459e-e5e0-4bd8-b118-0985e68a4ec5";
  }
});

// node_modules/typed-rest-client/handlers/basiccreds.js
var require_basiccreds = __commonJS({
  "node_modules/typed-rest-client/handlers/basiccreds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password, allowCrossOriginAuthentication) {
        this.username = username;
        this.password = password;
        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options2) {
        if (!this.origin) {
          this.origin = options2.host;
        }
        if (this.origin === options2.host || this.allowCrossOriginAuthentication) {
          options2.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
        }
        options2.headers["X-TFS-FedAuthRedirect"] = "Suppress";
      }
      // This handler cannot handle 401
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
  }
});

// node_modules/typed-rest-client/handlers/bearertoken.js
var require_bearertoken = __commonJS({
  "node_modules/typed-rest-client/handlers/bearertoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BearerCredentialHandler = void 0;
    var BearerCredentialHandler = class {
      constructor(token, allowCrossOriginAuthentication) {
        this.token = token;
        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options2) {
        if (!this.origin) {
          this.origin = options2.host;
        }
        if (this.origin === options2.host || this.allowCrossOriginAuthentication) {
          options2.headers["Authorization"] = `Bearer ${this.token}`;
        }
        options2.headers["X-TFS-FedAuthRedirect"] = "Suppress";
      }
      // This handler cannot handle 401
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
  }
});

// node_modules/underscore/modules/_setup.js
var VERSION, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX;
var init_setup = __esm({
  "node_modules/underscore/modules/_setup.js"() {
    VERSION = "1.13.7";
    root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
    ArrayProto = Array.prototype;
    ObjProto = Object.prototype;
    SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    push = ArrayProto.push;
    slice = ArrayProto.slice;
    toString = ObjProto.toString;
    hasOwnProperty = ObjProto.hasOwnProperty;
    supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    supportsDataView = typeof DataView !== "undefined";
    nativeIsArray = Array.isArray;
    nativeKeys = Object.keys;
    nativeCreate = Object.create;
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    _isNaN = isNaN;
    _isFinite = isFinite;
    hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  }
});

// node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
var init_restArguments = __esm({
  "node_modules/underscore/modules/restArguments.js"() {
  }
});

// node_modules/underscore/modules/isObject.js
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}
var init_isObject = __esm({
  "node_modules/underscore/modules/isObject.js"() {
  }
});

// node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}
var init_isNull = __esm({
  "node_modules/underscore/modules/isNull.js"() {
  }
});

// node_modules/underscore/modules/isUndefined.js
function isUndefined(obj) {
  return obj === void 0;
}
var init_isUndefined = __esm({
  "node_modules/underscore/modules/isUndefined.js"() {
  }
});

// node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
var init_isBoolean = __esm({
  "node_modules/underscore/modules/isBoolean.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isElement.js
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}
var init_isElement = __esm({
  "node_modules/underscore/modules/isElement.js"() {
  }
});

// node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
var init_tagTester = __esm({
  "node_modules/underscore/modules/_tagTester.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isString.js
var isString_default;
var init_isString = __esm({
  "node_modules/underscore/modules/isString.js"() {
    init_tagTester();
    isString_default = tagTester("String");
  }
});

// node_modules/underscore/modules/isNumber.js
var isNumber_default;
var init_isNumber = __esm({
  "node_modules/underscore/modules/isNumber.js"() {
    init_tagTester();
    isNumber_default = tagTester("Number");
  }
});

// node_modules/underscore/modules/isDate.js
var isDate_default;
var init_isDate = __esm({
  "node_modules/underscore/modules/isDate.js"() {
    init_tagTester();
    isDate_default = tagTester("Date");
  }
});

// node_modules/underscore/modules/isRegExp.js
var isRegExp_default;
var init_isRegExp = __esm({
  "node_modules/underscore/modules/isRegExp.js"() {
    init_tagTester();
    isRegExp_default = tagTester("RegExp");
  }
});

// node_modules/underscore/modules/isError.js
var isError_default;
var init_isError = __esm({
  "node_modules/underscore/modules/isError.js"() {
    init_tagTester();
    isError_default = tagTester("Error");
  }
});

// node_modules/underscore/modules/isSymbol.js
var isSymbol_default;
var init_isSymbol = __esm({
  "node_modules/underscore/modules/isSymbol.js"() {
    init_tagTester();
    isSymbol_default = tagTester("Symbol");
  }
});

// node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default;
var init_isArrayBuffer = __esm({
  "node_modules/underscore/modules/isArrayBuffer.js"() {
    init_tagTester();
    isArrayBuffer_default = tagTester("ArrayBuffer");
  }
});

// node_modules/underscore/modules/isFunction.js
var isFunction, nodelist, isFunction_default;
var init_isFunction = __esm({
  "node_modules/underscore/modules/isFunction.js"() {
    init_tagTester();
    init_setup();
    isFunction = tagTester("Function");
    nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction = function(obj) {
        return typeof obj == "function" || false;
      };
    }
    isFunction_default = isFunction;
  }
});

// node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default;
var init_hasObjectTag = __esm({
  "node_modules/underscore/modules/_hasObjectTag.js"() {
    init_tagTester();
    hasObjectTag_default = tagTester("Object");
  }
});

// node_modules/underscore/modules/_stringTagBug.js
var hasDataViewBug, isIE11;
var init_stringTagBug = __esm({
  "node_modules/underscore/modules/_stringTagBug.js"() {
    init_setup();
    init_hasObjectTag();
    hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag_default(new DataView(new ArrayBuffer(8))));
    isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());
  }
});

// node_modules/underscore/modules/isDataView.js
function alternateIsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView, isDataView_default;
var init_isDataView = __esm({
  "node_modules/underscore/modules/isDataView.js"() {
    init_tagTester();
    init_isFunction();
    init_isArrayBuffer();
    init_stringTagBug();
    isDataView = tagTester("DataView");
    isDataView_default = hasDataViewBug ? alternateIsDataView : isDataView;
  }
});

// node_modules/underscore/modules/isArray.js
var isArray_default;
var init_isArray = __esm({
  "node_modules/underscore/modules/isArray.js"() {
    init_setup();
    init_tagTester();
    isArray_default = nativeIsArray || tagTester("Array");
  }
});

// node_modules/underscore/modules/_has.js
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var init_has = __esm({
  "node_modules/underscore/modules/_has.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isArguments.js
var isArguments, isArguments_default;
var init_isArguments = __esm({
  "node_modules/underscore/modules/isArguments.js"() {
    init_tagTester();
    init_has();
    isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has(obj, "callee");
        };
      }
    })();
    isArguments_default = isArguments;
  }
});

// node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
var init_isFinite = __esm({
  "node_modules/underscore/modules/isFinite.js"() {
    init_setup();
    init_isSymbol();
  }
});

// node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}
var init_isNaN = __esm({
  "node_modules/underscore/modules/isNaN.js"() {
    init_setup();
    init_isNumber();
  }
});

// node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var init_constant = __esm({
  "node_modules/underscore/modules/constant.js"() {
  }
});

// node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
var init_createSizePropertyCheck = __esm({
  "node_modules/underscore/modules/_createSizePropertyCheck.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
var init_shallowProperty = __esm({
  "node_modules/underscore/modules/_shallowProperty.js"() {
  }
});

// node_modules/underscore/modules/_getByteLength.js
var getByteLength_default;
var init_getByteLength = __esm({
  "node_modules/underscore/modules/_getByteLength.js"() {
    init_shallowProperty();
    getByteLength_default = shallowProperty("byteLength");
  }
});

// node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default;
var init_isBufferLike = __esm({
  "node_modules/underscore/modules/_isBufferLike.js"() {
    init_createSizePropertyCheck();
    init_getByteLength();
    isBufferLike_default = createSizePropertyCheck(getByteLength_default);
  }
});

// node_modules/underscore/modules/isTypedArray.js
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString.call(obj));
}
var typedArrayPattern, isTypedArray_default;
var init_isTypedArray = __esm({
  "node_modules/underscore/modules/isTypedArray.js"() {
    init_setup();
    init_isDataView();
    init_constant();
    init_isBufferLike();
    typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);
  }
});

// node_modules/underscore/modules/_getLength.js
var getLength_default;
var init_getLength = __esm({
  "node_modules/underscore/modules/_getLength.js"() {
    init_shallowProperty();
    getLength_default = shallowProperty("length");
  }
});

// node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l = keys2.length, i = 0; i < l; ++i) hash[keys2[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj, prop) && !keys2.contains(prop)) keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
var init_collectNonEnumProps = __esm({
  "node_modules/underscore/modules/_collectNonEnumProps.js"() {
    init_setup();
    init_isFunction();
    init_has();
  }
});

// node_modules/underscore/modules/keys.js
function keys(obj) {
  if (!isObject(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj) if (has(obj, key)) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_keys = __esm({
  "node_modules/underscore/modules/keys.js"() {
    init_isObject();
    init_setup();
    init_has();
    init_collectNonEnumProps();
  }
});

// node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null) return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj))) return length === 0;
  return getLength_default(keys(obj)) === 0;
}
var init_isEmpty = __esm({
  "node_modules/underscore/modules/isEmpty.js"() {
    init_getLength();
    init_isArray();
    init_isString();
    init_isArguments();
    init_keys();
  }
});

// node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null) return !length;
  var obj = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}
var init_isMatch = __esm({
  "node_modules/underscore/modules/isMatch.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/underscore.js
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}
var init_underscore = __esm({
  "node_modules/underscore/modules/underscore.js"() {
    init_setup();
    _.VERSION = VERSION;
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return String(this._wrapped);
    };
  }
});

// node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}
var init_toBufferView = __esm({
  "node_modules/underscore/modules/_toBufferView.js"() {
    init_getByteLength();
  }
});

// node_modules/underscore/modules/isEqual.js
function eq(a, b, aStack, bStack) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null) return false;
  if (a !== a) return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _) a = a._wrapped;
  if (b instanceof _) b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  if (hasDataViewBug && className == "[object Object]" && isDataView_default(a)) {
    if (!isDataView_default(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a)) {
    var byteLength = getByteLength_default(a);
    if (byteLength !== getByteLength_default(b)) return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length) return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}
var tagDataView;
var init_isEqual = __esm({
  "node_modules/underscore/modules/isEqual.js"() {
    init_underscore();
    init_setup();
    init_getByteLength();
    init_isTypedArray();
    init_isFunction();
    init_stringTagBug();
    init_isDataView();
    init_keys();
    init_has();
    init_toBufferView();
    tagDataView = "[object DataView]";
  }
});

// node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject(obj)) return [];
  var keys2 = [];
  for (var key in obj) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_allKeys = __esm({
  "node_modules/underscore/modules/allKeys.js"() {
    init_isObject();
    init_setup();
    init_collectNonEnumProps();
  }
});

// node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null) return false;
    var keys2 = allKeys(obj);
    if (getLength_default(keys2)) return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction_default(obj[methods[i]])) return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName, hasName, commonInit, mapTail, mapMethods, weakMapMethods, setMethods;
var init_methodFingerprint = __esm({
  "node_modules/underscore/modules/_methodFingerprint.js"() {
    init_getLength();
    init_isFunction();
    init_allKeys();
    forEachName = "forEach";
    hasName = "has";
    commonInit = ["clear", "delete"];
    mapTail = ["get", hasName, "set"];
    mapMethods = commonInit.concat(forEachName, mapTail);
    weakMapMethods = commonInit.concat(mapTail);
    setMethods = ["add"].concat(commonInit, forEachName, hasName);
  }
});

// node_modules/underscore/modules/isMap.js
var isMap_default;
var init_isMap = __esm({
  "node_modules/underscore/modules/isMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  }
});

// node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default;
var init_isWeakMap = __esm({
  "node_modules/underscore/modules/isWeakMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  }
});

// node_modules/underscore/modules/isSet.js
var isSet_default;
var init_isSet = __esm({
  "node_modules/underscore/modules/isSet.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  }
});

// node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default;
var init_isWeakSet = __esm({
  "node_modules/underscore/modules/isWeakSet.js"() {
    init_tagTester();
    isWeakSet_default = tagTester("WeakSet");
  }
});

// node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj[_keys[i]];
  }
  return values2;
}
var init_values = __esm({
  "node_modules/underscore/modules/values.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs2;
}
var init_pairs = __esm({
  "node_modules/underscore/modules/pairs.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj[_keys[i]]] = _keys[i];
  }
  return result2;
}
var init_invert = __esm({
  "node_modules/underscore/modules/invert.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/functions.js
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction_default(obj[key])) names.push(key);
  }
  return names.sort();
}
var init_functions = __esm({
  "node_modules/underscore/modules/functions.js"() {
    init_isFunction();
  }
});

// node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
      for (var i = 0; i < l; i++) {
        var key = keys2[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}
var init_createAssigner = __esm({
  "node_modules/underscore/modules/_createAssigner.js"() {
  }
});

// node_modules/underscore/modules/extend.js
var extend_default;
var init_extend = __esm({
  "node_modules/underscore/modules/extend.js"() {
    init_createAssigner();
    init_allKeys();
    extend_default = createAssigner(allKeys);
  }
});

// node_modules/underscore/modules/extendOwn.js
var extendOwn_default;
var init_extendOwn = __esm({
  "node_modules/underscore/modules/extendOwn.js"() {
    init_createAssigner();
    init_keys();
    extendOwn_default = createAssigner(keys);
  }
});

// node_modules/underscore/modules/defaults.js
var defaults_default;
var init_defaults = __esm({
  "node_modules/underscore/modules/defaults.js"() {
    init_createAssigner();
    init_allKeys();
    defaults_default = createAssigner(allKeys, true);
  }
});

// node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
var init_baseCreate = __esm({
  "node_modules/underscore/modules/_baseCreate.js"() {
    init_isObject();
    init_setup();
  }
});

// node_modules/underscore/modules/create.js
function create2(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props) extendOwn_default(result2, props);
  return result2;
}
var init_create = __esm({
  "node_modules/underscore/modules/create.js"() {
    init_baseCreate();
    init_extendOwn();
  }
});

// node_modules/underscore/modules/clone.js
function clone(obj) {
  if (!isObject(obj)) return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}
var init_clone = __esm({
  "node_modules/underscore/modules/clone.js"() {
    init_isObject();
    init_isArray();
    init_extend();
  }
});

// node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
var init_tap = __esm({
  "node_modules/underscore/modules/tap.js"() {
  }
});

// node_modules/underscore/modules/toPath.js
function toPath(path10) {
  return isArray_default(path10) ? path10 : [path10];
}
var init_toPath = __esm({
  "node_modules/underscore/modules/toPath.js"() {
    init_underscore();
    init_isArray();
    _.toPath = toPath;
  }
});

// node_modules/underscore/modules/_toPath.js
function toPath2(path10) {
  return _.toPath(path10);
}
var init_toPath2 = __esm({
  "node_modules/underscore/modules/_toPath.js"() {
    init_underscore();
    init_toPath();
  }
});

// node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path10) {
  var length = path10.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path10[i]];
  }
  return length ? obj : void 0;
}
var init_deepGet = __esm({
  "node_modules/underscore/modules/_deepGet.js"() {
  }
});

// node_modules/underscore/modules/get.js
function get(object2, path10, defaultValue) {
  var value = deepGet(object2, toPath2(path10));
  return isUndefined(value) ? defaultValue : value;
}
var init_get = __esm({
  "node_modules/underscore/modules/get.js"() {
    init_toPath2();
    init_deepGet();
    init_isUndefined();
  }
});

// node_modules/underscore/modules/has.js
function has2(obj, path10) {
  path10 = toPath2(path10);
  var length = path10.length;
  for (var i = 0; i < length; i++) {
    var key = path10[i];
    if (!has(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}
var init_has2 = __esm({
  "node_modules/underscore/modules/has.js"() {
    init_has();
    init_toPath2();
  }
});

// node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}
var init_identity = __esm({
  "node_modules/underscore/modules/identity.js"() {
  }
});

// node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
var init_matcher = __esm({
  "node_modules/underscore/modules/matcher.js"() {
    init_extendOwn();
    init_isMatch();
  }
});

// node_modules/underscore/modules/property.js
function property(path10) {
  path10 = toPath2(path10);
  return function(obj) {
    return deepGet(obj, path10);
  };
}
var init_property = __esm({
  "node_modules/underscore/modules/property.js"() {
    init_deepGet();
    init_toPath2();
  }
});

// node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    // The 2-argument case is omitted because were not using it.
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
var init_optimizeCb = __esm({
  "node_modules/underscore/modules/_optimizeCb.js"() {
  }
});

// node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (isFunction_default(value)) return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray_default(value)) return matcher(value);
  return property(value);
}
var init_baseIteratee = __esm({
  "node_modules/underscore/modules/_baseIteratee.js"() {
    init_identity();
    init_isFunction();
    init_isObject();
    init_isArray();
    init_matcher();
    init_property();
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
var init_iteratee = __esm({
  "node_modules/underscore/modules/iteratee.js"() {
    init_underscore();
    init_baseIteratee();
    _.iteratee = iteratee;
  }
});

// node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee) return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
var init_cb = __esm({
  "node_modules/underscore/modules/_cb.js"() {
    init_underscore();
    init_baseIteratee();
    init_iteratee();
  }
});

// node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_mapObject = __esm({
  "node_modules/underscore/modules/mapObject.js"() {
    init_cb();
    init_keys();
  }
});

// node_modules/underscore/modules/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/underscore/modules/noop.js"() {
  }
});

// node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path10) {
    return get(obj, path10);
  };
}
var init_propertyOf = __esm({
  "node_modules/underscore/modules/propertyOf.js"() {
    init_noop();
    init_get();
  }
});

// node_modules/underscore/modules/times.js
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee2(i);
  return accum;
}
var init_times = __esm({
  "node_modules/underscore/modules/times.js"() {
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/random.js
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
var init_random = __esm({
  "node_modules/underscore/modules/random.js"() {
  }
});

// node_modules/underscore/modules/now.js
var now_default;
var init_now = __esm({
  "node_modules/underscore/modules/now.js"() {
    now_default = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
});

// node_modules/underscore/modules/_createEscaper.js
function createEscaper(map2) {
  var escaper = function(match2) {
    return map2[match2];
  };
  var source = "(?:" + keys(map2).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var init_createEscaper = __esm({
  "node_modules/underscore/modules/_createEscaper.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/_escapeMap.js
var escapeMap_default;
var init_escapeMap = __esm({
  "node_modules/underscore/modules/_escapeMap.js"() {
    escapeMap_default = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
  }
});

// node_modules/underscore/modules/escape.js
var escape_default;
var init_escape = __esm({
  "node_modules/underscore/modules/escape.js"() {
    init_createEscaper();
    init_escapeMap();
    escape_default = createEscaper(escapeMap_default);
  }
});

// node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default;
var init_unescapeMap = __esm({
  "node_modules/underscore/modules/_unescapeMap.js"() {
    init_invert();
    init_escapeMap();
    unescapeMap_default = invert(escapeMap_default);
  }
});

// node_modules/underscore/modules/unescape.js
var unescape_default;
var init_unescape = __esm({
  "node_modules/underscore/modules/unescape.js"() {
    init_createEscaper();
    init_unescapeMap();
    unescape_default = createEscaper(unescapeMap_default);
  }
});

// node_modules/underscore/modules/templateSettings.js
var templateSettings_default;
var init_templateSettings = __esm({
  "node_modules/underscore/modules/templateSettings.js"() {
    init_underscore();
    templateSettings_default = _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
  }
});

// node_modules/underscore/modules/template.js
function escapeChar(match2) {
  return "\\" + escapes[match2];
}
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match2, escape2, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match2.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match2;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument)) throw new Error(
      "variable is not a bare identifier: " + argument
    );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
var noMatch, escapes, escapeRegExp, bareIdentifier;
var init_template = __esm({
  "node_modules/underscore/modules/template.js"() {
    init_defaults();
    init_underscore();
    init_templateSettings();
    noMatch = /(.)^/;
    escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    bareIdentifier = /^\s*(\w|\$)+\s*$/;
  }
});

// node_modules/underscore/modules/result.js
function result(obj, path10, fallback) {
  path10 = toPath2(path10);
  var length = path10.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path10[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var init_result = __esm({
  "node_modules/underscore/modules/result.js"() {
    init_isFunction();
    init_toPath2();
  }
});

// node_modules/underscore/modules/uniqueId.js
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
var idCounter;
var init_uniqueId = __esm({
  "node_modules/underscore/modules/uniqueId.js"() {
    idCounter = 0;
  }
});

// node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}
var init_chain = __esm({
  "node_modules/underscore/modules/chain.js"() {
    init_underscore();
  }
});

// node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject(result2)) return result2;
  return self2;
}
var init_executeBound = __esm({
  "node_modules/underscore/modules/_executeBound.js"() {
    init_baseCreate();
    init_isObject();
  }
});

// node_modules/underscore/modules/partial.js
var partial, partial_default;
var init_partial = __esm({
  "node_modules/underscore/modules/partial.js"() {
    init_restArguments();
    init_executeBound();
    init_underscore();
    partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _;
    partial_default = partial;
  }
});

// node_modules/underscore/modules/bind.js
var bind_default;
var init_bind = __esm({
  "node_modules/underscore/modules/bind.js"() {
    init_restArguments();
    init_isFunction();
    init_executeBound();
    bind_default = restArguments(function(func, context, args) {
      if (!isFunction_default(func)) throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });
  }
});

// node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default;
var init_isArrayLike = __esm({
  "node_modules/underscore/modules/_isArrayLike.js"() {
    init_createSizePropertyCheck();
    init_getLength();
    isArrayLike_default = createSizePropertyCheck(getLength_default);
  }
});

// node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength_default(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var init_flatten = __esm({
  "node_modules/underscore/modules/_flatten.js"() {
    init_getLength();
    init_isArrayLike();
    init_isArray();
    init_isArguments();
  }
});

// node_modules/underscore/modules/bindAll.js
var bindAll_default;
var init_bindAll = __esm({
  "node_modules/underscore/modules/bindAll.js"() {
    init_restArguments();
    init_flatten();
    init_bind();
    bindAll_default = restArguments(function(obj, keys2) {
      keys2 = flatten(keys2, false, false);
      var index = keys2.length;
      if (index < 1) throw new Error("bindAll must be passed function names");
      while (index--) {
        var key = keys2[index];
        obj[key] = bind_default(obj[key], obj);
      }
      return obj;
    });
  }
});

// node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var init_memoize = __esm({
  "node_modules/underscore/modules/memoize.js"() {
    init_has();
  }
});

// node_modules/underscore/modules/delay.js
var delay_default;
var init_delay = __esm({
  "node_modules/underscore/modules/delay.js"() {
    init_restArguments();
    delay_default = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
  }
});

// node_modules/underscore/modules/defer.js
var defer_default;
var init_defer = __esm({
  "node_modules/underscore/modules/defer.js"() {
    init_partial();
    init_delay();
    init_underscore();
    defer_default = partial_default(delay_default, _, 1);
  }
});

// node_modules/underscore/modules/throttle.js
function throttle(func, wait, options2) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options2) options2 = {};
  var later = function() {
    previous = options2.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options2.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options2.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var init_throttle = __esm({
  "node_modules/underscore/modules/throttle.js"() {
    init_now();
  }
});

// node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result2 = func.apply(context, args);
      if (!timeout) args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
var init_debounce = __esm({
  "node_modules/underscore/modules/debounce.js"() {
    init_restArguments();
    init_now();
  }
});

// node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}
var init_wrap = __esm({
  "node_modules/underscore/modules/wrap.js"() {
    init_partial();
  }
});

// node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
var init_negate = __esm({
  "node_modules/underscore/modules/negate.js"() {
  }
});

// node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--) result2 = args[i].call(this, result2);
    return result2;
  };
}
var init_compose = __esm({
  "node_modules/underscore/modules/compose.js"() {
  }
});

// node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var init_after = __esm({
  "node_modules/underscore/modules/after.js"() {
  }
});

// node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1) func = null;
    return memo;
  };
}
var init_before = __esm({
  "node_modules/underscore/modules/before.js"() {
  }
});

// node_modules/underscore/modules/once.js
var once_default;
var init_once = __esm({
  "node_modules/underscore/modules/once.js"() {
    init_partial();
    init_before();
    once_default = partial_default(before, 2);
  }
});

// node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}
var init_findKey = __esm({
  "node_modules/underscore/modules/findKey.js"() {
    init_cb();
    init_keys();
  }
});

// node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}
var init_createPredicateIndexFinder = __esm({
  "node_modules/underscore/modules/_createPredicateIndexFinder.js"() {
    init_cb();
    init_getLength();
  }
});

// node_modules/underscore/modules/findIndex.js
var findIndex_default;
var init_findIndex = __esm({
  "node_modules/underscore/modules/findIndex.js"() {
    init_createPredicateIndexFinder();
    findIndex_default = createPredicateIndexFinder(1);
  }
});

// node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default;
var init_findLastIndex = __esm({
  "node_modules/underscore/modules/findLastIndex.js"() {
    init_createPredicateIndexFinder();
    findLastIndex_default = createPredicateIndexFinder(-1);
  }
});

// node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value) low = mid + 1;
    else high = mid;
  }
  return low;
}
var init_sortedIndex = __esm({
  "node_modules/underscore/modules/sortedIndex.js"() {
    init_cb();
    init_getLength();
  }
});

// node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN2);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}
var init_createIndexFinder = __esm({
  "node_modules/underscore/modules/_createIndexFinder.js"() {
    init_getLength();
    init_setup();
    init_isNaN();
  }
});

// node_modules/underscore/modules/indexOf.js
var indexOf_default;
var init_indexOf = __esm({
  "node_modules/underscore/modules/indexOf.js"() {
    init_sortedIndex();
    init_findIndex();
    init_createIndexFinder();
    indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);
  }
});

// node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default;
var init_lastIndexOf = __esm({
  "node_modules/underscore/modules/lastIndexOf.js"() {
    init_findLastIndex();
    init_createIndexFinder();
    lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);
  }
});

// node_modules/underscore/modules/find.js
function find(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}
var init_find = __esm({
  "node_modules/underscore/modules/find.js"() {
    init_isArrayLike();
    init_findIndex();
    init_findKey();
  }
});

// node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}
var init_findWhere = __esm({
  "node_modules/underscore/modules/findWhere.js"() {
    init_find();
    init_matcher();
  }
});

// node_modules/underscore/modules/each.js
function each(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i, length;
  if (isArrayLike_default(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee2(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}
var init_each = __esm({
  "node_modules/underscore/modules/each.js"() {
    init_optimizeCb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/map.js
function map(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_map = __esm({
  "node_modules/underscore/modules/map.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var init_createReduce = __esm({
  "node_modules/underscore/modules/_createReduce.js"() {
    init_isArrayLike();
    init_keys();
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/reduce.js
var reduce_default;
var init_reduce = __esm({
  "node_modules/underscore/modules/reduce.js"() {
    init_createReduce();
    reduce_default = createReduce(1);
  }
});

// node_modules/underscore/modules/reduceRight.js
var reduceRight_default;
var init_reduceRight = __esm({
  "node_modules/underscore/modules/reduceRight.js"() {
    init_createReduce();
    reduceRight_default = createReduce(-1);
  }
});

// node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}
var init_filter = __esm({
  "node_modules/underscore/modules/filter.js"() {
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/reject.js
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}
var init_reject = __esm({
  "node_modules/underscore/modules/reject.js"() {
    init_filter();
    init_negate();
    init_cb();
  }
});

// node_modules/underscore/modules/every.js
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}
var init_every = __esm({
  "node_modules/underscore/modules/every.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/some.js
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}
var init_some = __esm({
  "node_modules/underscore/modules/some.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj)) obj = values(obj);
  if (typeof fromIndex != "number" || guard) fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}
var init_contains = __esm({
  "node_modules/underscore/modules/contains.js"() {
    init_isArrayLike();
    init_values();
    init_indexOf();
  }
});

// node_modules/underscore/modules/invoke.js
var invoke_default;
var init_invoke = __esm({
  "node_modules/underscore/modules/invoke.js"() {
    init_restArguments();
    init_isFunction();
    init_map();
    init_deepGet();
    init_toPath2();
    invoke_default = restArguments(function(obj, path10, args) {
      var contextPath, func;
      if (isFunction_default(path10)) {
        func = path10;
      } else {
        path10 = toPath2(path10);
        contextPath = path10.slice(0, -1);
        path10 = path10[path10.length - 1];
      }
      return map(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null) return void 0;
          method = context[path10];
        }
        return method == null ? method : method.apply(context, args);
      });
    });
  }
});

// node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map(obj, property(key));
}
var init_pluck = __esm({
  "node_modules/underscore/modules/pluck.js"() {
    init_map();
    init_property();
  }
});

// node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}
var init_where = __esm({
  "node_modules/underscore/modules/where.js"() {
    init_filter();
    init_matcher();
  }
});

// node_modules/underscore/modules/max.js
function max(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_max = __esm({
  "node_modules/underscore/modules/max.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/min.js
function min(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_min = __esm({
  "node_modules/underscore/modules/min.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/toArray.js
function toArray(obj) {
  if (!obj) return [];
  if (isArray_default(obj)) return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj)) return map(obj, identity);
  return values(obj);
}
var reStrSymbol;
var init_toArray = __esm({
  "node_modules/underscore/modules/toArray.js"() {
    init_isArray();
    init_setup();
    init_isString();
    init_isArrayLike();
    init_map();
    init_identity();
    init_values();
    reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  }
});

// node_modules/underscore/modules/sample.js
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike_default(obj)) obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength_default(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}
var init_sample = __esm({
  "node_modules/underscore/modules/sample.js"() {
    init_isArrayLike();
    init_values();
    init_getLength();
    init_random();
    init_toArray();
  }
});

// node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}
var init_shuffle = __esm({
  "node_modules/underscore/modules/shuffle.js"() {
    init_sample();
  }
});

// node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), "value");
}
var init_sortBy = __esm({
  "node_modules/underscore/modules/sortBy.js"() {
    init_cb();
    init_pluck();
    init_map();
  }
});

// node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj, function(value, index) {
      var key = iteratee2(value, index, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var init_group = __esm({
  "node_modules/underscore/modules/_group.js"() {
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/groupBy.js
var groupBy_default;
var init_groupBy = __esm({
  "node_modules/underscore/modules/groupBy.js"() {
    init_group();
    init_has();
    groupBy_default = group(function(result2, value, key) {
      if (has(result2, key)) result2[key].push(value);
      else result2[key] = [value];
    });
  }
});

// node_modules/underscore/modules/indexBy.js
var indexBy_default;
var init_indexBy = __esm({
  "node_modules/underscore/modules/indexBy.js"() {
    init_group();
    indexBy_default = group(function(result2, value, key) {
      result2[key] = value;
    });
  }
});

// node_modules/underscore/modules/countBy.js
var countBy_default;
var init_countBy = __esm({
  "node_modules/underscore/modules/countBy.js"() {
    init_group();
    init_has();
    countBy_default = group(function(result2, value, key) {
      if (has(result2, key)) result2[key]++;
      else result2[key] = 1;
    });
  }
});

// node_modules/underscore/modules/partition.js
var partition_default;
var init_partition = __esm({
  "node_modules/underscore/modules/partition.js"() {
    init_group();
    partition_default = group(function(result2, value, pass) {
      result2[pass ? 0 : 1].push(value);
    }, true);
  }
});

// node_modules/underscore/modules/size.js
function size(obj) {
  if (obj == null) return 0;
  return isArrayLike_default(obj) ? obj.length : keys(obj).length;
}
var init_size = __esm({
  "node_modules/underscore/modules/size.js"() {
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}
var init_keyInObj = __esm({
  "node_modules/underscore/modules/_keyInObj.js"() {
  }
});

// node_modules/underscore/modules/pick.js
var pick_default;
var init_pick = __esm({
  "node_modules/underscore/modules/pick.js"() {
    init_restArguments();
    init_isFunction();
    init_optimizeCb();
    init_allKeys();
    init_keyInObj();
    init_flatten();
    pick_default = restArguments(function(obj, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj == null) return result2;
      if (isFunction_default(iteratee2)) {
        if (keys2.length > 1) iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten(keys2, false, false);
        obj = Object(obj);
      }
      for (var i = 0, length = keys2.length; i < length; i++) {
        var key = keys2[i];
        var value = obj[key];
        if (iteratee2(value, key, obj)) result2[key] = value;
      }
      return result2;
    });
  }
});

// node_modules/underscore/modules/omit.js
var omit_default;
var init_omit = __esm({
  "node_modules/underscore/modules/omit.js"() {
    init_restArguments();
    init_isFunction();
    init_negate();
    init_map();
    init_flatten();
    init_contains();
    init_pick();
    omit_default = restArguments(function(obj, keys2) {
      var iteratee2 = keys2[0], context;
      if (isFunction_default(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1) context = keys2[1];
      } else {
        keys2 = map(flatten(keys2, false, false), String);
        iteratee2 = function(value, key) {
          return !contains(keys2, key);
        };
      }
      return pick_default(obj, iteratee2, context);
    });
  }
});

// node_modules/underscore/modules/initial.js
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
var init_initial = __esm({
  "node_modules/underscore/modules/initial.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/first.js
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}
var init_first = __esm({
  "node_modules/underscore/modules/first.js"() {
    init_initial();
  }
});

// node_modules/underscore/modules/rest.js
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}
var init_rest = __esm({
  "node_modules/underscore/modules/rest.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/last.js
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}
var init_last = __esm({
  "node_modules/underscore/modules/last.js"() {
    init_rest();
  }
});

// node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}
var init_compact = __esm({
  "node_modules/underscore/modules/compact.js"() {
    init_filter();
  }
});

// node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}
var init_flatten2 = __esm({
  "node_modules/underscore/modules/flatten.js"() {
    init_flatten();
  }
});

// node_modules/underscore/modules/difference.js
var difference_default;
var init_difference = __esm({
  "node_modules/underscore/modules/difference.js"() {
    init_restArguments();
    init_flatten();
    init_filter();
    init_contains();
    difference_default = restArguments(function(array, rest2) {
      rest2 = flatten(rest2, true, true);
      return filter(array, function(value) {
        return !contains(rest2, value);
      });
    });
  }
});

// node_modules/underscore/modules/without.js
var without_default;
var init_without = __esm({
  "node_modules/underscore/modules/without.js"() {
    init_restArguments();
    init_difference();
    without_default = restArguments(function(array, otherArrays) {
      return difference_default(array, otherArrays);
    });
  }
});

// node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null) iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed) result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_uniq = __esm({
  "node_modules/underscore/modules/uniq.js"() {
    init_isBoolean();
    init_cb();
    init_getLength();
    init_contains();
  }
});

// node_modules/underscore/modules/union.js
var union_default;
var init_union = __esm({
  "node_modules/underscore/modules/union.js"() {
    init_restArguments();
    init_uniq();
    init_flatten();
    union_default = restArguments(function(arrays) {
      return uniq(flatten(arrays, true, true));
    });
  }
});

// node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result2.push(item);
  }
  return result2;
}
var init_intersection = __esm({
  "node_modules/underscore/modules/intersection.js"() {
    init_getLength();
    init_contains();
  }
});

// node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}
var init_unzip = __esm({
  "node_modules/underscore/modules/unzip.js"() {
    init_max();
    init_getLength();
    init_pluck();
  }
});

// node_modules/underscore/modules/zip.js
var zip_default;
var init_zip = __esm({
  "node_modules/underscore/modules/zip.js"() {
    init_restArguments();
    init_unzip();
    zip_default = restArguments(unzip);
  }
});

// node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength_default(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}
var init_object = __esm({
  "node_modules/underscore/modules/object.js"() {
    init_getLength();
  }
});

// node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
var init_range = __esm({
  "node_modules/underscore/modules/range.js"() {
  }
});

// node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice.call(array, i, i += count));
  }
  return result2;
}
var init_chunk = __esm({
  "node_modules/underscore/modules/chunk.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}
var init_chainResult = __esm({
  "node_modules/underscore/modules/_chainResult.js"() {
    init_underscore();
  }
});

// node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}
var init_mixin = __esm({
  "node_modules/underscore/modules/mixin.js"() {
    init_underscore();
    init_each();
    init_functions();
    init_setup();
    init_chainResult();
  }
});

// node_modules/underscore/modules/underscore-array-methods.js
var underscore_array_methods_default;
var init_underscore_array_methods = __esm({
  "node_modules/underscore/modules/underscore-array-methods.js"() {
    init_underscore();
    init_each();
    init_setup();
    init_chainResult();
    each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name === "shift" || name === "splice") && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });
    each(["concat", "join", "slice"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });
    underscore_array_methods_default = _;
  }
});

// node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create2,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_modules = __esm({
  "node_modules/underscore/modules/index.js"() {
    init_setup();
    init_restArguments();
    init_isObject();
    init_isNull();
    init_isUndefined();
    init_isBoolean();
    init_isElement();
    init_isString();
    init_isNumber();
    init_isDate();
    init_isRegExp();
    init_isError();
    init_isSymbol();
    init_isArrayBuffer();
    init_isDataView();
    init_isArray();
    init_isFunction();
    init_isArguments();
    init_isFinite();
    init_isNaN();
    init_isTypedArray();
    init_isEmpty();
    init_isMatch();
    init_isEqual();
    init_isMap();
    init_isWeakMap();
    init_isSet();
    init_isWeakSet();
    init_keys();
    init_allKeys();
    init_values();
    init_pairs();
    init_invert();
    init_functions();
    init_extend();
    init_extendOwn();
    init_defaults();
    init_create();
    init_clone();
    init_tap();
    init_get();
    init_has2();
    init_mapObject();
    init_identity();
    init_constant();
    init_noop();
    init_toPath();
    init_property();
    init_propertyOf();
    init_matcher();
    init_times();
    init_random();
    init_now();
    init_escape();
    init_unescape();
    init_templateSettings();
    init_template();
    init_result();
    init_uniqueId();
    init_chain();
    init_iteratee();
    init_partial();
    init_bind();
    init_bindAll();
    init_memoize();
    init_delay();
    init_defer();
    init_throttle();
    init_debounce();
    init_wrap();
    init_negate();
    init_compose();
    init_after();
    init_before();
    init_once();
    init_findKey();
    init_findIndex();
    init_findLastIndex();
    init_sortedIndex();
    init_indexOf();
    init_lastIndexOf();
    init_find();
    init_findWhere();
    init_each();
    init_map();
    init_reduce();
    init_reduceRight();
    init_filter();
    init_reject();
    init_every();
    init_some();
    init_contains();
    init_invoke();
    init_pluck();
    init_where();
    init_max();
    init_min();
    init_shuffle();
    init_sample();
    init_sortBy();
    init_groupBy();
    init_indexBy();
    init_countBy();
    init_partition();
    init_toArray();
    init_size();
    init_pick();
    init_omit();
    init_first();
    init_initial();
    init_last();
    init_rest();
    init_compact();
    init_flatten2();
    init_without();
    init_uniq();
    init_union();
    init_intersection();
    init_difference();
    init_unzip();
    init_zip();
    init_object();
    init_range();
    init_chunk();
    init_mixin();
    init_underscore_array_methods();
  }
});

// node_modules/underscore/modules/index-default.js
var _2, index_default_default;
var init_index_default = __esm({
  "node_modules/underscore/modules/index-default.js"() {
    init_modules();
    init_modules();
    _2 = mixin(modules_exports);
    _2._ = _2;
    index_default_default = _2;
  }
});

// node_modules/underscore/modules/index-all.js
var index_all_exports = {};
__export(index_all_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create2,
  debounce: () => debounce,
  default: () => index_default_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_index_all = __esm({
  "node_modules/underscore/modules/index-all.js"() {
    init_index_default();
    init_modules();
  }
});

// node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js
var require_common = __commonJS({
  "node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js"(exports2, module2) {
    var crypto = require("crypto");
    function zeroextend(str, len) {
      while (str.length < len)
        str = "0" + str;
      return str;
    }
    function oddpar(buf) {
      for (var j = 0; j < buf.length; j++) {
        var par = 1;
        for (var i = 1; i < 8; i++) {
          par = (par + (buf[j] >> i & 1)) % 2;
        }
        buf[j] |= par & 1;
      }
      return buf;
    }
    function expandkey(key56) {
      var key64 = Buffer.alloc(8);
      key64[0] = key56[0] & 254;
      key64[1] = key56[0] << 7 & 255 | key56[1] >> 1;
      key64[2] = key56[1] << 6 & 255 | key56[2] >> 2;
      key64[3] = key56[2] << 5 & 255 | key56[3] >> 3;
      key64[4] = key56[3] << 4 & 255 | key56[4] >> 4;
      key64[5] = key56[4] << 3 & 255 | key56[5] >> 5;
      key64[6] = key56[5] << 2 & 255 | key56[6] >> 6;
      key64[7] = key56[6] << 1 & 255;
      return key64;
    }
    function bintohex(bin) {
      var buf = Buffer.isBuffer(buf) ? buf : Buffer.from(bin, "binary");
      var str = buf.toString("hex").toUpperCase();
      return zeroextend(str, 32);
    }
    module2.exports.zeroextend = zeroextend;
    module2.exports.oddpar = oddpar;
    module2.exports.expandkey = expandkey;
    module2.exports.bintohex = bintohex;
  }
});

// node_modules/js-md4/src/md4.js
var require_md4 = __commonJS({
  "node_modules/js-md4/src/md4.js"(exports2, module2) {
    (function() {
      "use strict";
      var root2 = typeof window === "object" ? window : {};
      var NODE_JS = !root2.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root2 = global;
      }
      var COMMON_JS = !root2.JS_MD4_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root2.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md4(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md4();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto = require("crypto");
        var Buffer5 = require("buffer").Buffer;
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash("md4").update(message, "utf8").digest("hex");
          } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto.createHash("md4").update(new Buffer5(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Md4(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md4.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >> 12;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >> 18;
                  buffer82[i++] = 128 | code >> 12 & 63;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        return this;
      };
      Md4.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        this.hash();
      };
      Md4.prototype.hash = function() {
        var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 1;
          a = a << 3 | a >>> 29;
          d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
          d = d << 7 | d >>> 25;
          c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
          c = c << 11 | c >>> 21;
          b = (c & d | ~c & a) + blocks2[3] - 271733879;
          b = b << 19 | b >>> 13;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (b & c | ~b & d) + blocks2[0];
          a = a << 3 | a >>> 29;
          d += (a & b | ~a & c) + blocks2[1];
          d = d << 7 | d >>> 25;
          c += (d & a | ~d & b) + blocks2[2];
          c = c << 11 | c >>> 21;
          b += (c & d | ~c & a) + blocks2[3];
          b = b << 19 | b >>> 13;
        }
        a += (b & c | ~b & d) + blocks2[4];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[5];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[6];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[7];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[8];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[9];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[10];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[11];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[12];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[13];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[14];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[15];
        b = b << 19 | b >>> 13;
        bc = b & c;
        a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[4] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[8] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[12] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[1] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[5] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[9] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[13] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[2] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[6] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[10] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[14] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[3] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[7] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[11] + 1518500249;
        c = c << 9 | c >>> 23;
        b += (c & d | c & a | da) + blocks2[15] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[0] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[8] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[4] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[12] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[2] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[10] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[6] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[14] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[9] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[5] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[13] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[3] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[11] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[15] + 1859775393;
        b = b << 15 | b >>> 17;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md4.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md4.prototype.toString = Md4.prototype.hex;
      Md4.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
      };
      Md4.prototype.array = Md4.prototype.digest;
      Md4.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md4.prototype.buffer = Md4.prototype.arrayBuffer;
      var exports3 = createMethod();
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root2.md4 = exports3;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// node_modules/des.js/lib/des/utils.js
var require_utils2 = __commonJS({
  "node_modules/des.js/lib/des/utils.js"(exports2) {
    "use strict";
    exports2.readUInt32BE = function readUInt32BE(bytes, off) {
      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
      return res >>> 0;
    };
    exports2.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
      bytes[0 + off] = value >>> 24;
      bytes[1 + off] = value >>> 16 & 255;
      bytes[2 + off] = value >>> 8 & 255;
      bytes[3 + off] = value & 255;
    };
    exports2.ip = function ip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
        }
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.rip = function rip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 0; i < 4; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 4; i < 8; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.pc1 = function pc1(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 7; i >= 5; i--) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }
      for (var i = 1; i <= 3; i++) {
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.r28shl = function r28shl(num, shift) {
      return num << shift & 268435455 | num >>> 28 - shift;
    };
    var pc2table = [
      // inL => outL
      14,
      11,
      17,
      4,
      27,
      23,
      25,
      0,
      13,
      22,
      7,
      18,
      5,
      9,
      16,
      24,
      2,
      20,
      12,
      21,
      1,
      8,
      15,
      26,
      // inR => outR
      15,
      4,
      25,
      19,
      9,
      1,
      26,
      16,
      5,
      11,
      23,
      8,
      12,
      7,
      17,
      0,
      22,
      3,
      10,
      14,
      6,
      20,
      27,
      24
    ];
    exports2.pc2 = function pc2(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      var len = pc2table.length >>> 1;
      for (var i = 0; i < len; i++) {
        outL <<= 1;
        outL |= inL >>> pc2table[i] & 1;
      }
      for (var i = len; i < pc2table.length; i++) {
        outR <<= 1;
        outR |= inR >>> pc2table[i] & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.expand = function expand(r, out, off) {
      var outL = 0;
      var outR = 0;
      outL = (r & 1) << 5 | r >>> 27;
      for (var i = 23; i >= 15; i -= 4) {
        outL <<= 6;
        outL |= r >>> i & 63;
      }
      for (var i = 11; i >= 3; i -= 4) {
        outR |= r >>> i & 63;
        outR <<= 6;
      }
      outR |= (r & 31) << 1 | r >>> 31;
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    var sTable = [
      14,
      0,
      4,
      15,
      13,
      7,
      1,
      4,
      2,
      14,
      15,
      2,
      11,
      13,
      8,
      1,
      3,
      10,
      10,
      6,
      6,
      12,
      12,
      11,
      5,
      9,
      9,
      5,
      0,
      3,
      7,
      8,
      4,
      15,
      1,
      12,
      14,
      8,
      8,
      2,
      13,
      4,
      6,
      9,
      2,
      1,
      11,
      7,
      15,
      5,
      12,
      11,
      9,
      3,
      7,
      14,
      3,
      10,
      10,
      0,
      5,
      6,
      0,
      13,
      15,
      3,
      1,
      13,
      8,
      4,
      14,
      7,
      6,
      15,
      11,
      2,
      3,
      8,
      4,
      14,
      9,
      12,
      7,
      0,
      2,
      1,
      13,
      10,
      12,
      6,
      0,
      9,
      5,
      11,
      10,
      5,
      0,
      13,
      14,
      8,
      7,
      10,
      11,
      1,
      10,
      3,
      4,
      15,
      13,
      4,
      1,
      2,
      5,
      11,
      8,
      6,
      12,
      7,
      6,
      12,
      9,
      0,
      3,
      5,
      2,
      14,
      15,
      9,
      10,
      13,
      0,
      7,
      9,
      0,
      14,
      9,
      6,
      3,
      3,
      4,
      15,
      6,
      5,
      10,
      1,
      2,
      13,
      8,
      12,
      5,
      7,
      14,
      11,
      12,
      4,
      11,
      2,
      15,
      8,
      1,
      13,
      1,
      6,
      10,
      4,
      13,
      9,
      0,
      8,
      6,
      15,
      9,
      3,
      8,
      0,
      7,
      11,
      4,
      1,
      15,
      2,
      14,
      12,
      3,
      5,
      11,
      10,
      5,
      14,
      2,
      7,
      12,
      7,
      13,
      13,
      8,
      14,
      11,
      3,
      5,
      0,
      6,
      6,
      15,
      9,
      0,
      10,
      3,
      1,
      4,
      2,
      7,
      8,
      2,
      5,
      12,
      11,
      1,
      12,
      10,
      4,
      14,
      15,
      9,
      10,
      3,
      6,
      15,
      9,
      0,
      0,
      6,
      12,
      10,
      11,
      1,
      7,
      13,
      13,
      8,
      15,
      9,
      1,
      4,
      3,
      5,
      14,
      11,
      5,
      12,
      2,
      7,
      8,
      2,
      4,
      14,
      2,
      14,
      12,
      11,
      4,
      2,
      1,
      12,
      7,
      4,
      10,
      7,
      11,
      13,
      6,
      1,
      8,
      5,
      5,
      0,
      3,
      15,
      15,
      10,
      13,
      3,
      0,
      9,
      14,
      8,
      9,
      6,
      4,
      11,
      2,
      8,
      1,
      12,
      11,
      7,
      10,
      1,
      13,
      14,
      7,
      2,
      8,
      13,
      15,
      6,
      9,
      15,
      12,
      0,
      5,
      9,
      6,
      10,
      3,
      4,
      0,
      5,
      14,
      3,
      12,
      10,
      1,
      15,
      10,
      4,
      15,
      2,
      9,
      7,
      2,
      12,
      6,
      9,
      8,
      5,
      0,
      6,
      13,
      1,
      3,
      13,
      4,
      14,
      14,
      0,
      7,
      11,
      5,
      3,
      11,
      8,
      9,
      4,
      14,
      3,
      15,
      2,
      5,
      12,
      2,
      9,
      8,
      5,
      12,
      15,
      3,
      10,
      7,
      11,
      0,
      14,
      4,
      1,
      10,
      7,
      1,
      6,
      13,
      0,
      11,
      8,
      6,
      13,
      4,
      13,
      11,
      0,
      2,
      11,
      14,
      7,
      15,
      4,
      0,
      9,
      8,
      1,
      13,
      10,
      3,
      14,
      12,
      3,
      9,
      5,
      7,
      12,
      5,
      2,
      10,
      15,
      6,
      8,
      1,
      6,
      1,
      6,
      4,
      11,
      11,
      13,
      13,
      8,
      12,
      1,
      3,
      4,
      7,
      10,
      14,
      7,
      10,
      9,
      15,
      5,
      6,
      0,
      8,
      15,
      0,
      14,
      5,
      2,
      9,
      3,
      2,
      12,
      13,
      1,
      2,
      15,
      8,
      13,
      4,
      8,
      6,
      10,
      15,
      3,
      11,
      7,
      1,
      4,
      10,
      12,
      9,
      5,
      3,
      6,
      14,
      11,
      5,
      0,
      0,
      14,
      12,
      9,
      7,
      2,
      7,
      2,
      11,
      1,
      4,
      14,
      1,
      7,
      9,
      4,
      12,
      10,
      14,
      8,
      2,
      13,
      0,
      15,
      6,
      12,
      10,
      9,
      13,
      0,
      15,
      3,
      3,
      5,
      5,
      6,
      8,
      11
    ];
    exports2.substitute = function substitute(inL, inR) {
      var out = 0;
      for (var i = 0; i < 4; i++) {
        var b = inL >>> 18 - i * 6 & 63;
        var sb = sTable[i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      for (var i = 0; i < 4; i++) {
        var b = inR >>> 18 - i * 6 & 63;
        var sb = sTable[4 * 64 + i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      return out >>> 0;
    };
    var permuteTable = [
      16,
      25,
      12,
      11,
      3,
      20,
      4,
      15,
      31,
      17,
      9,
      6,
      27,
      14,
      1,
      22,
      30,
      24,
      8,
      18,
      0,
      5,
      29,
      23,
      13,
      19,
      2,
      26,
      10,
      21,
      28,
      7
    ];
    exports2.permute = function permute(num) {
      var out = 0;
      for (var i = 0; i < permuteTable.length; i++) {
        out <<= 1;
        out |= num >>> permuteTable[i] & 1;
      }
      return out >>> 0;
    };
    exports2.padSplit = function padSplit(num, size2, group2) {
      var str = num.toString(2);
      while (str.length < size2)
        str = "0" + str;
      var out = [];
      for (var i = 0; i < size2; i += group2)
        out.push(str.slice(i, i + group2));
      return out.join(" ");
    };
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert4;
    function assert4(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert4.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/des.js/lib/des/cipher.js
var require_cipher = __commonJS({
  "node_modules/des.js/lib/des/cipher.js"(exports2, module2) {
    "use strict";
    var assert4 = require_minimalistic_assert();
    function Cipher(options2) {
      this.options = options2;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
      this.padding = options2.padding !== false;
    }
    module2.exports = Cipher;
    Cipher.prototype._init = function _init() {
    };
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === "decrypt")
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
      var min2 = Math.min(this.buffer.length - this.bufferOff, data.length - off);
      for (var i = 0; i < min2; i++)
        this.buffer[this.bufferOff + i] = data[off + i];
      this.bufferOff += min2;
      return min2;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
      this._update(this.buffer, 0, out, off);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max2 = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max2; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count * this.blockSize);
      for (; count > 0; count--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer) {
      var first2;
      if (buffer)
        first2 = this.update(buffer);
      var last2;
      if (this.type === "encrypt")
        last2 = this._finalEncrypt();
      else
        last2 = this._finalDecrypt();
      if (first2)
        return first2.concat(last2);
      else
        return last2;
    };
    Cipher.prototype._pad = function _pad(buffer, off) {
      if (off === 0)
        return false;
      while (off < buffer.length)
        buffer[off++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer) {
      return buffer;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert4.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          ctor2.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor2,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor2.prototype = new TempCtor();
          ctor2.prototype.constructor = ctor2;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/des.js/lib/des/des.js
var require_des = __commonJS({
  "node_modules/des.js/lib/des/des.js"(exports2, module2) {
    "use strict";
    var assert4 = require_minimalistic_assert();
    var inherits = require_inherits();
    var utils = require_utils2();
    var Cipher = require_cipher();
    function DESState() {
      this.tmp = new Array(2);
      this.keys = null;
    }
    function DES(options2) {
      Cipher.call(this, options2);
      var state = new DESState();
      this._desState = state;
      this.deriveKeys(state, options2.key);
    }
    inherits(DES, Cipher);
    module2.exports = DES;
    DES.create = function create3(options2) {
      return new DES(options2);
    };
    var shiftTable = [
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1
    ];
    DES.prototype.deriveKeys = function deriveKeys(state, key) {
      state.keys = new Array(16 * 2);
      assert4.equal(key.length, this.blockSize, "Invalid key length");
      var kL = utils.readUInt32BE(key, 0);
      var kR = utils.readUInt32BE(key, 4);
      utils.pc1(kL, kR, state.tmp, 0);
      kL = state.tmp[0];
      kR = state.tmp[1];
      for (var i = 0; i < state.keys.length; i += 2) {
        var shift = shiftTable[i >>> 1];
        kL = utils.r28shl(kL, shift);
        kR = utils.r28shl(kR, shift);
        utils.pc2(kL, kR, state.keys, i);
      }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._desState;
      var l = utils.readUInt32BE(inp, inOff);
      var r = utils.readUInt32BE(inp, inOff + 4);
      utils.ip(l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      if (this.type === "encrypt")
        this._encrypt(state, l, r, state.tmp, 0);
      else
        this._decrypt(state, l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      utils.writeUInt32BE(out, l, outOff);
      utils.writeUInt32BE(out, r, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer, off) {
      if (this.padding === false) {
        return false;
      }
      var value = buffer.length - off;
      for (var i = off; i < buffer.length; i++)
        buffer[i] = value;
      return true;
    };
    DES.prototype._unpad = function _unpad(buffer) {
      if (this.padding === false) {
        return buffer;
      }
      var pad = buffer[buffer.length - 1];
      for (var i = buffer.length - pad; i < buffer.length; i++)
        assert4.equal(buffer[i], pad);
      return buffer.slice(0, buffer.length - pad);
    };
    DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
      var l = lStart;
      var r = rStart;
      for (var i = 0; i < state.keys.length; i += 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(r, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = r;
        r = (l ^ f) >>> 0;
        l = t;
      }
      utils.rip(r, l, out, off);
    };
    DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
      var l = rStart;
      var r = lStart;
      for (var i = state.keys.length - 2; i >= 0; i -= 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(l, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = l;
        l = (r ^ f) >>> 0;
        r = t;
      }
      utils.rip(l, r, out, off);
    };
  }
});

// node_modules/des.js/lib/des/cbc.js
var require_cbc = __commonJS({
  "node_modules/des.js/lib/des/cbc.js"(exports2) {
    "use strict";
    var assert4 = require_minimalistic_assert();
    var inherits = require_inherits();
    var proto = {};
    function CBCState(iv) {
      assert4.equal(iv.length, 8, "Invalid IV length");
      this.iv = new Array(8);
      for (var i = 0; i < this.iv.length; i++)
        this.iv[i] = iv[i];
    }
    function instantiate(Base) {
      function CBC(options2) {
        Base.call(this, options2);
        this._cbcInit();
      }
      inherits(CBC, Base);
      var keys2 = Object.keys(proto);
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        CBC.prototype[key] = proto[key];
      }
      CBC.create = function create3(options2) {
        return new CBC(options2);
      };
      return CBC;
    }
    exports2.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
      var state = new CBCState(this.options.iv);
      this._cbcState = state;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
      var state = this._cbcState;
      var superProto = this.constructor.super_.prototype;
      var iv = state.iv;
      if (this.type === "encrypt") {
        for (var i = 0; i < this.blockSize; i++)
          iv[i] ^= inp[inOff + i];
        superProto._update.call(this, iv, 0, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = out[outOff + i];
      } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          out[outOff + i] ^= iv[i];
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = inp[inOff + i];
      }
    };
  }
});

// node_modules/des.js/lib/des/ede.js
var require_ede = __commonJS({
  "node_modules/des.js/lib/des/ede.js"(exports2, module2) {
    "use strict";
    var assert4 = require_minimalistic_assert();
    var inherits = require_inherits();
    var Cipher = require_cipher();
    var DES = require_des();
    function EDEState(type, key) {
      assert4.equal(key.length, 24, "Invalid key length");
      var k1 = key.slice(0, 8);
      var k2 = key.slice(8, 16);
      var k3 = key.slice(16, 24);
      if (type === "encrypt") {
        this.ciphers = [
          DES.create({ type: "encrypt", key: k1 }),
          DES.create({ type: "decrypt", key: k2 }),
          DES.create({ type: "encrypt", key: k3 })
        ];
      } else {
        this.ciphers = [
          DES.create({ type: "decrypt", key: k3 }),
          DES.create({ type: "encrypt", key: k2 }),
          DES.create({ type: "decrypt", key: k1 })
        ];
      }
    }
    function EDE(options2) {
      Cipher.call(this, options2);
      var state = new EDEState(this.type, this.options.key);
      this._edeState = state;
    }
    inherits(EDE, Cipher);
    module2.exports = EDE;
    EDE.create = function create3(options2) {
      return new EDE(options2);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._edeState;
      state.ciphers[0]._update(inp, inOff, out, outOff);
      state.ciphers[1]._update(out, outOff, out, outOff);
      state.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
  }
});

// node_modules/des.js/lib/des.js
var require_des2 = __commonJS({
  "node_modules/des.js/lib/des.js"(exports2) {
    "use strict";
    exports2.utils = require_utils2();
    exports2.Cipher = require_cipher();
    exports2.DES = require_des();
    exports2.CBC = require_cbc();
    exports2.EDE = require_ede();
  }
});

// node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js
var require_smbhash = __commonJS({
  "node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js"(exports2, module2) {
    var $ = require_common();
    var jsmd4 = require_md4();
    var desjs = require_des2();
    function lmhashbuf(inputstr) {
      var x = inputstr.substring(0, 14).toUpperCase();
      var xl = Buffer.byteLength(x, "ascii");
      var y = Buffer.alloc(14);
      y.write(x, 0, xl, "ascii");
      y.fill(0, xl);
      var halves = [
        $.oddpar($.expandkey(y.slice(0, 7))),
        $.oddpar($.expandkey(y.slice(7, 14)))
      ];
      var buf = Buffer.alloc(16);
      var pos = 0;
      var cts = halves.forEach(function(z) {
        var des = desjs.DES.create({ type: "encrypt", key: z });
        var magicKey = Buffer.from("KGS!@#$%", "ascii");
        var insertBuff = Buffer.from(des.update(magicKey));
        buf.fill(insertBuff, pos, pos + 8, "binary");
        pos += 8;
      });
      return buf;
    }
    function nthashbuf(str) {
      var ucs2 = Buffer.from(str, "ucs2");
      var md4 = jsmd4.create();
      md4.update(ucs2);
      return Buffer.from(md4.digest("binary"), "binary");
    }
    function lmhash(is) {
      return $.bintohex(lmhashbuf(is));
    }
    function nthash(is) {
      return $.bintohex(nthashbuf(is));
    }
    module2.exports.nthashbuf = nthashbuf;
    module2.exports.lmhashbuf = lmhashbuf;
    module2.exports.nthash = nthash;
    module2.exports.lmhash = lmhash;
  }
});

// node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js
var require_ntlm = __commonJS({
  "node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js"(exports2) {
    var crypto = require("crypto");
    var $ = require_common();
    var lmhashbuf = require_smbhash().lmhashbuf;
    var nthashbuf = require_smbhash().nthashbuf;
    var desjs = require_des2();
    function encodeType1(hostname, ntdomain) {
      hostname = hostname.toUpperCase();
      ntdomain = ntdomain.toUpperCase();
      var hostnamelen = Buffer.byteLength(hostname, "ascii");
      var ntdomainlen = Buffer.byteLength(ntdomain, "ascii");
      var pos = 0;
      var buf = Buffer.alloc(32 + hostnamelen + ntdomainlen);
      buf.write("NTLMSSP", pos, 7, "ascii");
      pos += 7;
      buf.writeUInt8(0, pos);
      pos++;
      buf.writeUInt8(1, pos);
      pos++;
      buf.fill(0, pos, pos + 3);
      pos += 3;
      buf.writeUInt16LE(45571, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      var ntdomainoff = 32 + hostnamelen;
      buf.writeUInt16LE(ntdomainoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(32, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.write(hostname, 32, hostnamelen, "ascii");
      buf.write(ntdomain, ntdomainoff, ntdomainlen, "ascii");
      return buf;
    }
    function decodeType2(buf) {
      var proto = buf.toString("ascii", 0, 7);
      if (buf[7] !== 0 || proto !== "NTLMSSP")
        throw new Error("magic was not NTLMSSP");
      var type = buf.readUInt8(8);
      if (type !== 2)
        throw new Error("message was not NTLMSSP type 0x02");
      var nonce = buf.slice(24, 32);
      return nonce;
    }
    function encodeType3(username, hostname, ntdomain, nonce, password) {
      hostname = hostname.toUpperCase();
      ntdomain = ntdomain.toUpperCase();
      var lmh = Buffer.alloc(21);
      lmhashbuf(password).copy(lmh);
      lmh.fill(0, 16);
      var nth = Buffer.alloc(21);
      nthashbuf(password).copy(nth);
      nth.fill(0, 16);
      var lmr = makeResponse(lmh, nonce);
      var ntr = makeResponse(nth, nonce);
      var usernamelen = Buffer.byteLength(username, "ucs2");
      var hostnamelen = Buffer.byteLength(hostname, "ucs2");
      var ntdomainlen = Buffer.byteLength(ntdomain, "ucs2");
      var lmrlen = 24;
      var ntrlen = 24;
      var ntdomainoff = 64;
      var usernameoff = ntdomainoff + ntdomainlen;
      var hostnameoff = usernameoff + usernamelen;
      var lmroff = hostnameoff + hostnamelen;
      var ntroff = lmroff + lmrlen;
      var pos = 0;
      var msg_len = 64 + ntdomainlen + usernamelen + hostnamelen + lmrlen + ntrlen;
      var buf = Buffer.alloc(msg_len);
      buf.write("NTLMSSP", pos, 7, "ascii");
      pos += 7;
      buf.writeUInt8(0, pos);
      pos++;
      buf.writeUInt8(3, pos);
      pos++;
      buf.fill(0, pos, pos + 3);
      pos += 3;
      buf.writeUInt16LE(lmrlen, pos);
      pos += 2;
      buf.writeUInt16LE(lmrlen, pos);
      pos += 2;
      buf.writeUInt16LE(lmroff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(ntrlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntrlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntroff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntdomainoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(usernamelen, pos);
      pos += 2;
      buf.writeUInt16LE(usernamelen, pos);
      pos += 2;
      buf.writeUInt16LE(usernameoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(hostnameoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 6);
      pos += 6;
      buf.writeUInt16LE(msg_len, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(33281, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.write(ntdomain, ntdomainoff, ntdomainlen, "ucs2");
      buf.write(username, usernameoff, usernamelen, "ucs2");
      buf.write(hostname, hostnameoff, hostnamelen, "ucs2");
      lmr.copy(buf, lmroff, 0, lmrlen);
      ntr.copy(buf, ntroff, 0, ntrlen);
      return buf;
    }
    function makeResponse(hash, nonce) {
      var out = Buffer.alloc(24);
      for (var i = 0; i < 3; i++) {
        var keybuf = $.oddpar($.expandkey(hash.slice(i * 7, i * 7 + 7)));
        var des = desjs.DES.create({ type: "encrypt", key: keybuf });
        var magicKey = Buffer.from(nonce.toString("binary"));
        var insertBuff = Buffer.from(des.update(magicKey));
        out.fill(insertBuff, i * 8, i * 8 + 8, "binary");
      }
      return out;
    }
    exports2.encodeType1 = encodeType1;
    exports2.decodeType2 = decodeType2;
    exports2.encodeType3 = encodeType3;
    exports2.challengeHeader = function(hostname, domain) {
      return "NTLM " + exports2.encodeType1(hostname, domain).toString("base64");
    };
    exports2.responseHeader = function(res, url, domain, username, password) {
      var serverNonce = Buffer.from((res.headers["www-authenticate"].match(/^NTLM\s+(.+?)(,|\s+|$)/) || [])[1], "base64");
      var hostname = require("url").parse(url).hostname;
      return "NTLM " + exports2.encodeType3(username, hostname, domain, exports2.decodeType2(serverNonce), password).toString("base64");
    };
    exports2.smbhash = require_smbhash();
  }
});

// node_modules/typed-rest-client/handlers/ntlm.js
var require_ntlm2 = __commonJS({
  "node_modules/typed-rest-client/handlers/ntlm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NtlmCredentialHandler = void 0;
    var http = require("http");
    var https = require("https");
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var ntlm = require_ntlm();
    var NtlmCredentialHandler = class {
      constructor(username, password, workstation, domain) {
        this._ntlmOptions = {};
        this._ntlmOptions.username = username;
        this._ntlmOptions.password = password;
        this._ntlmOptions.domain = domain || "";
        this._ntlmOptions.workstation = workstation || "";
      }
      prepareRequest(options2) {
        if (options2.agent) {
          delete options2.agent;
        }
      }
      canHandleAuthentication(response) {
        if (response && response.message && response.message.statusCode === 401) {
          const wwwAuthenticate = response.message.headers["www-authenticate"];
          return wwwAuthenticate && wwwAuthenticate.split(", ").indexOf("NTLM") >= 0;
        }
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return new Promise((resolve, reject2) => {
          const callbackForResult = function(err, res) {
            if (err) {
              reject2(err);
              return;
            }
            res.readBody().then(() => {
              resolve(res);
            });
          };
          this.handleAuthenticationPrivate(httpClient, requestInfo, objs, callbackForResult);
        });
      }
      handleAuthenticationPrivate(httpClient, requestInfo, objs, finalCallback) {
        requestInfo.options = _3.extend(requestInfo.options, {
          username: this._ntlmOptions.username,
          password: this._ntlmOptions.password,
          domain: this._ntlmOptions.domain,
          workstation: this._ntlmOptions.workstation
        });
        requestInfo.options.agent = httpClient.isSsl ? new https.Agent({ keepAlive: true }) : new http.Agent({ keepAlive: true });
        let self2 = this;
        this.sendType1Message(httpClient, requestInfo, objs, function(err, res) {
          if (err) {
            return finalCallback(err, null, null);
          }
          res.readBody().then(() => {
            setImmediate(function() {
              self2.sendType3Message(httpClient, requestInfo, objs, res, finalCallback);
            });
          });
        });
      }
      // The following method is an adaptation of code found at https://github.com/SamDecrock/node-http-ntlm/blob/master/httpntlm.js
      sendType1Message(httpClient, requestInfo, objs, finalCallback) {
        const type1HexBuffer = ntlm.encodeType1(this._ntlmOptions.workstation, this._ntlmOptions.domain);
        const type1msg = `NTLM ${type1HexBuffer.toString("base64")}`;
        const type1options = {
          headers: {
            "Connection": "keep-alive",
            "Authorization": type1msg
          },
          timeout: requestInfo.options.timeout || 0,
          agent: requestInfo.httpModule
        };
        const type1info = {};
        type1info.httpModule = requestInfo.httpModule;
        type1info.parsedUrl = requestInfo.parsedUrl;
        type1info.options = _3.extend(type1options, _3.omit(requestInfo.options, "headers"));
        return httpClient.requestRawWithCallback(type1info, objs, finalCallback);
      }
      // The following method is an adaptation of code found at https://github.com/SamDecrock/node-http-ntlm/blob/master/httpntlm.js
      sendType3Message(httpClient, requestInfo, objs, res, callback) {
        if (!res.message.headers && !res.message.headers["www-authenticate"]) {
          throw new Error("www-authenticate not found on response of second request");
        }
        const serverNonceRegex = /^NTLM\s+(.+?)(,|\s+|$)/;
        const serverNonce = Buffer.from((res.message.headers["www-authenticate"].match(serverNonceRegex) || [])[1], "base64");
        let type2msg;
        try {
          type2msg = ntlm.decodeType2(serverNonce);
        } catch (error2) {
          throw new Error(`Decoding Server's Challenge to Obtain Type2Message failed with error: ${error2.message}`);
        }
        const type3msg = ntlm.encodeType3(this._ntlmOptions.username, this._ntlmOptions.workstation, this._ntlmOptions.domain, type2msg, this._ntlmOptions.password).toString("base64");
        const type3options = {
          headers: {
            "Authorization": `NTLM ${type3msg}`,
            "Connection": "Close"
          },
          agent: requestInfo.httpModule
        };
        const type3info = {};
        type3info.httpModule = requestInfo.httpModule;
        type3info.parsedUrl = requestInfo.parsedUrl;
        type3options.headers = _3.extend(type3options.headers, requestInfo.options.headers);
        type3info.options = _3.extend(type3options, _3.omit(requestInfo.options, "headers"));
        return httpClient.requestRawWithCallback(type3info, objs, callback);
      }
    };
    exports2.NtlmCredentialHandler = NtlmCredentialHandler;
  }
});

// node_modules/typed-rest-client/handlers/personalaccesstoken.js
var require_personalaccesstoken = __commonJS({
  "node_modules/typed-rest-client/handlers/personalaccesstoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = void 0;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token, allowCrossOriginAuthentication) {
        this.token = token;
        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options2) {
        if (!this.origin) {
          this.origin = options2.host;
        }
        if (this.origin === options2.host || this.allowCrossOriginAuthentication) {
          options2.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
        }
        options2.headers["X-TFS-FedAuthRedirect"] = "Suppress";
      }
      // This handler cannot handle 401
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/typed-rest-client/Handlers.js
var require_Handlers = __commonJS({
  "node_modules/typed-rest-client/Handlers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.NtlmCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var basiccreds_1 = require_basiccreds();
    Object.defineProperty(exports2, "BasicCredentialHandler", { enumerable: true, get: function() {
      return basiccreds_1.BasicCredentialHandler;
    } });
    var bearertoken_1 = require_bearertoken();
    Object.defineProperty(exports2, "BearerCredentialHandler", { enumerable: true, get: function() {
      return bearertoken_1.BearerCredentialHandler;
    } });
    var ntlm_1 = require_ntlm2();
    Object.defineProperty(exports2, "NtlmCredentialHandler", { enumerable: true, get: function() {
      return ntlm_1.NtlmCredentialHandler;
    } });
    var personalaccesstoken_1 = require_personalaccesstoken();
    Object.defineProperty(exports2, "PersonalAccessTokenCredentialHandler", { enumerable: true, get: function() {
      return personalaccesstoken_1.PersonalAccessTokenCredentialHandler;
    } });
  }
});

// packages/core/node_modules/azure-devops-node-api/handlers/basiccreds.js
var require_basiccreds2 = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/handlers/basiccreds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var BasicCredentialHandler = class extends resthandlers.BasicCredentialHandler {
      constructor(username, password, allowCrossOriginAuthentication = true) {
        super(username, password, allowCrossOriginAuthentication);
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
  }
});

// packages/core/node_modules/azure-devops-node-api/handlers/bearertoken.js
var require_bearertoken2 = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/handlers/bearertoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BearerCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var BearerCredentialHandler = class extends resthandlers.BearerCredentialHandler {
      constructor(token, allowCrossOriginAuthentication = true) {
        super(token, allowCrossOriginAuthentication);
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
  }
});

// packages/core/node_modules/azure-devops-node-api/handlers/ntlm.js
var require_ntlm3 = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/handlers/ntlm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NtlmCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var NtlmCredentialHandler = class extends resthandlers.NtlmCredentialHandler {
      constructor(username, password, workstation, domain) {
        super(username, password, workstation, domain);
      }
    };
    exports2.NtlmCredentialHandler = NtlmCredentialHandler;
  }
});

// packages/core/node_modules/azure-devops-node-api/handlers/personalaccesstoken.js
var require_personalaccesstoken2 = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/handlers/personalaccesstoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var PersonalAccessTokenCredentialHandler = class extends resthandlers.PersonalAccessTokenCredentialHandler {
      constructor(token, allowCrossOriginAuthentication = true) {
        super(token, allowCrossOriginAuthentication);
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// packages/core/node_modules/azure-devops-node-api/WebApi.js
var require_WebApi = __commonJS({
  "packages/core/node_modules/azure-devops-node-api/WebApi.js"(exports2) {
    "use strict";
    var __awaiter3 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebApi = exports2.getHandlerFromToken = exports2.getPersonalAccessTokenHandler = exports2.getBearerHandler = exports2.getNtlmHandler = exports2.getBasicHandler = void 0;
    var alertm = require_AlertApi();
    var buildm = require_BuildApi();
    var corem = require_CoreApi();
    var dashboardm = require_DashboardApi();
    var extmgmtm = require_ExtensionManagementApi();
    var featuremgmtm = require_FeatureManagementApi();
    var filecontainerm = require_FileContainerApi();
    var gallerym = require_GalleryApi();
    var gitm = require_GitApi();
    var locationsm = require_LocationsApi();
    var managementm = require_ManagementApi();
    var notificationm = require_NotificationApi();
    var policym = require_PolicyApi();
    var profilem = require_ProfileApi();
    var projectm = require_ProjectAnalysisApi();
    var releasem = require_ReleaseApi();
    var securityrolesm = require_SecurityRolesApi();
    var taskagentm = require_TaskAgentApi();
    var taskm = require_TaskApi();
    var testm = require_TestApi();
    var testplanm = require_TestPlanApi();
    var testresultsm = require_TestResultsApi();
    var tfvcm = require_TfvcApi();
    var wikim = require_WikiApi();
    var workm = require_WorkApi();
    var pipelinesm = require_PipelinesApi();
    var cixm = require_CIXApi();
    var workitemtrackingm = require_WorkItemTrackingApi();
    var workitemtrackingprocessm = require_WorkItemTrackingProcessApi();
    var workitemtrackingprocessdefinitionm = require_WorkItemTrackingProcessDefinitionsApi();
    var basicm = require_basiccreds2();
    var bearm = require_bearertoken2();
    var ntlmm = require_ntlm3();
    var patm = require_personalaccesstoken2();
    var rm = require_RestClient();
    var vsom = require_VsoClient();
    var crypto = require("crypto");
    var fs4 = require("fs");
    var os3 = require("os");
    var url = require("url");
    var path10 = require("path");
    var isBrowser = typeof window !== "undefined";
    var personalAccessTokenRegex = new RegExp("^.{76}AZDO.{4}$");
    function getBasicHandler(username, password, allowCrossOriginAuthentication) {
      return new basicm.BasicCredentialHandler(username, password, allowCrossOriginAuthentication);
    }
    exports2.getBasicHandler = getBasicHandler;
    function getNtlmHandler(username, password, workstation, domain) {
      return new ntlmm.NtlmCredentialHandler(username, password, workstation, domain);
    }
    exports2.getNtlmHandler = getNtlmHandler;
    function getBearerHandler(token, allowCrossOriginAuthentication) {
      return new bearm.BearerCredentialHandler(token, allowCrossOriginAuthentication);
    }
    exports2.getBearerHandler = getBearerHandler;
    function getPersonalAccessTokenHandler2(token, allowCrossOriginAuthentication) {
      return new patm.PersonalAccessTokenCredentialHandler(token, allowCrossOriginAuthentication);
    }
    exports2.getPersonalAccessTokenHandler = getPersonalAccessTokenHandler2;
    function getHandlerFromToken(token, allowCrossOriginAuthentication) {
      if (token.length === 52 || personalAccessTokenRegex.test(token)) {
        return getPersonalAccessTokenHandler2(token, allowCrossOriginAuthentication);
      } else {
        return getBearerHandler(token, allowCrossOriginAuthentication);
      }
    }
    exports2.getHandlerFromToken = getHandlerFromToken;
    var WebApi2 = class {
      /*
       * Factory to return client apis and handlers
       * @param defaultUrl default server url to use when creating new apis from factory methods
       * @param authHandler default authentication credentials to use when creating new apis from factory methods
       */
      constructor(defaultUrl, authHandler, options2, requestSettings) {
        this.isNoProxyHost = function(_url) {
          if (!process.env.no_proxy) {
            return false;
          }
          const noProxyDomains = (process.env.no_proxy || "").split(",").map((v) => v.toLowerCase());
          const serverUrl = url.parse(_url).host.toLowerCase();
          return noProxyDomains.indexOf(serverUrl) !== -1;
        };
        this.serverUrl = defaultUrl;
        this.authHandler = authHandler;
        this.options = options2 || {};
        if (!this.isNoProxyHost(this.serverUrl)) {
          if (!this.options.proxy || !this.options.proxy.proxyUrl) {
            if (global["_vsts_task_lib_proxy"]) {
              let proxyFromEnv = {
                proxyUrl: global["_vsts_task_lib_proxy_url"],
                proxyUsername: global["_vsts_task_lib_proxy_username"],
                proxyPassword: this._readTaskLibSecrets(global["_vsts_task_lib_proxy_password"]),
                proxyBypassHosts: JSON.parse(global["_vsts_task_lib_proxy_bypass"] || "[]")
              };
              this.options.proxy = proxyFromEnv;
            }
          }
        }
        if (!this.options.cert) {
          if (global["_vsts_task_lib_cert"]) {
            let certFromEnv = {
              caFile: global["_vsts_task_lib_cert_ca"],
              certFile: global["_vsts_task_lib_cert_clientcert"],
              keyFile: global["_vsts_task_lib_cert_key"],
              passphrase: this._readTaskLibSecrets(global["_vsts_task_lib_cert_passphrase"])
            };
            this.options.cert = certFromEnv;
          }
        }
        if (!this.options.ignoreSslError) {
          this.options.ignoreSslError = !!global["_vsts_task_lib_skip_cert_validation"];
        }
        let userAgent;
        const nodeApiName = "azure-devops-node-api";
        if (requestSettings && requestSettings.userAgent) {
          userAgent = requestSettings.userAgent;
          this.userAgent = requestSettings.userAgent;
        } else if (isBrowser) {
          if (requestSettings) {
            userAgent = `${requestSettings.productName}/${requestSettings.productVersion} (${nodeApiName}; ${window.navigator.userAgent})`;
          } else {
            userAgent = `${nodeApiName} (${window.navigator.userAgent})`;
          }
        } else {
          let nodeApiVersion = "unknown";
          const packageJsonPath = path10.resolve(__dirname, "package.json");
          if (fs4.existsSync(packageJsonPath)) {
            nodeApiVersion = JSON.parse(fs4.readFileSync(packageJsonPath, "utf8")).version;
          }
          const osName = os3.platform();
          const osVersion = os3.release();
          if (requestSettings) {
            userAgent = `${requestSettings.productName}/${requestSettings.productVersion} (${nodeApiName} ${nodeApiVersion}; ${osName} ${osVersion})`;
          } else {
            userAgent = `${nodeApiName}/${nodeApiVersion} (${osName} ${osVersion})`;
          }
        }
        this.rest = new rm.RestClient(userAgent, null, [this.authHandler], this.options);
        this.vsoClient = new vsom.VsoClient(defaultUrl, this.rest);
      }
      /**
       *  Convenience factory to create with a bearer token.
       * @param defaultServerUrl default server url to use when creating new apis from factory methods
       * @param defaultAuthHandler default authentication credentials to use when creating new apis from factory methods
       */
      static createWithBearerToken(defaultUrl, token, options2) {
        let bearerHandler = getBearerHandler(token);
        return new this(defaultUrl, bearerHandler, options2);
      }
      connect() {
        return __awaiter3(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter3(this, void 0, void 0, function* () {
            try {
              let res;
              res = yield this.rest.get(this.vsoClient.resolveUrl("/_apis/connectionData"));
              resolve(res.result);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Each factory method can take a serverUrl and a list of handlers
       * if these aren't provided, the default url and auth handler given to the constructor for this class will be used
       */
      getAlertApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "0f2ca920-f269-4545-b1f4-5b4173aa784e");
          handlers = handlers || [this.authHandler];
          return new alertm.AlertApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getBuildApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, buildm.BuildApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new buildm.BuildApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getCoreApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "79134c72-4a58-4b42-976c-04e7115f32bf");
          handlers = handlers || [this.authHandler];
          return new corem.CoreApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getDashboardApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "31c84e0a-3ece-48fd-a29d-100849af99ba");
          handlers = handlers || [this.authHandler];
          return new dashboardm.DashboardApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getExtensionManagementApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "6c2b0933-3600-42ae-bf8b-93d4f7e83594");
          handlers = handlers || [this.authHandler];
          return new extmgmtm.ExtensionManagementApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getFeatureManagementApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new featuremgmtm.FeatureManagementApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getFileContainerApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new filecontainerm.FileContainerApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getGalleryApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, gallerym.GalleryApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new gallerym.GalleryApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getGitApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, gitm.GitApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new gitm.GitApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      // TODO: Don't call resource area here? Will cause infinite loop?
      getLocationsApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          let optionsClone = Object.assign({}, this.options);
          optionsClone.allowRetries = true;
          optionsClone.maxRetries = 5;
          serverUrl = (yield serverUrl) || this.serverUrl;
          handlers = handlers || [this.authHandler];
          return new locationsm.LocationsApi(serverUrl, handlers, optionsClone, this.userAgent);
        });
      }
      getManagementApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "f101720c-9790-45a6-9fb3-494a09fddeeb");
          handlers = handlers || [this.authHandler];
          return new managementm.ManagementApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getNotificationApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new notificationm.NotificationApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getPolicyApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "fb13a388-40dd-4a04-b530-013a739c72ef");
          handlers = handlers || [this.authHandler];
          return new policym.PolicyApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getProfileApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "8ccfef3d-2b87-4e99-8ccb-66e343d2daa8");
          handlers = handlers || [this.authHandler];
          return new profilem.ProfileApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getProjectAnalysisApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "7658fa33-b1bf-4580-990f-fac5896773d3");
          handlers = handlers || [this.authHandler];
          return new projectm.ProjectAnalysisApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getSecurityRolesApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new securityrolesm.SecurityRolesApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getReleaseApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "efc2f575-36ef-48e9-b672-0c6fb4a48ac5");
          handlers = handlers || [this.authHandler];
          return new releasem.ReleaseApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getTaskApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new taskm.TaskApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getTaskAgentApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "a85b8835-c1a1-4aac-ae97-1c3d0ba72dbd");
          handlers = handlers || [this.authHandler];
          return new taskagentm.TaskAgentApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getTestApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "c2aa639c-3ccc-4740-b3b6-ce2a1e1d984e");
          handlers = handlers || [this.authHandler];
          return new testm.TestApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getTestPlanApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "e4c27205-9d23-4c98-b958-d798bc3f9cd4");
          handlers = handlers || [this.authHandler];
          return new testplanm.TestPlanApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getTestResultsApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "c83eaf52-edf3-4034-ae11-17d38f25404c");
          handlers = handlers || [this.authHandler];
          return new testresultsm.TestResultsApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getTfvcApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "8aa40520-446d-40e6-89f6-9c9f9ce44c48");
          handlers = handlers || [this.authHandler];
          return new tfvcm.TfvcApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getWikiApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "bf7d82a0-8aa5-4613-94ef-6172a5ea01f3");
          handlers = handlers || [this.authHandler];
          return new wikim.WikiApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getWorkApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "1d4f49f9-02b9-4e26-b826-2cdb6195f2a9");
          handlers = handlers || [this.authHandler];
          return new workm.WorkApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getWorkItemTrackingApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, workitemtrackingm.WorkItemTrackingApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new workitemtrackingm.WorkItemTrackingApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getWorkItemTrackingProcessApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new workitemtrackingprocessm.WorkItemTrackingProcessApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getWorkItemTrackingProcessDefinitionApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new workitemtrackingprocessdefinitionm.WorkItemTrackingProcessDefinitionsApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getPipelinesApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new pipelinesm.PipelinesApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      getCixApi(serverUrl, handlers) {
        return __awaiter3(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new cixm.CixApi(serverUrl, handlers, this.options, this.userAgent);
        });
      }
      _getResourceAreaUrl(serverUrl, resourceId) {
        return __awaiter3(this, void 0, void 0, function* () {
          if (!resourceId) {
            return serverUrl;
          }
          const resourceAreas = yield this._getResourceAreas();
          if (resourceAreas === void 0) {
            throw new Error(`Failed to retrieve resource areas ' + 'from server: ${serverUrl}`);
          }
          if (!resourceAreas || resourceAreas.length === 0 || resourceAreas.count === 0) {
            return serverUrl;
          }
          for (var resourceArea of resourceAreas) {
            if (resourceArea.id.toLowerCase() === resourceId.toLowerCase()) {
              return resourceArea.locationUrl;
            }
          }
          throw new Error(`Could not find information for resource area ${resourceId} ' + 'from server: ${serverUrl}`);
        });
      }
      _getResourceAreas() {
        return __awaiter3(this, void 0, void 0, function* () {
          if (!this._resourceAreas) {
            const locationClient = yield this.getLocationsApi();
            this._resourceAreas = yield locationClient.getResourceAreas();
          }
          return this._resourceAreas;
        });
      }
      _readTaskLibSecrets(lookupKey) {
        if (isBrowser) {
          throw new Error("Browsers can't securely keep secrets");
        }
        if (lookupKey && lookupKey.indexOf(":") > 0) {
          let lookupInfo = lookupKey.split(":", 2);
          let keyFile = new Buffer(lookupInfo[0], "base64").toString("utf8");
          let encryptKey = new Buffer(fs4.readFileSync(keyFile, "utf8"), "base64");
          let encryptedContent = new Buffer(lookupInfo[1], "base64").toString("utf8");
          let decipher = crypto.createDecipher("aes-256-ctr", encryptKey);
          let decryptedContent = decipher.update(encryptedContent, "hex", "utf8");
          decryptedContent += decipher.final("utf8");
          return decryptedContent;
        }
      }
    };
    exports2.WebApi = WebApi2;
  }
});

// packages/github-action/src/main.ts
var core6 = __toESM(require("@actions/core"), 1);

// packages/github-action/src/github-adapter.ts
var core4 = __toESM(require("@actions/core"), 1);
var exec = __toESM(require("@actions/exec"), 1);
var tc = __toESM(require("@actions/tool-cache"), 1);
var io = __toESM(require("@actions/io"), 1);

// node_modules/@actions/glob/lib/internal-globber.js
var core2 = __toESM(require("@actions/core"), 1);
var fs = __toESM(require("fs"), 1);

// node_modules/@actions/glob/lib/internal-glob-options-helper.js
var core = __toESM(require("@actions/core"), 1);
function getOptions(copy) {
  const result2 = {
    followSymbolicLinks: true,
    implicitDescendants: true,
    matchDirectories: true,
    omitBrokenSymbolicLinks: true,
    excludeHiddenFiles: false
  };
  if (copy) {
    if (typeof copy.followSymbolicLinks === "boolean") {
      result2.followSymbolicLinks = copy.followSymbolicLinks;
      core.debug(`followSymbolicLinks '${result2.followSymbolicLinks}'`);
    }
    if (typeof copy.implicitDescendants === "boolean") {
      result2.implicitDescendants = copy.implicitDescendants;
      core.debug(`implicitDescendants '${result2.implicitDescendants}'`);
    }
    if (typeof copy.matchDirectories === "boolean") {
      result2.matchDirectories = copy.matchDirectories;
      core.debug(`matchDirectories '${result2.matchDirectories}'`);
    }
    if (typeof copy.omitBrokenSymbolicLinks === "boolean") {
      result2.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
      core.debug(`omitBrokenSymbolicLinks '${result2.omitBrokenSymbolicLinks}'`);
    }
    if (typeof copy.excludeHiddenFiles === "boolean") {
      result2.excludeHiddenFiles = copy.excludeHiddenFiles;
      core.debug(`excludeHiddenFiles '${result2.excludeHiddenFiles}'`);
    }
  }
  return result2;
}

// node_modules/@actions/glob/lib/internal-globber.js
var path4 = __toESM(require("path"), 1);

// node_modules/@actions/glob/lib/internal-path-helper.js
var path = __toESM(require("path"), 1);
var import_assert = __toESM(require("assert"), 1);
var IS_WINDOWS = process.platform === "win32";
function dirname2(p) {
  p = safeTrimTrailingSeparator(p);
  if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
    return p;
  }
  let result2 = path.dirname(p);
  if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result2)) {
    result2 = safeTrimTrailingSeparator(result2);
  }
  return result2;
}
function ensureAbsoluteRoot(root2, itemPath) {
  (0, import_assert.default)(root2, `ensureAbsoluteRoot parameter 'root' must not be empty`);
  (0, import_assert.default)(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
  if (hasAbsoluteRoot(itemPath)) {
    return itemPath;
  }
  if (IS_WINDOWS) {
    if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
      let cwd = process.cwd();
      (0, import_assert.default)(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
      if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
        if (itemPath.length === 2) {
          return `${itemPath[0]}:\\${cwd.substr(3)}`;
        } else {
          if (!cwd.endsWith("\\")) {
            cwd += "\\";
          }
          return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
        }
      } else {
        return `${itemPath[0]}:\\${itemPath.substr(2)}`;
      }
    } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
      const cwd = process.cwd();
      (0, import_assert.default)(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
      return `${cwd[0]}:\\${itemPath.substr(1)}`;
    }
  }
  (0, import_assert.default)(hasAbsoluteRoot(root2), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
  if (root2.endsWith("/") || IS_WINDOWS && root2.endsWith("\\")) {
  } else {
    root2 += path.sep;
  }
  return root2 + itemPath;
}
function hasAbsoluteRoot(itemPath) {
  (0, import_assert.default)(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
  itemPath = normalizeSeparators(itemPath);
  if (IS_WINDOWS) {
    return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
  }
  return itemPath.startsWith("/");
}
function hasRoot(itemPath) {
  (0, import_assert.default)(itemPath, `isRooted parameter 'itemPath' must not be empty`);
  itemPath = normalizeSeparators(itemPath);
  if (IS_WINDOWS) {
    return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
  }
  return itemPath.startsWith("/");
}
function normalizeSeparators(p) {
  p = p || "";
  if (IS_WINDOWS) {
    p = p.replace(/\//g, "\\");
    const isUnc = /^\\\\+[^\\]/.test(p);
    return (isUnc ? "\\" : "") + p.replace(/\\\\+/g, "\\");
  }
  return p.replace(/\/\/+/g, "/");
}
function safeTrimTrailingSeparator(p) {
  if (!p) {
    return "";
  }
  p = normalizeSeparators(p);
  if (!p.endsWith(path.sep)) {
    return p;
  }
  if (p === path.sep) {
    return p;
  }
  if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
    return p;
  }
  return p.substr(0, p.length - 1);
}

// node_modules/@actions/glob/lib/internal-match-kind.js
var MatchKind;
(function(MatchKind2) {
  MatchKind2[MatchKind2["None"] = 0] = "None";
  MatchKind2[MatchKind2["Directory"] = 1] = "Directory";
  MatchKind2[MatchKind2["File"] = 2] = "File";
  MatchKind2[MatchKind2["All"] = 3] = "All";
})(MatchKind || (MatchKind = {}));

// node_modules/@actions/glob/lib/internal-pattern-helper.js
var IS_WINDOWS2 = process.platform === "win32";
function getSearchPaths(patterns) {
  patterns = patterns.filter((x) => !x.negate);
  const searchPathMap = {};
  for (const pattern of patterns) {
    const key = IS_WINDOWS2 ? pattern.searchPath.toUpperCase() : pattern.searchPath;
    searchPathMap[key] = "candidate";
  }
  const result2 = [];
  for (const pattern of patterns) {
    const key = IS_WINDOWS2 ? pattern.searchPath.toUpperCase() : pattern.searchPath;
    if (searchPathMap[key] === "included") {
      continue;
    }
    let foundAncestor = false;
    let tempKey = key;
    let parent = dirname2(tempKey);
    while (parent !== tempKey) {
      if (searchPathMap[parent]) {
        foundAncestor = true;
        break;
      }
      tempKey = parent;
      parent = dirname2(tempKey);
    }
    if (!foundAncestor) {
      result2.push(pattern.searchPath);
      searchPathMap[key] = "included";
    }
  }
  return result2;
}
function match(patterns, itemPath) {
  let result2 = MatchKind.None;
  for (const pattern of patterns) {
    if (pattern.negate) {
      result2 &= ~pattern.match(itemPath);
    } else {
      result2 |= pattern.match(itemPath);
    }
  }
  return result2;
}
function partialMatch(patterns, itemPath) {
  return patterns.some((x) => !x.negate && x.partialMatch(itemPath));
}

// node_modules/@actions/glob/lib/internal-pattern.js
var os = __toESM(require("os"), 1);
var path3 = __toESM(require("path"), 1);
var import_assert3 = __toESM(require("assert"), 1);
var import_minimatch = __toESM(require_minimatch(), 1);

// node_modules/@actions/glob/lib/internal-path.js
var path2 = __toESM(require("path"), 1);
var import_assert2 = __toESM(require("assert"), 1);
var IS_WINDOWS3 = process.platform === "win32";
var Path = class {
  /**
   * Constructs a Path
   * @param itemPath Path or array of segments
   */
  constructor(itemPath) {
    this.segments = [];
    if (typeof itemPath === "string") {
      (0, import_assert2.default)(itemPath, `Parameter 'itemPath' must not be empty`);
      itemPath = safeTrimTrailingSeparator(itemPath);
      if (!hasRoot(itemPath)) {
        this.segments = itemPath.split(path2.sep);
      } else {
        let remaining = itemPath;
        let dir = dirname2(remaining);
        while (dir !== remaining) {
          const basename3 = path2.basename(remaining);
          this.segments.unshift(basename3);
          remaining = dir;
          dir = dirname2(remaining);
        }
        this.segments.unshift(remaining);
      }
    } else {
      (0, import_assert2.default)(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
      for (let i = 0; i < itemPath.length; i++) {
        let segment = itemPath[i];
        (0, import_assert2.default)(segment, `Parameter 'itemPath' must not contain any empty segments`);
        segment = normalizeSeparators(itemPath[i]);
        if (i === 0 && hasRoot(segment)) {
          segment = safeTrimTrailingSeparator(segment);
          (0, import_assert2.default)(segment === dirname2(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
          this.segments.push(segment);
        } else {
          (0, import_assert2.default)(!segment.includes(path2.sep), `Parameter 'itemPath' contains unexpected path separators`);
          this.segments.push(segment);
        }
      }
    }
  }
  /**
   * Converts the path to it's string representation
   */
  toString() {
    let result2 = this.segments[0];
    let skipSlash = result2.endsWith(path2.sep) || IS_WINDOWS3 && /^[A-Z]:$/i.test(result2);
    for (let i = 1; i < this.segments.length; i++) {
      if (skipSlash) {
        skipSlash = false;
      } else {
        result2 += path2.sep;
      }
      result2 += this.segments[i];
    }
    return result2;
  }
};

// node_modules/@actions/glob/lib/internal-pattern.js
var { Minimatch } = import_minimatch.default;
var IS_WINDOWS4 = process.platform === "win32";
var Pattern = class _Pattern {
  constructor(patternOrNegate, isImplicitPattern = false, segments, homedir2) {
    this.negate = false;
    let pattern;
    if (typeof patternOrNegate === "string") {
      pattern = patternOrNegate.trim();
    } else {
      segments = segments || [];
      (0, import_assert3.default)(segments.length, `Parameter 'segments' must not empty`);
      const root2 = _Pattern.getLiteral(segments[0]);
      (0, import_assert3.default)(root2 && hasAbsoluteRoot(root2), `Parameter 'segments' first element must be a root path`);
      pattern = new Path(segments).toString().trim();
      if (patternOrNegate) {
        pattern = `!${pattern}`;
      }
    }
    while (pattern.startsWith("!")) {
      this.negate = !this.negate;
      pattern = pattern.substr(1).trim();
    }
    pattern = _Pattern.fixupPattern(pattern, homedir2);
    this.segments = new Path(pattern).segments;
    this.trailingSeparator = normalizeSeparators(pattern).endsWith(path3.sep);
    pattern = safeTrimTrailingSeparator(pattern);
    let foundGlob = false;
    const searchSegments = this.segments.map((x) => _Pattern.getLiteral(x)).filter((x) => !foundGlob && !(foundGlob = x === ""));
    this.searchPath = new Path(searchSegments).toString();
    this.rootRegExp = new RegExp(_Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS4 ? "i" : "");
    this.isImplicitPattern = isImplicitPattern;
    const minimatchOptions = {
      dot: true,
      nobrace: true,
      nocase: IS_WINDOWS4,
      nocomment: true,
      noext: true,
      nonegate: true
    };
    pattern = IS_WINDOWS4 ? pattern.replace(/\\/g, "/") : pattern;
    this.minimatch = new Minimatch(pattern, minimatchOptions);
  }
  /**
   * Matches the pattern against the specified path
   */
  match(itemPath) {
    if (this.segments[this.segments.length - 1] === "**") {
      itemPath = normalizeSeparators(itemPath);
      if (!itemPath.endsWith(path3.sep) && this.isImplicitPattern === false) {
        itemPath = `${itemPath}${path3.sep}`;
      }
    } else {
      itemPath = safeTrimTrailingSeparator(itemPath);
    }
    if (this.minimatch.match(itemPath)) {
      return this.trailingSeparator ? MatchKind.Directory : MatchKind.All;
    }
    return MatchKind.None;
  }
  /**
   * Indicates whether the pattern may match descendants of the specified path
   */
  partialMatch(itemPath) {
    itemPath = safeTrimTrailingSeparator(itemPath);
    if (dirname2(itemPath) === itemPath) {
      return this.rootRegExp.test(itemPath);
    }
    return this.minimatch.matchOne(itemPath.split(IS_WINDOWS4 ? /\\+/ : /\/+/), this.minimatch.set[0], true);
  }
  /**
   * Escapes glob patterns within a path
   */
  static globEscape(s) {
    return (IS_WINDOWS4 ? s : s.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
  }
  /**
   * Normalizes slashes and ensures absolute root
   */
  static fixupPattern(pattern, homedir2) {
    (0, import_assert3.default)(pattern, "pattern cannot be empty");
    const literalSegments = new Path(pattern).segments.map((x) => _Pattern.getLiteral(x));
    (0, import_assert3.default)(literalSegments.every((x, i) => (x !== "." || i === 0) && x !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
    (0, import_assert3.default)(!hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
    pattern = normalizeSeparators(pattern);
    if (pattern === "." || pattern.startsWith(`.${path3.sep}`)) {
      pattern = _Pattern.globEscape(process.cwd()) + pattern.substr(1);
    } else if (pattern === "~" || pattern.startsWith(`~${path3.sep}`)) {
      homedir2 = homedir2 || os.homedir();
      (0, import_assert3.default)(homedir2, "Unable to determine HOME directory");
      (0, import_assert3.default)(hasAbsoluteRoot(homedir2), `Expected HOME directory to be a rooted path. Actual '${homedir2}'`);
      pattern = _Pattern.globEscape(homedir2) + pattern.substr(1);
    } else if (IS_WINDOWS4 && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
      let root2 = ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
      if (pattern.length > 2 && !root2.endsWith("\\")) {
        root2 += "\\";
      }
      pattern = _Pattern.globEscape(root2) + pattern.substr(2);
    } else if (IS_WINDOWS4 && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
      let root2 = ensureAbsoluteRoot("C:\\dummy-root", "\\");
      if (!root2.endsWith("\\")) {
        root2 += "\\";
      }
      pattern = _Pattern.globEscape(root2) + pattern.substr(1);
    } else {
      pattern = ensureAbsoluteRoot(_Pattern.globEscape(process.cwd()), pattern);
    }
    return normalizeSeparators(pattern);
  }
  /**
   * Attempts to unescape a pattern segment to create a literal path segment.
   * Otherwise returns empty string.
   */
  static getLiteral(segment) {
    let literal = "";
    for (let i = 0; i < segment.length; i++) {
      const c = segment[i];
      if (c === "\\" && !IS_WINDOWS4 && i + 1 < segment.length) {
        literal += segment[++i];
        continue;
      } else if (c === "*" || c === "?") {
        return "";
      } else if (c === "[" && i + 1 < segment.length) {
        let set = "";
        let closed = -1;
        for (let i2 = i + 1; i2 < segment.length; i2++) {
          const c2 = segment[i2];
          if (c2 === "\\" && !IS_WINDOWS4 && i2 + 1 < segment.length) {
            set += segment[++i2];
            continue;
          } else if (c2 === "]") {
            closed = i2;
            break;
          } else {
            set += c2;
          }
        }
        if (closed >= 0) {
          if (set.length > 1) {
            return "";
          }
          if (set) {
            literal += set;
            i = closed;
            continue;
          }
        }
      }
      literal += c;
    }
    return literal;
  }
  /**
   * Escapes regexp special characters
   * https://javascript.info/regexp-escaping
   */
  static regExpEscape(s) {
    return s.replace(/[[\\^$.|?*+()]/g, "\\$&");
  }
};

// node_modules/@actions/glob/lib/internal-search-state.js
var SearchState = class {
  constructor(path10, level) {
    this.path = path10;
    this.level = level;
  }
};

// node_modules/@actions/glob/lib/internal-globber.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject2) {
        v = o[n](v), settle(resolve, reject2, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject2, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject2);
  }
};
var __await = function(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject2);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject2) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject2(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
};
var IS_WINDOWS5 = process.platform === "win32";
var DefaultGlobber = class _DefaultGlobber {
  constructor(options2) {
    this.patterns = [];
    this.searchPaths = [];
    this.options = getOptions(options2);
  }
  getSearchPaths() {
    return this.searchPaths.slice();
  }
  glob() {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, e_1, _b, _c;
      const result2 = [];
      try {
        for (var _d = true, _e = __asyncValues(this.globGenerator()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
          _c = _f.value;
          _d = false;
          const itemPath = _c;
          result2.push(itemPath);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      return result2;
    });
  }
  globGenerator() {
    return __asyncGenerator(this, arguments, function* globGenerator_1() {
      const options2 = getOptions(this.options);
      const patterns = [];
      for (const pattern of this.patterns) {
        patterns.push(pattern);
        if (options2.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
          patterns.push(new Pattern(pattern.negate, true, pattern.segments.concat("**")));
        }
      }
      const stack = [];
      for (const searchPath of getSearchPaths(patterns)) {
        core2.debug(`Search path '${searchPath}'`);
        try {
          yield __await(fs.promises.lstat(searchPath));
        } catch (err) {
          if (err.code === "ENOENT") {
            continue;
          }
          throw err;
        }
        stack.unshift(new SearchState(searchPath, 1));
      }
      const traversalChain = [];
      while (stack.length) {
        const item = stack.pop();
        const match2 = match(patterns, item.path);
        const partialMatch2 = !!match2 || partialMatch(patterns, item.path);
        if (!match2 && !partialMatch2) {
          continue;
        }
        const stats = yield __await(
          _DefaultGlobber.stat(item, options2, traversalChain)
          // Broken symlink, or symlink cycle detected, or no longer exists
        );
        if (!stats) {
          continue;
        }
        if (options2.excludeHiddenFiles && path4.basename(item.path).match(/^\./)) {
          continue;
        }
        if (stats.isDirectory()) {
          if (match2 & MatchKind.Directory && options2.matchDirectories) {
            yield yield __await(item.path);
          } else if (!partialMatch2) {
            continue;
          }
          const childLevel = item.level + 1;
          const childItems = (yield __await(fs.promises.readdir(item.path))).map((x) => new SearchState(path4.join(item.path, x), childLevel));
          stack.push(...childItems.reverse());
        } else if (match2 & MatchKind.File) {
          yield yield __await(item.path);
        }
      }
    });
  }
  /**
   * Constructs a DefaultGlobber
   */
  static create(patterns, options2) {
    return __awaiter(this, void 0, void 0, function* () {
      const result2 = new _DefaultGlobber(options2);
      if (IS_WINDOWS5) {
        patterns = patterns.replace(/\r\n/g, "\n");
        patterns = patterns.replace(/\r/g, "\n");
      }
      const lines = patterns.split("\n").map((x) => x.trim());
      for (const line of lines) {
        if (!line || line.startsWith("#")) {
          continue;
        } else {
          result2.patterns.push(new Pattern(line));
        }
      }
      result2.searchPaths.push(...getSearchPaths(result2.patterns));
      return result2;
    });
  }
  static stat(item, options2, traversalChain) {
    return __awaiter(this, void 0, void 0, function* () {
      let stats;
      if (options2.followSymbolicLinks) {
        try {
          stats = yield fs.promises.stat(item.path);
        } catch (err) {
          if (err.code === "ENOENT") {
            if (options2.omitBrokenSymbolicLinks) {
              core2.debug(`Broken symlink '${item.path}'`);
              return void 0;
            }
            throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
          }
          throw err;
        }
      } else {
        stats = yield fs.promises.lstat(item.path);
      }
      if (stats.isDirectory() && options2.followSymbolicLinks) {
        const realPath = yield fs.promises.realpath(item.path);
        while (traversalChain.length >= item.level) {
          traversalChain.pop();
        }
        if (traversalChain.some((x) => x === realPath)) {
          core2.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
          return void 0;
        }
        traversalChain.push(realPath);
      }
      return stats;
    });
  }
};

// node_modules/@actions/glob/lib/internal-hash-files.js
var core3 = __toESM(require("@actions/core"), 1);

// node_modules/@actions/glob/lib/glob.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function create(patterns, options2) {
  return __awaiter2(this, void 0, void 0, function* () {
    return yield DefaultGlobber.create(patterns, options2);
  });
}

// packages/core/dist/platform.js
var TaskResult;
(function(TaskResult2) {
  TaskResult2[TaskResult2["Succeeded"] = 0] = "Succeeded";
  TaskResult2[TaskResult2["Failed"] = 1] = "Failed";
  TaskResult2[TaskResult2["Warning"] = 2] = "Warning";
})(TaskResult || (TaskResult = {}));

// packages/core/dist/arg-builder.js
var ArgBuilder = class {
  args = [];
  /**
   * Add one or more arguments
   */
  arg(values2) {
    if (Array.isArray(values2)) {
      this.args.push(...values2);
    } else {
      this.args.push(values2);
    }
    return this;
  }
  /**
   * Add arguments if condition is truthy
   */
  argIf(condition, values2) {
    if (condition) {
      return this.arg(values2);
    }
    return this;
  }
  /**
   * Add a flag (e.g., '--json')
   */
  flag(name) {
    this.args.push(name);
    return this;
  }
  /**
   * Add a flag if condition is truthy
   */
  flagIf(condition, name) {
    if (condition) {
      return this.flag(name);
    }
    return this;
  }
  /**
   * Add an option with value (e.g., '--publisher', 'myPublisher')
   */
  option(name, value) {
    if (value !== void 0) {
      this.args.push(name, value);
    }
    return this;
  }
  /**
   * Add an option if condition is truthy
   */
  optionIf(condition, name, value) {
    if (condition && value !== void 0) {
      return this.option(name, value);
    }
    return this;
  }
  /**
   * Append raw command line string (split on spaces)
   */
  line(raw) {
    const parts = raw.split(/\s+/).filter((s) => s.length > 0);
    this.args.push(...parts);
    return this;
  }
  /**
   * Build and return the argument array
   */
  build() {
    return [...this.args];
  }
};

// packages/core/dist/json-output-stream.js
var import_stream = require("stream");
var JsonOutputStream = class extends import_stream.Writable {
  lineWriter;
  /** Accumulated JSON string */
  jsonString = "";
  /** Non-JSON messages (debug output, warnings, etc.) */
  messages = [];
  /**
   * @param lineWriter Function to write non-JSON lines (for logging)
   */
  constructor(lineWriter) {
    super();
    this.lineWriter = lineWriter;
  }
  /**
   * Process a chunk of data from the stream
   */
  _write(chunk2, _encoding, callback) {
    const chunkStr = chunk2.toString();
    const trimmed = chunkStr.trimStart();
    if (chunkStr.startsWith("[command]")) {
      this.writeOutput(chunkStr, this.lineWriter);
    } else if (!this.jsonString && !this.looksLikeJsonStart(trimmed)) {
      this.messages.push(chunkStr);
      this.writeOutput(chunkStr, this.lineWriter);
    } else {
      this.jsonString += chunkStr;
    }
    callback();
  }
  /**
   * Detect whether a chunk can be the start of a valid JSON value.
   */
  looksLikeJsonStart(input) {
    if (!input) {
      return false;
    }
    return /^(\{|\[|"|-?\d|true\b|false\b|null\b)/.test(input);
  }
  /**
   * Write output line by line (splits on newlines)
   */
  writeOutput(messages, writer) {
    if (!messages) {
      return;
    }
    messages.split("\n").forEach((line) => {
      if (line) {
        writer(line);
      }
    });
  }
  /**
   * Parse the accumulated JSON string
   * @returns Parsed JSON object or undefined if parsing fails
   */
  parseJson() {
    if (!this.jsonString) {
      return void 0;
    }
    try {
      return JSON.parse(this.jsonString);
    } catch (error2) {
      this.lineWriter(`Failed to parse JSON output: ${error2}`);
      return void 0;
    }
  }
};

// packages/core/dist/manifest-utils.js
var import_path = __toESM(require("path"), 1);
async function readManifest(manifestPath, platform) {
  const content = await platform.readFile(manifestPath);
  return JSON.parse(content);
}
function resolveTaskManifestPaths(extensionManifest, extensionManifestPath, _platform) {
  void _platform;
  const taskContributions = getTaskContributions(extensionManifest);
  if (taskContributions.length === 0) {
    return [];
  }
  const manifestDir = import_path.default.dirname(extensionManifestPath);
  const taskPaths = [];
  for (const contrib of taskContributions) {
    const taskName = contrib.properties?.name;
    if (!taskName) {
      continue;
    }
    const taskManifestPath = import_path.default.join(manifestDir, taskName, "task.json");
    taskPaths.push(taskManifestPath);
  }
  return taskPaths;
}
function getTaskContributions(manifest) {
  if (!manifest.contributions) {
    return [];
  }
  return manifest.contributions.filter((c) => c.type === "ms.vss-distributed-task.task" && c.properties && c.properties.name);
}

// packages/core/dist/tfx-manager.js
var import_path2 = __toESM(require("path"), 1);
var import_promises = __toESM(require("fs/promises"), 1);
var TfxManager = class {
  resolvedPath;
  tfxVersion;
  platform;
  constructor(options2) {
    this.tfxVersion = options2.tfxVersion;
    this.platform = options2.platform;
  }
  /**
   * Resolve tfx binary path using cache-first strategy
   * @returns Path to tfx executable
   */
  async resolve() {
    if (this.resolvedPath) {
      this.platform.debug(`Using cached tfx path: ${this.resolvedPath}`);
      return this.resolvedPath;
    }
    if (this.tfxVersion === "built-in") {
      this.resolvedPath = await this.resolveBuiltIn();
      return this.resolvedPath;
    }
    if (this.tfxVersion === "path") {
      this.resolvedPath = await this.resolveFromPath();
      return this.resolvedPath;
    }
    const exactVersion = await this.resolveVersionSpec(this.tfxVersion);
    this.platform.info(`Resolved tfx-cli version spec '${this.tfxVersion}' to exact version '${exactVersion}'`);
    const cachedPath = this.platform.findCachedTool("tfx-cli", exactVersion);
    if (cachedPath) {
      this.platform.info(`Found cached tfx-cli@${exactVersion} at ${cachedPath}`);
      this.resolvedPath = this.getTfxExecutable(cachedPath);
      return this.resolvedPath;
    }
    this.resolvedPath = await this.downloadAndCache(exactVersion);
    return this.resolvedPath;
  }
  /**
   * Resolve built-in tfx binary from core package dependencies
   * Similar to tfxinstaller v5 behavior
   *
   * The tfx-cli package is a direct dependency of the core package.
   * When bundled, tfx-cli is marked as external and will be in node_modules.
   * We use 'which' to locate it, which will find it in node_modules/.bin/ or PATH.
   */
  async resolveBuiltIn() {
    this.platform.info("Using built-in tfx-cli from core package dependencies");
    const entrypoint = process.argv[1];
    if (!entrypoint) {
      throw new Error("Built-in tfx-cli resolution failed: process.argv[1] is not set.");
    }
    const entryDir = import_path2.default.dirname(import_path2.default.resolve(entrypoint));
    const tfxExecutable = process.platform === "win32" ? "tfx.cmd" : "tfx";
    const builtInPath = import_path2.default.join(entryDir, "node_modules", ".bin", tfxExecutable);
    if (!await this.pathExists(builtInPath)) {
      throw new Error(`Built-in tfx-cli not found at expected path: ${builtInPath}. Install runtime dependencies and ensure node_modules/.bin is present next to the entrypoint.`);
    }
    this.platform.debug(`Resolved built-in tfx at: ${builtInPath}`);
    return builtInPath;
  }
  async pathExists(filePath) {
    try {
      await import_promises.default.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Resolve tfx from system PATH
   * No download, uses whatever tfx is installed on the system
   */
  async resolveFromPath() {
    this.platform.info("Using tfx-cli from system PATH");
    const tfxPath = await this.platform.which("tfx", true);
    this.platform.debug(`Resolved tfx from PATH at: ${tfxPath}`);
    return tfxPath;
  }
  /**
   * Resolve a version spec to an exact version
   * Uses npm to resolve version specs like "^0.17", "latest", etc.
   * @param versionSpec - Version spec to resolve (e.g., "^0.17", "latest", "0.17.0")
   * @returns Exact version string (e.g., "0.17.3")
   */
  async resolveVersionSpec(versionSpec) {
    this.platform.debug(`Resolving version spec: ${versionSpec}`);
    try {
      const npmPath = await this.platform.which("npm", true);
      let output = "";
      const outStream = {
        write: (data) => {
          output += data;
        }
      };
      const exitCode = await this.platform.exec(npmPath, ["view", `tfx-cli@${versionSpec}`, "version", "--json"], { outStream });
      if (exitCode !== 0) {
        throw new Error(`npm view failed with exit code ${exitCode}`);
      }
      const trimmed = output.trim();
      let exactVersion;
      if (trimmed.startsWith("[")) {
        const versions = JSON.parse(trimmed);
        exactVersion = versions[versions.length - 1];
      } else if (trimmed.startsWith('"')) {
        exactVersion = JSON.parse(trimmed);
      } else {
        exactVersion = trimmed;
      }
      this.platform.debug(`Resolved '${versionSpec}' to exact version '${exactVersion}'`);
      return exactVersion;
    } catch (error2) {
      throw new Error(`Failed to resolve tfx-cli version spec '${versionSpec}': ${error2}`);
    }
  }
  /**
   * Download tfx from npm and cache it
   * Uses npm install to download tfx-cli and all its dependencies
   * This matches the behavior of the previous tfxinstaller task
   * @param exactVersion - Exact version to download (e.g., "0.17.3")
   */
  async downloadAndCache(exactVersion) {
    this.platform.info(`Installing tfx-cli@${exactVersion} from npm...`);
    const tempDir = this.platform.getTempDir();
    const installDir = import_path2.default.join(tempDir, `tfx-install-${Date.now()}`);
    await import_promises.default.mkdir(installDir, { recursive: true });
    try {
      this.platform.debug(`Running npm install tfx-cli@${exactVersion} in ${installDir}`);
      const npmPath = await this.platform.which("npm", true);
      const exitCode = await this.platform.exec(npmPath, ["install", `tfx-cli@${exactVersion}`, "--production", "--no-save", "--no-package-lock"], { cwd: installDir });
      if (exitCode !== 0) {
        throw new Error(`npm install failed with exit code ${exitCode}`);
      }
      const tfxPackageDir = import_path2.default.join(installDir, "node_modules", "tfx-cli");
      try {
        await import_promises.default.access(tfxPackageDir);
      } catch {
        throw new Error(`tfx-cli not found at ${tfxPackageDir} after npm install`);
      }
      this.platform.info(`Successfully installed tfx-cli@${exactVersion} with dependencies`);
      await this.ensureExecutable(tfxPackageDir);
      this.platform.info(`Caching tfx-cli@${exactVersion}...`);
      const nodeModulesDir = import_path2.default.join(installDir, "node_modules");
      const cachedDir = await this.platform.cacheDir(nodeModulesDir, "tfx-cli", exactVersion);
      this.platform.info(`Cached tfx-cli@${exactVersion} to ${cachedDir}`);
      const binDir = import_path2.default.join(cachedDir, "tfx-cli", "bin");
      return this.getTfxExecutable(binDir);
    } catch (error2) {
      this.platform.warning(`Failed to install tfx-cli@${exactVersion}: ${error2 instanceof Error ? error2.message : String(error2)}`);
      this.platform.warning("Falling back to tfx from PATH");
      try {
        const tfxPath = await this.platform.which("tfx", true);
        return tfxPath;
      } catch {
        throw new Error(`Failed to install tfx-cli@${exactVersion} and no tfx found in PATH. Original error: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    } finally {
      try {
        await this.platform.rmRF(installDir);
        this.platform.debug(`Cleaned up temp directory: ${installDir}`);
      } catch (cleanupError) {
        this.platform.warning(`Failed to clean up temp directory ${installDir}: ${cleanupError instanceof Error ? cleanupError.message : String(cleanupError)}`);
      }
    }
  }
  /**
   * Ensure tfx binary is executable on Unix systems
   * @param tfxPackageDir - Path to tfx-cli package directory
   */
  async ensureExecutable(tfxPackageDir) {
    if (process.platform === "win32") {
      this.platform.debug("Skipping chmod on Windows");
      return;
    }
    try {
      const tfxBin = import_path2.default.join(tfxPackageDir, "bin", "tfx");
      await import_promises.default.chmod(tfxBin, 493);
      this.platform.debug(`Made tfx executable: ${tfxBin}`);
    } catch (error2) {
      this.platform.warning(`Failed to chmod tfx: ${error2}`);
    }
  }
  /**
   * Get tfx executable path from directory
   * On Windows, uses tfx.cmd or tfx.ps1
   * On Unix, uses tfx (made executable via chmod)
   */
  getTfxExecutable(dir) {
    const isWindows = process.platform === "win32";
    if (isWindows) {
      const cmdPath = import_path2.default.join(dir, "tfx.cmd");
      return cmdPath;
    }
    return import_path2.default.join(dir, "tfx");
  }
  /**
   * Execute tfx with given arguments
   * @param args Arguments to pass to tfx
   * @param options Execution options
   * @returns Result with exit code and output
   */
  async execute(args, options2) {
    const tfxPath = await this.resolve();
    const finalArgs = [...args];
    let jsonStream;
    if (options2?.captureJson) {
      if (!finalArgs.includes("--json")) {
        finalArgs.push("--json");
      }
      if (!finalArgs.includes("--debug-log-stream")) {
        finalArgs.push("--debug-log-stream", "stderr");
      }
      jsonStream = new JsonOutputStream((msg) => this.platform.debug(msg));
    }
    const execOptions = {
      cwd: options2?.cwd,
      env: options2?.env,
      outStream: jsonStream,
      errStream: void 0
    };
    this.platform.info(`Executing: ${tfxPath} ${finalArgs.join(" ")}`);
    const exitCode = await this.platform.exec(tfxPath, finalArgs, execOptions);
    let parsedJson;
    if (jsonStream) {
      parsedJson = jsonStream.parseJson();
    }
    return {
      exitCode,
      json: parsedJson,
      stdout: jsonStream?.jsonString || "",
      stderr: ""
    };
  }
};

// packages/core/dist/index.js
init_manifest_reader();
init_manifest_editor();

// packages/core/dist/vsix-reader.js
var import_yauzl = __toESM(require_yauzl(), 1);
var import_buffer3 = require("buffer");
var import_path4 = require("path");
init_manifest_reader();
function validateZipPath2(filePath) {
  const normalizedPath = (0, import_path4.normalize)(filePath);
  if ((0, import_path4.isAbsolute)(normalizedPath)) {
    throw new Error(`Security: Absolute paths are not allowed in VSIX files: ${filePath}`);
  }
  if (normalizedPath.startsWith("..") || normalizedPath.includes(`${(0, import_path4.normalize)("../")}`)) {
    throw new Error(`Security: Path traversal detected in VSIX file: ${filePath}`);
  }
  const suspiciousPatterns = [
    /\.\.[/\\]/,
    // Parent directory references
    /^[/\\]/,
    // Root references
    /[<>:"|?*]/
    // Windows invalid filename characters (except for paths)
  ];
  for (const pattern of suspiciousPatterns) {
    if (pattern.test(filePath)) {
      throw new Error(`Security: Suspicious pattern detected in path: ${filePath}`);
    }
  }
  if (filePath.includes("\0")) {
    throw new Error(`Security: Null byte detected in path: ${filePath}`);
  }
}
var VsixReader = class _VsixReader extends ManifestReader {
  zipFile = null;
  vsixPath;
  fileCache = /* @__PURE__ */ new Map();
  entriesCache = null;
  constructor(vsixPath) {
    super();
    this.vsixPath = vsixPath;
  }
  /**
   * Open a VSIX file for reading
   * @param vsixPath Path to the VSIX file
   * @returns VsixReader instance
   */
  static async open(vsixPath) {
    const reader = new _VsixReader(vsixPath);
    await reader.openZip();
    return reader;
  }
  /**
   * Open the ZIP file
   */
  async openZip() {
    return new Promise((resolve, reject2) => {
      import_yauzl.default.open(this.vsixPath, {
        lazyEntries: true,
        strictFileNames: false,
        validateEntrySizes: false,
        autoClose: false
        // Keep file open for multiple read operations
      }, (err, zipFile) => {
        if (err) {
          reject2(new Error(`Failed to open VSIX file: ${err.message}`));
          return;
        }
        this.zipFile = zipFile;
        resolve();
      });
    });
  }
  /**
   * Read all entries from the ZIP file
   * Validates all paths for security (zip slip protection)
   */
  async readEntries() {
    if (this.entriesCache) {
      return this.entriesCache;
    }
    if (!this.zipFile) {
      throw new Error("VSIX file is not open");
    }
    return new Promise((resolve, reject2) => {
      const entries = [];
      const onEntry = (entry) => {
        try {
          validateZipPath2(entry.fileName);
          entries.push(entry);
        } catch (err) {
          this.zipFile.removeListener("entry", onEntry);
          this.zipFile.removeListener("end", onEnd);
          this.zipFile.removeListener("error", onError);
          reject2(err);
          return;
        }
        this.zipFile.readEntry();
      };
      const onEnd = () => {
        this.zipFile.removeListener("entry", onEntry);
        this.zipFile.removeListener("end", onEnd);
        this.zipFile.removeListener("error", onError);
        this.entriesCache = entries;
        resolve(entries);
      };
      const onError = (err) => {
        this.zipFile.removeListener("entry", onEntry);
        this.zipFile.removeListener("end", onEnd);
        this.zipFile.removeListener("error", onError);
        reject2(new Error(`Error reading VSIX entries: ${err.message}`));
      };
      this.zipFile.on("entry", onEntry);
      this.zipFile.on("end", onEnd);
      this.zipFile.on("error", onError);
      this.zipFile.readEntry();
    });
  }
  /**
   * Read a specific file from the VSIX
   * @param filePath Path to the file within the VSIX
   * @returns File contents as Buffer
   */
  async readFile(filePath) {
    validateZipPath2(filePath);
    const normalizedPath = filePath.replace(/\\/g, "/");
    if (this.fileCache.has(normalizedPath)) {
      return this.fileCache.get(normalizedPath);
    }
    if (!this.zipFile) {
      throw new Error("VSIX file is not open");
    }
    const entries = await this.readEntries();
    const entry = entries.find((e) => e.fileName === normalizedPath);
    if (!entry) {
      throw new Error(`File not found in VSIX: ${filePath}`);
    }
    return new Promise((resolve, reject2) => {
      this.zipFile.openReadStream(entry, (err, readStream) => {
        if (err || !readStream) {
          reject2(new Error(`Failed to read file ${filePath}: ${err?.message || "No stream"}`));
          return;
        }
        const chunks = [];
        readStream.on("data", (chunk2) => chunks.push(chunk2));
        readStream.on("end", () => {
          const buffer = import_buffer3.Buffer.concat(chunks);
          this.fileCache.set(normalizedPath, buffer);
          resolve(buffer);
        });
        readStream.on("error", (streamErr) => {
          reject2(new Error(`Error reading file ${filePath}: ${streamErr.message}`));
        });
      });
    });
  }
  /**
   * Check if a file exists in the VSIX
   * @param filePath Path to check
   * @returns True if file exists
   */
  async fileExists(filePath) {
    const normalizedPath = filePath.replace(/\\/g, "/");
    const entries = await this.readEntries();
    return entries.some((e) => e.fileName === normalizedPath);
  }
  /**
   * List all files in the VSIX
   * @returns Array of file information
   */
  async listFiles() {
    const entries = await this.readEntries();
    return entries.filter((e) => !e.fileName.endsWith("/")).map((e) => ({
      path: e.fileName,
      size: e.uncompressedSize,
      compressedSize: e.compressedSize
    }));
  }
  /**
   * Read the extension manifest (vss-extension.json or extension.vsixmanifest)
   * @returns Parsed extension manifest
   */
  async readExtensionManifest() {
    if (await this.fileExists("extension.vsomanifest")) {
      const buffer = await this.readFile("extension.vsomanifest");
      return JSON.parse(buffer.toString("utf-8"));
    }
    if (await this.fileExists("vss-extension.json")) {
      const buffer = await this.readFile("vss-extension.json");
      return JSON.parse(buffer.toString("utf-8"));
    }
    throw new Error("Extension manifest not found in VSIX (expected vss-extension.json or extension.vsomanifest)");
  }
  /**
   * Find task directories from the extension manifest
   * @returns Array of task directory paths
   */
  async findTaskPaths() {
    const manifest = await this.readExtensionManifest();
    const taskPathsSet = /* @__PURE__ */ new Set();
    if (manifest.contributions) {
      for (const contribution of manifest.contributions) {
        if (contribution.type === "ms.vss-distributed-task.task" && contribution.properties) {
          const name = contribution.properties.name;
          if (name) {
            taskPathsSet.add(name);
          }
        }
      }
    }
    if (taskPathsSet.size === 0 && manifest.files) {
      const entries = await this.readEntries();
      for (const file of manifest.files) {
        const taskJsonPath = `${file.path}/task.json`.replace(/\\/g, "/");
        if (entries.some((e) => e.fileName === taskJsonPath)) {
          taskPathsSet.add(file.path);
        }
      }
    }
    return Array.from(taskPathsSet);
  }
  /**
   * Read a task manifest (task.json)
   * @param taskPath Path to the task directory
   * @returns Parsed task manifest
   */
  async readTaskManifest(taskPath) {
    const taskJsonPath = `${taskPath}/task.json`.replace(/\\/g, "/");
    const buffer = await this.readFile(taskJsonPath);
    return JSON.parse(buffer.toString("utf-8"));
  }
  /**
   * Close the VSIX file and clean up resources
   */
  async close() {
    if (this.zipFile) {
      this.zipFile.close();
      this.zipFile = null;
    }
    this.fileCache.clear();
    this.entriesCache = null;
  }
  /**
   * Get the path to the VSIX file
   */
  getPath() {
    return this.vsixPath;
  }
};

// packages/core/dist/index.js
init_vsix_writer();
init_filesystem_manifest_reader();
init_filesystem_manifest_writer();

// packages/core/dist/validation.js
function validateExtensionId(id) {
  if (!id || typeof id !== "string") {
    throw new Error("Extension ID is required and must be a string");
  }
  if (id.trim() !== id) {
    throw new Error("Extension ID cannot have leading or trailing whitespace");
  }
  if (id.length === 0) {
    throw new Error("Extension ID cannot be empty");
  }
  if (id.length > 200) {
    throw new Error("Extension ID cannot exceed 200 characters");
  }
  const validPattern = /^[a-zA-Z0-9._-]+$/;
  if (!validPattern.test(id)) {
    throw new Error("Extension ID can only contain letters, numbers, dots (.), underscores (_), and hyphens (-)");
  }
}
function validatePublisherId(id) {
  if (!id || typeof id !== "string") {
    throw new Error("Publisher ID is required and must be a string");
  }
  if (id.trim() !== id) {
    throw new Error("Publisher ID cannot have leading or trailing whitespace");
  }
  if (id.length === 0) {
    throw new Error("Publisher ID cannot be empty");
  }
  if (id.length > 200) {
    throw new Error("Publisher ID cannot exceed 200 characters");
  }
  const validPattern = /^[a-zA-Z0-9._-]+$/;
  if (!validPattern.test(id)) {
    throw new Error("Publisher ID can only contain letters, numbers, dots (.), underscores (_), and hyphens (-)");
  }
}
function validateAccountUrl(url) {
  if (!url || typeof url !== "string") {
    throw new Error("Account URL is required and must be a string");
  }
  if (url.trim() !== url) {
    throw new Error("Account URL cannot have leading or trailing whitespace");
  }
  if (url.length === 0) {
    throw new Error("Account URL cannot be empty");
  }
  let parsedUrl;
  try {
    parsedUrl = new URL(url);
  } catch {
    throw new Error("Account URL must be a valid URL");
  }
  if (parsedUrl.protocol !== "https:") {
    throw new Error("Account URL must use HTTPS protocol");
  }
  const validDomains = ["dev.azure.com", "visualstudio.com", "azure.com"];
  const hostname = parsedUrl.hostname.toLowerCase();
  const isValidDomain = validDomains.some((domain) => hostname === domain || hostname.endsWith("." + domain));
  if (!isValidDomain) {
    throw new Error("Account URL must be an Azure DevOps URL (dev.azure.com, *.visualstudio.com, or *.azure.com)");
  }
}
function validateVersion(version) {
  if (!version || typeof version !== "string") {
    throw new Error("Version is required and must be a string");
  }
  if (version.trim() !== version) {
    throw new Error("Version cannot have leading or trailing whitespace");
  }
  if (version.length === 0) {
    throw new Error("Version cannot be empty");
  }
  const semverPattern = /^\d+(\.\d+){0,3}$/;
  if (!semverPattern.test(version)) {
    throw new Error("Version must follow semantic versioning (e.g., 1.0.0, 1.0.0.0)");
  }
  const parts = version.split(".");
  for (const part of parts) {
    const num = parseInt(part, 10);
    if (num < 0 || num > 999999) {
      throw new Error("Version numbers must be between 0 and 999999");
    }
  }
}
async function getBinaryVersion(binary, platform) {
  try {
    const versionArgs = {
      node: ["--version"],
      npm: ["--version"],
      az: ["--version"],
      tfx: ["version", "--no-prompt", "--no-color"]
      // tfx version command with clean output
    };
    const args = versionArgs[binary] || ["--version"];
    const exitCode = await platform.exec(binary, args, {
      silent: true,
      ignoreReturnCode: true
    });
    if (exitCode === 0) {
      return "available";
    }
    return null;
  } catch {
    return null;
  }
}
async function validateBinaryAvailable(binary, platform, logVersion = true) {
  if (!binary || typeof binary !== "string") {
    throw new Error("Binary name is required and must be a string");
  }
  platform.debug(`Checking for required binary: ${binary}`);
  try {
    const binaryPath = await platform.which(binary, true);
    platform.debug(`Found ${binary} at: ${binaryPath}`);
    if (logVersion) {
      const version = await getBinaryVersion(binary, platform);
      if (version) {
        platform.debug(`${binary} version: ${version}`);
      } else {
        platform.debug(`${binary} version: Unable to determine`);
      }
    }
  } catch (error2) {
    const errorMessage = error2 instanceof Error ? error2.message : String(error2);
    throw new Error(`Required binary '${binary}' is not available. Please ensure ${binary} is installed and in your PATH. Error: ${errorMessage}`);
  }
}
async function validateNodeAvailable(platform, logVersion = true) {
  await validateBinaryAvailable("node", platform, logVersion);
}
async function validateNpmAvailable(platform, logVersion = true) {
  await validateBinaryAvailable("npm", platform, logVersion);
}
async function validateTfxAvailable(platform, logVersion = true) {
  await validateBinaryAvailable("tfx", platform, logVersion);
}
async function validateAzureCliAvailable(platform, logVersion = true) {
  await validateBinaryAvailable("az", platform, logVersion);
}

// packages/core/dist/commands/package.js
init_filesystem_manifest_reader();
init_manifest_editor();
async function packageExtension(options2, tfx, platform) {
  platform.info("Packaging extension...");
  const args = new ArgBuilder().arg(["extension", "create"]).flag("--json").flag("--no-color");
  if (options2.rootFolder) {
    args.option("--root", options2.rootFolder);
  }
  if (options2.manifestGlobs && options2.manifestGlobs.length > 0) {
    args.flag("--manifest-globs");
    options2.manifestGlobs.forEach((glob) => args.arg(glob));
  }
  if (options2.overridesFile) {
    args.option("--overrides-file", options2.overridesFile);
  }
  if (options2.publisherId) {
    args.option("--publisher", options2.publisherId);
  }
  const extensionId = options2.extensionId;
  if (extensionId) {
    args.option("--extension-id", extensionId);
  }
  if (options2.extensionName) {
    args.option("--extension-name", options2.extensionName);
  }
  if (options2.extensionVersion) {
    args.option("--extension-version", options2.extensionVersion);
  }
  if (options2.extensionVisibility) {
    args.option("--extension-visibility", options2.extensionVisibility);
  }
  if (options2.outputPath) {
    args.option("--output-path", options2.outputPath);
  }
  if (options2.bypassValidation) {
    args.flag("--bypass-validation");
  }
  if (options2.revVersion) {
    args.flag("--rev-version");
  }
  let cleanupWriter = null;
  if (options2.updateTasksVersion || options2.updateTasksId) {
    platform.info("Updating task manifests before packaging...");
    try {
      const rootFolder = options2.rootFolder || ".";
      const manifestGlobs = options2.manifestGlobs || ["vss-extension.json"];
      const reader = new FilesystemManifestReader({
        rootFolder,
        manifestGlobs,
        platform
      });
      const editor = ManifestEditor.fromReader(reader);
      await editor.applyOptions({
        publisherId: options2.publisherId,
        extensionId: options2.extensionId,
        extensionVersion: options2.extensionVersion,
        extensionName: options2.extensionName,
        extensionVisibility: options2.extensionVisibility,
        updateTasksVersion: options2.updateTasksVersion,
        updateTasksVersionType: options2.updateTasksVersionType,
        updateTasksId: options2.updateTasksId
      });
      const writer = await editor.toWriter();
      await writer.writeToFilesystem();
      const overridesPath = writer.getOverridesPath();
      if (overridesPath) {
        platform.debug(`Using overrides file: ${overridesPath}`);
        args.option("--overrides-file", overridesPath);
      }
      cleanupWriter = async () => {
        await writer.close();
        await reader.close();
      };
      platform.info("Task manifests updated successfully");
    } catch (err) {
      platform.error(`Failed to update task manifests: ${err.message}`);
      throw err;
    }
  }
  try {
    const result2 = await tfx.execute(args.build(), { captureJson: true });
    if (result2.exitCode !== 0) {
      platform.error(`tfx exited with code ${result2.exitCode}`);
      throw new Error(`tfx extension create failed with exit code ${result2.exitCode}`);
    }
    const json = result2.json;
    if (!json || !json.path) {
      throw new Error("tfx did not return expected JSON output with path");
    }
    if (options2.outputVariable) {
      platform.setVariable(options2.outputVariable, json.path, false, true);
    }
    platform.setVariable("Extension.OutputPath", json.path, false, true);
    platform.info(`Packaged extension: ${json.path}`);
    return {
      vsixPath: json.path,
      extensionId: json.id || extensionId || "",
      extensionVersion: json.version || options2.extensionVersion || "",
      publisherId: json.publisher || options2.publisherId || "",
      exitCode: result2.exitCode
    };
  } finally {
    if (cleanupWriter) {
      await cleanupWriter();
    }
  }
}

// packages/core/dist/commands/publish.js
init_manifest_editor();
async function executeTfxPublish(tfx, args, platform, options2) {
  if (options2.shareWith && options2.shareWith.length > 0) {
    const isPublic = options2.extensionVisibility === "public" || options2.extensionVisibility === "public_preview";
    if (isPublic) {
      platform.warning("Ignoring shareWith - not available for public extensions");
    } else {
      args.flag("--share-with");
      options2.shareWith.forEach((org) => args.arg(org));
    }
  }
  if (options2.noWaitValidation) {
    args.flag("--no-wait-validation");
  }
  if (options2.bypassValidation) {
    args.flag("--bypass-validation");
  }
  const result2 = await tfx.execute(args.build(), { captureJson: true });
  if (result2.exitCode !== 0) {
    platform.error(`tfx exited with code ${result2.exitCode}`);
    throw new Error(`tfx extension publish failed with exit code ${result2.exitCode}`);
  }
  const json = result2.json;
  if (!json || !json.published) {
    throw new Error("tfx did not return expected JSON output with published status");
  }
  let vsixPath = "";
  if (options2.publishSource === "manifest") {
    vsixPath = json.packaged || "";
  } else {
    vsixPath = options2.vsixFile || "";
  }
  if (options2.outputVariable && vsixPath) {
    platform.setVariable(options2.outputVariable, vsixPath, false, true);
  }
  platform.info(`Published extension: ${json.id} v${json.version}`);
  return {
    published: json.published === true,
    vsixPath,
    extensionId: json.id || options2.extensionId || "",
    extensionVersion: json.version || options2.extensionVersion || "",
    publisherId: json.publisher || options2.publisherId || "",
    exitCode: result2.exitCode
  };
}
async function publishExtension(options2, auth, tfx, platform) {
  platform.info("Publishing extension...");
  const args = new ArgBuilder().arg(["extension", "publish"]).flag("--json").flag("--no-color").flag("--debug-log-stream").arg("stderr");
  args.option("--service-url", auth.serviceUrl);
  if (auth.authType === "pat") {
    args.option("--auth-type", "pat");
    args.option("--token", auth.token);
    platform.setSecret(auth.token);
  } else if (auth.authType === "basic") {
    args.option("--auth-type", "basic");
    args.option("--username", auth.username);
    args.option("--password", auth.password);
    platform.setSecret(auth.password);
  }
  if (options2.publishSource === "manifest") {
    if (options2.rootFolder) {
      args.option("--root", options2.rootFolder);
    }
    if (options2.manifestGlobs && options2.manifestGlobs.length > 0) {
      args.flag("--manifest-globs");
      options2.manifestGlobs.forEach((glob) => args.arg(glob));
    }
    if (options2.overridesFile) {
      args.option("--overrides-file", options2.overridesFile);
    }
    if (options2.publisherId) {
      args.option("--publisher", options2.publisherId);
    }
    const extensionId = options2.extensionId;
    if (extensionId) {
      args.option("--extension-id", extensionId);
    }
    if (options2.extensionName) {
      args.option("--extension-name", options2.extensionName);
    }
    if (options2.extensionVersion) {
      args.option("--extension-version", options2.extensionVersion);
    }
    if (options2.extensionVisibility) {
      args.option("--extension-visibility", options2.extensionVisibility);
    }
    let cleanupWriter = null;
    if (options2.updateTasksVersion || options2.updateTasksId) {
      platform.info("Updating task manifests before publishing...");
      try {
        const { FilesystemManifestReader: FilesystemManifestReader2 } = await Promise.resolve().then(() => (init_filesystem_manifest_reader(), filesystem_manifest_reader_exports));
        const { ManifestEditor: ManifestEditor2 } = await Promise.resolve().then(() => (init_manifest_editor(), manifest_editor_exports));
        const rootFolder = options2.rootFolder || ".";
        const manifestGlobs = options2.manifestGlobs || ["vss-extension.json"];
        const reader = new FilesystemManifestReader2({
          rootFolder,
          manifestGlobs,
          platform
        });
        const editor = ManifestEditor2.fromReader(reader);
        await editor.applyOptions({
          publisherId: options2.publisherId,
          extensionId: options2.extensionId,
          extensionVersion: options2.extensionVersion,
          extensionName: options2.extensionName,
          extensionVisibility: options2.extensionVisibility,
          updateTasksVersion: options2.updateTasksVersion,
          updateTasksVersionType: options2.updateTasksVersionType,
          updateTasksId: options2.updateTasksId
        });
        const writer = await editor.toWriter();
        await writer.writeToFilesystem();
        const overridesPath = writer.getOverridesPath();
        if (overridesPath) {
          platform.debug(`Using overrides file: ${overridesPath}`);
          args.option("--overrides-file", overridesPath);
        }
        cleanupWriter = async () => {
          await writer.close();
          await reader.close();
        };
        platform.info("Task manifests updated successfully");
      } catch (err) {
        platform.error(`Failed to update task manifests: ${err.message}`);
        throw err;
      }
    }
    try {
      return await executeTfxPublish(tfx, args, platform, options2);
    } finally {
      if (cleanupWriter) {
        await cleanupWriter();
      }
    }
  } else {
    if (!options2.vsixFile) {
      throw new Error('vsixFile is required when publishSource is "vsix"');
    }
    const fileExists = await platform.fileExists(options2.vsixFile);
    if (!fileExists) {
      throw new Error(`VSIX file not found: ${options2.vsixFile}`);
    }
    const needsModification = options2.publisherId || options2.extensionId || options2.extensionVersion || options2.extensionName || options2.extensionVisibility || options2.updateTasksVersion || options2.updateTasksId;
    if (needsModification) {
      platform.info("Modifying VSIX before publishing...");
      const reader = await VsixReader.open(options2.vsixFile);
      const editor = ManifestEditor.fromReader(reader);
      await editor.applyOptions({
        publisherId: options2.publisherId,
        extensionId: options2.extensionId,
        extensionVersion: options2.extensionVersion,
        extensionName: options2.extensionName,
        extensionVisibility: options2.extensionVisibility,
        updateTasksVersion: options2.updateTasksVersion,
        updateTasksVersionType: options2.updateTasksVersionType,
        updateTasksId: options2.updateTasksId
      });
      const writer = await editor.toWriter();
      const tempDir = platform.getTempDir();
      const tempVsixPath = `${tempDir}/temp-${Date.now()}.vsix`;
      platform.debug(`Writing modified VSIX to: ${tempVsixPath}`);
      await writer.writeToFile(tempVsixPath);
      await writer.close();
      await reader.close();
      args.option("--vsix", tempVsixPath);
      platform.info("VSIX modifications applied successfully");
    } else {
      args.option("--vsix", options2.vsixFile);
    }
  }
  return executeTfxPublish(tfx, args, platform, options2);
}

// packages/core/dist/commands/unpublish.js
async function unpublishExtension(options2, auth, tfx, platform) {
  platform.info(`Unpublishing extension ${options2.publisherId}.${options2.extensionId}...`);
  const extensionId = options2.extensionId;
  const args = new ArgBuilder().arg(["extension", "unpublish"]).flag("--json").flag("--no-color").option("--publisher", options2.publisherId).option("--extension-id", extensionId);
  args.option("--service-url", auth.serviceUrl);
  if (auth.authType === "pat") {
    args.option("--auth-type", "pat");
    args.option("--token", auth.token);
    platform.setSecret(auth.token);
  } else if (auth.authType === "basic") {
    args.option("--auth-type", "basic");
    args.option("--username", auth.username);
    args.option("--password", auth.password);
    platform.setSecret(auth.password);
  }
  const result2 = await tfx.execute(args.build(), { captureJson: true });
  if (result2.exitCode !== 0) {
    platform.error(`tfx exited with code ${result2.exitCode}`);
    throw new Error(`tfx extension unpublish failed with exit code ${result2.exitCode}`);
  }
  platform.info(`Successfully unpublished extension: ${options2.publisherId}.${extensionId}`);
  return {
    success: true,
    extensionId,
    publisherId: options2.publisherId,
    exitCode: result2.exitCode
  };
}

// packages/core/dist/commands/share.js
async function shareExtension(options2, auth, tfx, platform) {
  if (!options2.shareWith || options2.shareWith.length === 0) {
    throw new Error("shareWith must contain at least one organization");
  }
  platform.info(`Sharing extension ${options2.publisherId}.${options2.extensionId} with ${options2.shareWith.length} organization(s)...`);
  const extensionId = options2.extensionId;
  const args = new ArgBuilder().arg(["extension", "share"]).flag("--json").flag("--no-color").option("--publisher", options2.publisherId).option("--extension-id", extensionId).flag("--share-with");
  options2.shareWith.forEach((org) => args.arg(org));
  args.option("--service-url", auth.serviceUrl);
  if (auth.authType === "pat") {
    args.option("--auth-type", "pat");
    args.option("--token", auth.token);
    platform.setSecret(auth.token);
  } else if (auth.authType === "basic") {
    args.option("--auth-type", "basic");
    args.option("--username", auth.username);
    args.option("--password", auth.password);
    platform.setSecret(auth.password);
  }
  const result2 = await tfx.execute(args.build(), { captureJson: true });
  if (result2.exitCode !== 0) {
    platform.error(`tfx exited with code ${result2.exitCode}`);
    throw new Error(`tfx extension share failed with exit code ${result2.exitCode}`);
  }
  platform.info(`Successfully shared extension with: ${options2.shareWith.join(", ")}`);
  return {
    success: true,
    extensionId,
    publisherId: options2.publisherId,
    sharedWith: options2.shareWith,
    exitCode: result2.exitCode
  };
}

// packages/core/dist/commands/unshare.js
async function unshareExtension(options2, auth, tfx, platform) {
  if (!options2.unshareWith || options2.unshareWith.length === 0) {
    throw new Error("unshareWith must contain at least one organization");
  }
  platform.info(`Unsharing extension ${options2.publisherId}.${options2.extensionId} from ${options2.unshareWith.length} organization(s)...`);
  const extensionId = options2.extensionId;
  const args = new ArgBuilder().arg(["extension", "unshare"]).flag("--json").flag("--no-color").option("--publisher", options2.publisherId).option("--extension-id", extensionId).flag("--unshare-with");
  options2.unshareWith.forEach((org) => args.arg(org));
  args.option("--service-url", auth.serviceUrl);
  if (auth.authType === "pat") {
    args.option("--auth-type", "pat");
    args.option("--token", auth.token);
    platform.setSecret(auth.token);
  } else if (auth.authType === "basic") {
    args.option("--auth-type", "basic");
    args.option("--username", auth.username);
    args.option("--password", auth.password);
    platform.setSecret(auth.password);
  }
  const result2 = await tfx.execute(args.build(), { captureJson: true });
  if (result2.exitCode !== 0) {
    platform.error(`tfx exited with code ${result2.exitCode}`);
    throw new Error(`tfx extension unshare failed with exit code ${result2.exitCode}`);
  }
  platform.info(`Successfully unshared extension from: ${options2.unshareWith.join(", ")}`);
  return {
    success: true,
    extensionId,
    publisherId: options2.publisherId,
    unsharedFrom: options2.unshareWith,
    exitCode: result2.exitCode
  };
}

// packages/core/dist/commands/install.js
async function installExtension(options2, auth, tfx, platform) {
  if (!options2.accounts || options2.accounts.length === 0) {
    throw new Error("accounts must contain at least one organization URL");
  }
  platform.info(`Installing extension ${options2.publisherId}.${options2.extensionId} to ${options2.accounts.length} organization(s)...`);
  const extensionId = options2.extensionId;
  const accountResults = [];
  let overallExitCode = 0;
  for (const account of options2.accounts) {
    platform.info(`Installing to ${account}...`);
    const args = new ArgBuilder().arg(["extension", "install"]).flag("--json").flag("--no-color").option("--publisher", options2.publisherId).option("--extension-id", extensionId).option("--service-url", account);
    if (options2.extensionVersion) {
      args.option("--extension-version", options2.extensionVersion);
    }
    args.option("--auth-type", auth.authType);
    if (auth.authType === "pat") {
      args.option("--token", auth.token);
      platform.setSecret(auth.token);
    } else if (auth.authType === "basic") {
      args.option("--username", auth.username);
      args.option("--password", auth.password);
      platform.setSecret(auth.password);
    }
    try {
      const result2 = await tfx.execute(args.build(), { captureJson: true });
      if (result2.exitCode === 0) {
        accountResults.push({
          account,
          success: true,
          alreadyInstalled: false
        });
        platform.info(`\u2713 Successfully installed to ${account}`);
      } else {
        const stderr = result2.stderr || "";
        const alreadyInstalled = stderr.includes("TF1590010");
        if (alreadyInstalled) {
          accountResults.push({
            account,
            success: true,
            alreadyInstalled: true
          });
          platform.warning(`Extension already installed in ${account} - continuing`);
        } else {
          accountResults.push({
            account,
            success: false,
            alreadyInstalled: false,
            error: `Exit code ${result2.exitCode}`
          });
          platform.error(`\u2717 Failed to install to ${account}: exit code ${result2.exitCode}`);
          overallExitCode = result2.exitCode;
        }
      }
    } catch (err) {
      accountResults.push({
        account,
        success: false,
        alreadyInstalled: false,
        error: String(err)
      });
      platform.error(`\u2717 Failed to install to ${account}: ${err}`);
      overallExitCode = 1;
    }
  }
  const allSuccess = accountResults.every((r) => r.success);
  const successCount = accountResults.filter((r) => r.success).length;
  platform.info(`Installation complete: ${successCount}/${options2.accounts.length} succeeded`);
  return {
    extensionId,
    publisherId: options2.publisherId,
    accountResults,
    allSuccess,
    exitCode: overallExitCode
  };
}

// packages/core/dist/commands/show.js
async function showExtension(options2, auth, tfx, platform) {
  platform.info(`Querying extension ${options2.publisherId}.${options2.extensionId}...`);
  const extensionId = options2.extensionId;
  const args = new ArgBuilder().arg(["extension", "show"]).flag("--json").flag("--no-color").option("--publisher", options2.publisherId).option("--extension-id", extensionId);
  args.option("--service-url", auth.serviceUrl);
  if (auth.authType === "pat") {
    args.option("--auth-type", "pat");
    args.option("--token", auth.token);
    platform.setSecret(auth.token);
  } else if (auth.authType === "basic") {
    args.option("--auth-type", "basic");
    args.option("--username", auth.username);
    args.option("--password", auth.password);
    platform.setSecret(auth.password);
  }
  const result2 = await tfx.execute(args.build(), { captureJson: true });
  if (result2.exitCode !== 0) {
    platform.error(`tfx exited with code ${result2.exitCode}`);
    throw new Error(`tfx extension show failed with exit code ${result2.exitCode}`);
  }
  const json = result2.json;
  if (!json) {
    throw new Error("tfx did not return expected JSON output");
  }
  const metadata = {
    id: json.extensionId || json.id || extensionId,
    publisher: json.publisher || options2.publisherId,
    version: json.version || json.versions?.[0]?.version || "",
    name: json.extensionName || json.displayName || json.name,
    description: json.shortDescription || json.description,
    categories: json.categories,
    tags: json.tags,
    ...json
    // Include all other fields
  };
  if (options2.outputVariable) {
    platform.setVariable(options2.outputVariable, JSON.stringify(metadata), false, true);
  }
  platform.info(`Extension: ${metadata.name || metadata.id} v${metadata.version}`);
  if (metadata.description) {
    platform.info(`Description: ${metadata.description}`);
  }
  return {
    metadata,
    exitCode: result2.exitCode
  };
}

// packages/core/dist/commands/query-version.js
function applyVersionAction(version, versionAction) {
  if (versionAction === "None") {
    return version;
  }
  const versionParts = version.split(".").map((part) => Number.parseInt(part, 10));
  if (versionParts.length !== 3 || Number.isNaN(versionParts[0]) || Number.isNaN(versionParts[1]) || Number.isNaN(versionParts[2])) {
    throw new Error(`Version '${version}' is not a valid semantic version (major.minor.patch)`);
  }
  switch (versionAction) {
    case "Major":
      return `${versionParts[0] + 1}.0.0`;
    case "Minor":
      return `${versionParts[0]}.${versionParts[1] + 1}.0`;
    case "Patch":
      return `${versionParts[0]}.${versionParts[1]}.${versionParts[2] + 1}`;
    default:
      return version;
  }
}
async function queryVersion(options2, auth, tfx, platform) {
  const versionAction = options2.versionAction ?? "None";
  if (options2.extensionVersionOverrideVariable) {
    platform.debug(`Override variable '${options2.extensionVersionOverrideVariable}' specified, checking for value.`);
    const overrideVersion = platform.getVariable(options2.extensionVersionOverrideVariable);
    if (overrideVersion) {
      platform.info(`Ignoring marketplace version and using supplied override: ${overrideVersion}.`);
      platform.setVariable("Extension.Version", overrideVersion, false, false);
      platform.setVariable("Extension.Version", overrideVersion, false, true);
      if (options2.outputVariable) {
        platform.setVariable(options2.outputVariable, overrideVersion, false, true);
      }
      return {
        currentVersion: overrideVersion,
        proposedVersion: overrideVersion,
        version: overrideVersion,
        source: "override"
      };
    }
  }
  const showResult = await showExtension({
    publisherId: options2.publisherId,
    extensionId: options2.extensionId
  }, auth, tfx, platform);
  const marketplaceVersion = showResult.metadata.version;
  if (!marketplaceVersion) {
    throw new Error("Could not determine extension version from marketplace response");
  }
  platform.info(`Latest version   : ${marketplaceVersion}.`);
  platform.info(`Requested action : ${versionAction}.`);
  const updatedVersion = applyVersionAction(marketplaceVersion, versionAction);
  if (updatedVersion !== marketplaceVersion) {
    platform.info(`Updated to       : ${updatedVersion}.`);
  }
  platform.setVariable("Extension.Version", updatedVersion, false, false);
  platform.setVariable("Extension.Version", updatedVersion, false, true);
  if (options2.outputVariable) {
    platform.setVariable(options2.outputVariable, updatedVersion, false, true);
  }
  return {
    currentVersion: marketplaceVersion,
    proposedVersion: updatedVersion,
    version: updatedVersion,
    source: "marketplace"
  };
}

// packages/core/dist/commands/wait-for-validation.js
async function waitForValidation(options2, auth, tfx, platform) {
  platform.info(`Validating extension ${options2.publisherId}.${options2.extensionId}...`);
  const extensionId = options2.extensionId;
  const maxRetries = options2.maxRetries ?? 10;
  const minTimeoutMs = (options2.minTimeout ?? 1) * 60 * 1e3;
  const maxTimeoutMs = (options2.maxTimeout ?? 15) * 60 * 1e3;
  let attempts = 0;
  let lastStatus = "pending";
  let lastExitCode = 0;
  while (attempts < maxRetries) {
    attempts++;
    platform.info(`Validation attempt ${attempts}/${maxRetries}...`);
    const args = new ArgBuilder().arg(["extension", "isvalid"]).flag("--json").flag("--no-color").option("--publisher", options2.publisherId).option("--extension-id", extensionId);
    if (options2.rootFolder) {
      args.option("--root", options2.rootFolder);
    }
    if (options2.manifestGlobs && options2.manifestGlobs.length > 0) {
      args.flag("--manifest-globs");
      options2.manifestGlobs.forEach((glob) => args.arg(glob));
    }
    args.option("--service-url", auth.serviceUrl);
    if (auth.authType === "pat") {
      args.option("--auth-type", "pat");
      args.option("--token", auth.token);
      platform.setSecret(auth.token);
    } else if (auth.authType === "basic") {
      args.option("--auth-type", "basic");
      args.option("--username", auth.username);
      args.option("--password", auth.password);
      platform.setSecret(auth.password);
    }
    try {
      const result2 = await tfx.execute(args.build(), { captureJson: true });
      lastExitCode = result2.exitCode;
      const json = result2.json;
      if (json && json.status) {
        lastStatus = json.status;
        switch (lastStatus) {
          case "success":
            platform.info("\u2713 Extension validation succeeded");
            return {
              status: lastStatus,
              isValid: true,
              extensionId,
              publisherId: options2.publisherId,
              attempts,
              exitCode: result2.exitCode
            };
          case "pending":
            platform.info("\u23F3 Validation pending, retrying...");
            if (attempts < maxRetries) {
              const waitTime = Math.min(minTimeoutMs * Math.pow(2, attempts - 1), maxTimeoutMs);
              platform.debug(`Waiting ${waitTime / 1e3}s before retry...`);
              await sleep(waitTime);
            }
            break;
          case "failed":
          case "error":
            platform.error(`\u2717 Extension validation failed: ${lastStatus}`);
            return {
              status: lastStatus,
              isValid: false,
              extensionId,
              publisherId: options2.publisherId,
              attempts,
              exitCode: result2.exitCode
            };
          default:
            platform.warning(`Unknown validation status: ${lastStatus}`);
            break;
        }
      } else {
        platform.warning("No status in validation response");
      }
    } catch (err) {
      platform.error(`Validation attempt ${attempts} failed: ${err}`);
      if (attempts >= maxRetries) {
        throw err;
      }
      await sleep(minTimeoutMs);
    }
  }
  platform.error(`\u2717 Extension validation timed out after ${attempts} attempts (status: ${lastStatus})`);
  return {
    status: lastStatus,
    isValid: false,
    extensionId,
    publisherId: options2.publisherId,
    attempts,
    exitCode: lastExitCode
  };
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// packages/core/dist/commands/wait-for-installation.js
var import_azure_devops_node_api = __toESM(require_WebApi(), 1);
async function resolveExpectedTasks(options2, platform) {
  if (options2.expectedTasks && options2.expectedTasks.length > 0) {
    platform.debug(`Using ${options2.expectedTasks.length} expected tasks from options`);
    return options2.expectedTasks;
  }
  if (options2.manifestPath) {
    try {
      platform.debug(`Reading task versions from manifest: ${options2.manifestPath}`);
      const manifest = await readManifest(options2.manifestPath, platform);
      const taskPaths = resolveTaskManifestPaths(manifest, options2.manifestPath, platform);
      const tasks = [];
      for (const taskPath of taskPaths) {
        try {
          const taskManifest = await readManifest(taskPath, platform);
          if (taskManifest.name && taskManifest.version) {
            const version = `${taskManifest.version.Major}.${taskManifest.version.Minor}.${taskManifest.version.Patch}`;
            tasks.push({
              name: taskManifest.name,
              versions: [version]
            });
            platform.debug(`Found task ${taskManifest.name} v${version}`);
          }
        } catch (error2) {
          platform.warning(`Failed to read task manifest ${taskPath}: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
      if (tasks.length > 0) {
        platform.debug(`Resolved ${tasks.length} tasks from manifest`);
        return tasks;
      }
    } catch (error2) {
      platform.warning(`Failed to read manifest ${options2.manifestPath}: ${error2 instanceof Error ? error2.message : String(error2)}`);
    }
  }
  if (options2.vsixPath) {
    try {
      platform.debug(`Reading task versions from VSIX: ${options2.vsixPath}`);
      const reader = await VsixReader.open(options2.vsixPath);
      try {
        const tasksInfo = await reader.getTasksInfo();
        const tasks = tasksInfo.map((task) => ({
          name: task.name,
          versions: [task.version]
        }));
        platform.debug(`Resolved ${tasks.length} tasks from VSIX`);
        return tasks;
      } finally {
        await reader.close();
      }
    } catch (error2) {
      platform.warning(`Failed to read VSIX ${options2.vsixPath}: ${error2 instanceof Error ? error2.message : String(error2)}`);
    }
  }
  return [];
}
async function waitForInstallation(options2, auth, platform) {
  const fullExtensionId = options2.extensionId;
  const timeoutMs = (options2.timeoutMinutes ?? 10) * 6e4;
  const pollingIntervalMs = (options2.pollingIntervalSeconds ?? 30) * 1e3;
  platform.debug(`Verifying installation of ${options2.publisherId}.${fullExtensionId} in ${options2.accounts.length} account(s)`);
  const expectedTasks = await resolveExpectedTasks(options2, platform);
  const accountResults = [];
  for (const accountUrl of options2.accounts) {
    platform.debug(`Checking account: ${accountUrl}`);
    platform.info(`Polling for task availability (timeout: ${options2.timeoutMinutes ?? 10} minutes, interval: ${options2.pollingIntervalSeconds ?? 30} seconds)`);
    try {
      if (!auth.token) {
        throw new Error("PAT token is required for waitForInstallation command");
      }
      const handler = (0, import_azure_devops_node_api.getPersonalAccessTokenHandler)(auth.token);
      const connection = new import_azure_devops_node_api.WebApi(accountUrl, handler);
      const taskAgentApi = await connection.getTaskAgentApi();
      const deadline = Date.now() + timeoutMs;
      let lastError;
      let found = false;
      let finalInstalledTasks = [];
      let finalMissingTasks = [];
      let finalMissingVersions = [];
      let pollCount = 0;
      while (Date.now() < deadline && !found) {
        pollCount++;
        const remainingMs = deadline - Date.now();
        const remainingMinutes = Math.ceil(remainingMs / 6e4);
        platform.debug(`Poll attempt ${pollCount} (${remainingMinutes} minute(s) remaining)`);
        try {
          const taskDefinitions = await taskAgentApi.getTaskDefinitions();
          const installedTasks = [];
          const missingTasks = [];
          const missingVersions = [];
          if (expectedTasks.length > 0) {
            for (const expectedTask of expectedTasks) {
              const installedTaskVersions = taskDefinitions.filter((t) => t.name?.toLowerCase() === expectedTask.name.toLowerCase() && t.id && t.version);
              if (installedTaskVersions.length === 0) {
                missingTasks.push(expectedTask.name);
                for (const ver of expectedTask.versions) {
                  missingVersions.push(`${expectedTask.name}@${ver}`);
                }
                continue;
              }
              for (const installedTask of installedTaskVersions) {
                const installedVersion = `${installedTask.version.major}.${installedTask.version.minor}.${installedTask.version.patch}`;
                const matchesExpected = expectedTask.versions.includes(installedVersion);
                installedTasks.push({
                  name: installedTask.name,
                  id: installedTask.id,
                  version: installedVersion,
                  friendlyName: installedTask.friendlyName || installedTask.name,
                  matchesExpected
                });
              }
              const installedVersionStrings = installedTaskVersions.map((t) => `${t.version.major}.${t.version.minor}.${t.version.patch}`);
              for (const expectedVer of expectedTask.versions) {
                if (!installedVersionStrings.includes(expectedVer)) {
                  missingVersions.push(`${expectedTask.name}@${expectedVer}`);
                  platform.debug(`Missing version ${expectedVer} for task ${expectedTask.name}`);
                }
              }
            }
            if (missingTasks.length === 0 && missingVersions.length === 0) {
              found = true;
              finalInstalledTasks = installedTasks;
              finalMissingTasks = missingTasks;
              finalMissingVersions = missingVersions;
              const uniqueTasks = new Set(expectedTasks.map((t) => t.name));
              const totalExpectedVersions = expectedTasks.reduce((sum, t) => {
                return sum + t.versions.length;
              }, 0);
              platform.info(`\u2713 All ${uniqueTasks.size} expected task(s) with ${totalExpectedVersions} version(s) found in ${accountUrl}`);
            } else if (missingTasks.length > 0) {
              platform.debug(`Missing ${missingTasks.length} task(s): ${missingTasks.join(", ")}`);
            } else if (missingVersions.length > 0) {
              platform.debug(`Missing ${missingVersions.length} version(s): ${missingVersions.join(", ")}`);
            }
          } else {
            for (const task of taskDefinitions) {
              if (task.name && task.id && task.version) {
                installedTasks.push({
                  name: task.name,
                  id: task.id,
                  version: `${task.version.major}.${task.version.minor}.${task.version.patch}`,
                  friendlyName: task.friendlyName || task.name,
                  matchesExpected: true
                  // No expectations, so all match
                });
              }
            }
            if (installedTasks.length > 0) {
              found = true;
              finalInstalledTasks = installedTasks;
              finalMissingTasks = missingTasks;
              finalMissingVersions = missingVersions;
              platform.info(`\u2713 Found ${installedTasks.length} task(s) from extension in ${accountUrl}`);
            }
          }
          if (!found && Date.now() < deadline) {
            platform.debug(`Waiting ${pollingIntervalMs / 1e3}s before next poll...`);
            await new Promise((resolve) => setTimeout(resolve, pollingIntervalMs));
          }
        } catch (error2) {
          lastError = error2 instanceof Error ? error2 : new Error(String(error2));
          platform.debug(`Error polling for tasks: ${lastError.message}. Retrying...`);
          if (Date.now() < deadline) {
            await new Promise((resolve) => setTimeout(resolve, pollingIntervalMs));
          }
        }
      }
      if (found) {
        accountResults.push({
          accountUrl,
          available: true,
          installedTasks: finalInstalledTasks,
          missingTasks: finalMissingTasks,
          missingVersions: finalMissingVersions
        });
      } else {
        const errorMsg = lastError ? `Timeout waiting for tasks. Last error: ${lastError.message}` : `Timeout waiting for tasks after ${options2.timeoutMinutes ?? 10} minutes`;
        platform.warning(errorMsg);
        const allMissingVersions = [];
        for (const task of expectedTasks) {
          for (const ver of task.versions) {
            allMissingVersions.push(`${task.name}@${ver}`);
          }
        }
        accountResults.push({
          accountUrl,
          available: false,
          installedTasks: [],
          missingTasks: expectedTasks.map((t) => t.name),
          missingVersions: allMissingVersions,
          error: errorMsg
        });
      }
    } catch (error2) {
      const errorMsg = error2 instanceof Error ? error2.message : String(error2);
      platform.error(`Failed to verify installation in ${accountUrl}: ${errorMsg}`);
      const allMissingVersions = [];
      for (const task of expectedTasks) {
        for (const ver of task.versions) {
          allMissingVersions.push(`${task.name}@${ver}`);
        }
      }
      accountResults.push({
        accountUrl,
        available: false,
        installedTasks: [],
        missingTasks: expectedTasks.map((t) => t.name),
        missingVersions: allMissingVersions,
        error: errorMsg
      });
    }
  }
  const allTasksAvailable = accountResults.every((r) => r.available && r.missingVersions.length === 0);
  if (allTasksAvailable) {
    platform.info(`\u2705 All tasks verified successfully across ${options2.accounts.length} account(s)`);
  } else {
    const failedAccounts = accountResults.filter((r) => !r.available);
    const missingVersionAccounts = accountResults.filter((r) => r.available && r.missingVersions.length > 0);
    if (failedAccounts.length > 0) {
      platform.warning(`\u274C Failed to verify tasks in ${failedAccounts.length} account(s)`);
    }
    if (missingVersionAccounts.length > 0) {
      platform.warning(`\u26A0\uFE0F Missing versions found in ${missingVersionAccounts.length} account(s)`);
    }
  }
  return {
    success: allTasksAvailable,
    accountResults,
    allTasksAvailable
  };
}

// packages/github-action/src/github-adapter.ts
var import_fs2 = require("fs");
var os2 = __toESM(require("os"), 1);
var import_path6 = __toESM(require("path"), 1);
var GitHubAdapter = class {
  // ===== Input =====
  getInput(name, required) {
    const value = core4.getInput(name, { required: required || false });
    return value || void 0;
  }
  getBoolInput(name, required) {
    return core4.getBooleanInput(name, { required: required || false });
  }
  getDelimitedInput(name, delimiter, required) {
    const value = core4.getInput(name, { required: required || false });
    if (!value) return [];
    return value.split(delimiter).map((v) => v.trim()).filter((v) => v);
  }
  // ===== Output =====
  setOutput(name, value) {
    core4.setOutput(name, value);
  }
  setResult(result2, message) {
    if (result2 === TaskResult.Succeeded) {
      core4.info(`\u2705 ${message}`);
    } else if (result2 === TaskResult.Failed) {
      core4.setFailed(message);
    } else {
      core4.warning(message);
    }
  }
  setVariable(name, value, isSecret, isOutput) {
    if (isSecret) {
      core4.setSecret(value);
    }
    if (isOutput) {
      core4.setOutput(name, value);
    } else {
      core4.exportVariable(name, value);
    }
  }
  setSecret(value) {
    core4.setSecret(value);
  }
  // ===== Logging =====
  debug(message) {
    core4.debug(message);
  }
  info(message) {
    core4.info(message);
  }
  warning(message) {
    core4.warning(message);
  }
  error(message) {
    core4.error(message);
  }
  // ===== Execution =====
  async which(tool, check) {
    const result2 = await io.which(tool, check);
    return result2;
  }
  async exec(tool, args, options2) {
    let stderr = "";
    const listeners = {
      stdout: (data) => {
        const str = data.toString();
        if (options2?.outStream) {
          options2.outStream.write(str);
        }
      },
      stderr: (data) => {
        const str = data.toString();
        stderr += str;
        if (options2?.errStream) {
          options2.errStream.write(str);
        }
      }
    };
    const exitCode = await exec.exec(tool, args, {
      cwd: options2?.cwd,
      env: options2?.env,
      silent: options2?.silent,
      ignoreReturnCode: options2?.ignoreReturnCode,
      listeners
    });
    if (options2?.failOnStdErr && stderr) {
      throw new Error(`Command failed with stderr: ${stderr}`);
    }
    return exitCode;
  }
  // ===== Filesystem =====
  async findMatch(root2, patterns) {
    const normalizedPatterns = patterns.map((pattern) => pattern.trim()).filter((pattern) => pattern.length > 0).map((pattern) => {
      const isExclude = pattern.startsWith("!");
      const value = isExclude ? pattern.slice(1) : pattern;
      const rootedPattern = import_path6.default.isAbsolute(value) ? value : import_path6.default.join(root2, value);
      const normalized = rootedPattern.replace(/\\/g, "/");
      return isExclude ? `!${normalized}` : normalized;
    });
    if (normalizedPatterns.length === 0) {
      return [];
    }
    const globber = await create(normalizedPatterns.join("\n"));
    const matches = await globber.glob();
    return Array.from(new Set(matches.map((match2) => import_path6.default.resolve(match2))));
  }
  async fileExists(filePath) {
    try {
      await import_fs2.promises.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
  async readFile(filePath) {
    return import_fs2.promises.readFile(filePath, "utf-8");
  }
  async writeFile(filePath, content) {
    await import_fs2.promises.writeFile(filePath, content, "utf-8");
  }
  async mkdirP(dirPath) {
    await io.mkdirP(dirPath);
  }
  async rmRF(dirPath) {
    await io.rmRF(dirPath);
  }
  // ===== Environment =====
  getVariable(name) {
    return process.env[name];
  }
  getTempDir() {
    return process.env.RUNNER_TEMP || os2.tmpdir();
  }
  // ===== Tool Management =====
  async cacheDir(sourceDir, tool, version) {
    return tc.cacheDir(sourceDir, tool, version);
  }
  findCachedTool(tool, version) {
    const found = tc.find(tool, version);
    return found || void 0;
  }
  async downloadTool(url) {
    return tc.downloadTool(url);
  }
};

// packages/github-action/src/auth/pat-auth.ts
async function getPatAuth(token, serviceUrl, platform) {
  if (!token) {
    throw new Error("PAT token is required");
  }
  platform.setSecret(token);
  const finalServiceUrl = serviceUrl || "https://marketplace.visualstudio.com";
  return {
    authType: "pat",
    serviceUrl: finalServiceUrl,
    token
  };
}

// packages/github-action/src/auth/basic-auth.ts
async function getBasicAuth(username, password, serviceUrl, platform) {
  if (!username) {
    throw new Error("Username is required for basic authentication");
  }
  if (password === void 0 || password === null) {
    throw new Error("Password is required for basic authentication");
  }
  platform.setSecret(password);
  const finalServiceUrl = serviceUrl || "https://marketplace.visualstudio.com";
  return {
    authType: "basic",
    serviceUrl: finalServiceUrl,
    username,
    password
  };
}

// packages/github-action/src/auth/oidc-auth.ts
var core5 = __toESM(require("@actions/core"), 1);
var exec3 = __toESM(require("@actions/exec"), 1);
async function getOidcAuth(serviceUrl, platform) {
  const tokenResource = serviceUrl || "https://marketplace.visualstudio.com";
  const finalServiceUrl = serviceUrl || "https://marketplace.visualstudio.com";
  core5.info("Getting Azure AD token via Azure CLI (requires azure/login action)...");
  try {
    let output = "";
    let errorOutput = "";
    const exitCode = await exec3.exec(
      "az",
      ["account", "get-access-token", "--resource", tokenResource, "--output", "json"],
      {
        silent: true,
        listeners: {
          stdout: (data) => {
            output += data.toString();
          },
          stderr: (data) => {
            errorOutput += data.toString();
          }
        }
      }
    );
    if (exitCode !== 0) {
      throw new Error(`Azure CLI exited with code ${exitCode}: ${errorOutput}`);
    }
    const result2 = JSON.parse(output);
    const token = result2.accessToken;
    if (!token) {
      throw new Error("No accessToken in Azure CLI response");
    }
    core5.setSecret(token);
    platform.setSecret(token);
    core5.info("Successfully obtained Azure AD token via Azure CLI");
    return {
      authType: "pat",
      // Use 'pat' type as the token format is similar
      serviceUrl: finalServiceUrl,
      token
    };
  } catch (error2) {
    const message = error2 instanceof Error ? error2.message : String(error2);
    throw new Error(
      `Failed to get Azure AD token via Azure CLI: ${message}

Make sure you have run the azure/login action before this action:
  - uses: azure/login@v2
    with:
      client-id: \${{ secrets.AZURE_CLIENT_ID }}
      tenant-id: \${{ secrets.AZURE_TENANT_ID }}
      subscription-id: \${{ secrets.AZURE_SUBSCRIPTION_ID }}

See: https://jessehouwing.net/authenticate-connect-mggraph-using-oidc-in-github-actions/`
    );
  }
}

// packages/github-action/src/auth/index.ts
async function getAuth(authType, platform, options2) {
  const finalServiceUrl = options2.serviceUrl || options2.marketplaceUrl;
  switch (authType) {
    case "pat":
      if (!options2.token) {
        throw new Error("Token is required for PAT authentication");
      }
      return getPatAuth(options2.token, finalServiceUrl, platform);
    case "basic":
      if (!options2.username || !options2.password) {
        throw new Error("Username and password are required for basic authentication");
      }
      return getBasicAuth(options2.username, options2.password, finalServiceUrl, platform);
    case "oidc":
      return getOidcAuth(finalServiceUrl, platform);
    default:
      throw new Error(`Unsupported auth type: ${authType}`);
  }
}

// packages/github-action/src/main.ts
async function run() {
  try {
    const platform = new GitHubAdapter();
    await validateNodeAvailable(platform);
    const operation = platform.getInput("operation", true);
    if (!operation) {
      throw new Error("Operation is required");
    }
    platform.debug(`Starting operation: ${operation}`);
    const publisherId = platform.getInput("publisher-id");
    if (publisherId) {
      validatePublisherId(publisherId);
    }
    const extensionId = platform.getInput("extension-id");
    if (extensionId) {
      validateExtensionId(extensionId);
    }
    const extensionVersion = platform.getInput("extension-version");
    if (extensionVersion) {
      validateVersion(extensionVersion);
    }
    const tfxVersion = platform.getInput("tfx-version") || "built-in";
    if (tfxVersion === "path") {
      await validateTfxAvailable(platform);
    } else if (tfxVersion !== "built-in") {
      await validateNpmAvailable(platform);
    }
    const tfxManager = new TfxManager({ tfxVersion, platform });
    let auth;
    if (operation !== "package") {
      const authType = platform.getInput("auth-type") || "pat";
      if (authType === "oidc") {
        await validateAzureCliAvailable(platform);
      }
      const token = platform.getInput("token");
      const username = platform.getInput("username");
      const password = platform.getInput("password");
      const serviceUrl = platform.getInput("service-url");
      const marketplaceUrl = platform.getInput("marketplace-url");
      auth = await getAuth(authType, platform, {
        token,
        username,
        password,
        serviceUrl,
        marketplaceUrl
      });
      if (auth.token) {
        platform.setSecret(auth.token);
      }
      if (auth.password) {
        platform.setSecret(auth.password);
      }
      if (auth.serviceUrl) {
        validateAccountUrl(auth.serviceUrl);
      }
    }
    if (operation === "install" || operation === "wait-for-installation") {
      const accounts = platform.getDelimitedInput("accounts", ";", false);
      accounts.forEach((account) => {
        if (account) {
          validateAccountUrl(account);
        }
      });
    }
    switch (operation) {
      case "package":
        await runPackage(platform, tfxManager);
        break;
      case "publish":
        await runPublish(platform, tfxManager, auth);
        break;
      case "unpublish":
        await runUnpublish(platform, tfxManager, auth);
        break;
      case "share":
        await runShare(platform, tfxManager, auth);
        break;
      case "unshare":
        await runUnshare(platform, tfxManager, auth);
        break;
      case "install":
        await runInstall(platform, tfxManager, auth);
        break;
      case "show":
        await runShow(platform, tfxManager, auth);
        break;
      case "query-version":
        await runQueryVersion(platform, tfxManager, auth);
        break;
      case "wait-for-validation":
        await runWaitForValidation(platform, tfxManager, auth);
        break;
      case "wait-for-installation":
        await runWaitForInstallation(platform, auth);
        break;
      default:
        throw new Error(`Unknown operation: ${operation}`);
    }
    platform.info("\u2705 Operation completed successfully");
    platform.setResult(TaskResult.Succeeded, `${operation} completed successfully`);
  } catch (error2) {
    const message = error2 instanceof Error ? error2.message : String(error2);
    core6.setFailed(message);
  }
}
async function runPackage(platform, tfxManager) {
  const options2 = {
    rootFolder: platform.getInput("root-folder"),
    manifestGlobs: platform.getDelimitedInput("manifest-globs", "\n"),
    publisherId: platform.getInput("publisher-id"),
    extensionId: platform.getInput("extension-id"),
    extensionVersion: platform.getInput("extension-version"),
    extensionName: platform.getInput("extension-name"),
    outputPath: platform.getInput("output-path"),
    outputVariable: platform.getInput("output-variable"),
    bypassValidation: platform.getBoolInput("bypass-validation"),
    revVersion: platform.getBoolInput("rev-version")
  };
  const result2 = await packageExtension(options2, tfxManager, platform);
  if (options2.outputVariable && result2.vsixPath) {
    platform.setOutput(options2.outputVariable, result2.vsixPath);
  }
}
async function runPublish(platform, tfxManager, auth) {
  const publishSource = platform.getInput("publish-source", true);
  const result2 = await publishExtension(
    {
      publishSource,
      vsixFile: publishSource === "vsix" ? platform.getInput("vsix-file", true) : void 0,
      manifestGlobs: publishSource === "manifest" ? platform.getDelimitedInput("manifest-globs", "\n", true) : void 0,
      rootFolder: publishSource === "manifest" ? platform.getInput("root-folder") : void 0,
      publisherId: platform.getInput("publisher-id"),
      extensionId: platform.getInput("extension-id"),
      extensionVersion: platform.getInput("extension-version"),
      extensionName: platform.getInput("extension-name"),
      extensionVisibility: platform.getInput("extension-visibility"),
      shareWith: platform.getDelimitedInput("share-with", "\n"),
      noWaitValidation: platform.getBoolInput("no-wait-validation"),
      bypassValidation: platform.getBoolInput("bypass-validation"),
      updateTasksVersion: platform.getBoolInput("update-tasks-version"),
      updateTasksId: platform.getBoolInput("update-tasks-id")
    },
    auth,
    tfxManager,
    platform
  );
  platform.debug(`Published: ${JSON.stringify(result2)}`);
}
async function runUnpublish(platform, tfxManager, auth) {
  await unpublishExtension(
    {
      publisherId: platform.getInput("publisher-id", true),
      extensionId: platform.getInput("extension-id", true)
    },
    auth,
    tfxManager,
    platform
  );
}
async function runShare(platform, tfxManager, auth) {
  await shareExtension(
    {
      publisherId: platform.getInput("publisher-id", true),
      extensionId: platform.getInput("extension-id", true),
      shareWith: platform.getDelimitedInput("share-with", "\n", true)
    },
    auth,
    tfxManager,
    platform
  );
}
async function runUnshare(platform, tfxManager, auth) {
  await unshareExtension(
    {
      publisherId: platform.getInput("publisher-id", true),
      extensionId: platform.getInput("extension-id", true),
      unshareWith: platform.getDelimitedInput("unshare-with", "\n", true)
    },
    auth,
    tfxManager,
    platform
  );
}
async function runInstall(platform, tfxManager, auth) {
  const result2 = await installExtension(
    {
      publisherId: platform.getInput("publisher-id", true),
      extensionId: platform.getInput("extension-id", true),
      accounts: platform.getDelimitedInput("accounts", "\n", true),
      extensionVersion: platform.getInput("extension-version")
    },
    auth,
    tfxManager,
    platform
  );
  if (!result2.allSuccess) {
    throw new Error(`Some accounts failed to install the extension`);
  }
}
async function runShow(platform, tfxManager, auth) {
  const options2 = {
    publisherId: platform.getInput("publisher-id", true),
    extensionId: platform.getInput("extension-id", true),
    outputVariable: platform.getInput("output-variable")
  };
  const result2 = await showExtension(options2, auth, tfxManager, platform);
  if (options2.outputVariable && result2.metadata) {
    platform.setOutput(options2.outputVariable, JSON.stringify(result2.metadata));
  }
}
async function runQueryVersion(platform, tfxManager, auth) {
  const result2 = await queryVersion(
    {
      publisherId: platform.getInput("publisher-id", true),
      extensionId: platform.getInput("extension-id", true),
      versionAction: platform.getInput("version-action") ?? "None",
      extensionVersionOverrideVariable: platform.getInput("extension-version-override"),
      outputVariable: platform.getInput("output-variable")
    },
    auth,
    tfxManager,
    platform
  );
  platform.setOutput("proposed-version", result2.proposedVersion);
  platform.setOutput("current-version", result2.currentVersion);
}
async function runWaitForValidation(platform, tfxManager, auth) {
  const result2 = await waitForValidation(
    {
      publisherId: platform.getInput("publisher-id", true),
      extensionId: platform.getInput("extension-id", true),
      rootFolder: platform.getInput("root-folder"),
      manifestGlobs: platform.getDelimitedInput("manifest-globs", "\n"),
      maxRetries: parseInt(platform.getInput("max-retries") || "10"),
      minTimeout: parseInt(platform.getInput("min-timeout") || "1"),
      maxTimeout: parseInt(platform.getInput("max-timeout") || "15")
    },
    auth,
    tfxManager,
    platform
  );
  if (result2.status !== "success") {
    throw new Error(`Validation failed with status: ${result2.status}`);
  }
}
async function runWaitForInstallation(platform, auth) {
  const expectedTasksInput = platform.getInput("expected-tasks");
  let expectedTasks;
  if (expectedTasksInput) {
    try {
      expectedTasks = JSON.parse(expectedTasksInput);
    } catch (error2) {
      throw new Error(`Failed to parse expected-tasks: ${error2}`);
    }
  }
  const result2 = await waitForInstallation(
    {
      publisherId: platform.getInput("publisher-id", true),
      extensionId: platform.getInput("extension-id", true),
      accounts: platform.getDelimitedInput("accounts", "\n", true),
      expectedTasks,
      manifestPath: platform.getInput("manifest-path"),
      vsixPath: platform.getInput("vsix-path"),
      timeoutMinutes: parseInt(platform.getInput("timeout-minutes") || "10"),
      pollingIntervalSeconds: parseInt(platform.getInput("polling-interval-seconds") || "30")
    },
    auth,
    platform
  );
  if (!result2.success) {
    throw new Error(`Verification failed - not all tasks are available`);
  }
}
void run();
/*! Bundled license information:

js-md4/src/md4.js:
  (**
   * [js-md4]{@link https://github.com/emn178/js-md4}
   *
   * @namespace md4
   * @version 0.3.2
   * @author Yi-Cyuan Chen [emn178@gmail.com]
   * @copyright Yi-Cyuan Chen 2015-2027
   * @license MIT
   *)
*/
//# sourceMappingURL=bundle.js.map
