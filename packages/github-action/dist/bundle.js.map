{
  "version": 3,
  "sources": ["../../core/src/manifest-reader.ts", "../../../node_modules/uuid/dist-node/regex.js", "../../../node_modules/uuid/dist-node/validate.js", "../../../node_modules/uuid/dist-node/parse.js", "../../../node_modules/uuid/dist-node/stringify.js", "../../../node_modules/uuid/dist-node/v35.js", "../../../node_modules/uuid/dist-node/sha1.js", "../../../node_modules/uuid/dist-node/v5.js", "../../../node_modules/uuid/dist-node/index.js", "../../core/src/vsix-reader.ts", "../../core/src/filesystem-manifest-reader.ts", "../../../node_modules/fast-xml-parser/src/util.js", "../../../node_modules/fast-xml-parser/src/validator.js", "../../../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js", "../../../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js", "../../../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js", "../../../node_modules/strnum/strnum.js", "../../../node_modules/fast-xml-parser/src/ignoreAttributes.js", "../../../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js", "../../../node_modules/fast-xml-parser/src/xmlparser/node2json.js", "../../../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js", "../../../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js", "../../../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js", "../../../node_modules/fast-xml-parser/src/fxp.js", "../../core/src/vsix-writer.ts", "../../core/src/filesystem-manifest-writer.ts", "../../core/src/manifest-editor.ts", "../../../node_modules/concat-map/index.js", "../../../node_modules/balanced-match/index.js", "../../../node_modules/brace-expansion/index.js", "../../../node_modules/minimatch/minimatch.js", "../src/main.ts", "../../core/src/platform.ts", "../../core/src/arg-builder.ts", "../../core/src/json-output-stream.ts", "../../core/src/manifest-utils.ts", "../../core/src/tfx-manager.ts", "../../core/src/index.ts", "../../core/src/validation.ts", "../../core/src/commands/package.ts", "../../core/src/commands/publish.ts", "../../core/src/commands/unpublish.ts", "../../core/src/commands/share.ts", "../../core/src/commands/unshare.ts", "../../core/src/commands/install.ts", "../../core/src/commands/show.ts", "../../core/src/commands/query-version.ts", "../../core/src/commands/wait-for-validation.ts", "../../core/src/commands/wait-for-installation.ts", "../src/auth/basic-auth.ts", "../src/auth/oidc-auth.ts", "../src/auth/pat-auth.ts", "../src/auth/index.ts", "../src/github-adapter.ts", "../../../node_modules/@actions/glob/src/internal-globber.ts", "../../../node_modules/@actions/glob/src/internal-glob-options-helper.ts", "../../../node_modules/@actions/glob/src/internal-path-helper.ts", "../../../node_modules/@actions/glob/src/internal-match-kind.ts", "../../../node_modules/@actions/glob/src/internal-pattern-helper.ts", "../../../node_modules/@actions/glob/src/internal-pattern.ts", "../../../node_modules/@actions/glob/src/internal-path.ts", "../../../node_modules/@actions/glob/src/internal-search-state.ts", "../../../node_modules/@actions/glob/src/internal-hash-files.ts", "../../../node_modules/@actions/glob/src/glob.ts"],
  "sourcesContent": ["/**\n * Manifest Reader - Base class for reading extension and task manifests\n *\n * Provides abstract interface for reading manifests from different sources\n * (VSIX files, filesystem, etc.). Implementations provide source-specific\n * reading logic while sharing the same interface.\n *\n * Architecture:\n * - ManifestReader (base/abstract) - defines interface\n * - VsixReader extends ManifestReader - reads from VSIX\n * - FilesystemManifestReader extends ManifestReader - reads from filesystem\n */\n\n/**\n * Extension manifest from vss-extension.json\n */\nexport interface ExtensionManifest {\n  manifestVersion?: number;\n  id: string;\n  publisher: string;\n  version: string;\n  name?: string;\n  description?: string;\n  categories?: string[];\n  tags?: string[];\n  targets?: Array<{ id: string }>;\n  icons?: Record<string, string>;\n  content?: Record<string, string>;\n  files?: Array<{\n    path: string;\n    packagePath?: string;\n    contentType?: string;\n    addressable?: boolean;\n    [key: string]: unknown;\n  }>;\n  contributions?: Array<{\n    id: string;\n    type: string;\n    targets?: string[];\n    properties?: Record<string, unknown>;\n  }>;\n  galleryFlags?: string[];\n  [key: string]: unknown;\n}\n\n/**\n * Task manifest from task.json\n */\nexport interface TaskManifest {\n  id: string;\n  name: string;\n  friendlyName: string;\n  description: string;\n  version: {\n    Major: number;\n    Minor: number;\n    Patch: number;\n  };\n  instanceNameFormat?: string;\n  inputs?: Array<{\n    name: string;\n    type: string;\n    label: string;\n    required?: boolean;\n    defaultValue?: string;\n    [key: string]: unknown;\n  }>;\n  execution?: Record<string, unknown>;\n  [key: string]: unknown;\n}\n\n/**\n * Quick metadata access\n */\nexport interface ManifestMetadata {\n  publisher: string;\n  extensionId: string;\n  version: string;\n  name?: string;\n  description?: string;\n}\n\n/**\n * Task information\n */\nexport interface TaskInfo {\n  name: string;\n  friendlyName: string;\n  version: string;\n  path: string;\n}\n\n/**\n * ManifestReader - Abstract base class for reading manifests\n *\n * Provides a common interface for reading extension and task manifests\n * from different sources (VSIX files, filesystem, etc.).\n *\n * Subclasses must implement:\n * - readExtensionManifest(): Read the main extension manifest\n * - readTaskManifest(path): Read a specific task manifest\n * - findTaskPaths(): Find all task paths in the extension\n * - close(): Clean up resources\n */\nexport abstract class ManifestReader {\n  /**\n   * Read the extension manifest (vss-extension.json or extension.vsomanifest)\n   * @returns Parsed extension manifest\n   */\n  abstract readExtensionManifest(): Promise<ExtensionManifest>;\n\n  /**\n   * Read a task manifest (task.json)\n   * @param taskPath Path to the task directory or task.json file\n   * @returns Parsed task manifest\n   */\n  abstract readTaskManifest(taskPath: string): Promise<TaskManifest>;\n\n  /**\n   * Find all task paths in the extension\n   * @returns Array of task directory paths\n   */\n  abstract findTaskPaths(): Promise<string[]>;\n\n  /**\n   * Close and clean up resources\n   */\n  abstract close(): Promise<void>;\n\n  /**\n   * Read all task manifests in the extension\n   * Default implementation using findTaskPaths() and readTaskManifest()\n   * Subclasses can override for optimization\n   * @returns Array of task manifests with their paths\n   */\n  async readTaskManifests(): Promise<Array<{ path: string; manifest: TaskManifest }>> {\n    const taskPaths = await this.findTaskPaths();\n    const results: Array<{ path: string; manifest: TaskManifest }> = [];\n\n    for (const taskPath of taskPaths) {\n      try {\n        const manifest = await this.readTaskManifest(taskPath);\n        results.push({ path: taskPath, manifest });\n      } catch {\n        // Skip tasks that don't have valid task.json\n        // Silently continue - caller can check if all expected tasks were found\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get quick metadata about the extension\n   * Default implementation using readExtensionManifest()\n   * @returns Extension metadata\n   */\n  async getMetadata(): Promise<ManifestMetadata> {\n    const manifest = await this.readExtensionManifest();\n    return {\n      publisher: manifest.publisher,\n      extensionId: manifest.id,\n      version: manifest.version,\n      name: manifest.name,\n      description: manifest.description,\n    };\n  }\n\n  /**\n   * Get information about all tasks in the extension\n   * Default implementation using readTaskManifests()\n   * @returns Array of task information\n   */\n  async getTasksInfo(): Promise<TaskInfo[]> {\n    const tasks = await this.readTaskManifests();\n    return tasks.map(({ path, manifest }) => ({\n      name: manifest.name,\n      friendlyName: manifest.friendlyName,\n      version: `${manifest.version.Major}.${manifest.version.Minor}.${manifest.version.Patch}`,\n      path,\n    }));\n  }\n}\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n", "import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n", "import validate from './validate.js';\nfunction parse(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexport default parse;\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = parse(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\n", "import { createHash } from 'node:crypto';\nfunction sha1(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return createHash('sha1').update(bytes).digest();\n}\nexport default sha1;\n", "import sha1 from './sha1.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v5(value, namespace, buf, offset) {\n    return v35(0x50, sha1, value, namespace, buf, offset);\n}\nv5.DNS = DNS;\nv5.URL = URL;\nexport default v5;\n", "export { default as MAX } from './max.js';\nexport { default as NIL } from './nil.js';\nexport { default as parse } from './parse.js';\nexport { default as stringify } from './stringify.js';\nexport { default as v1 } from './v1.js';\nexport { default as v1ToV6 } from './v1ToV6.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as v6 } from './v6.js';\nexport { default as v6ToV1 } from './v6ToV1.js';\nexport { default as v7 } from './v7.js';\nexport { default as validate } from './validate.js';\nexport { default as version } from './version.js';\n", "/**\n * VSIX Reader - Read-only operations for VSIX files\n *\n * Extends ManifestReader to provide VSIX-specific reading from ZIP archives.\n * Completely separate from editing and writing concerns.\n *\n * Security: Protected against zip slip attacks with path validation.\n */\n\nimport { Buffer } from 'buffer';\nimport { isAbsolute, normalize } from 'path';\nimport yauzl from 'yauzl';\nimport {\n  ManifestReader,\n  type ExtensionManifest,\n  type ManifestMetadata,\n  type TaskManifest,\n} from './manifest-reader.js';\n\ninterface VsixXmlMetadata {\n  extensionId?: string;\n  publisher?: string;\n  version?: string;\n  name?: string;\n  description?: string;\n}\n\nfunction decodeXmlEntities(input: string): string {\n  return input\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&amp;/g, '&')\n    .trim();\n}\n\nfunction extractXmlTagValue(xml: string, tagName: string): string | undefined {\n  const regex = new RegExp(`<${tagName}[^>]*>([\\\\s\\\\S]*?)</${tagName}>`, 'i');\n  const match = xml.match(regex);\n  if (!match || !match[1]) {\n    return undefined;\n  }\n  return decodeXmlEntities(match[1]);\n}\n\nfunction extractIdentityAttribute(identityTag: string, name: string): string | undefined {\n  const regex = new RegExp(`\\\\b${name}\\\\s*=\\\\s*[\"']([^\"']+)[\"']`, 'i');\n  const match = identityTag.match(regex);\n  if (!match || !match[1]) {\n    return undefined;\n  }\n  return decodeXmlEntities(match[1]);\n}\n\nfunction parseVsixManifestXml(xml: string): VsixXmlMetadata {\n  const identityMatch = xml.match(/<Identity\\b[^>]*>/i);\n  const identityTag = identityMatch?.[0];\n\n  return {\n    extensionId: identityTag ? extractIdentityAttribute(identityTag, 'Id') : undefined,\n    publisher: identityTag ? extractIdentityAttribute(identityTag, 'Publisher') : undefined,\n    version: identityTag ? extractIdentityAttribute(identityTag, 'Version') : undefined,\n    name: extractXmlTagValue(xml, 'DisplayName'),\n    description: extractXmlTagValue(xml, 'Description'),\n  };\n}\n\n/**\n * Validate that a path from a ZIP file is safe and doesn't escape the extraction directory\n * Protects against zip slip vulnerabilities\n * @param filePath Path from ZIP entry\n * @throws Error if path is unsafe\n */\nfunction validateZipPath(filePath: string): void {\n  // Normalize the path to resolve any .. or . segments\n  const normalizedPath = normalize(filePath);\n\n  // Check for absolute paths (e.g., /etc/passwd or C:\\Windows\\System32)\n  if (isAbsolute(normalizedPath)) {\n    throw new Error(`Security: Absolute paths are not allowed in VSIX files: ${filePath}`);\n  }\n\n  // Check if the normalized path tries to escape upward (starts with ..)\n  if (normalizedPath.startsWith('..') || normalizedPath.includes(`${normalize('../')}`)) {\n    throw new Error(`Security: Path traversal detected in VSIX file: ${filePath}`);\n  }\n\n  // Check for suspicious patterns\n  const suspiciousPatterns = [\n    /\\.\\.[/\\\\]/, // Parent directory references\n    /^[/\\\\]/, // Root references\n    /[<>:\"|?*]/, // Windows invalid filename characters (except for paths)\n  ];\n\n  for (const pattern of suspiciousPatterns) {\n    if (pattern.test(filePath)) {\n      throw new Error(`Security: Suspicious pattern detected in path: ${filePath}`);\n    }\n  }\n\n  // Validate that the path doesn't contain null bytes (another attack vector)\n  if (filePath.includes('\\0')) {\n    throw new Error(`Security: Null byte detected in path: ${filePath}`);\n  }\n}\n\n/**\n * File entry in VSIX archive\n */\nexport interface VsixFile {\n  path: string;\n  size: number;\n  compressedSize: number;\n}\n\n/**\n * VsixReader - Read-only VSIX file operations extending ManifestReader\n *\n * Example usage:\n * ```typescript\n * const reader = await VsixReader.open('/path/to/extension.vsix');\n * const manifest = await reader.readExtensionManifest();\n * const tasks = await reader.readTaskManifests();\n * await reader.close();\n * ```\n *\n * Or chained:\n * ```typescript\n * const reader = await VsixReader.open('/path/to/extension.vsix');\n * const [manifest, tasks] = await Promise.all([\n *   reader.readExtensionManifest(),\n *   reader.readTaskManifests()\n * ]);\n * await reader.close();\n * ```\n */\nexport class VsixReader extends ManifestReader {\n  private zipFile: yauzl.ZipFile | null = null;\n  private readonly vsixPath: string;\n  private fileCache: Map<string, Buffer> = new Map();\n  private entriesCache: yauzl.Entry[] | null = null;\n\n  private constructor(vsixPath: string) {\n    super();\n    this.vsixPath = vsixPath;\n  }\n\n  /**\n   * Open a VSIX file for reading\n   * @param vsixPath Path to the VSIX file\n   * @returns VsixReader instance\n   */\n  static async open(vsixPath: string): Promise<VsixReader> {\n    const reader = new VsixReader(vsixPath);\n    await reader.openZip();\n    return reader;\n  }\n\n  /**\n   * Open the ZIP file\n   */\n  private async openZip(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      yauzl.open(\n        this.vsixPath,\n        {\n          lazyEntries: true,\n          strictFileNames: false,\n          validateEntrySizes: false,\n          autoClose: false, // Keep file open for multiple read operations\n        },\n        (err: Error | null, zipFile?: yauzl.ZipFile) => {\n          if (err) {\n            reject(new Error(`Failed to open VSIX file: ${err.message}`));\n            return;\n          }\n          this.zipFile = zipFile!;\n          resolve();\n        }\n      );\n    });\n  }\n\n  /**\n   * Read all entries from the ZIP file\n   * Validates all paths for security (zip slip protection)\n   */\n  private async readEntries(): Promise<yauzl.Entry[]> {\n    if (this.entriesCache) {\n      return this.entriesCache;\n    }\n\n    if (!this.zipFile) {\n      throw new Error('VSIX file is not open');\n    }\n\n    return new Promise((resolve, reject) => {\n      const entries: yauzl.Entry[] = [];\n\n      const onEntry = (entry: yauzl.Entry) => {\n        try {\n          // Validate path for security\n          validateZipPath(entry.fileName);\n          entries.push(entry);\n        } catch (err) {\n          // Security violation - reject the entire operation\n          this.zipFile.removeListener('entry', onEntry);\n          this.zipFile.removeListener('end', onEnd);\n          this.zipFile.removeListener('error', onError);\n          reject(err);\n          return;\n        }\n        this.zipFile.readEntry();\n      };\n\n      const onEnd = () => {\n        this.zipFile.removeListener('entry', onEntry);\n        this.zipFile.removeListener('end', onEnd);\n        this.zipFile.removeListener('error', onError);\n        this.entriesCache = entries;\n        resolve(entries);\n      };\n\n      const onError = (err: Error) => {\n        this.zipFile.removeListener('entry', onEntry);\n        this.zipFile.removeListener('end', onEnd);\n        this.zipFile.removeListener('error', onError);\n        reject(new Error(`Error reading VSIX entries: ${err.message}`));\n      };\n\n      this.zipFile.on('entry', onEntry);\n      this.zipFile.on('end', onEnd);\n      this.zipFile.on('error', onError);\n\n      this.zipFile.readEntry();\n    });\n  }\n\n  /**\n   * Read a specific file from the VSIX\n   * @param filePath Path to the file within the VSIX\n   * @returns File contents as Buffer\n   */\n  async readFile(filePath: string): Promise<Buffer> {\n    // Validate path for security (zip slip protection)\n    validateZipPath(filePath);\n\n    // Normalize path separators\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n\n    // Check cache\n    if (this.fileCache.has(normalizedPath)) {\n      return this.fileCache.get(normalizedPath);\n    }\n\n    if (!this.zipFile) {\n      throw new Error('VSIX file is not open');\n    }\n\n    const entries = await this.readEntries();\n    const entry = entries.find((e) => e.fileName === normalizedPath);\n\n    if (!entry) {\n      throw new Error(`File not found in VSIX: ${filePath}`);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.zipFile.openReadStream(entry, (err: Error | null, readStream?: any) => {\n        if (err || !readStream) {\n          reject(new Error(`Failed to read file ${filePath}: ${err?.message || 'No stream'}`));\n          return;\n        }\n\n        const chunks: Buffer[] = [];\n        readStream.on('data', (chunk: Buffer) => chunks.push(chunk));\n        readStream.on('end', () => {\n          const buffer = Buffer.concat(chunks);\n          this.fileCache.set(normalizedPath, buffer);\n          resolve(buffer);\n        });\n        readStream.on('error', (streamErr: Error) => {\n          reject(new Error(`Error reading file ${filePath}: ${streamErr.message}`));\n        });\n      });\n    });\n  }\n\n  /**\n   * Check if a file exists in the VSIX\n   * @param filePath Path to check\n   * @returns True if file exists\n   */\n  async fileExists(filePath: string): Promise<boolean> {\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n    const entries = await this.readEntries();\n    return entries.some((e) => e.fileName === normalizedPath);\n  }\n\n  /**\n   * List all files in the VSIX\n   * @returns Array of file information\n   */\n  async listFiles(): Promise<VsixFile[]> {\n    const entries = await this.readEntries();\n    return entries\n      .filter((e) => !e.fileName.endsWith('/')) // Exclude directories\n      .map((e) => ({\n        path: e.fileName,\n        size: e.uncompressedSize,\n        compressedSize: e.compressedSize,\n      }));\n  }\n\n  /**\n   * Read the extension manifest (vss-extension.json or extension.vsixmanifest)\n   * @returns Parsed extension manifest\n   */\n  async readExtensionManifest(): Promise<ExtensionManifest> {\n    // Try vss-extension.json first (standard)\n    if (await this.fileExists('extension.vsomanifest')) {\n      const buffer = await this.readFile('extension.vsomanifest');\n      return JSON.parse(buffer.toString('utf-8'));\n    }\n\n    if (await this.fileExists('vss-extension.json')) {\n      const buffer = await this.readFile('vss-extension.json');\n      return JSON.parse(buffer.toString('utf-8'));\n    }\n\n    throw new Error(\n      'Extension manifest not found in VSIX (expected vss-extension.json or extension.vsomanifest)'\n    );\n  }\n\n  /**\n   * Find task directories from the extension manifest\n   * @returns Array of task directory paths\n   */\n  async findTaskPaths(): Promise<string[]> {\n    const manifest = await this.readExtensionManifest();\n    const taskPathsSet = new Set<string>();\n\n    // Look for task contributions\n    if (manifest.contributions) {\n      for (const contribution of manifest.contributions) {\n        if (contribution.type === 'ms.vss-distributed-task.task' && contribution.properties) {\n          const name = contribution.properties.name as string;\n          if (name) {\n            taskPathsSet.add(name);\n          }\n        }\n      }\n    }\n\n    // Look for files array (only if no contributions found)\n    if (taskPathsSet.size === 0 && manifest.files) {\n      const entries = await this.readEntries();\n      for (const file of manifest.files) {\n        // Task directories typically contain task.json\n        const taskJsonPath = `${file.path}/task.json`.replace(/\\\\/g, '/');\n        if (entries.some((e) => e.fileName === taskJsonPath)) {\n          taskPathsSet.add(file.path);\n        }\n      }\n    }\n\n    return Array.from(taskPathsSet);\n  }\n\n  /**\n   * Read a task manifest (task.json)\n   * @param taskPath Path to the task directory\n   * @returns Parsed task manifest\n   */\n  async readTaskManifest(taskPath: string): Promise<TaskManifest> {\n    const taskJsonPath = `${taskPath}/task.json`.replace(/\\\\/g, '/');\n    const buffer = await this.readFile(taskJsonPath);\n    return JSON.parse(buffer.toString('utf-8'));\n  }\n\n  /**\n   * Get quick metadata with fallback to extension.vsixmanifest XML identity\n   */\n  async getMetadata(): Promise<ManifestMetadata> {\n    const manifest = await this.readExtensionManifest();\n\n    let metadata: ManifestMetadata = {\n      publisher: manifest.publisher,\n      extensionId: manifest.id,\n      version: manifest.version,\n      name: manifest.name,\n      description: manifest.description,\n    };\n\n    const needsXmlFallback = !metadata.publisher || !metadata.extensionId || !metadata.version;\n    if (needsXmlFallback && (await this.fileExists('extension.vsixmanifest'))) {\n      try {\n        const xml = (await this.readFile('extension.vsixmanifest')).toString('utf-8');\n        const xmlMetadata = parseVsixManifestXml(xml);\n\n        metadata = {\n          publisher: metadata.publisher || xmlMetadata.publisher || '',\n          extensionId: metadata.extensionId || xmlMetadata.extensionId || '',\n          version: metadata.version || xmlMetadata.version || '',\n          name: metadata.name || xmlMetadata.name,\n          description: metadata.description || xmlMetadata.description,\n        };\n      } catch {\n        // Ignore XML parsing issues and return best-effort metadata from JSON manifest\n      }\n    }\n\n    return metadata;\n  }\n\n  /**\n   * Close the VSIX file and clean up resources\n   */\n  async close(): Promise<void> {\n    const zipFile = this.zipFile;\n    this.zipFile = null;\n\n    if (zipFile) {\n      await new Promise<void>((resolve) => {\n        let settled = false;\n\n        const complete = () => {\n          if (!settled) {\n            settled = true;\n            resolve();\n          }\n        };\n\n        const onClose = () => {\n          zipFile.removeListener('error', onError);\n          complete();\n        };\n\n        const onError = () => {\n          zipFile.removeListener('close', onClose);\n          complete();\n        };\n\n        zipFile.once('close', onClose);\n        zipFile.once('error', onError);\n\n        try {\n          zipFile.close();\n        } catch {\n          zipFile.removeListener('close', onClose);\n          zipFile.removeListener('error', onError);\n          complete();\n          return;\n        }\n\n        // Safety fallback: avoid hanging if no close/error event is emitted\n        setTimeout(() => {\n          zipFile.removeListener('close', onClose);\n          zipFile.removeListener('error', onError);\n          complete();\n        }, 200);\n      });\n    }\n\n    this.fileCache.clear();\n    this.entriesCache = null;\n  }\n\n  /**\n   * Get the path to the VSIX file\n   */\n  getPath(): string {\n    return this.vsixPath;\n  }\n}\n\n// Re-export types from manifest-reader for backwards compatibility\nexport type {\n  ExtensionManifest,\n  ManifestMetadata,\n  TaskInfo,\n  TaskManifest,\n} from './manifest-reader.js';\n", "/**\n * Filesystem Manifest Reader - Read manifests from filesystem\n *\n * Extends ManifestReader to provide filesystem-based reading of extension\n * and task manifests directly from source directories.\n */\n\nimport { readFile } from 'fs/promises';\nimport path from 'path';\nimport { ManifestReader, type ExtensionManifest, type TaskManifest } from './manifest-reader.js';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * FilesystemManifestReader - Read manifests from filesystem\n *\n * Reads extension and task manifests directly from a source directory.\n * Useful for package command where manifests haven't been packaged yet.\n *\n * Example usage:\n * ```typescript\n * const reader = new FilesystemManifestReader({\n *   rootFolder: '/path/to/extension',\n *   manifestGlobs: ['vss-extension.json'],\n *   platform\n * });\n * const manifest = await reader.readExtensionManifest();\n * await reader.close();\n * ```\n */\nexport class FilesystemManifestReader extends ManifestReader {\n  private readonly rootFolder: string;\n  private readonly manifestGlobs: string[];\n  private readonly platform: IPlatformAdapter;\n  private manifestPath: string | null = null;\n  private manifestPaths: string[] | null = null;\n  private extensionManifest: ExtensionManifest | null = null;\n  // Map of packagePath (task name) to actual source path\n  private packagePathMap: Map<string, string> | null = null;\n\n  constructor(options: {\n    rootFolder: string;\n    manifestGlobs?: string[];\n    platform: IPlatformAdapter;\n  }) {\n    super();\n    this.rootFolder = options.rootFolder;\n    this.manifestGlobs = options.manifestGlobs || ['vss-extension.json'];\n    this.platform = options.platform;\n  }\n\n  /**\n   * Find and resolve all extension manifest file paths\n   */\n  private async resolveManifestPaths(): Promise<string[]> {\n    if (this.manifestPaths) {\n      return this.manifestPaths;\n    }\n\n    const matches = await this.platform.findMatch(this.rootFolder, this.manifestGlobs);\n\n    if (matches.length === 0) {\n      const commonNames = ['vss-extension.json', 'extension.vsomanifest'];\n      for (const name of commonNames) {\n        const candidate = path.join(this.rootFolder, name);\n        if (await this.platform.fileExists(candidate)) {\n          this.manifestPaths = [candidate];\n          this.manifestPath = candidate;\n          return this.manifestPaths;\n        }\n      }\n\n      throw new Error(\n        `Extension manifest not found in ${this.rootFolder}. ` +\n          `Tried patterns: ${this.manifestGlobs.join(', ')}`\n      );\n    }\n\n    if (matches.length > 1) {\n      this.platform.warning(\n        `Multiple manifest files found: ${matches.join(', ')}. Using first match as primary.`\n      );\n    }\n\n    this.manifestPaths = matches;\n    this.manifestPath = matches[0];\n    return this.manifestPaths;\n  }\n\n  /**\n   * Find and resolve the extension manifest file path\n   */\n  private async resolveManifestPath(): Promise<string> {\n    const paths = await this.resolveManifestPaths();\n    return paths[0];\n  }\n\n  /**\n   * Read the extension manifest from filesystem\n   * @returns Parsed extension manifest\n   */\n  async readExtensionManifest(): Promise<ExtensionManifest> {\n    if (this.extensionManifest) {\n      return this.extensionManifest;\n    }\n\n    const manifestPath = await this.resolveManifestPath();\n    const content = (await readFile(manifestPath)).toString('utf8');\n    this.extensionManifest = JSON.parse(content);\n    return this.extensionManifest;\n  }\n\n  /**\n   * Build a map of packagePath to actual source path from files array\n   * This handles cases where task.json is in a different directory than the final package path\n   * @returns Map of packagePath to source path\n   */\n  private async buildPackagePathMap(): Promise<Map<string, string>> {\n    if (this.packagePathMap) {\n      return this.packagePathMap;\n    }\n\n    this.packagePathMap = new Map<string, string>();\n    const manifest = await this.readExtensionManifest();\n\n    // Check if files array exists with packagePath mappings\n    if (manifest.files) {\n      for (const file of manifest.files) {\n        // If packagePath is specified, map it to the source path\n        if (file.packagePath) {\n          this.packagePathMap.set(file.packagePath, file.path);\n          this.platform.debug(\n            `Mapped packagePath '${file.packagePath}' to source path '${file.path}'`\n          );\n        }\n      }\n    }\n\n    return this.packagePathMap;\n  }\n\n  /**\n   * Find task paths from the extension manifest\n   * @returns Array of task directory paths (relative to rootFolder)\n   */\n  async findTaskPaths(): Promise<string[]> {\n    const manifest = await this.readExtensionManifest();\n    const taskPaths: string[] = [];\n\n    // Look for task contributions\n    if (manifest.contributions) {\n      for (const contribution of manifest.contributions) {\n        if (contribution.type === 'ms.vss-distributed-task.task' && contribution.properties) {\n          const name = contribution.properties.name as string;\n          if (name) {\n            taskPaths.push(name);\n          }\n        }\n      }\n    }\n\n    // If no contributions found, look in files array\n    if (taskPaths.length === 0 && manifest.files) {\n      for (const file of manifest.files) {\n        const taskJsonPath = path.join(this.rootFolder, file.path, 'task.json');\n        if (await this.platform.fileExists(taskJsonPath)) {\n          taskPaths.push(file.path);\n        }\n      }\n    }\n\n    return taskPaths;\n  }\n\n  /**\n   * Read a task manifest from filesystem\n   * @param taskPath Path to the task directory (relative to rootFolder) or packagePath\n   * @returns Parsed task manifest\n   */\n  async readTaskManifest(taskPath: string): Promise<TaskManifest> {\n    // Build packagePath map to handle files with packagePath\n    const packagePathMap = await this.buildPackagePathMap();\n\n    // Check if taskPath starts with a packagePath prefix and replace it\n    let actualPath = taskPath;\n\n    // Normalize path separators for consistent matching\n    const normalizedTaskPath = taskPath.replace(/\\\\/g, '/');\n\n    // Try to find a matching packagePath prefix\n    for (const [pkgPath, sourcePath] of packagePathMap.entries()) {\n      const normalizedPkgPath = pkgPath.replace(/\\\\/g, '/');\n\n      // Check for exact match or prefix match (packagePath/subdir)\n      if (normalizedTaskPath === normalizedPkgPath) {\n        // Exact match: TaskName \u2192 sourcePath\n        actualPath = sourcePath;\n        break;\n      } else if (normalizedTaskPath.startsWith(normalizedPkgPath + '/')) {\n        // Prefix match: TaskName/v2 \u2192 sourcePath/v2\n        const remainder = normalizedTaskPath.substring(normalizedPkgPath.length + 1);\n        actualPath = path.join(sourcePath, remainder);\n        break;\n      }\n    }\n\n    this.platform.debug(\n      `Reading task manifest: taskPath='${taskPath}', actualPath='${actualPath}'`\n    );\n\n    // Resolve relative path from rootFolder\n    const absoluteTaskPath = path.isAbsolute(actualPath)\n      ? actualPath\n      : path.join(this.rootFolder, actualPath);\n\n    const taskJsonPath = path.join(absoluteTaskPath, 'task.json');\n\n    if (!(await this.platform.fileExists(taskJsonPath))) {\n      throw new Error(`Task manifest not found: ${taskJsonPath}`);\n    }\n\n    const content = (await readFile(taskJsonPath)).toString('utf8');\n    return JSON.parse(content);\n  }\n\n  /**\n   * Close and clean up resources\n   * No-op for filesystem reader as there are no persistent resources\n   */\n  async close(): Promise<void> {\n    // No resources to clean up\n    this.extensionManifest = null;\n    this.manifestPath = null;\n    this.manifestPaths = null;\n    this.packagePathMap = null;\n  }\n\n  /**\n   * Read all extension manifests matched by manifest globs\n   */\n  async readAllExtensionManifests(): Promise<Array<{ path: string; manifest: ExtensionManifest }>> {\n    const paths = await this.resolveManifestPaths();\n    const manifests: Array<{ path: string; manifest: ExtensionManifest }> = [];\n\n    for (const manifestPath of paths) {\n      const content = (await readFile(manifestPath)).toString('utf8');\n      manifests.push({\n        path: manifestPath,\n        manifest: JSON.parse(content) as ExtensionManifest,\n      });\n    }\n\n    return manifests;\n  }\n\n  /**\n   * Get the root folder path\n   */\n  getRootFolder(): string {\n    return this.rootFolder;\n  }\n\n  /**\n   * Get the resolved manifest path (if already resolved)\n   */\n  getManifestPath(): string | null {\n    return this.manifestPath;\n  }\n}\n", "'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n", "'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else if (tags.length === 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n", "\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;", "'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;", "const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    let entityName, val;\n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n", "const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.search(/[eE]/)!== -1) { //eNotation\n        const notation = trimmedStr.match(/^([-\\+])?(0*)([0-9]*(\\.[0-9]*)?[eE][-\\+]?[0-9]+)$/); \n        // +00.123 => [ , '+', '00', '.123', ..\n        if(notation){\n            // console.log(notation)\n            if(options.leadingZeros){ //accept with leading zeros\n                trimmedStr = (notation[1] || \"\") + notation[3];\n            }else{\n                if(notation[2] === \"0\" && notation[3][0]=== \".\"){ //valid number\n                }else{\n                    return str;\n                }\n            }\n            return options.eNotation ? Number(trimmedStr) : str;\n        }else{\n            return str;\n        }\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else if(options.leadingZeros && leadingZeros===str) return 0; //00\n            \n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    return (numTrimmedByZeros === numStr) || (sign+numTrimmedByZeros === numStr) ? num : str\n                }else  {\n                    return (trimmedStr === numStr) || (trimmedStr === sign+numStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}\n\nmodule.exports = toNumber;", "function getIgnoreAttributesFn(ignoreAttributes) {\n    if (typeof ignoreAttributes === 'function') {\n        return ignoreAttributes\n    }\n    if (Array.isArray(ignoreAttributes)) {\n        return (attrName) => {\n            for (const pattern of ignoreAttributes) {\n                if (typeof pattern === 'string' && attrName === pattern) {\n                    return true\n                }\n                if (pattern instanceof RegExp && pattern.test(attrName)) {\n                    return true\n                }\n            }\n        }\n    }\n    return () => false\n}\n\nmodule.exports = getIgnoreAttributesFn", "'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\nconst getIgnoreAttributesFn = require('../ignoreAttributes')\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\u00A2\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\u00A3\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\u00A5\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\u20AC\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\u00A9\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\u00AE\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\u20B9\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      if (this.ignoreAttributesFn(attrName, jPath)) {\n        continue\n      }\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            \n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = currentNode.child.length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n", "'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n", "const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;", "const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n", "'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\nconst getIgnoreAttributesFn = require('../ignoreAttributes')\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0, []).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level, ajPath) {\n  let attrStr = '';\n  let val = '';\n  const jPath = ajPath.join('.')\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key === this.options.cdataPropName) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr && !this.ignoreAttributesFn(attr, jPath)) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      } else if (!attr) {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      let listTagAttr = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup){\n            const result = this.j2x(item, level + 1, ajPath.concat(key));\n            listTagVal += result.val;\n            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {\n              listTagAttr += result.attrStr\n            }\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level, ajPath)\n          }\n        } else {\n          if (this.options.oneListGroup) {\n            let textValue = this.options.tagValueProcessor(key, item);\n            textValue = this.replaceEntitiesValue(textValue);\n            listTagVal += textValue;\n          } else {\n            listTagVal += this.buildTextValNode(item, key, '', level);\n          }\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level, ajPath)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level, ajPath) {\n  const result = this.j2x(object, level + 1, ajPath.concat(key));\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n", "'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}", "/**\n * VSIX Writer - Write modified VSIX files efficiently\n *\n * Optimizes ZIP file updates by copying unchanged entries directly\n * without recompression. Only modified/new files are recompressed.\n *\n * Chain: Reader \u2192 ManifestEditor \u2192 Writer\n */\n\nimport { Buffer } from 'buffer';\nimport { createWriteStream } from 'fs';\nimport { XMLBuilder, XMLParser } from 'fast-xml-parser';\nimport yazl from 'yazl';\nimport type { ManifestEditor } from './manifest-editor.js';\nimport type { ExtensionManifest, TaskManifest } from './manifest-reader.js';\n\n/**\n * Source-of-truth reference for manifest split behavior:\n * - https://github.com/microsoft/tfs-cli/blob/master/app/exec/extension/_lib/vsix-manifest-builder.ts\n * - https://github.com/microsoft/tfs-cli/blob/master/app/exec/extension/_lib/targets/Microsoft.VisualStudio.Services/vso-manifest-builder.ts\n *\n * Routing rules intentionally followed here:\n * - extension.vsixmanifest (XML): identity/display/packaging metadata\n *   - id, publisher, version, name, description, galleryFlags\n * - extension.vsomanifest (JSON): runtime contribution model\n *   - contributions, scopes, repository, etc.\n *\n * Real-world sample manifests used to validate and document this split are copied in:\n * - packages/core/src/__tests__/fixtures/real-world-manifest-samples.ts\n */\n\ntype XmlObject = Record<string, unknown>;\n\nconst xmlParser = new XMLParser({\n  ignoreAttributes: false,\n  attributeNamePrefix: '@_',\n  trimValues: false,\n  parseTagValue: false,\n  parseAttributeValue: false,\n} as const);\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\nconst xmlBuilder = new XMLBuilder({\n  ignoreAttributes: false,\n  attributeNamePrefix: '@_',\n  format: true,\n  indentBy: '  ',\n  suppressEmptyNode: true,\n  suppressBooleanAttributes: false,\n} as const) as XMLBuilder;\n\nfunction ensureObject(value: unknown): XmlObject {\n  if (!value || typeof value !== 'object' || Array.isArray(value)) {\n    return {};\n  }\n\n  return value as XmlObject;\n}\n\nfunction ensureMetadataContainer(parsed: XmlObject): XmlObject {\n  const packageManifest = ensureObject(parsed.PackageManifest);\n  parsed.PackageManifest = packageManifest;\n\n  const metadata = ensureObject(packageManifest.Metadata);\n  packageManifest.Metadata = metadata;\n\n  return metadata;\n}\n\nfunction setIdentityAttribute(metadata: XmlObject, attrName: string, value: string): void {\n  const identity = ensureObject(metadata.Identity);\n  metadata.Identity = identity;\n\n  identity[`@_${attrName}`] = value;\n}\n\nfunction setMetadataTextTag(metadata: XmlObject, tagName: string, value: string): void {\n  const current = metadata[tagName];\n\n  if (current && typeof current === 'object' && !Array.isArray(current)) {\n    const currentObj = current as XmlObject;\n    const hasAttributes = Object.keys(currentObj).some((key) => key.startsWith('@_'));\n\n    if (hasAttributes) {\n      currentObj['#text'] = value;\n      metadata[tagName] = currentObj;\n      return;\n    }\n  }\n\n  metadata[tagName] = value;\n}\n\nfunction applyVsixManifestXmlMetadata(\n  xml: string,\n  manifestMods: Partial<ExtensionManifest>\n): string {\n  const parsed = ensureObject(xmlParser.parse(xml));\n  const metadata = ensureMetadataContainer(parsed);\n\n  if (manifestMods.id) {\n    setIdentityAttribute(metadata, 'Id', manifestMods.id);\n  }\n  if (manifestMods.publisher) {\n    setIdentityAttribute(metadata, 'Publisher', manifestMods.publisher);\n  }\n  if (manifestMods.version) {\n    setIdentityAttribute(metadata, 'Version', manifestMods.version);\n  }\n\n  if (manifestMods.name) {\n    setMetadataTextTag(metadata, 'DisplayName', manifestMods.name);\n  }\n\n  if (manifestMods.description) {\n    const currentDescription = ensureObject(metadata.Description);\n    if (!currentDescription['@_xml:space']) {\n      currentDescription['@_xml:space'] = 'preserve';\n    }\n    currentDescription['#text'] = manifestMods.description;\n    metadata.Description = currentDescription;\n  }\n\n  if (manifestMods.galleryFlags && manifestMods.galleryFlags.length > 0) {\n    setMetadataTextTag(metadata, 'GalleryFlags', manifestMods.galleryFlags.join(' '));\n  }\n\n  return xmlBuilder.build(parsed);\n}\n\nfunction splitJsonAndXmlManifestMods(manifestMods: Partial<ExtensionManifest>): {\n  jsonMods: Partial<ExtensionManifest>;\n  xmlMods: Partial<ExtensionManifest>;\n} {\n  const xmlMods: Partial<ExtensionManifest> = {\n    id: manifestMods.id,\n    publisher: manifestMods.publisher,\n    version: manifestMods.version,\n    name: manifestMods.name,\n    description: manifestMods.description,\n    galleryFlags: manifestMods.galleryFlags,\n  };\n\n  const jsonMods: Partial<ExtensionManifest> = { ...manifestMods };\n  delete jsonMods.id;\n  delete jsonMods.publisher;\n  delete jsonMods.version;\n  delete jsonMods.name;\n  delete jsonMods.description;\n  delete jsonMods.galleryFlags;\n\n  return { jsonMods, xmlMods };\n}\n\n/**\n * Validate that a path is safe for writing to ZIP\n * Protects against zip slip vulnerabilities\n * @param filePath Path to validate\n * @throws Error if path is unsafe\n */\nfunction validateZipPath(filePath: string): void {\n  // Same validation as in VsixReader\n  const normalizedPath = filePath.replace(/\\\\/g, '/');\n\n  // Check for absolute paths\n  if (normalizedPath.startsWith('/') || /^[A-Z]:/i.test(normalizedPath)) {\n    throw new Error(`Security: Absolute paths are not allowed: ${filePath}`);\n  }\n\n  // Check for parent directory traversal\n  if (normalizedPath.includes('../') || normalizedPath.startsWith('..')) {\n    throw new Error(`Security: Path traversal detected: ${filePath}`);\n  }\n\n  // Check for null bytes\n  if (normalizedPath.includes('\\0')) {\n    throw new Error(`Security: Null byte detected in path: ${filePath}`);\n  }\n}\n\n/**\n * VsixWriter - Efficient VSIX file writing\n *\n * Example usage:\n * ```typescript\n * const reader = await VsixReader.open('input.vsix');\n * const editor = ManifestEditor.fromReader(reader);\n * editor.setPublisher('new-publisher');\n * const writer = await editor.toWriter();\n * await writer.writeToFile('output.vsix');\n * await writer.close();\n * ```\n */\nexport class VsixWriter {\n  private readonly editor: ManifestEditor;\n  private zipFile: yazl.ZipFile | null = null;\n\n  private constructor(editor: ManifestEditor) {\n    this.editor = editor;\n  }\n\n  /**\n   * Create a writer from an editor\n   * @param editor The ManifestEditor with modifications\n   * @returns VsixWriter instance\n   */\n  static fromEditor(editor: ManifestEditor): VsixWriter {\n    return new VsixWriter(editor);\n  }\n\n  /**\n   * Write the modified VSIX to a file\n   *\n   * This method efficiently copies unchanged entries from the source VSIX\n   * without recompression, significantly improving performance for large files.\n   *\n   * @param outputPath Path where the new VSIX should be written\n   * @returns Promise that resolves when writing is complete\n   */\n  async writeToFile(outputPath: string): Promise<void> {\n    const reader = this.editor.getReader();\n    const modifications = this.editor.getModifications();\n    const manifestMods = this.editor.getManifestModifications();\n    const taskManifestMods = this.editor.getTaskManifestModifications();\n\n    // Create new ZIP file\n    this.zipFile = new yazl.ZipFile();\n\n    // Track which files we've added\n    const addedFiles = new Set<string>();\n\n    // Step 1: Apply manifest modifications\n    const manifestPath = await this.determineManifestPath(reader);\n    if (Object.keys(manifestMods).length > 0 || taskManifestMods.size > 0) {\n      await this.applyManifestModifications(\n        reader,\n        manifestPath,\n        manifestMods,\n        taskManifestMods,\n        addedFiles\n      );\n    }\n\n    // Step 2: Apply file modifications (add/modify/remove)\n    for (const [path, mod] of modifications) {\n      validateZipPath(path);\n\n      if (mod.type === 'remove') {\n        // Mark as added so we skip it when copying from source\n        addedFiles.add(path);\n      } else if (mod.type === 'modify' && mod.content) {\n        // Add modified file\n        this.zipFile.addBuffer(mod.content, path);\n        addedFiles.add(path);\n      }\n    }\n\n    // Step 3: Copy all other files from source VSIX efficiently\n    // This is the key optimization: unchanged files are copied without recompression\n    await this.copyUnchangedFiles(reader, addedFiles);\n\n    // Step 4: Finalize and write\n    await this.finalizeZip(outputPath);\n  }\n\n  /**\n   * Write the modified VSIX to a buffer in memory\n   * @returns Promise<Buffer> containing the complete VSIX\n   */\n  async writeToBuffer(): Promise<Buffer> {\n    const reader = this.editor.getReader();\n    const modifications = this.editor.getModifications();\n    const manifestMods = this.editor.getManifestModifications();\n    const taskManifestMods = this.editor.getTaskManifestModifications();\n\n    this.zipFile = new yazl.ZipFile();\n    const addedFiles = new Set<string>();\n\n    // Same steps as writeToFile, but collect to buffer\n    const manifestPath = await this.determineManifestPath(reader);\n    if (Object.keys(manifestMods).length > 0 || taskManifestMods.size > 0) {\n      await this.applyManifestModifications(\n        reader,\n        manifestPath,\n        manifestMods,\n        taskManifestMods,\n        addedFiles\n      );\n    }\n\n    for (const [path, mod] of modifications) {\n      validateZipPath(path);\n\n      if (mod.type === 'remove') {\n        addedFiles.add(path);\n      } else if (mod.type === 'modify' && mod.content) {\n        this.zipFile.addBuffer(mod.content, path);\n        addedFiles.add(path);\n      }\n    }\n\n    await this.copyUnchangedFiles(reader, addedFiles);\n\n    return this.finalizeZipToBuffer();\n  }\n\n  /**\n   * Determine which manifest file to use\n   */\n  private async determineManifestPath(reader: any): Promise<string> {\n    if (await reader.fileExists('extension.vsomanifest')) {\n      return 'extension.vsomanifest';\n    }\n    if (await reader.fileExists('vss-extension.json')) {\n      return 'vss-extension.json';\n    }\n    throw new Error('No extension manifest found in source VSIX');\n  }\n\n  /**\n   * Apply modifications to manifests\n   */\n  private async applyManifestModifications(\n    reader: any,\n    manifestPath: string,\n    manifestMods: Partial<ExtensionManifest>,\n    taskManifestMods: Map<string, Partial<TaskManifest>>,\n    addedFiles: Set<string>\n  ): Promise<void> {\n    const hasVsixXmlManifest = await reader.fileExists('extension.vsixmanifest');\n    const shouldSplitMetadata = hasVsixXmlManifest;\n\n    const { jsonMods, xmlMods } = shouldSplitMetadata\n      ? splitJsonAndXmlManifestMods(manifestMods)\n      : { jsonMods: manifestMods, xmlMods: {} as Partial<ExtensionManifest> };\n\n    // Read and modify extension JSON manifest\n    const manifest = await reader.readExtensionManifest();\n    Object.assign(manifest, jsonMods);\n\n    const manifestJson = JSON.stringify(manifest, null, 2);\n    this.zipFile.addBuffer(Buffer.from(manifestJson, 'utf-8'), manifestPath);\n    addedFiles.add(manifestPath);\n\n    // Update extension.vsixmanifest XML metadata when present\n    if (hasVsixXmlManifest) {\n      const hasXmlMods =\n        !!xmlMods.id ||\n        !!xmlMods.publisher ||\n        !!xmlMods.version ||\n        !!xmlMods.name ||\n        !!xmlMods.description;\n\n      if (hasXmlMods) {\n        const xmlBuffer = await reader.readFile('extension.vsixmanifest');\n        const xml = xmlBuffer.toString('utf-8');\n        const updatedXml = applyVsixManifestXmlMetadata(xml, xmlMods);\n        this.zipFile.addBuffer(Buffer.from(updatedXml, 'utf-8'), 'extension.vsixmanifest');\n        addedFiles.add('extension.vsixmanifest');\n      }\n    }\n\n    // Modify task manifests if needed\n    if (taskManifestMods.size > 0) {\n      const taskManifests = await reader.readTaskManifests();\n\n      for (const taskManifest of taskManifests) {\n        const mods = taskManifestMods.get(taskManifest.manifest.name);\n        if (mods) {\n          // Apply modifications to the manifest object\n          Object.assign(taskManifest.manifest, mods);\n          const taskJson = JSON.stringify(taskManifest.manifest, null, 2);\n          const taskPath = `${taskManifest.path}/task.json`;\n          this.zipFile.addBuffer(Buffer.from(taskJson, 'utf-8'), taskPath);\n          addedFiles.add(taskPath);\n        }\n      }\n    }\n  }\n\n  /**\n   * Copy unchanged files from source VSIX\n   *\n   * This is the key optimization: files are copied directly from the source\n   * ZIP without decompression/recompression, preserving original compression.\n   */\n  private async copyUnchangedFiles(reader: any, addedFiles: Set<string>): Promise<void> {\n    const allFiles = await reader.listFiles();\n\n    for (const file of allFiles) {\n      if (!addedFiles.has(file.path)) {\n        // File hasn't been modified - copy it efficiently\n        // Note: yazl will copy the compressed data directly if we use the right method\n        try {\n          const content = await reader.readFile(file.path);\n          this.zipFile.addBuffer(content, file.path);\n        } catch (err) {\n          // If we can't read it, skip it (might be a directory or corrupt entry)\n          console.warn(`Warning: Could not copy file ${file.path}: ${(err as Error).message}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Finalize ZIP and write to file\n   */\n  private async finalizeZip(outputPath: string): Promise<void> {\n    if (!this.zipFile) {\n      throw new Error('ZIP file not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const outputStream = createWriteStream(outputPath);\n\n      outputStream.on('error', (err) => {\n        reject(new Error(`Failed to write VSIX file: ${err.message}`));\n      });\n\n      outputStream.on('finish', () => {\n        resolve();\n      });\n\n      this.zipFile.outputStream.pipe(outputStream as any).on('error', (err: Error) => {\n        reject(new Error(`Failed to write VSIX stream: ${err.message}`));\n      });\n\n      this.zipFile.end();\n    });\n  }\n\n  /**\n   * Finalize ZIP to buffer\n   */\n  private async finalizeZipToBuffer(): Promise<Buffer> {\n    if (!this.zipFile) {\n      throw new Error('ZIP file not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const chunks: Buffer[] = [];\n\n      this.zipFile.outputStream.on('data', (chunk: Buffer) => {\n        chunks.push(chunk);\n      });\n\n      this.zipFile.outputStream.on('end', () => {\n        resolve(Buffer.concat(chunks));\n      });\n\n      this.zipFile.outputStream.on('error', (err: Error) => {\n        reject(new Error(`Failed to create VSIX buffer: ${err.message}`));\n      });\n\n      this.zipFile.end();\n    });\n  }\n\n  /**\n   * Close and cleanup resources\n   */\n  async close(): Promise<void> {\n    // ZIP file is automatically closed after end()\n    this.zipFile = null;\n  }\n}\n", "/**\n * Filesystem Manifest Writer - Write modified manifests to filesystem\n *\n * Writes extension and task manifests back to the filesystem and generates\n * an overrides.json file for tfx to use during packaging.\n */\n\nimport { mkdir, readFile, readdir, writeFile } from 'fs/promises';\nimport path from 'path';\nimport type { FilesystemManifestReader } from './filesystem-manifest-reader.js';\nimport type { ManifestEditor } from './manifest-editor.js';\nimport type { ExtensionManifest, TaskManifest } from './manifest-reader.js';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * FilesystemManifestWriter - Write manifests to filesystem\n *\n * Writes modified extension and task manifests directly to filesystem files.\n * Also generates an overrides.json file in the temp directory that tfx can\n * use to override values during packaging without modifying source files.\n *\n * Example usage:\n * ```typescript\n * const reader = new FilesystemManifestReader({ rootFolder: './src', platform });\n * const editor = ManifestEditor.fromReader(reader);\n * editor.setVersion('2.0.0');\n * await editor.updateAllTaskVersions('2.0.0', 'major');\n *\n * const writer = await editor.toWriter();\n * await writer.writeToFilesystem();\n * await writer.close();\n *\n * // Use writer.getOverridesPath() with tfx --overrides-file\n * ```\n */\nexport class FilesystemManifestWriter {\n  private readonly editor: ManifestEditor;\n  private readonly platform: IPlatformAdapter;\n  private overridesPath: string | null = null;\n\n  private constructor(editor: ManifestEditor, platform: IPlatformAdapter) {\n    this.editor = editor;\n    this.platform = platform;\n  }\n\n  /**\n   * Create a writer from an editor\n   * @param editor The editor with modifications\n   * @returns FilesystemManifestWriter instance\n   */\n  static fromEditor(editor: ManifestEditor): FilesystemManifestWriter {\n    const reader = editor.getReader();\n\n    // Ensure reader is a FilesystemManifestReader\n    if (reader.constructor.name !== 'FilesystemManifestReader') {\n      throw new Error('FilesystemManifestWriter can only be used with FilesystemManifestReader');\n    }\n\n    // Get platform from reader (we need it for file operations)\n    const fsReader = reader as FilesystemManifestReader;\n    const platform = (fsReader as any).platform as IPlatformAdapter;\n\n    return new FilesystemManifestWriter(editor, platform);\n  }\n\n  /**\n   * Write modified manifests to the filesystem\n   *\n   * This updates task.json files directly and writes extension manifest changes.\n   * It also generates an overrides.json in the temp directory that can be passed\n   * to tfx with --overrides-file.\n   *\n   * @returns Promise that resolves when writing is complete\n   */\n  async writeToFilesystem(): Promise<void> {\n    const reader = this.editor.getReader() as FilesystemManifestReader;\n    const rootFolder = (reader as any).getRootFolder() as string;\n\n    const manifestMods = this.editor.getManifestModifications();\n    const taskManifestMods = this.editor.getTaskManifestModifications();\n    const fileMods = this.editor.getModifications();\n\n    this.platform.debug('Writing manifests to filesystem...');\n\n    // Optional: synchronize extension manifest binary file entries\n    let synchronizedManifests: Array<{ manifestPath: string; manifest: ExtensionManifest }> = [];\n    if (this.editor.shouldSynchronizeBinaryFileEntries()) {\n      synchronizedManifests = await this.synchronizeBinaryFileEntries(reader, rootFolder);\n    }\n\n    // Step 1: Write task manifest modifications\n    if (taskManifestMods.size > 0) {\n      await this.writeTaskManifests(reader, rootFolder, taskManifestMods);\n    }\n\n    // Step 2: Write extension manifest modifications (if directly modifying source)\n    // Note: For package command, we typically use overrides.json instead\n    // But we support direct writes for other scenarios\n    if (Object.keys(manifestMods).length > 0 || synchronizedManifests.length > 0) {\n      await this.writeSynchronizedManifests(reader, manifestMods, synchronizedManifests);\n    }\n\n    // Step 3: Write any additional file modifications\n    for (const [filePath, mod] of fileMods) {\n      if (mod.type === 'modify' && mod.content) {\n        const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(rootFolder, filePath);\n\n        this.platform.debug(`Writing file: ${absolutePath}`);\n        await writeFile(absolutePath, new Uint8Array(mod.content));\n      }\n    }\n\n    // Step 4: Generate overrides.json for extension manifest overrides\n    // This is used by tfx during packaging to override values without modifying source\n    await this.generateOverridesFile(manifestMods);\n\n    this.platform.info('Manifests written to filesystem successfully');\n  }\n\n  /**\n   * Write task manifest modifications to filesystem\n   */\n  private async writeTaskManifests(\n    reader: FilesystemManifestReader,\n    rootFolder: string,\n    taskManifestMods: Map<string, Partial<TaskManifest>>\n  ): Promise<void> {\n    const tasks = await reader.readTaskManifests();\n    const appliedTaskNames = new Set<string>();\n\n    // Get packagePath map to resolve actual source paths\n    const packagePathMap = (await (reader as any).buildPackagePathMap()) as Map<string, string>;\n\n    for (const { path: taskPath, manifest } of tasks) {\n      const mods = taskManifestMods.get(manifest.name);\n      if (mods) {\n        appliedTaskNames.add(manifest.name);\n        // Apply modifications\n        Object.assign(manifest, mods);\n\n        // Resolve actual source path using prefix matching (same logic as reader)\n        let actualPath = taskPath;\n        const normalizedTaskPath = taskPath.replace(/\\\\/g, '/');\n\n        // Try to find a matching packagePath prefix\n        for (const [pkgPath, sourcePath] of packagePathMap.entries()) {\n          const normalizedPkgPath = pkgPath.replace(/\\\\/g, '/');\n\n          // Check for exact match or prefix match (packagePath/subdir)\n          if (normalizedTaskPath === normalizedPkgPath) {\n            // Exact match: TaskName \u2192 sourcePath\n            actualPath = sourcePath;\n            break;\n          } else if (normalizedTaskPath.startsWith(normalizedPkgPath + '/')) {\n            // Prefix match: TaskName/v2 \u2192 sourcePath/v2\n            const remainder = normalizedTaskPath.substring(normalizedPkgPath.length + 1);\n            actualPath = path.join(sourcePath, remainder);\n            break;\n          }\n        }\n\n        this.platform.debug(\n          `Writing task manifest: taskPath='${taskPath}', actualPath='${actualPath}'`\n        );\n\n        // Resolve absolute path\n        const absoluteTaskPath = path.isAbsolute(actualPath)\n          ? actualPath\n          : path.join(rootFolder, actualPath);\n\n        const taskJsonPath = path.join(absoluteTaskPath, 'task.json');\n\n        this.platform.debug(`Writing to file: ${taskJsonPath}`);\n        const manifestJson = JSON.stringify(manifest, null, 2) + '\\n';\n        await writeFile(taskJsonPath, manifestJson, 'utf-8');\n      }\n    }\n\n    // Fallback: apply modifications for tasks not discoverable via contribution paths\n    for (const [taskName, mods] of taskManifestMods.entries()) {\n      if (appliedTaskNames.has(taskName)) {\n        continue;\n      }\n\n      const fallbackTaskDir = await this.findTaskDirectoryByName(rootFolder, taskName);\n      if (!fallbackTaskDir) {\n        this.platform.debug(`No task.json found for task '${taskName}' during fallback write`);\n        continue;\n      }\n\n      const taskJsonPath = path.join(fallbackTaskDir, 'task.json');\n      const content = (await readFile(taskJsonPath)).toString('utf8');\n      const manifest = JSON.parse(content) as TaskManifest;\n      Object.assign(manifest, mods);\n\n      this.platform.debug(`Fallback writing task manifest: ${taskJsonPath}`);\n      await writeFile(taskJsonPath, JSON.stringify(manifest, null, 2) + '\\n', 'utf-8');\n    }\n  }\n\n  /**\n   * Recursively find a task directory by task manifest name\n   */\n  private async findTaskDirectoryByName(\n    rootFolder: string,\n    taskName: string\n  ): Promise<string | null> {\n    const stack: string[] = [rootFolder];\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n      let entries;\n\n      try {\n        entries = await readdir(current, { withFileTypes: true });\n      } catch {\n        continue;\n      }\n\n      for (const entry of entries) {\n        const absolutePath = path.join(current, entry.name);\n\n        if (entry.isDirectory()) {\n          stack.push(absolutePath);\n          continue;\n        }\n\n        if (!entry.isFile() || entry.name !== 'task.json') {\n          continue;\n        }\n\n        try {\n          const content = (await readFile(absolutePath)).toString('utf8');\n          const manifest = JSON.parse(content) as TaskManifest;\n          if (manifest.name === taskName) {\n            return path.dirname(absolutePath);\n          }\n        } catch {\n          // ignore unreadable/invalid task manifests during search\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Write extension manifest modifications to filesystem\n   */\n  private async writeExtensionManifest(\n    reader: FilesystemManifestReader,\n    manifestMods: Partial<ExtensionManifest>,\n    baseManifest?: ExtensionManifest\n  ): Promise<void> {\n    const manifest = baseManifest ?? (await reader.readExtensionManifest());\n    Object.assign(manifest, manifestMods);\n\n    // Get manifest path from reader\n    const manifestPath = (reader as any).getManifestPath() as string;\n    if (!manifestPath) {\n      throw new Error('Extension manifest path not resolved');\n    }\n\n    this.platform.debug(`Writing extension manifest: ${manifestPath}`);\n    await this.writeManifestAtPath(manifestPath, manifest);\n  }\n\n  private async writeSynchronizedManifests(\n    reader: FilesystemManifestReader,\n    manifestMods: Partial<ExtensionManifest>,\n    synchronizedManifests: Array<{ manifestPath: string; manifest: ExtensionManifest }>\n  ): Promise<void> {\n    const primaryManifestPath = (reader as any).getManifestPath() as string | null;\n    const synchronizedByPath = new Map<string, ExtensionManifest>(\n      synchronizedManifests.map((item) => [item.manifestPath, item.manifest])\n    );\n\n    // Apply explicit extension manifest modifications to primary manifest only.\n    if (Object.keys(manifestMods).length > 0) {\n      const primaryBaseManifest = primaryManifestPath\n        ? synchronizedByPath.get(primaryManifestPath)\n        : undefined;\n      await this.writeExtensionManifest(reader, manifestMods, primaryBaseManifest);\n\n      if (primaryManifestPath) {\n        synchronizedByPath.delete(primaryManifestPath);\n      }\n    }\n\n    // Write remaining synchronized manifests without extension-level overrides.\n    for (const [manifestPath, manifest] of synchronizedByPath) {\n      this.platform.debug(`Writing synchronized extension manifest: ${manifestPath}`);\n      await this.writeManifestAtPath(manifestPath, manifest);\n    }\n  }\n\n  private async writeManifestAtPath(\n    manifestPath: string,\n    manifest: ExtensionManifest\n  ): Promise<void> {\n    const manifestJson = JSON.stringify(manifest, null, 2) + '\\n';\n    await writeFile(manifestPath, manifestJson, 'utf-8');\n  }\n\n  /**\n   * Synchronize extension manifest file entries for extensionless files.\n   *\n   * Behavior ported from the legacy manifest-fix workflow:\n   * 1) Remove all explicit application/octet-stream file entries\n   * 2) Re-scan manifest-referenced directories\n   * 3) Add extensionless files back as application/octet-stream\n   *\n   * packagePath mapping is preserved for added file entries.\n   */\n  private async synchronizeBinaryFileEntries(\n    reader: FilesystemManifestReader,\n    rootFolder: string\n  ): Promise<Array<{ manifestPath: string; manifest: ExtensionManifest }>> {\n    const allManifests = await reader.readAllExtensionManifests();\n\n    if (allManifests.length === 0) {\n      this.platform.debug('No extension manifest files array found; skipping binary file sync');\n      return [];\n    }\n\n    const changedManifests: Array<{ manifestPath: string; manifest: ExtensionManifest }> = [];\n    let totalRemovedCount = 0;\n    let totalAddedCount = 0;\n\n    for (const { path: manifestPath, manifest } of allManifests) {\n      const originalFiles = Array.isArray(manifest.files) ? manifest.files : [];\n      if (originalFiles.length === 0) {\n        continue;\n      }\n\n      const retainedFiles = originalFiles.filter(\n        (entry) => entry.contentType !== 'application/octet-stream'\n      );\n      const removedCount = originalFiles.length - retainedFiles.length;\n      totalRemovedCount += removedCount;\n\n      const scanRoots = await this.getManifestDirectoryScanRoots(rootFolder, retainedFiles);\n\n      const existingKeys = new Set<string>();\n      for (const entry of retainedFiles) {\n        existingKeys.add(this.getManifestEntryKey(entry.path, entry.packagePath));\n      }\n\n      const addedEntries: Array<{ path: string; packagePath?: string; contentType: string }> = [];\n\n      for (const scanRoot of scanRoots) {\n        const files = await this.collectFilesRecursive(scanRoot.absolutePath);\n\n        for (const absoluteFilePath of files) {\n          const fileName = path.basename(absoluteFilePath);\n          if (!this.isExtensionlessFileName(fileName)) {\n            continue;\n          }\n\n          const relativeInsideRoot = this.toPosixPath(\n            path.relative(scanRoot.absolutePath, absoluteFilePath)\n          );\n\n          const filePath = this.joinManifestPath(scanRoot.manifestPathPrefix, relativeInsideRoot);\n          const packagePath = scanRoot.packagePathPrefix\n            ? this.joinManifestPath(scanRoot.packagePathPrefix, relativeInsideRoot)\n            : undefined;\n\n          const key = this.getManifestEntryKey(filePath, packagePath);\n          if (existingKeys.has(key)) {\n            continue;\n          }\n\n          existingKeys.add(key);\n          addedEntries.push({\n            path: filePath,\n            packagePath,\n            contentType: 'application/octet-stream',\n          });\n        }\n      }\n\n      totalAddedCount += addedEntries.length;\n\n      if (removedCount > 0 || addedEntries.length > 0) {\n        manifest.files = [...retainedFiles, ...addedEntries];\n        changedManifests.push({ manifestPath, manifest });\n      }\n    }\n\n    if (changedManifests.length === 0) {\n      this.platform.debug('Binary file sync: no changes required');\n      return [];\n    }\n\n    this.platform.info(\n      `Synchronized binary file entries in extension manifests (removed ${totalRemovedCount}, added ${totalAddedCount})`\n    );\n    return changedManifests;\n  }\n\n  private async getManifestDirectoryScanRoots(\n    rootFolder: string,\n    fileEntries: Array<{ path: string; packagePath?: string }>\n  ): Promise<\n    Array<{ absolutePath: string; manifestPathPrefix: string; packagePathPrefix?: string }>\n  > {\n    const roots: Array<{\n      absolutePath: string;\n      manifestPathPrefix: string;\n      packagePathPrefix?: string;\n    }> = [];\n\n    for (const entry of fileEntries) {\n      if (!entry.path) {\n        continue;\n      }\n\n      const absolutePath = path.isAbsolute(entry.path)\n        ? entry.path\n        : path.join(rootFolder, entry.path.replace(/\\//g, path.sep));\n\n      let stats;\n      try {\n        stats = await readdir(absolutePath, { withFileTypes: true });\n      } catch {\n        continue;\n      }\n\n      // If directory is readable, we consider it a scan root\n      if (Array.isArray(stats)) {\n        roots.push({\n          absolutePath,\n          manifestPathPrefix: this.toPosixPath(entry.path),\n          packagePathPrefix: entry.packagePath ? this.toPosixPath(entry.packagePath) : undefined,\n        });\n      }\n    }\n\n    return roots;\n  }\n\n  private async collectFilesRecursive(directory: string): Promise<string[]> {\n    const files: string[] = [];\n    const entries = await readdir(directory, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const absolutePath = path.join(directory, entry.name);\n\n      if (entry.isDirectory()) {\n        const nestedFiles = await this.collectFilesRecursive(absolutePath);\n        files.push(...nestedFiles);\n      } else if (entry.isFile()) {\n        files.push(absolutePath);\n      }\n    }\n\n    return files;\n  }\n\n  private isExtensionlessFileName(fileName: string): boolean {\n    return !/\\.[^.]+$/.test(fileName) || fileName.endsWith('.');\n  }\n\n  private toPosixPath(inputPath: string): string {\n    return inputPath.replace(/\\\\/g, '/').replace(/^\\.\\//, '');\n  }\n\n  private joinManifestPath(basePath: string, relativePath: string): string {\n    const normalizedBase = this.toPosixPath(basePath).replace(/\\/$/, '');\n    const normalizedRelative = this.toPosixPath(relativePath).replace(/^\\//, '');\n    if (!normalizedRelative) {\n      return normalizedBase;\n    }\n    return `${normalizedBase}/${normalizedRelative}`;\n  }\n\n  private getManifestEntryKey(filePath: string, packagePath?: string): string {\n    const normalizedPath = this.toPosixPath(filePath);\n    const normalizedPackagePath = packagePath ? this.toPosixPath(packagePath) : '';\n    return `${normalizedPath}::${normalizedPackagePath}`;\n  }\n\n  /**\n   * Generate overrides.json file in temp directory\n   *\n   * This file can be passed to tfx with --overrides-file to override\n   * extension manifest values during packaging without modifying source files.\n   */\n  private async generateOverridesFile(manifestMods: Partial<ExtensionManifest>): Promise<void> {\n    if (Object.keys(manifestMods).length === 0) {\n      this.platform.debug('No manifest modifications, skipping overrides.json generation');\n      return;\n    }\n\n    // Create overrides object with only the fields that should be overridden\n    const overrides: any = {};\n\n    if (manifestMods.publisher) {\n      overrides.publisher = manifestMods.publisher;\n    }\n\n    if (manifestMods.id) {\n      overrides.id = manifestMods.id;\n    }\n\n    if (manifestMods.version) {\n      overrides.version = manifestMods.version;\n    }\n\n    if (manifestMods.name) {\n      overrides.name = manifestMods.name;\n    }\n\n    if (manifestMods.description) {\n      overrides.description = manifestMods.description;\n    }\n\n    if (manifestMods.galleryFlags) {\n      overrides.galleryFlags = manifestMods.galleryFlags;\n    }\n\n    // Write to temp directory\n    const tempDir = this.platform.getTempDir();\n    await mkdir(tempDir, { recursive: true });\n    this.overridesPath = path.join(tempDir, `overrides-${Date.now()}.json`);\n\n    this.platform.debug(`Writing overrides file: ${this.overridesPath}`);\n    const overridesJson = JSON.stringify(overrides, null, 2) + '\\n';\n    await writeFile(this.overridesPath, overridesJson, 'utf-8');\n\n    this.platform.info(`Generated overrides file: ${this.overridesPath}`);\n  }\n\n  /**\n   * Get the path to the generated overrides.json file\n   * This can be passed to tfx with --overrides-file\n   * @returns Path to overrides.json or null if not generated\n   */\n  getOverridesPath(): string | null {\n    return this.overridesPath;\n  }\n\n  /**\n   * Close and cleanup resources\n   */\n  async close(): Promise<void> {\n    // Could clean up overrides file here, but we leave it for tfx to use\n    // Temp directory will be cleaned up by the build agent\n  }\n}\n", "/**\n * Manifest Editor - Unified manifest editing for both VSIX and filesystem sources\n *\n * Provides chainable API for modifying extension and task manifests.\n * Tracks modifications without writing until toWriter() is called.\n * Works with any ManifestReader implementation (VSIX or filesystem).\n *\n * Centralizes all logic for calculating UUIDs, updating task versions, etc.\n */\n\nimport { Buffer } from 'buffer';\nimport { v5 as uuidv5 } from 'uuid';\nimport type { ExtensionManifest, ManifestReader, TaskManifest } from './manifest-reader.js';\n\n/**\n * Tracks a file modification\n */\ninterface FileModification {\n  type: 'add' | 'modify' | 'remove';\n  path: string;\n  content?: Buffer;\n}\n\n/**\n * Options for creating a ManifestEditor\n */\nexport interface ManifestEditorOptions {\n  reader: ManifestReader;\n}\n\n/**\n * Options for applying changes to manifests\n * Contains all possible modifications that can be made to an extension\n */\nexport interface ApplyManifestOptions {\n  // Extension manifest overrides\n  publisherId?: string;\n  extensionId?: string;\n  extensionVersion?: string;\n  extensionName?: string;\n  extensionVisibility?: 'public' | 'private' | 'public_preview' | 'private_preview';\n  extensionPricing?: 'free' | 'paid' | 'trial';\n\n  // Task updates\n  updateTasksVersion?: boolean;\n  updateTasksVersionType?: 'major' | 'minor' | 'patch';\n  updateTasksId?: boolean;\n\n  // Manifest file updates\n  synchronizeBinaryFileEntries?: boolean;\n}\n\n/**\n * ManifestEditor - Unified editor for extension and task manifests\n *\n * Works with any ManifestReader (VsixReader, FilesystemManifestReader, etc.)\n * Provides chainable API for modifications and centralizes all manifest\n * editing logic including UUID generation and task version calculations.\n *\n * Example usage with VSIX:\n * ```typescript\n * const reader = await VsixReader.open('input.vsix');\n * const editor = ManifestEditor.fromReader(reader);\n * await editor\n *   .setPublisher('new-publisher')\n *   .setVersion('2.0.0')\n *   .updateAllTaskVersions('2.0.0', 'major')\n *   .updateAllTaskIds();\n * const writer = await editor.toWriter();\n * await writer.writeToFile('output.vsix');\n * ```\n *\n * Example usage with filesystem:\n * ```typescript\n * const reader = new FilesystemManifestReader({ rootFolder: './src', platform });\n * const editor = ManifestEditor.fromReader(reader);\n * await editor\n *   .setVersion('1.5.0')\n *   .updateAllTaskVersions('1.5.0', 'minor');\n * const writer = await editor.toWriter();\n * await writer.writeToFilesystem('./dist');\n * ```\n */\nexport class ManifestEditor {\n  private readonly reader: ManifestReader;\n  private modifications: Map<string, FileModification> = new Map();\n  private manifestModifications: Partial<ExtensionManifest> = {};\n  private taskManifestModifications: Map<string, Partial<TaskManifest>> = new Map();\n  private synchronizeBinaryFileEntries = false;\n\n  // Track original task IDs for updating extension manifest references\n  private taskIdUpdates: Map<string, { oldId: string; newId: string }> = new Map();\n\n  constructor(options: ManifestEditorOptions) {\n    this.reader = options.reader;\n  }\n\n  /**\n   * Create an editor from a reader\n   * @param reader The manifest reader (VSIX or filesystem)\n   * @returns ManifestEditor instance\n   */\n  static fromReader(reader: ManifestReader): ManifestEditor {\n    return new ManifestEditor({ reader });\n  }\n\n  /**\n   * Apply a set of options to the manifest\n   * This is the main entry point for batch modifications\n   * All conditional logic for applying changes is contained here\n   *\n   * @param options Options to apply\n   * @returns Promise<this> for async chaining\n   */\n  async applyOptions(options: ApplyManifestOptions): Promise<this> {\n    // Apply extension manifest overrides\n    if (options.publisherId) {\n      this.setPublisher(options.publisherId);\n    }\n\n    // Handle extension ID\n    if (options.extensionId) {\n      this.setExtensionId(options.extensionId);\n    }\n\n    if (options.extensionVersion) {\n      this.setVersion(options.extensionVersion);\n    }\n\n    if (options.extensionName) {\n      this.setName(options.extensionName);\n    }\n\n    if (options.extensionVisibility) {\n      this.setVisibility(options.extensionVisibility);\n    }\n\n    if (options.extensionPricing) {\n      this.setPricing(options.extensionPricing);\n    }\n\n    // Apply task updates\n    if (options.updateTasksVersion && options.extensionVersion) {\n      const versionType = options.updateTasksVersionType || 'major';\n      await this.updateAllTaskVersions(options.extensionVersion, versionType);\n    }\n\n    if (options.updateTasksId) {\n      await this.updateAllTaskIds();\n    }\n\n    if (options.synchronizeBinaryFileEntries) {\n      this.synchronizeBinaryFileEntries = true;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the publisher ID\n   * @param publisher New publisher ID\n   * @returns This editor for chaining\n   */\n  setPublisher(publisher: string): this {\n    this.manifestModifications.publisher = publisher;\n    return this;\n  }\n\n  /**\n   * Set the extension ID\n   * @param id New extension ID\n   * @returns This editor for chaining\n   */\n  setExtensionId(id: string): this {\n    this.manifestModifications.id = id;\n    return this;\n  }\n\n  /**\n   * Set the extension version\n   * @param version New version (e.g., \"1.2.3\")\n   * @returns This editor for chaining\n   */\n  setVersion(version: string): this {\n    this.manifestModifications.version = version;\n    return this;\n  }\n\n  /**\n   * Set the extension name\n   * @param name New display name\n   * @returns This editor for chaining\n   */\n  setName(name: string): this {\n    this.manifestModifications.name = name;\n    return this;\n  }\n\n  /**\n   * Set the extension description\n   * @param description New description\n   * @returns This editor for chaining\n   */\n  setDescription(description: string): this {\n    this.manifestModifications.description = description;\n    return this;\n  }\n\n  /**\n   * Set extension visibility in gallery\n   * @param visibility 'public', 'private', 'public_preview', or 'private_preview'\n   * @returns This editor for chaining\n   */\n  setVisibility(visibility: 'public' | 'private' | 'public_preview' | 'private_preview'): this {\n    if (!this.manifestModifications.galleryFlags) {\n      this.manifestModifications.galleryFlags = [];\n    }\n    const flags = this.manifestModifications.galleryFlags;\n\n    // Remove existing visibility flags\n    const visibilityFlags = ['Public', 'Private', 'Preview'];\n    for (const flag of visibilityFlags) {\n      const index = flags.indexOf(flag);\n      if (index >= 0) {\n        flags.splice(index, 1);\n      }\n    }\n\n    // Add new flags based on visibility\n    if (visibility === 'public') {\n      flags.push('Public');\n    } else if (visibility === 'private') {\n      flags.push('Private');\n    } else if (visibility === 'public_preview') {\n      flags.push('Public', 'Preview');\n    } else if (visibility === 'private_preview') {\n      flags.push('Private', 'Preview');\n    }\n\n    return this;\n  }\n\n  /**\n   * Set extension pricing model\n   * @param pricing 'free', 'paid', or 'trial'\n   * @returns This editor for chaining\n   */\n  setPricing(pricing: 'free' | 'paid' | 'trial'): this {\n    if (!this.manifestModifications.galleryFlags) {\n      this.manifestModifications.galleryFlags = [];\n    }\n    const flags = this.manifestModifications.galleryFlags;\n\n    // Remove existing pricing flags\n    const pricingFlags = ['Free', 'Paid', 'Trial'];\n    for (const flag of pricingFlags) {\n      const index = flags.indexOf(flag);\n      if (index >= 0) {\n        flags.splice(index, 1);\n      }\n    }\n\n    // Add new flag\n    const flagMap = { free: 'Free', paid: 'Paid', trial: 'Trial' };\n    flags.push(flagMap[pricing]);\n\n    return this;\n  }\n\n  /**\n   * Update a specific task's version\n   * @param taskName Name of the task\n   * @param extensionVersion Extension version to apply (e.g., \"1.2.3\")\n   * @param versionType How to apply the version: 'major', 'minor', or 'patch'\n   * @returns This editor for chaining\n   */\n  updateTaskVersion(\n    taskName: string,\n    extensionVersion: string,\n    versionType: 'major' | 'minor' | 'patch' = 'major'\n  ): this {\n    const versionParts = extensionVersion.split('.');\n    if (versionParts.length > 3) {\n      // Warning: version has more than 3 parts\n      // Taking only first 3\n    }\n\n    const newVersion = {\n      major: parseInt(versionParts[0], 10) || 0,\n      minor: parseInt(versionParts[1], 10) || 0,\n      patch: parseInt(versionParts[2], 10) || 0,\n    };\n\n    if (!this.taskManifestModifications.has(taskName)) {\n      this.taskManifestModifications.set(taskName, {});\n    }\n\n    const taskMods = this.taskManifestModifications.get(taskName);\n\n    // Get existing version from modifications or we'll read it when applying\n    const existingVersion = taskMods.version || { Major: 0, Minor: 0, Patch: 0 };\n\n    // Apply version update based on type (cascading per v5 logic)\n    switch (versionType) {\n      case 'major':\n        taskMods.version = {\n          Major: newVersion.major,\n          Minor: newVersion.minor,\n          Patch: newVersion.patch,\n        };\n        break;\n      case 'minor':\n        taskMods.version = {\n          Major: existingVersion.Major,\n          Minor: newVersion.minor,\n          Patch: newVersion.patch,\n        };\n        break;\n      case 'patch':\n        taskMods.version = {\n          Major: existingVersion.Major,\n          Minor: existingVersion.Minor,\n          Patch: newVersion.patch,\n        };\n        break;\n    }\n\n    return this;\n  }\n\n  /**\n   * Update a specific task's ID (UUID) using v5 namespacing\n   * @param taskName Name of the task\n   * @param publisherId Publisher ID (for UUID generation)\n   * @param extensionId Extension ID (for UUID generation)\n   * @returns This editor for chaining\n   */\n  updateTaskId(taskName: string, publisherId: string, extensionId: string): this {\n    // Generate deterministic UUID v5 based on publisher, extension, and task name\n    // This matches v5 implementation exactly\n    const marketplaceNamespace = uuidv5('https://marketplace.visualstudio.com/vsts', uuidv5.URL);\n    const taskNamespace = `${publisherId}.${extensionId}.${taskName}`;\n    const newId = uuidv5(taskNamespace, marketplaceNamespace);\n\n    if (!this.taskManifestModifications.has(taskName)) {\n      this.taskManifestModifications.set(taskName, {});\n    }\n\n    const taskMods = this.taskManifestModifications.get(taskName);\n\n    // Store old ID for updating extension manifest references later\n    // We'll read the old ID when applying modifications\n    taskMods.id = newId;\n\n    return this;\n  }\n\n  /**\n   * Update all tasks' versions in the extension\n   * Reads all tasks from the reader and updates their versions\n   * @param extensionVersion Extension version to apply\n   * @param versionType How to apply the version: 'major', 'minor', or 'patch'\n   * @returns Promise<this> for async chaining\n   */\n  async updateAllTaskVersions(\n    extensionVersion: string,\n    versionType: 'major' | 'minor' | 'patch' = 'major'\n  ): Promise<this> {\n    const tasks = await this.reader.getTasksInfo();\n    const versionParts = extensionVersion.split('.');\n    const parsedVersion = {\n      major: parseInt(versionParts[0], 10) || 0,\n      minor: parseInt(versionParts[1], 10) || 0,\n      patch: parseInt(versionParts[2], 10) || 0,\n    };\n\n    for (const task of tasks) {\n      const existingParts = (task.version || '0.0.0').split('.');\n      const existingVersion = {\n        Major: parseInt(existingParts[0], 10) || 0,\n        Minor: parseInt(existingParts[1], 10) || 0,\n        Patch: parseInt(existingParts[2], 10) || 0,\n      };\n\n      if (!this.taskManifestModifications.has(task.name)) {\n        this.taskManifestModifications.set(task.name, {});\n      }\n\n      const taskMods = this.taskManifestModifications.get(task.name);\n\n      switch (versionType) {\n        case 'major':\n          taskMods.version = {\n            Major: parsedVersion.major,\n            Minor: parsedVersion.minor,\n            Patch: parsedVersion.patch,\n          };\n          break;\n        case 'minor':\n          taskMods.version = {\n            Major: existingVersion.Major,\n            Minor: parsedVersion.minor,\n            Patch: parsedVersion.patch,\n          };\n          break;\n        case 'patch':\n          taskMods.version = {\n            Major: existingVersion.Major,\n            Minor: existingVersion.Minor,\n            Patch: parsedVersion.patch,\n          };\n          break;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Update all tasks' IDs in the extension using v5 namespacing\n   * Reads extension manifest for publisher/ID and all tasks from reader\n   * @returns Promise<this> for async chaining\n   */\n  async updateAllTaskIds(): Promise<this> {\n    const manifest = await this.reader.readExtensionManifest();\n    const publisherId = this.manifestModifications.publisher || manifest.publisher;\n    const extensionId = this.manifestModifications.id || manifest.id;\n\n    const tasks = await this.reader.getTasksInfo();\n\n    for (const task of tasks) {\n      this.updateTaskId(task.name, publisherId, extensionId);\n    }\n\n    return this;\n  }\n\n  /**\n   * Add or modify a file\n   * @param path Path to the file\n   * @param content File content\n   * @returns This editor for chaining\n   */\n  setFile(path: string, content: Buffer | string): this {\n    const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content, 'utf-8');\n    const normalizedPath = path.replace(/\\\\/g, '/');\n\n    this.modifications.set(normalizedPath, {\n      type: 'modify',\n      path: normalizedPath,\n      content: buffer,\n    });\n\n    return this;\n  }\n\n  /**\n   * Remove a file\n   * @param path Path to the file\n   * @returns This editor for chaining\n   */\n  removeFile(path: string): this {\n    const normalizedPath = path.replace(/\\\\/g, '/');\n\n    this.modifications.set(normalizedPath, {\n      type: 'remove',\n      path: normalizedPath,\n    });\n\n    return this;\n  }\n\n  /**\n   * Convert to a writer for output\n   * The writer type depends on the reader type\n   * @returns Promise<Writer> ready to write (VsixWriter or FilesystemManifestWriter)\n   */\n  async toWriter(): Promise<any> {\n    // Dynamically import based on reader type\n    const readerConstructorName = this.reader.constructor.name;\n    const { VsixReader } = await import('./vsix-reader.js');\n    const { FilesystemManifestReader } = await import('./filesystem-manifest-reader.js');\n\n    if (this.reader instanceof VsixReader || readerConstructorName === 'VsixReader') {\n      const { VsixWriter } = await import('./vsix-writer.js');\n      return VsixWriter.fromEditor(this);\n    }\n\n    if (\n      this.reader instanceof FilesystemManifestReader ||\n      readerConstructorName === 'FilesystemManifestReader'\n    ) {\n      const { FilesystemManifestWriter } = await import('./filesystem-manifest-writer.js');\n      return FilesystemManifestWriter.fromEditor(this);\n    }\n\n    throw new Error(`Unsupported reader type: ${readerConstructorName}`);\n  }\n\n  /**\n   * Get the source reader\n   * @internal\n   */\n  getReader(): ManifestReader {\n    return this.reader;\n  }\n\n  /**\n   * Get all file modifications\n   * @internal\n   */\n  getModifications(): Map<string, FileModification> {\n    return this.modifications;\n  }\n\n  /**\n   * Get manifest modifications\n   * @internal\n   */\n  getManifestModifications(): Partial<ExtensionManifest> {\n    return this.manifestModifications;\n  }\n\n  /**\n   * Get task manifest modifications\n   * @internal\n   */\n  getTaskManifestModifications(): Map<string, Partial<TaskManifest>> {\n    return this.taskManifestModifications;\n  }\n\n  /**\n   * Get task ID updates (for updating extension manifest references)\n   * @internal\n   */\n  getTaskIdUpdates(): Map<string, { oldId: string; newId: string }> {\n    return this.taskIdUpdates;\n  }\n\n  /**\n   * Indicates whether filesystem writer should synchronize extension binary file entries\n   * @internal\n   */\n  shouldSynchronizeBinaryFileEntries(): boolean {\n    return this.synchronizeBinaryFileEntries;\n  }\n}\n", "module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n", "'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,(?!,).*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n", "module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = (function () { try { return require('path') } catch (e) {}}()) || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  b = b || {}\n  var t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n  this.partial = !!options.partial\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nvar MAX_PATTERN_LENGTH = 1024 * 64\nvar assertValidPattern = function (pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar)\n      return GLOBSTAR\n    else\n      pattern = '*'\n  }\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      /* istanbul ignore next */\n      case '/': {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i)\n        try {\n          RegExp('[' + cs + ']')\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE)\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n          hasMagic = hasMagic || sp[1]\n          inClass = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '[': case '.': case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = function match (f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      hit = f === p\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n", "import * as core from '@actions/core';\nimport {\n  installExtension,\n  packageExtension,\n  publishExtension,\n  queryVersion,\n  shareExtension,\n  showExtension,\n  TaskResult,\n  TfxManager,\n  unpublishExtension,\n  unshareExtension,\n  validateAccountUrl,\n  validateAzureCliAvailable,\n  validateExtensionId,\n  validateNodeAvailable,\n  validateNpmAvailable,\n  validatePublisherId,\n  validateTfxAvailable,\n  validateVersion,\n  waitForInstallation,\n  waitForValidation,\n} from '@extension-tasks/core';\nimport { AuthType, getAuth } from './auth/index.js';\nimport { GitHubAdapter } from './github-adapter.js';\n\nasync function run(): Promise<void> {\n  try {\n    const platform = new GitHubAdapter();\n\n    // Validate node is available (always required)\n    await validateNodeAvailable(platform);\n\n    // Get the operation to perform\n    const operation = platform.getInput('operation', true);\n    if (!operation) {\n      throw new Error('Operation is required');\n    }\n\n    platform.debug(`Starting operation: ${operation}`);\n\n    // Validate common inputs early to fail fast\n    const publisherId = platform.getInput('publisher-id');\n    if (publisherId) {\n      validatePublisherId(publisherId);\n    }\n\n    const extensionId = platform.getInput('extension-id');\n    if (extensionId) {\n      validateExtensionId(extensionId);\n    }\n\n    const extensionVersion = platform.getInput('extension-version');\n    if (extensionVersion) {\n      validateVersion(extensionVersion);\n    }\n\n    // Create TfxManager\n    const tfxVersion = platform.getInput('tfx-version') || 'built-in';\n\n    // Validate binaries based on tfx version mode\n    if (tfxVersion === 'path') {\n      // User wants to use tfx from PATH\n      await validateTfxAvailable(platform);\n    } else if (tfxVersion !== 'built-in') {\n      // Version spec mode - need npm to download\n      await validateNpmAvailable(platform);\n    }\n\n    const tfxManager = new TfxManager({ tfxVersion: tfxVersion, platform });\n\n    // Get authentication if needed (not required for package)\n    let auth;\n    if (operation !== 'package') {\n      const authType = (platform.getInput('auth-type') || 'pat') as AuthType;\n\n      // For OIDC auth, validate Azure CLI is available\n      if (authType === 'oidc') {\n        await validateAzureCliAvailable(platform);\n      }\n\n      // Get authentication credentials with optional service/marketplace URLs\n      const token = platform.getInput('token');\n      const username = platform.getInput('username');\n      const password = platform.getInput('password');\n      const serviceUrl = platform.getInput('service-url');\n\n      auth = await getAuth(authType, platform, {\n        token,\n        username,\n        password,\n        serviceUrl,\n      });\n\n      // Secret masking is now handled inside auth providers\n      // But we keep this as defense in depth\n      if (auth.token) {\n        platform.setSecret(auth.token);\n      }\n      if (auth.password) {\n        platform.setSecret(auth.password);\n      }\n\n      // Validate service URL if present\n      if (auth.serviceUrl) {\n        validateAccountUrl(auth.serviceUrl);\n      }\n    }\n\n    // Validate account URLs for operations that need them\n    if (operation === 'install' || operation === 'wait-for-installation') {\n      const accounts = platform.getDelimitedInput('accounts', ';', false);\n      accounts.forEach((account) => {\n        if (account) {\n          validateAccountUrl(account);\n        }\n      });\n    }\n\n    // Route to appropriate command\n    switch (operation) {\n      case 'package':\n        await runPackage(platform, tfxManager);\n        break;\n\n      case 'publish':\n        await runPublish(platform, tfxManager, auth);\n        break;\n\n      case 'unpublish':\n        await runUnpublish(platform, tfxManager, auth);\n        break;\n\n      case 'share':\n        await runShare(platform, tfxManager, auth);\n        break;\n\n      case 'unshare':\n        await runUnshare(platform, tfxManager, auth);\n        break;\n\n      case 'install':\n        await runInstall(platform, tfxManager, auth);\n        break;\n\n      case 'show':\n        await runShow(platform, tfxManager, auth);\n        break;\n\n      case 'query-version':\n        await runQueryVersion(platform, tfxManager, auth);\n        break;\n\n      case 'wait-for-validation':\n        await runWaitForValidation(platform, tfxManager, auth);\n        break;\n\n      case 'wait-for-installation':\n        await runWaitForInstallation(platform, auth);\n        break;\n\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    platform.info('\u2705 Operation completed successfully');\n    platform.setResult(TaskResult.Succeeded, `${operation} completed successfully`);\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    core.setFailed(message);\n  }\n}\n\nasync function runPackage(platform: GitHubAdapter, tfxManager: TfxManager): Promise<void> {\n  const options = {\n    rootFolder: platform.getInput('root-folder'),\n    manifestGlobs: platform.getDelimitedInput('manifest-globs', '\\n'),\n    publisherId: platform.getInput('publisher-id'),\n    extensionId: platform.getInput('extension-id'),\n    extensionVersion: platform.getInput('extension-version'),\n    extensionName: platform.getInput('extension-name'),\n    extensionVisibility: platform.getInput('extension-visibility') as any,\n    updateTasksVersion: platform.getBoolInput('update-tasks-version'),\n    updateTasksId: platform.getBoolInput('update-tasks-id'),\n    outputPath: platform.getInput('output-path'),\n    bypassValidation: platform.getBoolInput('bypass-validation'),\n    revVersion: platform.getBoolInput('rev-version'),\n  };\n\n  const result = await packageExtension(options, tfxManager, platform);\n\n  if (result.vsixPath) {\n    platform.setOutput('vsix-path', result.vsixPath);\n  }\n}\n\nasync function runPublish(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const publishSource = platform.getInput('publish-source', true) as 'manifest' | 'vsix';\n\n  const result = await publishExtension(\n    {\n      publishSource,\n      vsixFile: publishSource === 'vsix' ? platform.getInput('vsix-file', true) : undefined,\n      manifestGlobs:\n        publishSource === 'manifest'\n          ? platform.getDelimitedInput('manifest-globs', '\\n', true)\n          : undefined,\n      rootFolder: publishSource === 'manifest' ? platform.getInput('root-folder') : undefined,\n      publisherId: platform.getInput('publisher-id'),\n      extensionId: platform.getInput('extension-id'),\n      extensionVersion: platform.getInput('extension-version'),\n      extensionName: platform.getInput('extension-name'),\n      extensionVisibility: platform.getInput('extension-visibility') as any,\n      shareWith: platform.getDelimitedInput('share-with', '\\n'),\n      noWaitValidation: platform.getBoolInput('no-wait-validation'),\n      bypassValidation: platform.getBoolInput('bypass-validation'),\n      updateTasksVersion: platform.getBoolInput('update-tasks-version'),\n      updateTasksId: platform.getBoolInput('update-tasks-id'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  if (result.vsixPath) {\n    platform.setOutput('vsix-path', result.vsixPath);\n  }\n\n  platform.debug(`Published: ${JSON.stringify(result)}`);\n}\n\nasync function runUnpublish(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  await unpublishExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n}\n\nasync function runShare(platform: GitHubAdapter, tfxManager: TfxManager, auth: any): Promise<void> {\n  await shareExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      shareWith: platform.getDelimitedInput('share-with', '\\n', true),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n}\n\nasync function runUnshare(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  await unshareExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      unshareWith: platform.getDelimitedInput('unshare-with', '\\n', true),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n}\n\nasync function runInstall(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const result = await installExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      accounts: platform.getDelimitedInput('accounts', '\\n', true),\n      extensionVersion: platform.getInput('extension-version'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  if (!result.allSuccess) {\n    throw new Error(`Some accounts failed to install the extension`);\n  }\n}\n\nasync function runShow(platform: GitHubAdapter, tfxManager: TfxManager, auth: any): Promise<void> {\n  const options = {\n    publisherId: platform.getInput('publisher-id', true),\n    extensionId: platform.getInput('extension-id', true),\n  };\n\n  const result = await showExtension(options, auth, tfxManager, platform);\n\n  if (result.metadata) {\n    platform.setOutput('extension-metadata', JSON.stringify(result.metadata));\n  }\n}\n\nasync function runQueryVersion(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const result = await queryVersion(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      versionAction:\n        (platform.getInput('version-action') as 'None' | 'Major' | 'Minor' | 'Patch') ?? 'None',\n      extensionVersionOverrideVariable: platform.getInput('extension-version-override'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  platform.setOutput('proposed-version', result.proposedVersion);\n  platform.setOutput('current-version', result.currentVersion);\n}\n\nasync function runWaitForValidation(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const result = await waitForValidation(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      rootFolder: platform.getInput('root-folder'),\n      manifestGlobs: platform.getDelimitedInput('manifest-globs', '\\n'),\n      maxRetries: parseInt(platform.getInput('max-retries') || '10'),\n      minTimeout: parseInt(platform.getInput('min-timeout') || '1'),\n      maxTimeout: parseInt(platform.getInput('max-timeout') || '15'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  if (result.status !== 'success') {\n    throw new Error(`Validation failed with status: ${result.status}`);\n  }\n}\n\nasync function runWaitForInstallation(platform: GitHubAdapter, auth: any): Promise<void> {\n  const expectedTasksInput = platform.getInput('expected-tasks');\n  let expectedTasks;\n  if (expectedTasksInput) {\n    try {\n      expectedTasks = JSON.parse(expectedTasksInput);\n    } catch (error) {\n      throw new Error(`Failed to parse expected-tasks: ${error}`);\n    }\n  }\n\n  const result = await waitForInstallation(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      accounts: platform.getDelimitedInput('accounts', '\\n', true),\n      expectedTasks,\n      manifestPath: platform.getInput('manifest-path'),\n      vsixPath: platform.getInput('vsix-path'),\n      timeoutMinutes: parseInt(platform.getInput('timeout-minutes') || '10'),\n      pollingIntervalSeconds: parseInt(platform.getInput('polling-interval-seconds') || '30'),\n    },\n    auth,\n    platform\n  );\n\n  if (!result.success) {\n    throw new Error(`Verification failed - not all tasks are available`);\n  }\n}\n\n// Run the action\nvoid run();\n", "/**\n * Platform abstraction layer interface\n * This interface abstracts ALL platform-specific operations\n */\n\nexport enum TaskResult {\n  Succeeded = 0,\n  Failed = 1,\n  Warning = 2,\n}\n\nexport interface ExecOptions {\n  cwd?: string;\n  env?: Record<string, string>;\n  silent?: boolean;\n  ignoreReturnCode?: boolean;\n  outStream?: NodeJS.WritableStream;\n  errStream?: NodeJS.WritableStream;\n  failOnStdErr?: boolean;\n}\n\nexport interface ExecResult {\n  exitCode: number;\n  stdout: string;\n  stderr: string;\n}\n\n/**\n * Platform adapter interface\n * Implementations provide platform-specific functionality for Azure Pipelines or GitHub Actions\n */\nexport interface IPlatformAdapter {\n  // ===== Input =====\n  getInput(name: string, required?: boolean): string | undefined;\n  getBoolInput(name: string, required?: boolean): boolean;\n  getDelimitedInput(name: string, delimiter: string, required?: boolean): string[];\n\n  // ===== Output =====\n  setOutput(name: string, value: string): void;\n  setResult(result: TaskResult, message: string): void;\n  setVariable(name: string, value: string, isSecret?: boolean, isOutput?: boolean): void;\n  setSecret(value: string): void;\n\n  // ===== Logging =====\n  debug(message: string): void;\n  info(message: string): void;\n  warning(message: string): void;\n  error(message: string): void;\n  isDebugEnabled(): boolean;\n\n  // ===== Execution =====\n  which(tool: string, check?: boolean): Promise<string>;\n  exec(tool: string, args: string[], options?: ExecOptions): Promise<number>;\n\n  // ===== Filesystem =====\n  findMatch(root: string, patterns: string[]): Promise<string[]>;\n  fileExists(path: string): Promise<boolean>;\n  readFile(path: string): Promise<string>;\n  writeFile(path: string, content: string): Promise<void>;\n  mkdirP(path: string): Promise<void>;\n  rmRF(path: string): Promise<void>;\n\n  // ===== Environment =====\n  getVariable(name: string): string | undefined;\n  getTempDir(): string;\n\n  // ===== Tool Management =====\n  cacheDir(sourceDir: string, tool: string, version: string): Promise<string>;\n  findCachedTool(tool: string, version: string): string | undefined;\n  downloadTool(url: string): Promise<string>;\n}\n", "/**\n * Fluent argument builder for constructing tfx CLI arguments\n */\nexport class ArgBuilder {\n  private args: string[] = [];\n\n  /**\n   * Add one or more arguments\n   */\n  arg(values: string | string[]): this {\n    if (Array.isArray(values)) {\n      this.args.push(...values);\n    } else {\n      this.args.push(values);\n    }\n    return this;\n  }\n\n  /**\n   * Add arguments if condition is truthy\n   */\n  argIf(condition: unknown, values: string | string[]): this {\n    if (condition) {\n      return this.arg(values);\n    }\n    return this;\n  }\n\n  /**\n   * Add a flag (e.g., '--json')\n   */\n  flag(name: string): this {\n    this.args.push(name);\n    return this;\n  }\n\n  /**\n   * Add a flag if condition is truthy\n   */\n  flagIf(condition: unknown, name: string): this {\n    if (condition) {\n      return this.flag(name);\n    }\n    return this;\n  }\n\n  /**\n   * Add an option with value (e.g., '--publisher', 'myPublisher')\n   */\n  option(name: string, value: string | undefined): this {\n    if (value !== undefined) {\n      this.args.push(name, value);\n    }\n    return this;\n  }\n\n  /**\n   * Add an option if condition is truthy\n   */\n  optionIf(condition: unknown, name: string, value: string | undefined): this {\n    if (condition && value !== undefined) {\n      return this.option(name, value);\n    }\n    return this;\n  }\n\n  /**\n   * Append raw command line string (split on spaces)\n   */\n  line(raw: string): this {\n    const parts = raw.split(/\\s+/).filter((s) => s.length > 0);\n    this.args.push(...parts);\n    return this;\n  }\n\n  /**\n   * Build and return the argument array\n   */\n  build(): string[] {\n    return [...this.args];\n  }\n}\n", "/**\n * JSON output stream parser for tfx CLI output\n * Parses mixed output from tfx --json --debug-log-stream stderr\n */\n\nimport { Writable } from 'stream';\n\n/**\n * Stream that separates tfx JSON output from debug messages\n * The tfx CLI with --json flag outputs JSON to stdout but also emits\n * debug messages and command echoes. This stream separates them.\n */\nexport class JsonOutputStream extends Writable {\n  /** Accumulated JSON string */\n  public jsonString = '';\n\n  /** Non-JSON messages (debug output, warnings, etc.) */\n  public messages: string[] = [];\n\n  /**\n   * @param lineWriter Function to write non-JSON lines (for logging)\n   */\n  constructor(private lineWriter: (message: string) => void) {\n    super();\n  }\n\n  /**\n   * Process a chunk of data from the stream\n   */\n  _write(\n    chunk: Buffer | string,\n    _encoding: string,\n    callback: (error?: Error | null) => void\n  ): void {\n    const chunkStr = chunk.toString();\n    const trimmed = chunkStr.trimStart();\n\n    // Azure Pipelines task-lib command output\n    if (chunkStr.startsWith('[command]')) {\n      this.writeOutput(chunkStr, this.lineWriter);\n    }\n    // If we haven't started collecting JSON yet and this doesn't look like JSON\n    else if (!this.jsonString && !this.looksLikeJsonStart(trimmed)) {\n      this.messages.push(chunkStr);\n      this.writeOutput(chunkStr, this.lineWriter);\n    }\n    // Accumulate JSON\n    else {\n      this.jsonString += chunkStr;\n      // Don't write JSON to output (will be parsed and processed separately)\n    }\n\n    callback();\n  }\n\n  /**\n   * Detect whether a chunk can be the start of a valid JSON value.\n   */\n  private looksLikeJsonStart(input: string): boolean {\n    if (!input) {\n      return false;\n    }\n\n    return /^(\\{|\\[|\"|-?\\d|true\\b|false\\b|null\\b)/.test(input);\n  }\n\n  /**\n   * Write output line by line (splits on newlines)\n   */\n  private writeOutput(messages: string, writer: (m: string) => void): void {\n    if (!messages) {\n      return;\n    }\n    // Split messages to invoke writer for each line\n    // This ensures proper line prefixing in logging systems\n    messages.split('\\n').forEach((line) => {\n      if (line) {\n        writer(line);\n      }\n    });\n  }\n\n  /**\n   * Parse the accumulated JSON string\n   * @returns Parsed JSON object or undefined if parsing fails\n   */\n  public parseJson<T = unknown>(): T | undefined {\n    if (!this.jsonString) {\n      return undefined;\n    }\n\n    try {\n      return JSON.parse(this.jsonString) as T;\n    } catch (error) {\n      // If JSON parsing fails, log the error and return undefined\n      this.lineWriter(`Failed to parse JSON output: ${error}`);\n      return undefined;\n    }\n  }\n}\n", "/**\n * Manifest utilities for reading, writing, and manipulating extension manifests\n */\n\nimport path from 'path';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * Resolve manifest file paths from root folder and glob patterns\n * @param rootFolder Root directory to search from\n * @param patterns Glob patterns to match (e.g., [\"vss-extension.json\", \"*.json\"])\n * @param platform Platform adapter for filesystem operations\n * @returns Array of resolved manifest file paths\n */\nexport async function resolveManifestPaths(\n  rootFolder: string,\n  patterns: string[],\n  platform: IPlatformAdapter\n): Promise<string[]> {\n  if (!patterns || patterns.length === 0) {\n    return [];\n  }\n\n  const matches = await platform.findMatch(rootFolder, patterns);\n  return matches;\n}\n\n/**\n * Read and parse a manifest file\n * @param manifestPath Path to manifest file\n * @param platform Platform adapter for filesystem operations\n * @returns Parsed manifest object\n */\nexport async function readManifest(\n  manifestPath: string,\n  platform: IPlatformAdapter\n): Promise<unknown> {\n  const content = await platform.readFile(manifestPath);\n  return JSON.parse(content);\n}\n\n/**\n * Write a manifest object to file\n * @param manifest Manifest object to serialize\n * @param manifestPath Path to write to\n * @param platform Platform adapter for filesystem operations\n */\nexport async function writeManifest(\n  manifest: unknown,\n  manifestPath: string,\n  platform: IPlatformAdapter\n): Promise<void> {\n  const content = JSON.stringify(manifest, null, 2);\n  await platform.writeFile(manifestPath, content);\n}\n\n/**\n * Resolve task manifest paths from extension manifest\n * Issue #188: Honor package path mappings when resolving task manifests\n *\n * @param extensionManifest Parsed extension manifest\n * @param extensionManifestPath Path to the extension manifest file\n * @param _platform Platform adapter for filesystem operations (reserved for future use)\n * @returns Array of task manifest file paths\n */\nexport function resolveTaskManifestPaths(\n  extensionManifest: any,\n  extensionManifestPath: string,\n  _platform: IPlatformAdapter\n): string[] {\n  void _platform;\n  // Get task contributions from manifest\n  const taskContributions = getTaskContributions(extensionManifest);\n\n  if (taskContributions.length === 0) {\n    return [];\n  }\n\n  const manifestDir = path.dirname(extensionManifestPath);\n  const taskPaths: string[] = [];\n\n  for (const contrib of taskContributions) {\n    const taskName = contrib.properties?.name;\n    if (!taskName) {\n      continue;\n    }\n\n    // Construct path to task.json\n    const taskManifestPath = path.join(manifestDir, taskName, 'task.json');\n    taskPaths.push(taskManifestPath);\n  }\n\n  return taskPaths;\n}\n\n/**\n * Get task contributions from extension manifest\n */\nfunction getTaskContributions(manifest: any): any[] {\n  if (!manifest.contributions) {\n    return [];\n  }\n\n  return manifest.contributions.filter(\n    (c: any) => c.type === 'ms.vss-distributed-task.task' && c.properties && c.properties.name\n  );\n}\n\n/**\n * Update contribution references in manifest when extension ID changes\n * Issue #172: Update internal contribution references when extension ID changes\n *\n * @param manifest Extension manifest to update\n * @param originalExtensionId Original extension ID\n * @param newExtensionId New extension ID\n * @returns Updated manifest\n */\nexport function updateContributionReferences(\n  manifest: any,\n  originalExtensionId: string,\n  newExtensionId: string\n): any {\n  if (!manifest || originalExtensionId === newExtensionId) {\n    return manifest;\n  }\n\n  const updated = JSON.parse(JSON.stringify(manifest)); // Deep clone\n\n  // Update contribution IDs\n  if (updated.contributions) {\n    updated.contributions = updated.contributions.map((contribution: any) => {\n      if (contribution.id && typeof contribution.id === 'string') {\n        // Replace extension ID in contribution ID\n        contribution.id = contribution.id.replace(\n          new RegExp(`^${escapeRegex(originalExtensionId)}\\\\.`),\n          `${newExtensionId}.`\n        );\n      }\n      return contribution;\n    });\n  }\n\n  // Update contribution targets in contribution points\n  if (updated.contributionTypes) {\n    updated.contributionTypes = updated.contributionTypes.map((type: any) => {\n      if (type.id && typeof type.id === 'string') {\n        type.id = type.id.replace(\n          new RegExp(`^${escapeRegex(originalExtensionId)}\\\\.`),\n          `${newExtensionId}.`\n        );\n      }\n      return type;\n    });\n  }\n\n  // Update targets in contributions that reference other contributions\n  if (updated.contributions) {\n    updated.contributions = updated.contributions.map((contribution: any) => {\n      if (contribution.targets && Array.isArray(contribution.targets)) {\n        contribution.targets = contribution.targets.map((target: string) => {\n          if (typeof target === 'string') {\n            return target.replace(\n              new RegExp(`^${escapeRegex(originalExtensionId)}\\\\.`),\n              `${newExtensionId}.`\n            );\n          }\n          return target;\n        });\n      }\n      return contribution;\n    });\n  }\n\n  return updated;\n}\n\n/**\n * Escape special regex characters\n */\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * TfxManager - Manages tfx-cli installation, caching, and execution\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { JsonOutputStream } from './json-output-stream.js';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * Options for TfxManager\n */\nexport interface TfxManagerOptions {\n  /**\n   * Version of tfx to use:\n   * - \"built-in\": Use tfx-cli from core package dependencies\n   * - \"path\": Use tfx from system PATH\n   * - Version spec: Download and cache (e.g., \"0.17.0\", \"^0.17\", \"latest\")\n   */\n  tfxVersion: string;\n  /** Platform adapter for operations */\n  platform: IPlatformAdapter;\n}\n\n/**\n * Options for executing tfx\n */\nexport interface TfxExecOptions {\n  /** Working directory */\n  cwd?: string;\n  /** Additional environment variables */\n  env?: Record<string, string>;\n  /** Capture JSON output (adds --json and --debug-log-stream stderr flags) */\n  captureJson?: boolean;\n  /** Override command silence behavior */\n  silent?: boolean;\n}\n\n/**\n * Result from tfx execution\n */\nexport interface TfxResult {\n  /** Exit code from tfx process */\n  exitCode: number;\n  /** Parsed JSON output (if captureJson was true and JSON was present) */\n  json?: unknown;\n  /** Standard output */\n  stdout: string;\n  /** Standard error */\n  stderr: string;\n}\n\n/**\n * Manages tfx-cli binary resolution, caching, and execution\n */\nexport class TfxManager {\n  private resolvedPath?: string;\n  private readonly tfxVersion: string;\n  private readonly platform: IPlatformAdapter;\n\n  constructor(options: TfxManagerOptions) {\n    this.tfxVersion = options.tfxVersion;\n    this.platform = options.platform;\n  }\n\n  /**\n   * Resolve tfx binary path using cache-first strategy\n   * @returns Path to tfx executable\n   */\n  async resolve(): Promise<string> {\n    // 1. In-memory cache (same process invocation)\n    if (this.resolvedPath) {\n      this.platform.debug(`Using cached tfx path: ${this.resolvedPath}`);\n      return this.resolvedPath;\n    }\n\n    // 2. Built-in mode - use tfx from core package dependencies\n    if (this.tfxVersion === 'built-in') {\n      this.resolvedPath = await this.resolveBuiltIn();\n      return this.resolvedPath;\n    }\n\n    // 3. Path mode - use tfx from system PATH (no download)\n    if (this.tfxVersion === 'path') {\n      this.resolvedPath = await this.resolveFromPath();\n      return this.resolvedPath;\n    }\n\n    // 4. Version spec - resolve to exact version first\n    const exactVersion = await this.resolveVersionSpec(this.tfxVersion);\n    this.platform.info(\n      `Resolved tfx-cli version spec '${this.tfxVersion}' to exact version '${exactVersion}'`\n    );\n\n    // 5. Check platform tool cache (cross-step reuse)\n    const cachedPath = this.platform.findCachedTool('tfx-cli', exactVersion);\n    if (cachedPath) {\n      this.platform.info(`Found cached tfx-cli@${exactVersion} at ${cachedPath}`);\n      this.resolvedPath = this.getTfxExecutable(cachedPath);\n      return this.resolvedPath;\n    }\n\n    // 6. Download and cache exact version\n    this.resolvedPath = await this.downloadAndCache(exactVersion);\n    return this.resolvedPath;\n  }\n\n  /**\n   * Resolve built-in tfx binary from core package dependencies\n   * Similar to tfxinstaller v5 behavior\n   *\n   * The tfx-cli package is a direct dependency of the core package.\n   * When bundled, tfx-cli is marked as external and will be in node_modules.\n   * We use 'which' to locate it, which will find it in node_modules/.bin/ or PATH.\n   */\n  private async resolveBuiltIn(): Promise<string> {\n    this.platform.info('Using built-in tfx-cli from core package dependencies');\n\n    const entrypoint = process.argv[1];\n    if (!entrypoint) {\n      throw new Error('Built-in tfx-cli resolution failed: process.argv[1] is not set.');\n    }\n\n    const entryDir = path.dirname(path.resolve(entrypoint));\n    const tfxExecutable = process.platform === 'win32' ? 'tfx.cmd' : 'tfx';\n    const candidateDirs = [entryDir];\n    const normalizedEntrypoint = path.resolve(entrypoint).replace(/\\\\/g, '/');\n\n    if (normalizedEntrypoint.includes('/node_modules/')) {\n      candidateDirs.push(process.cwd());\n    }\n\n    for (const candidateDir of candidateDirs) {\n      const builtInPath = path.join(candidateDir, 'node_modules', '.bin', tfxExecutable);\n\n      if (await this.pathExists(builtInPath)) {\n        this.platform.debug(`Resolved built-in tfx at: ${builtInPath}`);\n        return builtInPath;\n      }\n    }\n\n    throw new Error(\n      `Built-in tfx-cli not found at expected path: ${path.join(entryDir, 'node_modules', '.bin', tfxExecutable)}.`\n    );\n  }\n\n  private async pathExists(filePath: string): Promise<boolean> {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Resolve tfx from system PATH\n   * No download, uses whatever tfx is installed on the system\n   */\n  private async resolveFromPath(): Promise<string> {\n    this.platform.info('Using tfx-cli from system PATH');\n\n    // Find tfx on PATH\n    const tfxPath = await this.platform.which('tfx', true);\n\n    this.platform.debug(`Resolved tfx from PATH at: ${tfxPath}`);\n    return tfxPath;\n  }\n\n  /**\n   * Resolve a version spec to an exact version\n   * Uses npm to resolve version specs like \"^0.17\", \"latest\", etc.\n   * @param versionSpec - Version spec to resolve (e.g., \"^0.17\", \"latest\", \"0.17.0\")\n   * @returns Exact version string (e.g., \"0.17.3\")\n   */\n  private async resolveVersionSpec(versionSpec: string): Promise<string> {\n    this.platform.debug(`Resolving version spec: ${versionSpec}`);\n\n    try {\n      // Use npm view to get the exact version\n      const npmPath = await this.platform.which('npm', true);\n\n      // Create a temp buffer to capture output\n      let output = '';\n      const outStream: any = {\n        write: (data: string) => {\n          output += data;\n        },\n      };\n\n      const exitCode = await this.platform.exec(\n        npmPath,\n        ['view', `tfx-cli@${versionSpec}`, 'version', '--json'],\n        { outStream }\n      );\n\n      if (exitCode !== 0) {\n        throw new Error(`npm view failed with exit code ${exitCode}`);\n      }\n\n      // Parse the output\n      const trimmed = output.trim();\n      let exactVersion: string;\n\n      if (trimmed.startsWith('[')) {\n        // Multiple versions returned, take the last one (latest)\n        const versions = JSON.parse(trimmed) as string[];\n        exactVersion = versions[versions.length - 1];\n      } else if (trimmed.startsWith('\"')) {\n        // Single version as JSON string\n        exactVersion = JSON.parse(trimmed) as string;\n      } else {\n        // Plain version string\n        exactVersion = trimmed;\n      }\n\n      this.platform.debug(`Resolved '${versionSpec}' to exact version '${exactVersion}'`);\n      return exactVersion;\n    } catch (error) {\n      throw new Error(`Failed to resolve tfx-cli version spec '${versionSpec}': ${error}`);\n    }\n  }\n\n  /**\n   * Download tfx from npm and cache it\n   * Uses npm install to download tfx-cli and all its dependencies\n   * This matches the behavior of the previous tfxinstaller task\n   * @param exactVersion - Exact version to download (e.g., \"0.17.3\")\n   */\n  private async downloadAndCache(exactVersion: string): Promise<string> {\n    this.platform.info(`Installing tfx-cli@${exactVersion} from npm...`);\n\n    // Create temp directory for installation\n    const tempDir = this.platform.getTempDir();\n    const installDir = path.join(tempDir, `tfx-install-${Date.now()}`);\n    await fs.mkdir(installDir, { recursive: true });\n\n    try {\n      // Step 1: Run npm install to download tfx-cli and all dependencies\n      // This installs into node_modules/tfx-cli with full dependency tree\n      this.platform.debug(`Running npm install tfx-cli@${exactVersion} in ${installDir}`);\n      const npmPath = await this.platform.which('npm', true);\n      const exitCode = await this.platform.exec(\n        npmPath,\n        ['install', `tfx-cli@${exactVersion}`, '--production', '--no-save', '--no-package-lock'],\n        { cwd: installDir }\n      );\n\n      if (exitCode !== 0) {\n        throw new Error(`npm install failed with exit code ${exitCode}`);\n      }\n\n      // Step 2: Verify node_modules/tfx-cli exists\n      const tfxPackageDir = path.join(installDir, 'node_modules', 'tfx-cli');\n      try {\n        await fs.access(tfxPackageDir);\n      } catch {\n        throw new Error(`tfx-cli not found at ${tfxPackageDir} after npm install`);\n      }\n\n      this.platform.info(`Successfully installed tfx-cli@${exactVersion} with dependencies`);\n\n      // Step 3: Make tfx executable on Unix systems\n      await this.ensureExecutable(tfxPackageDir);\n\n      // Step 4: Cache the entire node_modules directory structure\n      // This preserves the full dependency tree for tfx to work correctly\n      this.platform.info(`Caching tfx-cli@${exactVersion}...`);\n      const nodeModulesDir = path.join(installDir, 'node_modules');\n      const cachedDir = await this.platform.cacheDir(nodeModulesDir, 'tfx-cli', exactVersion);\n      this.platform.info(`Cached tfx-cli@${exactVersion} to ${cachedDir}`);\n\n      // Step 5: Return path to tfx executable\n      // The tfx executable is in tfx-cli/bin/ within the cached node_modules\n      const binDir = path.join(cachedDir, 'tfx-cli', 'bin');\n      return this.getTfxExecutable(binDir);\n    } catch (error) {\n      // If install fails, fall back to PATH as last resort\n      this.platform.warning(\n        `Failed to install tfx-cli@${exactVersion}: ${error instanceof Error ? error.message : String(error)}`\n      );\n      this.platform.warning('Falling back to tfx from PATH');\n\n      try {\n        const tfxPath = await this.platform.which('tfx', true);\n        return tfxPath;\n      } catch {\n        throw new Error(\n          `Failed to install tfx-cli@${exactVersion} and no tfx found in PATH. ` +\n            `Original error: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    } finally {\n      // Clean up temp directory\n      try {\n        await this.platform.rmRF(installDir);\n        this.platform.debug(`Cleaned up temp directory: ${installDir}`);\n      } catch (cleanupError) {\n        this.platform.warning(\n          `Failed to clean up temp directory ${installDir}: ${cleanupError instanceof Error ? cleanupError.message : String(cleanupError)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Ensure tfx binary is executable on Unix systems\n   * @param tfxPackageDir - Path to tfx-cli package directory\n   */\n  private async ensureExecutable(tfxPackageDir: string): Promise<void> {\n    // Only needed on Unix systems\n    if (process.platform === 'win32') {\n      this.platform.debug('Skipping chmod on Windows');\n      return;\n    }\n\n    try {\n      const tfxBin = path.join(tfxPackageDir, 'bin', 'tfx');\n      await fs.chmod(tfxBin, 0o755);\n      this.platform.debug(`Made tfx executable: ${tfxBin}`);\n    } catch (error) {\n      this.platform.warning(`Failed to chmod tfx: ${error}`);\n    }\n  }\n\n  /**\n   * Get tfx executable path from directory\n   * On Windows, uses tfx.cmd or tfx.ps1\n   * On Unix, uses tfx (made executable via chmod)\n   */\n  private getTfxExecutable(dir: string): string {\n    // On Windows, prefer .cmd wrapper, fallback to .ps1\n    const isWindows = process.platform === 'win32';\n    if (isWindows) {\n      const cmdPath = path.join(dir, 'tfx.cmd');\n      // Note: We return tfx.cmd even if it doesn't exist yet\n      // npm install will create it\n      return cmdPath;\n    }\n    // On Unix, use the tfx binary (will be made executable)\n    return path.join(dir, 'tfx');\n  }\n\n  /**\n   * Execute tfx with given arguments\n   * @param args Arguments to pass to tfx\n   * @param options Execution options\n   * @returns Result with exit code and output\n   */\n  async execute(args: string[], options?: TfxExecOptions): Promise<TfxResult> {\n    const tfxPath = await this.resolve();\n\n    // Add JSON output flags if requested\n    const finalArgs = [...args];\n    let jsonStream: JsonOutputStream | undefined;\n\n    if (options?.captureJson) {\n      // Add tfx flags for JSON output\n      if (!finalArgs.includes('--json')) {\n        finalArgs.push('--json');\n      }\n      if (!finalArgs.includes('--debug-log-stream')) {\n        finalArgs.push('--debug-log-stream', 'stderr');\n      }\n\n      // Create JSON output stream\n      jsonStream = new JsonOutputStream((msg) => this.platform.debug(msg));\n    }\n\n    // Build exec options\n    const defaultSilent = options?.captureJson ? true : !this.platform.isDebugEnabled();\n    const execOptions = {\n      cwd: options?.cwd,\n      env: options?.env,\n      silent: options?.silent ?? defaultSilent,\n      outStream: jsonStream,\n      errStream: undefined as NodeJS.WritableStream | undefined,\n    };\n\n    // Execute tfx\n    this.platform.debug(`Executing: ${tfxPath} ${finalArgs.join(' ')}`);\n    const exitCode = await this.platform.exec(tfxPath, finalArgs, execOptions);\n\n    // Parse JSON if captured\n    let parsedJson: unknown | undefined;\n    if (jsonStream) {\n      parsedJson = jsonStream.parseJson();\n    }\n\n    return {\n      exitCode,\n      json: parsedJson,\n      stdout: jsonStream?.jsonString || '',\n      stderr: '',\n    };\n  }\n}\n", "// Platform abstraction layer\nexport * from './platform.js';\n\n// Authentication\nexport * from './auth.js';\n\n// Core utilities\nexport * from './arg-builder.js';\nexport * from './version-utils.js';\nexport * from './json-output-stream.js';\nexport * from './manifest-utils.js';\nexport * from './tfx-manager.js';\n\n// Manifest handling (unified architecture)\nexport * from './manifest-reader.js';\nexport * from './manifest-editor.js';\nexport * from './vsix-reader.js';\nexport * from './vsix-writer.js';\nexport * from './filesystem-manifest-reader.js';\nexport * from './filesystem-manifest-writer.js';\n\n// Validation\nexport * from './validation.js';\n\n// Commands\nexport * from './commands/index.js';\n", "/**\n * Input validation functions for extension tasks\n */\n\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * Validates an extension ID\n * @param id Extension ID to validate\n * @throws Error if invalid\n */\nexport function validateExtensionId(id: string): void {\n  if (!id || typeof id !== 'string') {\n    throw new Error('Extension ID is required and must be a string');\n  }\n\n  if (id.trim() !== id) {\n    throw new Error('Extension ID cannot have leading or trailing whitespace');\n  }\n\n  if (id.length === 0) {\n    throw new Error('Extension ID cannot be empty');\n  }\n\n  if (id.length > 200) {\n    throw new Error('Extension ID cannot exceed 200 characters');\n  }\n\n  // Azure DevOps extension IDs can contain letters, numbers, dots, underscores, and hyphens\n  const validPattern = /^[a-zA-Z0-9._-]+$/;\n  if (!validPattern.test(id)) {\n    throw new Error(\n      'Extension ID can only contain letters, numbers, dots (.), underscores (_), and hyphens (-)'\n    );\n  }\n}\n\n/**\n * Validates a publisher ID\n * @param id Publisher ID to validate\n * @throws Error if invalid\n */\nexport function validatePublisherId(id: string): void {\n  if (!id || typeof id !== 'string') {\n    throw new Error('Publisher ID is required and must be a string');\n  }\n\n  if (id.trim() !== id) {\n    throw new Error('Publisher ID cannot have leading or trailing whitespace');\n  }\n\n  if (id.length === 0) {\n    throw new Error('Publisher ID cannot be empty');\n  }\n\n  if (id.length > 200) {\n    throw new Error('Publisher ID cannot exceed 200 characters');\n  }\n\n  // Publisher IDs have same constraints as extension IDs\n  const validPattern = /^[a-zA-Z0-9._-]+$/;\n  if (!validPattern.test(id)) {\n    throw new Error(\n      'Publisher ID can only contain letters, numbers, dots (.), underscores (_), and hyphens (-)'\n    );\n  }\n}\n\n/**\n * Validates an Azure DevOps account URL\n * @param url Account URL to validate\n * @throws Error if invalid\n */\nexport function validateAccountUrl(url: string): void {\n  if (!url || typeof url !== 'string') {\n    throw new Error('Account URL is required and must be a string');\n  }\n\n  if (url.trim() !== url) {\n    throw new Error('Account URL cannot have leading or trailing whitespace');\n  }\n\n  if (url.length === 0) {\n    throw new Error('Account URL cannot be empty');\n  }\n\n  // Basic URL validation\n  let parsedUrl: URL;\n  try {\n    parsedUrl = new URL(url);\n  } catch {\n    throw new Error('Account URL must be a valid URL');\n  }\n\n  // Must use HTTPS\n  if (parsedUrl.protocol !== 'https:') {\n    throw new Error('Account URL must use HTTPS protocol');\n  }\n\n  // Check for Azure DevOps domains\n  const validDomains = ['dev.azure.com', 'visualstudio.com', 'azure.com'];\n\n  const hostname = parsedUrl.hostname.toLowerCase();\n  const isValidDomain = validDomains.some(\n    (domain) => hostname === domain || hostname.endsWith('.' + domain)\n  );\n\n  if (!isValidDomain) {\n    throw new Error(\n      'Account URL must be an Azure DevOps URL (dev.azure.com, *.visualstudio.com, or *.azure.com)'\n    );\n  }\n}\n\n/**\n * Validates a version string\n * @param version Version string to validate\n * @throws Error if invalid\n */\nexport function validateVersion(version: string): void {\n  if (!version || typeof version !== 'string') {\n    throw new Error('Version is required and must be a string');\n  }\n\n  if (version.trim() !== version) {\n    throw new Error('Version cannot have leading or trailing whitespace');\n  }\n\n  if (version.length === 0) {\n    throw new Error('Version cannot be empty');\n  }\n\n  // Semantic versioning pattern (simplified)\n  // Supports: 1.0.0, 1.0.0.0, 1.0, etc.\n  const semverPattern = /^\\d+(\\.\\d+){0,3}$/;\n\n  if (!semverPattern.test(version)) {\n    throw new Error('Version must follow semantic versioning (e.g., 1.0.0, 1.0.0.0)');\n  }\n\n  // Validate each part is within valid range\n  const parts = version.split('.');\n  for (const part of parts) {\n    const num = parseInt(part, 10);\n    if (num < 0 || num > 999999) {\n      throw new Error('Version numbers must be between 0 and 999999');\n    }\n  }\n}\n\n/**\n * Gets the version of a binary by executing it with --version\n * @param binary Binary name\n * @param platform Platform adapter for executing commands\n * @returns Version string or null if unable to determine\n */\nasync function getBinaryVersion(\n  binary: string,\n  platform: IPlatformAdapter\n): Promise<string | null> {\n  try {\n    // Different binaries use different flags for version info\n    const versionArgs: { [key: string]: string[] } = {\n      node: ['--version'],\n      npm: ['--version'],\n      az: ['--version'],\n      tfx: ['version', '--no-prompt', '--no-color'], // tfx version command with clean output\n    };\n\n    const args = versionArgs[binary] || ['--version'];\n\n    // Execute binary to check if it's available\n    const exitCode = await platform.exec(binary, args, {\n      silent: true,\n      ignoreReturnCode: true,\n    } as any);\n\n    // If exec succeeds, binary is available\n    if (exitCode === 0) {\n      return 'available';\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Validates that a required binary is available\n * @param binary Binary name to check (e.g., 'az', 'tfx', 'npm', 'node')\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if binary is not available\n */\nexport async function validateBinaryAvailable(\n  binary: string,\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  if (!binary || typeof binary !== 'string') {\n    throw new Error('Binary name is required and must be a string');\n  }\n\n  platform.debug(`Checking for required binary: ${binary}`);\n\n  try {\n    const binaryPath = await platform.which(binary, true);\n    platform.debug(`Found ${binary} at: ${binaryPath}`);\n\n    // Log version in debug mode\n    if (logVersion) {\n      const version = await getBinaryVersion(binary, platform);\n      if (version) {\n        platform.debug(`${binary} version: ${version}`);\n      } else {\n        platform.debug(`${binary} version: Unable to determine`);\n      }\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(\n      `Required binary '${binary}' is not available. ` +\n        `Please ensure ${binary} is installed and in your PATH. ` +\n        `Error: ${errorMessage}`\n    );\n  }\n}\n\n/**\n * Validates that Node.js is available and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if Node.js is not available\n */\nexport async function validateNodeAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('node', platform, logVersion);\n}\n\n/**\n * Validates that npm is available and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if npm is not available\n */\nexport async function validateNpmAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('npm', platform, logVersion);\n}\n\n/**\n * Validates that tfx is available (for path mode) and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if tfx is not available\n */\nexport async function validateTfxAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('tfx', platform, logVersion);\n}\n\n/**\n * Validates that Azure CLI is available (for OIDC authentication) and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if Azure CLI is not available\n */\nexport async function validateAzureCliAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('az', platform, logVersion);\n}\n", "/**\n * Package command - Creates a .vsix file from extension manifest\n */\n\nimport { ArgBuilder } from '../arg-builder.js';\nimport { FilesystemManifestReader } from '../filesystem-manifest-reader.js';\nimport { ManifestEditor } from '../manifest-editor.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\n\n/**\n * Options for package command\n */\nexport interface PackageOptions {\n  // Manifest source\n  rootFolder?: string;\n  manifestGlobs?: string[];\n  overridesFile?: string;\n\n  // Overrides\n  publisherId?: string;\n  extensionId?: string;\n  extensionName?: string;\n  extensionVersion?: string;\n  extensionVisibility?: 'private' | 'public' | 'private_preview' | 'public_preview';\n  extensionPricing?: 'free' | 'paid' | 'trial';\n\n  // Task patching\n  updateTasksVersion?: boolean;\n  updateTasksVersionType?: 'major' | 'minor' | 'patch';\n  updateTasksId?: boolean;\n\n  // Output\n  outputPath?: string;\n\n  // Behavior\n  bypassValidation?: boolean;\n  revVersion?: boolean;\n}\n\n/**\n * Result from package command\n */\nexport interface PackageResult {\n  /** Path to created .vsix file */\n  vsixPath: string;\n  /** Extension ID from manifest */\n  extensionId: string;\n  /** Extension version */\n  extensionVersion: string;\n  /** Publisher ID from manifest */\n  publisherId: string;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Package an extension into a .vsix file\n * @param options Package options\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Package result with vsix path and metadata\n */\nexport async function packageExtension(\n  options: PackageOptions,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<PackageResult> {\n  platform.info('Packaging extension...');\n\n  // Build tfx arguments\n  const args = new ArgBuilder().arg(['extension', 'create']).flag('--json').flag('--no-color');\n\n  // Manifest arguments\n  if (options.rootFolder) {\n    args.option('--root', options.rootFolder);\n  }\n\n  if (options.manifestGlobs && options.manifestGlobs.length > 0) {\n    args.flag('--manifest-globs');\n    options.manifestGlobs.forEach((glob) => args.arg(glob));\n  }\n\n  if (options.overridesFile) {\n    args.option('--overrides-file', options.overridesFile);\n  }\n\n  // Overrides\n  if (options.publisherId) {\n    args.option('--publisher', options.publisherId);\n  }\n\n  const extensionId = options.extensionId;\n\n  if (extensionId) {\n    args.option('--extension-id', extensionId);\n  }\n\n  // Output path\n  if (options.outputPath) {\n    args.option('--output-path', options.outputPath);\n  }\n\n  // Flags\n  if (options.bypassValidation) {\n    args.flag('--bypass-validation');\n  }\n\n  if (options.revVersion) {\n    args.flag('--rev-version');\n  }\n\n  // Handle manifest updates using the unified architecture\n  let cleanupWriter: (() => Promise<void>) | null = null;\n  const synchronizeBinaryFileEntries = true;\n\n  const shouldApplyManifestOptions =\n    options.updateTasksVersion ||\n    options.updateTasksId ||\n    options.extensionVersion ||\n    options.extensionName ||\n    options.extensionVisibility ||\n    options.extensionPricing ||\n    synchronizeBinaryFileEntries;\n\n  if (shouldApplyManifestOptions) {\n    platform.info('Updating task manifests before packaging...');\n\n    try {\n      // Create filesystem reader for the source directory\n      const rootFolder = options.rootFolder || '.';\n      const manifestGlobs = options.manifestGlobs || ['vss-extension.json'];\n\n      const reader = new FilesystemManifestReader({\n        rootFolder,\n        manifestGlobs,\n        platform,\n      });\n\n      // Create editor and apply all options at once\n      const editor = ManifestEditor.fromReader(reader);\n      await editor.applyOptions({\n        publisherId: options.publisherId,\n        extensionId: options.extensionId,\n        extensionVersion: options.extensionVersion,\n        extensionName: options.extensionName,\n        extensionVisibility: options.extensionVisibility,\n        extensionPricing: options.extensionPricing,\n        updateTasksVersion: options.updateTasksVersion,\n        updateTasksVersionType: options.updateTasksVersionType,\n        updateTasksId: options.updateTasksId,\n        synchronizeBinaryFileEntries,\n      });\n\n      // Write modifications to filesystem\n      const writer = await editor.toWriter();\n      await writer.writeToFilesystem();\n\n      // Get overrides file path if generated\n      const overridesPath = writer.getOverridesPath();\n      if (overridesPath) {\n        platform.debug(`Using overrides file: ${overridesPath}`);\n        args.option('--overrides-file', overridesPath);\n      }\n\n      // Setup cleanup function\n      cleanupWriter = async () => {\n        await writer.close();\n        await reader.close();\n      };\n\n      platform.info('Task manifests updated successfully');\n    } catch (err) {\n      platform.error(`Failed to update task manifests: ${(err as Error).message}`);\n      throw err;\n    }\n  }\n\n  try {\n    // Execute tfx\n    const result = await tfx.execute(args.build(), { captureJson: true });\n\n    if (result.exitCode !== 0) {\n      platform.error(`tfx exited with code ${result.exitCode}`);\n      throw new Error(`tfx extension create failed with exit code ${result.exitCode}`);\n    }\n\n    // Parse JSON result\n    const json = result.json as any;\n    if (!json || !json.path) {\n      throw new Error('tfx did not return expected JSON output with path');\n    }\n\n    platform.setVariable('vsixPath', json.path, false, true);\n\n    platform.info(`Packaged extension: ${json.path}`);\n\n    return {\n      vsixPath: json.path,\n      extensionId: json.id || extensionId || '',\n      extensionVersion: json.version || options.extensionVersion || '',\n      publisherId: json.publisher || options.publisherId || '',\n      exitCode: result.exitCode,\n    };\n  } finally {\n    // Clean up writer resources if created\n    if (cleanupWriter) {\n      await cleanupWriter();\n    }\n  }\n}\n", "/**\n * Publish command - Publishes an extension to the marketplace\n */\n\nimport { ArgBuilder } from '../arg-builder.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ManifestEditor } from '../manifest-editor.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport { VsixReader } from '../vsix-reader.js';\n\n/**\n * Source for publishing\n */\nexport type PublishSource = 'manifest' | 'vsix';\n\n/**\n * Options for publish command\n */\nexport interface PublishOptions {\n  // Source\n  publishSource: PublishSource;\n\n  // Manifest source (when publishSource = 'manifest')\n  rootFolder?: string;\n  manifestGlobs?: string[];\n  overridesFile?: string;\n\n  // VSIX source (when publishSource = 'vsix')\n  vsixFile?: string;\n\n  // Overrides\n  publisherId?: string;\n  extensionId?: string;\n  extensionName?: string;\n  extensionVersion?: string;\n  extensionVisibility?: 'private' | 'public' | 'private_preview' | 'public_preview';\n  extensionPricing?: 'free' | 'paid' | 'trial';\n\n  // Task patching\n  updateTasksVersion?: boolean;\n  updateTasksVersionType?: 'major' | 'minor' | 'patch';\n  updateTasksId?: boolean;\n\n  // Sharing\n  shareWith?: string[]; // Array of organization names to share with\n\n  // Behavior\n  noWaitValidation?: boolean;\n  bypassValidation?: boolean;\n}\n\n/**\n * Result from publish command\n */\nexport interface PublishResult {\n  /** Whether extension was published successfully */\n  published: boolean;\n  /** Path to the vsix file that was published */\n  vsixPath: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Extension version */\n  extensionVersion: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Helper function to execute tfx publish and parse results\n */\nasync function executeTfxPublish(\n  tfx: TfxManager,\n  args: ArgBuilder,\n  platform: IPlatformAdapter,\n  options: PublishOptions,\n  publishedVsixPath?: string\n): Promise<PublishResult> {\n  // Sharing\n  if (options.shareWith && options.shareWith.length > 0) {\n    // Only share if extension is not public\n    const isPublic =\n      options.extensionVisibility === 'public' || options.extensionVisibility === 'public_preview';\n\n    if (isPublic) {\n      platform.warning('Ignoring shareWith - not available for public extensions');\n    } else {\n      args.flag('--share-with');\n      options.shareWith.forEach((org) => args.arg(org));\n    }\n  }\n\n  // Flags\n  if (options.noWaitValidation) {\n    args.flag('--no-wait-validation');\n  }\n\n  if (options.bypassValidation) {\n    args.flag('--bypass-validation');\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension publish failed with exit code ${result.exitCode}`);\n  }\n\n  // Parse JSON result\n  const json = result.json as any;\n  if (!json || !json.published) {\n    throw new Error('tfx did not return expected JSON output with published status');\n  }\n\n  let extensionId = '';\n  let extensionVersion = '';\n  let publisherId = '';\n\n  if (options.publishSource === 'vsix') {\n    const metadataVsixPath = publishedVsixPath ?? options.vsixFile;\n\n    if (metadataVsixPath && (await platform.fileExists(metadataVsixPath))) {\n      try {\n        const reader = await VsixReader.open(metadataVsixPath);\n        const metadata = await reader.getMetadata();\n        await reader.close();\n\n        extensionId = metadata.extensionId;\n        extensionVersion = metadata.version;\n        publisherId = metadata.publisher;\n      } catch (error) {\n        platform.debug(\n          `Could not read VSIX metadata from ${metadataVsixPath}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n  } else {\n    extensionId = json.id || '';\n    extensionVersion = json.version || '';\n    publisherId = json.publisher || '';\n  }\n\n  extensionId = extensionId || options.extensionId || '';\n  extensionVersion = extensionVersion || options.extensionVersion || '';\n  publisherId = publisherId || options.publisherId || '';\n\n  // Determine vsix path\n  let vsixPath = '';\n  if (options.publishSource === 'manifest') {\n    vsixPath = json.packaged || '';\n  } else {\n    vsixPath = publishedVsixPath || options.vsixFile || '';\n  }\n\n  platform.info(\n    `Published extension: ${extensionId || '(unknown id)'} v${extensionVersion || '(unknown version)'}`\n  );\n\n  return {\n    published: json.published === true,\n    vsixPath,\n    extensionId,\n    extensionVersion,\n    publisherId,\n    exitCode: result.exitCode,\n  };\n}\n\n/**\n * Publish an extension to the marketplace\n * @param options Publish options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Publish result\n */\nexport async function publishExtension(\n  options: PublishOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<PublishResult> {\n  platform.info('Publishing extension...');\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'publish'])\n    .flag('--json')\n    .flag('--no-color')\n    .flag('--debug-log-stream')\n    .arg('stderr');\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Source-specific arguments\n  if (options.publishSource === 'manifest') {\n    // Publishing from manifest files\n    if (options.rootFolder) {\n      args.option('--root', options.rootFolder);\n    }\n\n    if (options.manifestGlobs && options.manifestGlobs.length > 0) {\n      args.flag('--manifest-globs');\n      options.manifestGlobs.forEach((glob) => args.arg(glob));\n    }\n\n    if (options.overridesFile) {\n      args.option('--overrides-file', options.overridesFile);\n    }\n\n    // Overrides\n    if (options.publisherId) {\n      args.option('--publisher', options.publisherId);\n    }\n\n    const extensionId = options.extensionId;\n\n    if (extensionId) {\n      args.option('--extension-id', extensionId);\n    }\n\n    if (options.extensionName) {\n      args.option('--extension-name', options.extensionName);\n    }\n\n    if (options.extensionVersion) {\n      args.option('--extension-version', options.extensionVersion);\n    }\n\n    if (options.extensionVisibility) {\n      args.option('--extension-visibility', options.extensionVisibility);\n    }\n\n    // Handle task version and ID updates for manifest publishing\n    // This uses the same approach as package.ts\n    let cleanupWriter: (() => Promise<void>) | null = null;\n\n    const synchronizeBinaryFileEntries = true;\n\n    if (\n      options.updateTasksVersion ||\n      options.updateTasksId ||\n      options.extensionPricing ||\n      synchronizeBinaryFileEntries\n    ) {\n      platform.info('Updating task manifests before publishing...');\n\n      try {\n        // Import filesystem manifest modules\n        const { FilesystemManifestReader } = await import('../filesystem-manifest-reader.js');\n        const { ManifestEditor } = await import('../manifest-editor.js');\n\n        // Create filesystem reader for the source directory\n        const rootFolder = options.rootFolder || '.';\n        const manifestGlobs = options.manifestGlobs || ['vss-extension.json'];\n\n        const reader = new FilesystemManifestReader({\n          rootFolder,\n          manifestGlobs,\n          platform,\n        });\n\n        // Create editor and apply all options at once\n        const editor = ManifestEditor.fromReader(reader);\n        await editor.applyOptions({\n          publisherId: options.publisherId,\n          extensionId: options.extensionId,\n          extensionVersion: options.extensionVersion,\n          extensionName: options.extensionName,\n          extensionVisibility: options.extensionVisibility,\n          extensionPricing: options.extensionPricing,\n          updateTasksVersion: options.updateTasksVersion,\n          updateTasksVersionType: options.updateTasksVersionType,\n          updateTasksId: options.updateTasksId,\n          synchronizeBinaryFileEntries,\n        });\n\n        // Write modifications to filesystem\n        const writer = await editor.toWriter();\n        await writer.writeToFilesystem();\n\n        // Get overrides file path if generated\n        const overridesPath = writer.getOverridesPath();\n        if (overridesPath) {\n          platform.debug(`Using overrides file: ${overridesPath}`);\n          args.option('--overrides-file', overridesPath);\n        }\n\n        // Setup cleanup function\n        cleanupWriter = async () => {\n          await writer.close();\n          await reader.close();\n        };\n\n        platform.info('Task manifests updated successfully');\n      } catch (err) {\n        platform.error(`Failed to update task manifests: ${(err as Error).message}`);\n        throw err;\n      }\n    }\n\n    // Execute tfx and handle cleanup\n    try {\n      return await executeTfxPublish(tfx, args, platform, options);\n    } finally {\n      if (cleanupWriter) {\n        await cleanupWriter();\n      }\n    }\n  } else {\n    // Publishing from VSIX file\n    if (!options.vsixFile) {\n      throw new Error('vsixFile is required when publishSource is \"vsix\"');\n    }\n\n    // Check if file exists\n    const fileExists = await platform.fileExists(options.vsixFile);\n    if (!fileExists) {\n      throw new Error(`VSIX file not found: ${options.vsixFile}`);\n    }\n\n    // Check if we need to modify the VSIX before publishing\n    const needsModification =\n      options.publisherId ||\n      options.extensionId ||\n      options.extensionVersion ||\n      options.extensionName ||\n      options.extensionVisibility ||\n      options.extensionPricing ||\n      options.updateTasksVersion ||\n      options.updateTasksId;\n\n    let vsixPathToPublish = options.vsixFile;\n\n    if (needsModification) {\n      platform.info('Modifying VSIX before publishing...');\n\n      // Open the VSIX and create an editor using the unified architecture\n      const reader = await VsixReader.open(options.vsixFile);\n      const editor = ManifestEditor.fromReader(reader);\n\n      // Apply all options at once\n      await editor.applyOptions({\n        publisherId: options.publisherId,\n        extensionId: options.extensionId,\n        extensionVersion: options.extensionVersion,\n        extensionName: options.extensionName,\n        extensionVisibility: options.extensionVisibility,\n        extensionPricing: options.extensionPricing,\n        updateTasksVersion: options.updateTasksVersion,\n        updateTasksVersionType: options.updateTasksVersionType,\n        updateTasksId: options.updateTasksId,\n      });\n\n      // Write modified VSIX to a temporary file\n      const writer = await editor.toWriter();\n      const tempDir = platform.getTempDir();\n      const tempVsixPath = `${tempDir}/temp-${Date.now()}.vsix`;\n\n      platform.debug(`Writing modified VSIX to: ${tempVsixPath}`);\n      await writer.writeToFile(tempVsixPath);\n      await writer.close();\n      await reader.close();\n\n      // Use the modified VSIX for publishing\n      vsixPathToPublish = tempVsixPath;\n      args.option('--vsix', tempVsixPath);\n\n      platform.info('VSIX modifications applied successfully');\n    } else {\n      // No modifications needed - publish as-is\n      args.option('--vsix', options.vsixFile);\n    }\n\n    return executeTfxPublish(tfx, args, platform, options, vsixPathToPublish);\n  }\n\n  // Execute tfx using the helper function\n  return executeTfxPublish(tfx, args, platform, options);\n}\n", "/**\n * Unpublish command - Removes an extension from the marketplace\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for unpublish command\n */\nexport interface UnpublishOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n}\n\n/**\n * Result from unpublish command\n */\nexport interface UnpublishResult {\n  /** Whether extension was unpublished successfully */\n  success: boolean;\n  /** Extension ID that was unpublished */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Unpublish an extension from the marketplace\n * @param options Unpublish options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Unpublish result\n */\nexport async function unpublishExtension(\n  options: UnpublishOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<UnpublishResult> {\n  platform.info(`Unpublishing extension ${options.publisherId}.${options.extensionId}...`);\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'unpublish'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId);\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension unpublish failed with exit code ${result.exitCode}`);\n  }\n\n  platform.info(`Successfully unpublished extension: ${options.publisherId}.${extensionId}`);\n\n  return {\n    success: true,\n    extensionId,\n    publisherId: options.publisherId,\n    exitCode: result.exitCode,\n  };\n}\n", "/**\n * Share command - Shares an extension with organizations\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for share command\n */\nexport interface ShareOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Array of organization names to share with */\n  shareWith: string[];\n}\n\n/**\n * Result from share command\n */\nexport interface ShareResult {\n  /** Whether extension was shared successfully */\n  success: boolean;\n  /** Extension ID that was shared */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Organizations shared with */\n  sharedWith: string[];\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Share an extension with organizations\n * @param options Share options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Share result\n */\nexport async function shareExtension(\n  options: ShareOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<ShareResult> {\n  if (!options.shareWith || options.shareWith.length === 0) {\n    throw new Error('shareWith must contain at least one organization');\n  }\n\n  platform.info(\n    `Sharing extension ${options.publisherId}.${options.extensionId} with ${options.shareWith.length} organization(s)...`\n  );\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'share'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId)\n    .flag('--share-with');\n\n  // Add each organization\n  options.shareWith.forEach((org) => args.arg(org));\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension share failed with exit code ${result.exitCode}`);\n  }\n\n  platform.info(`Successfully shared extension with: ${options.shareWith.join(', ')}`);\n\n  return {\n    success: true,\n    extensionId,\n    publisherId: options.publisherId,\n    sharedWith: options.shareWith,\n    exitCode: result.exitCode,\n  };\n}\n", "/**\n * Unshare command - Unshares an extension from organizations\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for unshare command\n */\nexport interface UnshareOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Array of organization names to unshare from */\n  unshareWith: string[];\n}\n\n/**\n * Result from unshare command\n */\nexport interface UnshareResult {\n  /** Whether extension was unshared successfully */\n  success: boolean;\n  /** Extension ID that was unshared */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Organizations unshared from */\n  unsharedFrom: string[];\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Unshare an extension from organizations\n * @param options Unshare options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Unshare result\n */\nexport async function unshareExtension(\n  options: UnshareOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<UnshareResult> {\n  if (!options.unshareWith || options.unshareWith.length === 0) {\n    throw new Error('unshareWith must contain at least one organization');\n  }\n\n  platform.info(\n    `Unsharing extension ${options.publisherId}.${options.extensionId} from ${options.unshareWith.length} organization(s)...`\n  );\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'unshare'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId)\n    .flag('--unshare-with');\n\n  // Add each organization\n  options.unshareWith.forEach((org) => args.arg(org));\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension unshare failed with exit code ${result.exitCode}`);\n  }\n\n  platform.info(`Successfully unshared extension from: ${options.unshareWith.join(', ')}`);\n\n  return {\n    success: true,\n    extensionId,\n    publisherId: options.publisherId,\n    unsharedFrom: options.unshareWith,\n    exitCode: result.exitCode,\n  };\n}\n", "/**\n * Install command - Installs an extension to organization(s)\n */\n\nimport { ArgBuilder } from '../arg-builder.js';\nimport type { AuthCredentials } from '../auth.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\n\n/**\n * Options for install command\n */\nexport interface InstallOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Target organization URLs to install to */\n  accounts: string[];\n  /** Extension version to install (optional) */\n  extensionVersion?: string;\n}\n\n/**\n * Result from install command for a single account\n */\nexport interface InstallAccountResult {\n  /** Account URL */\n  account: string;\n  /** Whether installation succeeded */\n  success: boolean;\n  /** Whether extension was already installed */\n  alreadyInstalled: boolean;\n  /** Error message if failed */\n  error?: string;\n}\n\n/**\n * Result from install command\n */\nexport interface InstallResult {\n  /** Extension ID that was installed */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Results per account */\n  accountResults: InstallAccountResult[];\n  /** Overall success (all accounts succeeded) */\n  allSuccess: boolean;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Install an extension to one or more organizations\n * @param options Install options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Install result\n */\nexport async function installExtension(\n  options: InstallOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<InstallResult> {\n  if (!options.accounts || options.accounts.length === 0) {\n    throw new Error('accounts must contain at least one organization URL');\n  }\n\n  platform.info(\n    `Installing extension ${options.publisherId}.${options.extensionId} to ${options.accounts.length} organization(s)...`\n  );\n\n  const extensionId = options.extensionId;\n\n  const accountResults: InstallAccountResult[] = [];\n  let overallExitCode = 0;\n\n  // Install to each account\n  for (const account of options.accounts) {\n    platform.info(`Installing to ${account}...`);\n\n    // Build tfx arguments for this account\n    const args = new ArgBuilder()\n      .arg(['extension', 'install'])\n      .flag('--json')\n      .flag('--no-color')\n      .option('--publisher', options.publisherId)\n      .option('--extension-id', extensionId)\n      .option('--service-url', account);\n\n    // Version if specified\n    if (options.extensionVersion) {\n      args.option('--extension-version', options.extensionVersion);\n    }\n\n    // Authentication (using marketplace auth, not account-specific)\n    args.option('--auth-type', auth.authType);\n\n    if (auth.authType === 'pat') {\n      args.option('--token', auth.token);\n      platform.setSecret(auth.token);\n    } else if (auth.authType === 'basic') {\n      args.option('--username', auth.username);\n      args.option('--password', auth.password);\n      platform.setSecret(auth.password);\n    }\n\n    try {\n      // Execute tfx\n      const result = await tfx.execute(args.build(), { captureJson: true });\n\n      if (result.exitCode === 0) {\n        accountResults.push({\n          account,\n          success: true,\n          alreadyInstalled: false,\n        });\n        platform.info(`\u2713 Successfully installed to ${account}`);\n      } else {\n        // Check if error is \"already installed\" (TF1590010)\n        const stderr = result.stderr || '';\n        const alreadyInstalled = stderr.includes('TF1590010');\n\n        if (alreadyInstalled) {\n          accountResults.push({\n            account,\n            success: true,\n            alreadyInstalled: true,\n          });\n          platform.warning(`Extension already installed in ${account} - continuing`);\n        } else {\n          accountResults.push({\n            account,\n            success: false,\n            alreadyInstalled: false,\n            error: `Exit code ${result.exitCode}`,\n          });\n          platform.error(`\u2717 Failed to install to ${account}: exit code ${result.exitCode}`);\n          overallExitCode = result.exitCode;\n        }\n      }\n    } catch (err) {\n      accountResults.push({\n        account,\n        success: false,\n        alreadyInstalled: false,\n        error: String(err),\n      });\n      platform.error(`\u2717 Failed to install to ${account}: ${err}`);\n      overallExitCode = 1;\n    }\n  }\n\n  const allSuccess = accountResults.every((r) => r.success);\n  const successCount = accountResults.filter((r) => r.success).length;\n\n  platform.info(`Installation complete: ${successCount}/${options.accounts.length} succeeded`);\n\n  return {\n    extensionId,\n    publisherId: options.publisherId,\n    accountResults,\n    allSuccess,\n    exitCode: overallExitCode,\n  };\n}\n", "/**\n * Show command - Displays extension metadata from marketplace\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for show command\n */\nexport interface ShowOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n}\n\n/**\n * Extension metadata from marketplace\n */\nexport interface ExtensionMetadata {\n  /** Extension ID */\n  id: string;\n  /** Publisher ID */\n  publisher: string;\n  /** Extension version */\n  version: string;\n  /** Display name */\n  name?: string;\n  /** Description */\n  description?: string;\n  /** Categories */\n  categories?: string[];\n  /** Tags */\n  tags?: string[];\n  /** Any other metadata from tfx */\n  [key: string]: any;\n}\n\n/**\n * Result from show command\n */\nexport interface ShowResult {\n  /** Extension metadata */\n  metadata: ExtensionMetadata;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Show extension metadata from marketplace\n * @param options Show options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Show result with extension metadata\n */\nexport async function showExtension(\n  options: ShowOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<ShowResult> {\n  platform.info(`Querying extension ${options.publisherId}.${options.extensionId}...`);\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'show'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId);\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension show failed with exit code ${result.exitCode}`);\n  }\n\n  // Parse JSON result\n  const json = result.json as any;\n  if (!json) {\n    throw new Error('tfx did not return expected JSON output');\n  }\n\n  const metadata: ExtensionMetadata = {\n    id: json.extensionId || json.id || extensionId,\n    publisher: json.publisher || options.publisherId,\n    version: json.version || json.versions?.[0]?.version || '',\n    name: json.extensionName || json.displayName || json.name,\n    description: json.shortDescription || json.description,\n    categories: json.categories,\n    tags: json.tags,\n    ...json, // Include all other fields\n  };\n\n  platform.info(`Extension: ${metadata.name || metadata.id} v${metadata.version}`);\n  if (metadata.description) {\n    platform.info(`Description: ${metadata.description}`);\n  }\n\n  return {\n    metadata,\n    exitCode: result.exitCode,\n  };\n}\n", "import type { AuthCredentials } from '../auth.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport { showExtension } from './show.js';\n\nexport type VersionAction = 'None' | 'Major' | 'Minor' | 'Patch';\n\nexport interface QueryVersionOptions {\n  publisherId: string;\n  extensionId: string;\n  versionAction?: VersionAction;\n  extensionVersionOverrideVariable?: string;\n}\n\nexport interface QueryVersionResult {\n  currentVersion: string;\n  proposedVersion: string;\n  version: string;\n  source: 'override' | 'marketplace';\n}\n\nfunction applyVersionAction(version: string, versionAction: VersionAction): string {\n  if (versionAction === 'None') {\n    return version;\n  }\n\n  const versionParts = version.split('.').map((part) => Number.parseInt(part, 10));\n  if (\n    versionParts.length !== 3 ||\n    Number.isNaN(versionParts[0]) ||\n    Number.isNaN(versionParts[1]) ||\n    Number.isNaN(versionParts[2])\n  ) {\n    throw new Error(`Version '${version}' is not a valid semantic version (major.minor.patch)`);\n  }\n\n  switch (versionAction) {\n    case 'Major':\n      return `${versionParts[0] + 1}.0.0`;\n    case 'Minor':\n      return `${versionParts[0]}.${versionParts[1] + 1}.0`;\n    case 'Patch':\n      return `${versionParts[0]}.${versionParts[1]}.${versionParts[2] + 1}`;\n    default:\n      return version;\n  }\n}\n\nexport async function queryVersion(\n  options: QueryVersionOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<QueryVersionResult> {\n  const versionAction = options.versionAction ?? 'None';\n\n  if (options.extensionVersionOverrideVariable) {\n    platform.debug(\n      `Override variable '${options.extensionVersionOverrideVariable}' specified, checking for value.`\n    );\n    const overrideVersion = platform.getVariable(options.extensionVersionOverrideVariable);\n    if (overrideVersion) {\n      platform.info(\n        `Ignoring marketplace version and using supplied override: ${overrideVersion}.`\n      );\n      platform.setVariable('currentVersion', overrideVersion, false, true);\n      platform.setVariable('proposedVersion', overrideVersion, false, true);\n      return {\n        currentVersion: overrideVersion,\n        proposedVersion: overrideVersion,\n        version: overrideVersion,\n        source: 'override',\n      };\n    }\n  }\n\n  const showResult = await showExtension(\n    {\n      publisherId: options.publisherId,\n      extensionId: options.extensionId,\n    },\n    auth,\n    tfx,\n    platform\n  );\n\n  const marketplaceVersion = showResult.metadata.version;\n  if (!marketplaceVersion) {\n    throw new Error('Could not determine extension version from marketplace response');\n  }\n\n  platform.info(`Latest version   : ${marketplaceVersion}.`);\n  platform.info(`Requested action : ${versionAction}.`);\n\n  const updatedVersion = applyVersionAction(marketplaceVersion, versionAction);\n  if (updatedVersion !== marketplaceVersion) {\n    platform.info(`Updated to       : ${updatedVersion}.`);\n  }\n\n  platform.setVariable('currentVersion', marketplaceVersion, false, true);\n  platform.setVariable('proposedVersion', updatedVersion, false, true);\n\n  return {\n    currentVersion: marketplaceVersion,\n    proposedVersion: updatedVersion,\n    version: updatedVersion,\n    source: 'marketplace',\n  };\n}\n", "/**\n * WaitForValidation command - Validates extension against marketplace with retry\n */\n\nimport { ArgBuilder } from '../arg-builder.js';\nimport type { AuthCredentials } from '../auth.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\n\n/**\n * Validation status from marketplace\n */\nexport type ValidationStatus = 'pending' | 'success' | 'failed' | 'error';\n\n/**\n * Options for waitForValidation command\n */\nexport interface WaitForValidationOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Root folder for manifest (if validating from manifest) */\n  rootFolder?: string;\n  /** Manifest globs (if validating from manifest) */\n  manifestGlobs?: string[];\n  /** Max retries for pending validation (default: 10) */\n  maxRetries?: number;\n  /** Min timeout between retries in minutes (default: 1) */\n  minTimeout?: number;\n  /** Max timeout between retries in minutes (default: 15) */\n  maxTimeout?: number;\n}\n\n/**\n * Result from waitForValidation command\n */\nexport interface WaitForValidationResult {\n  /** Validation status */\n  status: ValidationStatus;\n  /** Whether extension is valid */\n  isValid: boolean;\n  /** Extension ID */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Number of attempts made */\n  attempts: number;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Validate extension against marketplace\n * Retries if validation is pending\n * @param options WaitForValidation options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns WaitForValidation result\n */\nexport async function waitForValidation(\n  options: WaitForValidationOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<WaitForValidationResult> {\n  platform.info(`Validating extension ${options.publisherId}.${options.extensionId}...`);\n\n  const extensionId = options.extensionId;\n\n  // Retry configuration\n  const maxRetries = options.maxRetries ?? 10;\n  const minTimeoutMs = (options.minTimeout ?? 1) * 60 * 1000;\n  const maxTimeoutMs = (options.maxTimeout ?? 15) * 60 * 1000;\n\n  let attempts = 0;\n  let lastStatus: ValidationStatus = 'pending';\n  let lastExitCode = 0;\n\n  while (attempts < maxRetries) {\n    attempts++;\n    platform.info(`Validation attempt ${attempts}/${maxRetries}...`);\n\n    // Build tfx arguments\n    const args = new ArgBuilder()\n      .arg(['extension', 'isvalid'])\n      .flag('--json')\n      .flag('--no-color')\n      .option('--publisher', options.publisherId)\n      .option('--extension-id', extensionId);\n\n    // Manifest arguments if provided\n    if (options.rootFolder) {\n      args.option('--root', options.rootFolder);\n    }\n\n    if (options.manifestGlobs && options.manifestGlobs.length > 0) {\n      args.flag('--manifest-globs');\n      options.manifestGlobs.forEach((glob) => args.arg(glob));\n    }\n\n    // Authentication\n    args.option('--service-url', auth.serviceUrl);\n\n    if (auth.authType === 'pat') {\n      args.option('--auth-type', 'pat');\n      args.option('--token', auth.token);\n      platform.setSecret(auth.token);\n    } else if (auth.authType === 'basic') {\n      args.option('--auth-type', 'basic');\n      args.option('--username', auth.username);\n      args.option('--password', auth.password);\n      platform.setSecret(auth.password);\n    }\n\n    try {\n      // Execute tfx (allow non-zero exit codes for pending/failed status)\n      const result = await tfx.execute(args.build(), { captureJson: true });\n      lastExitCode = result.exitCode;\n\n      // Parse JSON result\n      const json = result.json as any;\n      if (json && json.status) {\n        lastStatus = json.status as ValidationStatus;\n\n        switch (lastStatus) {\n          case 'success':\n            platform.info('\u2713 Extension validation succeeded');\n            return {\n              status: lastStatus,\n              isValid: true,\n              extensionId,\n              publisherId: options.publisherId,\n              attempts,\n              exitCode: result.exitCode,\n            };\n\n          case 'pending':\n            platform.info('\u23F3 Validation pending, retrying...');\n            // Wait before retry with exponential backoff\n            if (attempts < maxRetries) {\n              const waitTime = Math.min(minTimeoutMs * Math.pow(2, attempts - 1), maxTimeoutMs);\n              platform.debug(`Waiting ${waitTime / 1000}s before retry...`);\n              await sleep(waitTime);\n            }\n            break;\n\n          case 'failed':\n          case 'error':\n            platform.error(`\u2717 Extension validation failed: ${lastStatus}`);\n            return {\n              status: lastStatus,\n              isValid: false,\n              extensionId,\n              publisherId: options.publisherId,\n              attempts,\n              exitCode: result.exitCode,\n            };\n\n          default:\n            platform.warning(`Unknown validation status: ${lastStatus}`);\n            break;\n        }\n      } else {\n        platform.warning('No status in validation response');\n      }\n    } catch (err) {\n      platform.error(`Validation attempt ${attempts} failed: ${err}`);\n      if (attempts >= maxRetries) {\n        throw err;\n      }\n      // Wait before retry\n      await sleep(minTimeoutMs);\n    }\n  }\n\n  // Max retries reached\n  platform.error(\n    `\u2717 Extension validation timed out after ${attempts} attempts (status: ${lastStatus})`\n  );\n  return {\n    status: lastStatus,\n    isValid: false,\n    extensionId,\n    publisherId: options.publisherId,\n    attempts,\n    exitCode: lastExitCode,\n  };\n}\n\n/**\n * Sleep for specified milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "import { WebApi, getPersonalAccessTokenHandler } from 'azure-devops-node-api';\nimport type { ITaskAgentApi } from 'azure-devops-node-api/TaskAgentApi.js';\nimport type { TaskDefinition } from 'azure-devops-node-api/interfaces/TaskAgentInterfaces.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { readManifest, resolveTaskManifestPaths } from '../manifest-utils.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport { VsixReader } from '../vsix-reader.js';\n\nexport interface ExpectedTask {\n  name: string;\n  versions: string[]; // Expected versions (major.minor.patch)\n}\n\nexport interface WaitForInstallationOptions {\n  publisherId: string;\n  extensionId: string;\n  accounts: string[]; // Target org URLs\n  expectedTasks?: ExpectedTask[]; // Tasks with expected versions\n  manifestPath?: string; // Path to extension manifest (vss-extension.json) to read task versions\n  vsixPath?: string; // Path to VSIX file to read task versions from\n  timeoutMinutes?: number; // Default: 10\n  pollingIntervalSeconds?: number; // Default: 30\n}\n\nexport interface InstalledTask {\n  name: string;\n  id: string;\n  version: string;\n  friendlyName: string;\n  matchesExpected: boolean; // True if this version is one of the expected versions\n}\n\nexport interface WaitForInstallationResult {\n  success: boolean;\n  accountResults: {\n    accountUrl: string;\n    available: boolean;\n    installedTasks: InstalledTask[];\n    missingTasks: string[]; // Task names that are completely missing\n    missingVersions: string[]; // Task/version combinations that are missing (e.g., \"TaskName@1.0.0\")\n    error?: string;\n  }[];\n  allTasksAvailable: boolean;\n}\n\nfunction validateWaitForInstallationServiceUrl(serviceUrl: string | undefined): void {\n  if (!serviceUrl) {\n    throw new Error(\n      'wait-for-installation requires service-url to be set to an Azure DevOps organization/server endpoint (not marketplace)'\n    );\n  }\n\n  let parsedUrl: URL;\n  try {\n    parsedUrl = new URL(serviceUrl);\n  } catch {\n    throw new Error(\n      'wait-for-installation requires service-url to be a valid HTTPS Azure DevOps organization/server URL'\n    );\n  }\n\n  const hostname = parsedUrl.hostname.toLowerCase();\n  if (hostname === 'marketplace.visualstudio.com') {\n    throw new Error(\n      'wait-for-installation cannot use the default marketplace endpoint. Set service-url to https://dev.azure.com/<organization>'\n    );\n  }\n\n  if (parsedUrl.protocol !== 'https:') {\n    throw new Error(\n      'wait-for-installation requires service-url to be a valid HTTPS Azure DevOps organization/server URL'\n    );\n  }\n}\n\n/**\n * Resolve expected tasks from various sources\n */\nasync function resolveExpectedTasks(\n  options: WaitForInstallationOptions,\n  platform: IPlatformAdapter\n): Promise<ExpectedTask[]> {\n  // If expectedTasks is provided directly, use it\n  if (options.expectedTasks && options.expectedTasks.length > 0) {\n    platform.debug(`Using ${options.expectedTasks.length} expected tasks from options`);\n    return options.expectedTasks;\n  }\n\n  // If manifestPath is provided, read task versions from manifest\n  if (options.manifestPath) {\n    try {\n      platform.debug(`Reading task versions from manifest: ${options.manifestPath}`);\n      const manifest = await readManifest(options.manifestPath, platform);\n      const taskPaths = resolveTaskManifestPaths(manifest, options.manifestPath, platform);\n\n      const tasks: ExpectedTask[] = [];\n      for (const taskPath of taskPaths) {\n        try {\n          const taskManifest = (await readManifest(taskPath, platform)) as any;\n          if (taskManifest.name && taskManifest.version) {\n            const version = `${taskManifest.version.Major}.${taskManifest.version.Minor}.${taskManifest.version.Patch}`;\n            tasks.push({\n              name: taskManifest.name as string,\n              versions: [version],\n            });\n            platform.debug(`Found task ${taskManifest.name} v${version}`);\n          }\n        } catch (error) {\n          platform.warning(\n            `Failed to read task manifest ${taskPath}: ${error instanceof Error ? error.message : String(error)}`\n          );\n        }\n      }\n\n      if (tasks.length > 0) {\n        platform.debug(`Resolved ${tasks.length} tasks from manifest`);\n        return tasks;\n      }\n    } catch (error) {\n      platform.warning(\n        `Failed to read manifest ${options.manifestPath}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // If vsixPath is provided, read task versions from VSIX\n  if (options.vsixPath) {\n    try {\n      platform.debug(`Reading task versions from VSIX: ${options.vsixPath}`);\n      const reader = await VsixReader.open(options.vsixPath);\n\n      try {\n        const tasksInfo = await reader.getTasksInfo();\n        const tasks: ExpectedTask[] = tasksInfo.map((task) => ({\n          name: task.name,\n          versions: [task.version],\n        }));\n\n        platform.debug(`Resolved ${tasks.length} tasks from VSIX`);\n        return tasks;\n      } finally {\n        await reader.close();\n      }\n    } catch (error) {\n      platform.warning(\n        `Failed to read VSIX ${options.vsixPath}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // No expected tasks specified\n  return [];\n}\n\n/**\n * Verify that an extension's tasks are installed and available in Azure DevOps organizations.\n * Uses Azure DevOps REST API to poll for task availability.\n */\nexport async function waitForInstallation(\n  options: WaitForInstallationOptions,\n  auth: AuthCredentials,\n  platform: IPlatformAdapter\n): Promise<WaitForInstallationResult> {\n  validateWaitForInstallationServiceUrl(auth.serviceUrl);\n\n  const fullExtensionId = options.extensionId;\n\n  const timeoutMs = (options.timeoutMinutes ?? 10) * 60_000;\n  const pollingIntervalMs = (options.pollingIntervalSeconds ?? 30) * 1000;\n\n  platform.debug(\n    `Verifying installation of ${options.publisherId}.${fullExtensionId} in ${options.accounts.length} account(s)`\n  );\n\n  // Resolve expected tasks with versions\n  const expectedTasks = await resolveExpectedTasks(options, platform);\n\n  const accountResults: WaitForInstallationResult['accountResults'] = [];\n\n  for (const accountUrl of options.accounts) {\n    platform.debug(`Checking account: ${accountUrl}`);\n    platform.info(\n      `Polling for task availability (timeout: ${options.timeoutMinutes ?? 10} minutes, interval: ${options.pollingIntervalSeconds ?? 30} seconds)`\n    );\n\n    try {\n      // Create Azure DevOps API connection\n      if (!auth.token) {\n        throw new Error('PAT token is required for waitForInstallation command');\n      }\n\n      const handler = getPersonalAccessTokenHandler(auth.token);\n      const connection = new WebApi(accountUrl, handler);\n      const taskAgentApi: ITaskAgentApi = await connection.getTaskAgentApi();\n\n      // Poll until tasks appear or timeout\n      const deadline = Date.now() + timeoutMs;\n      let lastError: Error | undefined;\n      let found = false;\n      let finalInstalledTasks: InstalledTask[] = [];\n      let finalMissingTasks: string[] = [];\n      let finalMissingVersions: string[] = [];\n      let pollCount = 0;\n\n      while (Date.now() < deadline && !found) {\n        pollCount++;\n        const remainingMs = deadline - Date.now();\n        const remainingMinutes = Math.ceil(remainingMs / 60_000);\n\n        platform.debug(`Poll attempt ${pollCount} (${remainingMinutes} minute(s) remaining)`);\n\n        try {\n          const taskDefinitions: TaskDefinition[] = await taskAgentApi.getTaskDefinitions();\n\n          // Find tasks matching the extension\n          const installedTasks: InstalledTask[] = [];\n          const missingTasks: string[] = [];\n          const missingVersions: string[] = [];\n\n          // If we have expected tasks, check for them specifically\n          if (expectedTasks.length > 0) {\n            for (const expectedTask of expectedTasks) {\n              // Find all installed versions of this task\n              const installedTaskVersions = taskDefinitions.filter(\n                (t) =>\n                  t.name?.toLowerCase() === expectedTask.name.toLowerCase() && t.id && t.version\n              );\n\n              if (installedTaskVersions.length === 0) {\n                // Task name not found at all\n                missingTasks.push(expectedTask.name);\n                // Also track specific versions that are missing\n                for (const ver of expectedTask.versions) {\n                  missingVersions.push(`${expectedTask.name}@${ver}`);\n                }\n                continue;\n              }\n\n              // Check each installed version of this task\n              for (const installedTask of installedTaskVersions) {\n                const installedVersion = `${installedTask.version.major}.${installedTask.version.minor}.${installedTask.version.patch}`;\n\n                // Check if this version matches any expected version\n                const matchesExpected = expectedTask.versions.includes(installedVersion);\n\n                installedTasks.push({\n                  name: installedTask.name,\n                  id: installedTask.id,\n                  version: installedVersion,\n                  friendlyName: installedTask.friendlyName || installedTask.name,\n                  matchesExpected,\n                });\n              }\n\n              // Check if all required versions are present\n              const installedVersionStrings = installedTaskVersions.map(\n                (t) => `${t.version.major}.${t.version.minor}.${t.version.patch}`\n              );\n\n              for (const expectedVer of expectedTask.versions) {\n                if (!installedVersionStrings.includes(expectedVer)) {\n                  missingVersions.push(`${expectedTask.name}@${expectedVer}`);\n                  platform.debug(`Missing version ${expectedVer} for task ${expectedTask.name}`);\n                }\n              }\n            }\n\n            // Success if all tasks found and all required versions present\n            if (missingTasks.length === 0 && missingVersions.length === 0) {\n              found = true;\n              finalInstalledTasks = installedTasks;\n              finalMissingTasks = missingTasks;\n              finalMissingVersions = missingVersions;\n\n              // Count unique task names and total expected versions\n              const uniqueTasks = new Set(expectedTasks.map((t) => t.name));\n              const totalExpectedVersions = expectedTasks.reduce((sum, t) => {\n                return sum + t.versions.length;\n              }, 0);\n\n              platform.info(\n                `\u2713 All ${uniqueTasks.size} expected task(s) with ${totalExpectedVersions} version(s) found in ${accountUrl}`\n              );\n            } else if (missingTasks.length > 0) {\n              platform.debug(`Missing ${missingTasks.length} task(s): ${missingTasks.join(', ')}`);\n            } else if (missingVersions.length > 0) {\n              platform.debug(\n                `Missing ${missingVersions.length} version(s): ${missingVersions.join(', ')}`\n              );\n            }\n          } else {\n            // No expected tasks - collect all tasks\n            for (const task of taskDefinitions) {\n              if (task.name && task.id && task.version) {\n                installedTasks.push({\n                  name: task.name,\n                  id: task.id,\n                  version: `${task.version.major}.${task.version.minor}.${task.version.patch}`,\n                  friendlyName: task.friendlyName || task.name,\n                  matchesExpected: true, // No expectations, so all match\n                });\n              }\n            }\n\n            if (installedTasks.length > 0) {\n              found = true;\n              finalInstalledTasks = installedTasks;\n              finalMissingTasks = missingTasks;\n              finalMissingVersions = missingVersions;\n              platform.info(\n                `\u2713 Found ${installedTasks.length} task(s) from extension in ${accountUrl}`\n              );\n            }\n          }\n\n          if (!found && Date.now() < deadline) {\n            // Wait before next poll\n            platform.debug(`Waiting ${pollingIntervalMs / 1000}s before next poll...`);\n            await new Promise((resolve) => setTimeout(resolve, pollingIntervalMs));\n          }\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n          platform.debug(`Error polling for tasks: ${lastError.message}. Retrying...`);\n\n          if (Date.now() < deadline) {\n            await new Promise((resolve) => setTimeout(resolve, pollingIntervalMs));\n          }\n        }\n      }\n\n      if (found) {\n        accountResults.push({\n          accountUrl,\n          available: true,\n          installedTasks: finalInstalledTasks,\n          missingTasks: finalMissingTasks,\n          missingVersions: finalMissingVersions,\n        });\n      } else {\n        const errorMsg = lastError\n          ? `Timeout waiting for tasks. Last error: ${lastError.message}`\n          : `Timeout waiting for tasks after ${options.timeoutMinutes ?? 10} minutes`;\n\n        platform.warning(errorMsg);\n\n        // Calculate all missing versions for expected tasks\n        const allMissingVersions: string[] = [];\n        for (const task of expectedTasks) {\n          for (const ver of task.versions) {\n            allMissingVersions.push(`${task.name}@${ver}`);\n          }\n        }\n\n        accountResults.push({\n          accountUrl,\n          available: false,\n          installedTasks: [],\n          missingTasks: expectedTasks.map((t) => t.name),\n          missingVersions: allMissingVersions,\n          error: errorMsg,\n        });\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      platform.error(`Failed to verify installation in ${accountUrl}: ${errorMsg}`);\n\n      // Calculate all missing versions for expected tasks\n      const allMissingVersions: string[] = [];\n      for (const task of expectedTasks) {\n        for (const ver of task.versions) {\n          allMissingVersions.push(`${task.name}@${ver}`);\n        }\n      }\n\n      accountResults.push({\n        accountUrl,\n        available: false,\n        installedTasks: [],\n        missingTasks: expectedTasks.map((t) => t.name),\n        missingVersions: allMissingVersions,\n        error: errorMsg,\n      });\n    }\n  }\n\n  const allTasksAvailable = accountResults.every(\n    (r) => r.available && r.missingVersions.length === 0\n  );\n\n  // Log summary\n  if (allTasksAvailable) {\n    platform.info(\n      `\u2705 All tasks verified successfully across ${options.accounts.length} account(s)`\n    );\n  } else {\n    const failedAccounts = accountResults.filter((r) => !r.available);\n    const missingVersionAccounts = accountResults.filter(\n      (r) => r.available && r.missingVersions.length > 0\n    );\n\n    if (failedAccounts.length > 0) {\n      platform.warning(`\u274C Failed to verify tasks in ${failedAccounts.length} account(s)`);\n    }\n    if (missingVersionAccounts.length > 0) {\n      platform.warning(`\u26A0\uFE0F Missing versions found in ${missingVersionAccounts.length} account(s)`);\n    }\n  }\n\n  return {\n    success: allTasksAvailable,\n    accountResults,\n    allTasksAvailable,\n  };\n}\n", "import { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\n\n/**\n * Get basic authentication from GitHub Actions inputs\n */\nexport async function getBasicAuth(\n  username: string,\n  password: string,\n  serviceUrl: string | undefined,\n  platform: IPlatformAdapter\n): Promise<AuthCredentials> {\n  if (!username) {\n    throw new Error('Username is required for basic authentication');\n  }\n\n  if (password === undefined || password === null) {\n    throw new Error('Password is required for basic authentication');\n  }\n\n  // Mask the password immediately to prevent exposure in logs\n  // Note: username is typically not sensitive, but password definitely is\n  // We mask even empty passwords for consistency\n  platform.setSecret(password);\n\n  // Use provided service URL or default to marketplace\n  const finalServiceUrl = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  return {\n    authType: 'basic',\n    serviceUrl: finalServiceUrl,\n    username,\n    password,\n  };\n}\n", "import * as core from '@actions/core';\nimport * as exec from '@actions/exec';\nimport { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\n\n/**\n * Get Azure AD token via Azure CLI for marketplace authentication\n *\n * This approach requires the azure/login action to be run first with OIDC federation.\n * The azure/login action handles:\n * 1. GitHub OIDC \u2192 Azure AD federation\n * 2. Azure CLI authentication\n *\n * Then this function retrieves an Azure AD access token using the Azure CLI.\n * This token is accepted by the Visual Studio Marketplace.\n *\n * This mirrors the Azure Pipelines approach where Azure RM service connections\n * provide Azure AD tokens for marketplace operations.\n *\n * Requirements:\n * 1. Run azure/login action first:\n *    ```yaml\n *    - uses: azure/login@v2\n *      with:\n *        client-id: ${{ secrets.AZURE_CLIENT_ID }}\n *        tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n *        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n *    ```\n *\n * 2. Azure App Registration with:\n *    - Federated credentials for GitHub Actions\n *    - Appropriate permissions (if needed for marketplace)\n *\n * See: https://jessehouwing.net/authenticate-connect-mggraph-using-oidc-in-github-actions/\n *\n * @param resource - The Azure resource to get token for (defaults to marketplace)\n * @param platform - Platform adapter for secret masking\n */\nexport async function getOidcAuth(\n  serviceUrl: string | undefined,\n  platform: IPlatformAdapter\n): Promise<AuthCredentials> {\n  // Determine the resource URL to request token for\n  // If custom service URL is provided, use it as the token resource\n  const tokenResource = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  // Use the provided service URL or default to marketplace URL\n  const finalServiceUrl = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  core.info('Getting Azure AD token via Azure CLI (requires azure/login action)...');\n\n  try {\n    // Execute Azure CLI to get access token\n    let output = '';\n    let errorOutput = '';\n\n    const exitCode = await exec.exec(\n      'az',\n      ['account', 'get-access-token', '--resource', tokenResource, '--output', 'json'],\n      {\n        silent: true,\n        listeners: {\n          stdout: (data: Buffer) => {\n            output += data.toString();\n          },\n          stderr: (data: Buffer) => {\n            errorOutput += data.toString();\n          },\n        },\n      }\n    );\n\n    if (exitCode !== 0) {\n      throw new Error(`Azure CLI exited with code ${exitCode}: ${errorOutput}`);\n    }\n\n    // Parse JSON output\n    const result = JSON.parse(output);\n    const token = result.accessToken;\n\n    if (!token) {\n      throw new Error('No accessToken in Azure CLI response');\n    }\n\n    // Mask the token immediately using both the core API and platform adapter\n    // This provides defense in depth\n    core.setSecret(token);\n    platform.setSecret(token);\n\n    core.info('Successfully obtained Azure AD token via Azure CLI');\n\n    return {\n      authType: 'pat', // Use 'pat' type as the token format is similar\n      serviceUrl: finalServiceUrl,\n      token: token,\n    };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new Error(\n      `Failed to get Azure AD token via Azure CLI: ${message}\\n\\n` +\n        'Make sure you have run the azure/login action before this action:\\n' +\n        '  - uses: azure/login@v2\\n' +\n        '    with:\\n' +\n        '      client-id: ${{ secrets.AZURE_CLIENT_ID }}\\n' +\n        '      tenant-id: ${{ secrets.AZURE_TENANT_ID }}\\n' +\n        '      subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\\n\\n' +\n        'See: https://jessehouwing.net/authenticate-connect-mggraph-using-oidc-in-github-actions/'\n    );\n  }\n}\n", "import { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\n\n/**\n * Get PAT authentication from GitHub Actions input\n */\nexport async function getPatAuth(\n  token: string,\n  serviceUrl: string | undefined,\n  platform: IPlatformAdapter\n): Promise<AuthCredentials> {\n  if (!token) {\n    throw new Error('PAT token is required');\n  }\n\n  // Mask the secret immediately to prevent exposure in logs\n  platform.setSecret(token);\n\n  // Use provided service URL or default to marketplace\n  const finalServiceUrl = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  return {\n    authType: 'pat',\n    serviceUrl: finalServiceUrl,\n    token,\n  };\n}\n", "import { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\nimport { getBasicAuth } from './basic-auth.js';\nimport { getOidcAuth } from './oidc-auth.js';\nimport { getPatAuth } from './pat-auth.js';\n\nexport type AuthType = 'pat' | 'basic' | 'oidc';\n\nexport interface AuthOptions {\n  token?: string;\n  username?: string;\n  password?: string;\n  serviceUrl?: string;\n}\n\n/**\n * Get authentication credentials based on auth type\n */\nexport async function getAuth(\n  authType: AuthType,\n  platform: IPlatformAdapter,\n  options: AuthOptions\n): Promise<AuthCredentials> {\n  const finalServiceUrl = options.serviceUrl;\n\n  switch (authType) {\n    case 'pat':\n      if (!options.token) {\n        throw new Error('Token is required for PAT authentication');\n      }\n      return getPatAuth(options.token, finalServiceUrl, platform);\n\n    case 'basic':\n      if (!options.username || !options.password) {\n        throw new Error('Username and password are required for basic authentication');\n      }\n      return getBasicAuth(options.username, options.password, finalServiceUrl, platform);\n\n    case 'oidc':\n      return getOidcAuth(finalServiceUrl, platform);\n\n    default:\n      throw new Error(`Unsupported auth type: ${authType}`);\n  }\n}\n\nexport { getBasicAuth, getOidcAuth, getPatAuth };\n", "import * as core from '@actions/core';\nimport * as exec from '@actions/exec';\nimport * as glob from '@actions/glob';\nimport * as io from '@actions/io';\nimport * as tc from '@actions/tool-cache';\nimport { ExecOptions, IPlatformAdapter, TaskResult } from '@extension-tasks/core';\nimport { promises as fs } from 'fs';\nimport * as os from 'os';\nimport path from 'path';\n\n/**\n * GitHub Actions platform adapter\n * Implements IPlatformAdapter using @actions/* packages\n */\nexport class GitHubAdapter implements IPlatformAdapter {\n  // ===== Input =====\n\n  getInput(name: string, required?: boolean): string | undefined {\n    const value = core.getInput(name, { required: required || false });\n    return value || undefined;\n  }\n\n  getBoolInput(name: string, required?: boolean): boolean {\n    const value = core.getInput(name, { required: required || false });\n    if (!value) {\n      return false;\n    }\n\n    return core.getBooleanInput(name, { required: required || false });\n  }\n\n  getDelimitedInput(name: string, delimiter: string, required?: boolean): string[] {\n    const value = core.getInput(name, { required: required || false });\n    if (!value) return [];\n    return value\n      .split(delimiter)\n      .map((v) => v.trim())\n      .filter((v) => v);\n  }\n\n  // ===== Output =====\n\n  setOutput(name: string, value: string): void {\n    core.setOutput(name, value);\n  }\n\n  setResult(result: TaskResult, message: string): void {\n    if (result === TaskResult.Succeeded) {\n      core.info(`\u2705 ${message}`);\n    } else if (result === TaskResult.Failed) {\n      core.setFailed(message);\n    } else {\n      core.warning(message);\n    }\n  }\n\n  setVariable(name: string, value: string, isSecret?: boolean, isOutput?: boolean): void {\n    if (isSecret) {\n      core.setSecret(value);\n    }\n    if (isOutput) {\n      core.setOutput(name, value);\n    } else {\n      core.exportVariable(name, value);\n    }\n  }\n\n  setSecret(value: string): void {\n    core.setSecret(value);\n  }\n\n  // ===== Logging =====\n\n  debug(message: string): void {\n    core.debug(message);\n  }\n\n  info(message: string): void {\n    core.info(message);\n  }\n\n  warning(message: string): void {\n    core.warning(message);\n  }\n\n  error(message: string): void {\n    core.error(message);\n  }\n\n  isDebugEnabled(): boolean {\n    return core.isDebug() || process.env.ACTIONS_STEP_DEBUG === 'true';\n  }\n\n  // ===== Execution =====\n\n  async which(tool: string, check?: boolean): Promise<string> {\n    const result = await io.which(tool, check);\n    return result;\n  }\n\n  async exec(tool: string, args: string[], options?: ExecOptions): Promise<number> {\n    let stderr = '';\n    const toolCommand = tool.includes(' ') ? `\"${tool}\"` : tool;\n\n    const listeners = {\n      stdout: (data: Buffer) => {\n        const str = data.toString();\n        if (options?.outStream) {\n          options.outStream.write(str);\n        }\n      },\n      stderr: (data: Buffer) => {\n        const str = data.toString();\n        stderr += str;\n        if (options?.errStream) {\n          options.errStream.write(str);\n        }\n      },\n    };\n\n    const exitCode = await exec.exec(toolCommand, args, {\n      cwd: options?.cwd,\n      env: options?.env,\n      silent: options?.silent,\n      ignoreReturnCode: options?.ignoreReturnCode,\n      listeners,\n    });\n\n    if (options?.failOnStdErr && stderr) {\n      throw new Error(`Command failed with stderr: ${stderr}`);\n    }\n\n    return exitCode;\n  }\n\n  // ===== Filesystem =====\n\n  async findMatch(root: string, patterns: string[]): Promise<string[]> {\n    const normalizedPatterns = patterns\n      .map((pattern) => pattern.trim())\n      .filter((pattern) => pattern.length > 0)\n      .map((pattern) => {\n        const isExclude = pattern.startsWith('!');\n        const value = isExclude ? pattern.slice(1) : pattern;\n        const rootedPattern = path.isAbsolute(value) ? value : path.join(root, value);\n        const normalized = rootedPattern.replace(/\\\\/g, '/');\n        return isExclude ? `!${normalized}` : normalized;\n      });\n\n    if (normalizedPatterns.length === 0) {\n      return [];\n    }\n\n    const globber = await glob.create(normalizedPatterns.join('\\n'));\n    const matches = await globber.glob();\n\n    return Array.from(new Set(matches.map((match) => path.resolve(match))));\n  }\n\n  async fileExists(filePath: string): Promise<boolean> {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async readFile(filePath: string): Promise<string> {\n    return fs.readFile(filePath, 'utf-8');\n  }\n\n  async writeFile(filePath: string, content: string): Promise<void> {\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  async mkdirP(dirPath: string): Promise<void> {\n    await io.mkdirP(dirPath);\n  }\n\n  async rmRF(dirPath: string): Promise<void> {\n    await io.rmRF(dirPath);\n  }\n\n  // ===== Environment =====\n\n  getVariable(name: string): string | undefined {\n    return process.env[name];\n  }\n\n  getTempDir(): string {\n    return process.env.RUNNER_TEMP || os.tmpdir();\n  }\n\n  // ===== Tool Management =====\n\n  async cacheDir(sourceDir: string, tool: string, version: string): Promise<string> {\n    return tc.cacheDir(sourceDir, tool, version);\n  }\n\n  findCachedTool(tool: string, version: string): string | undefined {\n    const found = tc.find(tool, version);\n    return found || undefined;\n  }\n\n  async downloadTool(url: string): Promise<string> {\n    return tc.downloadTool(url);\n  }\n}\n", null, null, null, null, null, null, null, null, null, null],
  "mappings": "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",
  "names": ["path", "URL", "URL", "Buffer", "match", "path", "match", "match", "match", "result", "XMLParser", "attStr", "XMLParser", "XMLBuilder", "Buffer", "validateZipPath", "path", "readFile", "path", "Buffer", "path", "VsixReader", "FilesystemManifestReader", "VsixWriter", "FilesystemManifestWriter", "minimatch", "Minimatch", "path", "filter", "makeRe", "braceExpand", "debug", "set", "parse", "match", "core", "TaskResult", "error", "path", "path", "error", "error", "error", "FilesystemManifestReader", "ManifestEditor", "error", "error", "core", "exec", "core", "fs", "core", "path", "path", "dirname", "MatchKind", "IS_WINDOWS", "dirname", "path", "assert", "path", "assert", "IS_WINDOWS", "dirname", "basename", "minimatch", "IS_WINDOWS", "homedir", "assert", "dirname", "path", "IS_WINDOWS", "match", "partialMatch", "core", "fs", "os", "path", "match", "error"]
}
