{
  "version": 3,
  "sources": ["../../core/src/manifest-reader.ts", "../../../node_modules/uuid/dist-node/regex.js", "../../../node_modules/uuid/dist-node/validate.js", "../../../node_modules/uuid/dist-node/parse.js", "../../../node_modules/uuid/dist-node/stringify.js", "../../../node_modules/uuid/dist-node/v35.js", "../../../node_modules/uuid/dist-node/sha1.js", "../../../node_modules/uuid/dist-node/v5.js", "../../../node_modules/uuid/dist-node/index.js", "../../core/src/vsix-writer.ts", "../../core/src/filesystem-manifest-writer.ts", "../../core/src/manifest-editor.ts", "../../core/src/filesystem-manifest-reader.ts", "../../../node_modules/concat-map/index.js", "../../../node_modules/balanced-match/index.js", "../../../node_modules/brace-expansion/index.js", "../../../node_modules/minimatch/minimatch.js", "../src/main.ts", "../../core/src/platform.ts", "../../core/src/arg-builder.ts", "../../core/src/json-output-stream.ts", "../../core/src/manifest-utils.ts", "../../core/src/tfx-manager.ts", "../../core/src/index.ts", "../../core/src/vsix-reader.ts", "../../core/src/validation.ts", "../../core/src/commands/package.ts", "../../core/src/commands/publish.ts", "../../core/src/commands/unpublish.ts", "../../core/src/commands/share.ts", "../../core/src/commands/unshare.ts", "../../core/src/commands/install.ts", "../../core/src/commands/show.ts", "../../core/src/commands/query-version.ts", "../../core/src/commands/wait-for-validation.ts", "../../core/src/commands/wait-for-installation.ts", "../src/auth/basic-auth.ts", "../src/auth/oidc-auth.ts", "../src/auth/pat-auth.ts", "../src/auth/index.ts", "../src/github-adapter.ts", "../../../node_modules/@actions/glob/src/internal-globber.ts", "../../../node_modules/@actions/glob/src/internal-glob-options-helper.ts", "../../../node_modules/@actions/glob/src/internal-path-helper.ts", "../../../node_modules/@actions/glob/src/internal-match-kind.ts", "../../../node_modules/@actions/glob/src/internal-pattern-helper.ts", "../../../node_modules/@actions/glob/src/internal-pattern.ts", "../../../node_modules/@actions/glob/src/internal-path.ts", "../../../node_modules/@actions/glob/src/internal-search-state.ts", "../../../node_modules/@actions/glob/src/internal-hash-files.ts", "../../../node_modules/@actions/glob/src/glob.ts"],
  "sourcesContent": ["/**\n * Manifest Reader - Base class for reading extension and task manifests\n *\n * Provides abstract interface for reading manifests from different sources\n * (VSIX files, filesystem, etc.). Implementations provide source-specific\n * reading logic while sharing the same interface.\n *\n * Architecture:\n * - ManifestReader (base/abstract) - defines interface\n * - VsixReader extends ManifestReader - reads from VSIX\n * - FilesystemManifestReader extends ManifestReader - reads from filesystem\n */\n\n/**\n * Extension manifest from vss-extension.json\n */\nexport interface ExtensionManifest {\n  manifestVersion?: number;\n  id: string;\n  publisher: string;\n  version: string;\n  name?: string;\n  description?: string;\n  categories?: string[];\n  tags?: string[];\n  targets?: Array<{ id: string }>;\n  icons?: Record<string, string>;\n  content?: Record<string, string>;\n  files?: Array<{ path: string; packagePath?: string }>;\n  contributions?: Array<{\n    id: string;\n    type: string;\n    targets?: string[];\n    properties?: Record<string, unknown>;\n  }>;\n  galleryFlags?: string[];\n  [key: string]: unknown;\n}\n\n/**\n * Task manifest from task.json\n */\nexport interface TaskManifest {\n  id: string;\n  name: string;\n  friendlyName: string;\n  description: string;\n  version: {\n    Major: number;\n    Minor: number;\n    Patch: number;\n  };\n  instanceNameFormat?: string;\n  inputs?: Array<{\n    name: string;\n    type: string;\n    label: string;\n    required?: boolean;\n    defaultValue?: string;\n    [key: string]: unknown;\n  }>;\n  execution?: Record<string, unknown>;\n  [key: string]: unknown;\n}\n\n/**\n * Quick metadata access\n */\nexport interface ManifestMetadata {\n  publisher: string;\n  extensionId: string;\n  version: string;\n  name?: string;\n  description?: string;\n}\n\n/**\n * Task information\n */\nexport interface TaskInfo {\n  name: string;\n  friendlyName: string;\n  version: string;\n  path: string;\n}\n\n/**\n * ManifestReader - Abstract base class for reading manifests\n *\n * Provides a common interface for reading extension and task manifests\n * from different sources (VSIX files, filesystem, etc.).\n *\n * Subclasses must implement:\n * - readExtensionManifest(): Read the main extension manifest\n * - readTaskManifest(path): Read a specific task manifest\n * - findTaskPaths(): Find all task paths in the extension\n * - close(): Clean up resources\n */\nexport abstract class ManifestReader {\n  /**\n   * Read the extension manifest (vss-extension.json or extension.vsomanifest)\n   * @returns Parsed extension manifest\n   */\n  abstract readExtensionManifest(): Promise<ExtensionManifest>;\n\n  /**\n   * Read a task manifest (task.json)\n   * @param taskPath Path to the task directory or task.json file\n   * @returns Parsed task manifest\n   */\n  abstract readTaskManifest(taskPath: string): Promise<TaskManifest>;\n\n  /**\n   * Find all task paths in the extension\n   * @returns Array of task directory paths\n   */\n  abstract findTaskPaths(): Promise<string[]>;\n\n  /**\n   * Close and clean up resources\n   */\n  abstract close(): Promise<void>;\n\n  /**\n   * Read all task manifests in the extension\n   * Default implementation using findTaskPaths() and readTaskManifest()\n   * Subclasses can override for optimization\n   * @returns Array of task manifests with their paths\n   */\n  async readTaskManifests(): Promise<Array<{ path: string; manifest: TaskManifest }>> {\n    const taskPaths = await this.findTaskPaths();\n    const results: Array<{ path: string; manifest: TaskManifest }> = [];\n\n    for (const taskPath of taskPaths) {\n      try {\n        const manifest = await this.readTaskManifest(taskPath);\n        results.push({ path: taskPath, manifest });\n      } catch {\n        // Skip tasks that don't have valid task.json\n        // Silently continue - caller can check if all expected tasks were found\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Get quick metadata about the extension\n   * Default implementation using readExtensionManifest()\n   * @returns Extension metadata\n   */\n  async getMetadata(): Promise<ManifestMetadata> {\n    const manifest = await this.readExtensionManifest();\n    return {\n      publisher: manifest.publisher,\n      extensionId: manifest.id,\n      version: manifest.version,\n      name: manifest.name,\n      description: manifest.description,\n    };\n  }\n\n  /**\n   * Get information about all tasks in the extension\n   * Default implementation using readTaskManifests()\n   * @returns Array of task information\n   */\n  async getTasksInfo(): Promise<TaskInfo[]> {\n    const tasks = await this.readTaskManifests();\n    return tasks.map(({ path, manifest }) => ({\n      name: manifest.name,\n      friendlyName: manifest.friendlyName,\n      version: `${manifest.version.Major}.${manifest.version.Minor}.${manifest.version.Patch}`,\n      path,\n    }));\n  }\n}\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n", "import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n", "import validate from './validate.js';\nfunction parse(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexport default parse;\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = parse(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\n", "import { createHash } from 'node:crypto';\nfunction sha1(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return createHash('sha1').update(bytes).digest();\n}\nexport default sha1;\n", "import sha1 from './sha1.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v5(value, namespace, buf, offset) {\n    return v35(0x50, sha1, value, namespace, buf, offset);\n}\nv5.DNS = DNS;\nv5.URL = URL;\nexport default v5;\n", "export { default as MAX } from './max.js';\nexport { default as NIL } from './nil.js';\nexport { default as parse } from './parse.js';\nexport { default as stringify } from './stringify.js';\nexport { default as v1 } from './v1.js';\nexport { default as v1ToV6 } from './v1ToV6.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as v6 } from './v6.js';\nexport { default as v6ToV1 } from './v6ToV1.js';\nexport { default as v7 } from './v7.js';\nexport { default as validate } from './validate.js';\nexport { default as version } from './version.js';\n", "/**\n * VSIX Writer - Write modified VSIX files efficiently\n *\n * Optimizes ZIP file updates by copying unchanged entries directly\n * without recompression. Only modified/new files are recompressed.\n *\n * Chain: Reader \u2192 ManifestEditor \u2192 Writer\n */\n\nimport yazl from 'yazl';\nimport { Buffer } from 'buffer';\nimport { createWriteStream } from 'fs';\nimport type { ManifestEditor } from './manifest-editor.js';\nimport type { ExtensionManifest, TaskManifest } from './manifest-reader.js';\n\n/**\n * Validate that a path is safe for writing to ZIP\n * Protects against zip slip vulnerabilities\n * @param filePath Path to validate\n * @throws Error if path is unsafe\n */\nfunction validateZipPath(filePath: string): void {\n  // Same validation as in VsixReader\n  const normalizedPath = filePath.replace(/\\\\/g, '/');\n\n  // Check for absolute paths\n  if (normalizedPath.startsWith('/') || /^[A-Z]:/i.test(normalizedPath)) {\n    throw new Error(`Security: Absolute paths are not allowed: ${filePath}`);\n  }\n\n  // Check for parent directory traversal\n  if (normalizedPath.includes('../') || normalizedPath.startsWith('..')) {\n    throw new Error(`Security: Path traversal detected: ${filePath}`);\n  }\n\n  // Check for null bytes\n  if (normalizedPath.includes('\\0')) {\n    throw new Error(`Security: Null byte detected in path: ${filePath}`);\n  }\n}\n\n/**\n * VsixWriter - Efficient VSIX file writing\n *\n * Example usage:\n * ```typescript\n * const reader = await VsixReader.open('input.vsix');\n * const editor = ManifestEditor.fromReader(reader);\n * editor.setPublisher('new-publisher');\n * const writer = await editor.toWriter();\n * await writer.writeToFile('output.vsix');\n * await writer.close();\n * ```\n */\nexport class VsixWriter {\n  private readonly editor: ManifestEditor;\n  private zipFile: yazl.ZipFile | null = null;\n\n  private constructor(editor: ManifestEditor) {\n    this.editor = editor;\n  }\n\n  /**\n   * Create a writer from an editor\n   * @param editor The ManifestEditor with modifications\n   * @returns VsixWriter instance\n   */\n  static fromEditor(editor: ManifestEditor): VsixWriter {\n    return new VsixWriter(editor);\n  }\n\n  /**\n   * Write the modified VSIX to a file\n   *\n   * This method efficiently copies unchanged entries from the source VSIX\n   * without recompression, significantly improving performance for large files.\n   *\n   * @param outputPath Path where the new VSIX should be written\n   * @returns Promise that resolves when writing is complete\n   */\n  async writeToFile(outputPath: string): Promise<void> {\n    const reader = this.editor.getReader();\n    const modifications = this.editor.getModifications();\n    const manifestMods = this.editor.getManifestModifications();\n    const taskManifestMods = this.editor.getTaskManifestModifications();\n\n    // Create new ZIP file\n    this.zipFile = new yazl.ZipFile();\n\n    // Track which files we've added\n    const addedFiles = new Set<string>();\n\n    // Step 1: Apply manifest modifications\n    const manifestPath = await this.determineManifestPath(reader);\n    if (Object.keys(manifestMods).length > 0 || taskManifestMods.size > 0) {\n      await this.applyManifestModifications(\n        reader,\n        manifestPath,\n        manifestMods,\n        taskManifestMods,\n        addedFiles\n      );\n    }\n\n    // Step 2: Apply file modifications (add/modify/remove)\n    for (const [path, mod] of modifications) {\n      validateZipPath(path);\n\n      if (mod.type === 'remove') {\n        // Mark as added so we skip it when copying from source\n        addedFiles.add(path);\n      } else if (mod.type === 'modify' && mod.content) {\n        // Add modified file\n        this.zipFile.addBuffer(mod.content, path);\n        addedFiles.add(path);\n      }\n    }\n\n    // Step 3: Copy all other files from source VSIX efficiently\n    // This is the key optimization: unchanged files are copied without recompression\n    await this.copyUnchangedFiles(reader, addedFiles);\n\n    // Step 4: Finalize and write\n    await this.finalizeZip(outputPath);\n  }\n\n  /**\n   * Write the modified VSIX to a buffer in memory\n   * @returns Promise<Buffer> containing the complete VSIX\n   */\n  async writeToBuffer(): Promise<Buffer> {\n    const reader = this.editor.getReader();\n    const modifications = this.editor.getModifications();\n    const manifestMods = this.editor.getManifestModifications();\n    const taskManifestMods = this.editor.getTaskManifestModifications();\n\n    this.zipFile = new yazl.ZipFile();\n    const addedFiles = new Set<string>();\n\n    // Same steps as writeToFile, but collect to buffer\n    const manifestPath = await this.determineManifestPath(reader);\n    if (Object.keys(manifestMods).length > 0 || taskManifestMods.size > 0) {\n      await this.applyManifestModifications(\n        reader,\n        manifestPath,\n        manifestMods,\n        taskManifestMods,\n        addedFiles\n      );\n    }\n\n    for (const [path, mod] of modifications) {\n      validateZipPath(path);\n\n      if (mod.type === 'remove') {\n        addedFiles.add(path);\n      } else if (mod.type === 'modify' && mod.content) {\n        this.zipFile.addBuffer(mod.content, path);\n        addedFiles.add(path);\n      }\n    }\n\n    await this.copyUnchangedFiles(reader, addedFiles);\n\n    return this.finalizeZipToBuffer();\n  }\n\n  /**\n   * Determine which manifest file to use\n   */\n  private async determineManifestPath(reader: any): Promise<string> {\n    if (await reader.fileExists('extension.vsomanifest')) {\n      return 'extension.vsomanifest';\n    }\n    if (await reader.fileExists('vss-extension.json')) {\n      return 'vss-extension.json';\n    }\n    throw new Error('No extension manifest found in source VSIX');\n  }\n\n  /**\n   * Apply modifications to manifests\n   */\n  private async applyManifestModifications(\n    reader: any,\n    manifestPath: string,\n    manifestMods: Partial<ExtensionManifest>,\n    taskManifestMods: Map<string, Partial<TaskManifest>>,\n    addedFiles: Set<string>\n  ): Promise<void> {\n    // Read and modify extension manifest\n    const manifest = await reader.readExtensionManifest();\n    Object.assign(manifest, manifestMods);\n\n    const manifestJson = JSON.stringify(manifest, null, 2);\n    this.zipFile.addBuffer(Buffer.from(manifestJson, 'utf-8'), manifestPath);\n    addedFiles.add(manifestPath);\n\n    // Modify task manifests if needed\n    if (taskManifestMods.size > 0) {\n      const taskManifests = await reader.readTaskManifests();\n\n      for (const taskManifest of taskManifests) {\n        const mods = taskManifestMods.get(taskManifest.manifest.name);\n        if (mods) {\n          // Apply modifications to the manifest object\n          Object.assign(taskManifest.manifest, mods);\n          const taskJson = JSON.stringify(taskManifest.manifest, null, 2);\n          const taskPath = `${taskManifest.path}/task.json`;\n          this.zipFile.addBuffer(Buffer.from(taskJson, 'utf-8'), taskPath);\n          addedFiles.add(taskPath);\n        }\n      }\n    }\n  }\n\n  /**\n   * Copy unchanged files from source VSIX\n   *\n   * This is the key optimization: files are copied directly from the source\n   * ZIP without decompression/recompression, preserving original compression.\n   */\n  private async copyUnchangedFiles(reader: any, addedFiles: Set<string>): Promise<void> {\n    const allFiles = await reader.listFiles();\n\n    for (const file of allFiles) {\n      if (!addedFiles.has(file.path)) {\n        // File hasn't been modified - copy it efficiently\n        // Note: yazl will copy the compressed data directly if we use the right method\n        try {\n          const content = await reader.readFile(file.path);\n          this.zipFile.addBuffer(content, file.path);\n        } catch (err) {\n          // If we can't read it, skip it (might be a directory or corrupt entry)\n          console.warn(`Warning: Could not copy file ${file.path}: ${(err as Error).message}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Finalize ZIP and write to file\n   */\n  private async finalizeZip(outputPath: string): Promise<void> {\n    if (!this.zipFile) {\n      throw new Error('ZIP file not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const outputStream = createWriteStream(outputPath);\n\n      outputStream.on('error', (err) => {\n        reject(new Error(`Failed to write VSIX file: ${err.message}`));\n      });\n\n      outputStream.on('finish', () => {\n        resolve();\n      });\n\n      this.zipFile.outputStream.pipe(outputStream).on('error', (err: Error) => {\n        reject(new Error(`Failed to write VSIX stream: ${err.message}`));\n      });\n\n      this.zipFile.end();\n    });\n  }\n\n  /**\n   * Finalize ZIP to buffer\n   */\n  private async finalizeZipToBuffer(): Promise<Buffer> {\n    if (!this.zipFile) {\n      throw new Error('ZIP file not initialized');\n    }\n\n    return new Promise((resolve, reject) => {\n      const chunks: Buffer[] = [];\n\n      this.zipFile.outputStream.on('data', (chunk: Buffer) => {\n        chunks.push(chunk);\n      });\n\n      this.zipFile.outputStream.on('end', () => {\n        resolve(Buffer.concat(chunks));\n      });\n\n      this.zipFile.outputStream.on('error', (err: Error) => {\n        reject(new Error(`Failed to create VSIX buffer: ${err.message}`));\n      });\n\n      this.zipFile.end();\n    });\n  }\n\n  /**\n   * Close and cleanup resources\n   */\n  async close(): Promise<void> {\n    // ZIP file is automatically closed after end()\n    this.zipFile = null;\n  }\n}\n", "/**\n * Filesystem Manifest Writer - Write modified manifests to filesystem\n *\n * Writes extension and task manifests back to the filesystem and generates\n * an overrides.json file for tfx to use during packaging.\n */\n\nimport { mkdir, readFile, readdir, writeFile } from 'fs/promises';\nimport path from 'path';\nimport type { FilesystemManifestReader } from './filesystem-manifest-reader.js';\nimport type { ManifestEditor } from './manifest-editor.js';\nimport type { ExtensionManifest, TaskManifest } from './manifest-reader.js';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * FilesystemManifestWriter - Write manifests to filesystem\n *\n * Writes modified extension and task manifests directly to filesystem files.\n * Also generates an overrides.json file in the temp directory that tfx can\n * use to override values during packaging without modifying source files.\n *\n * Example usage:\n * ```typescript\n * const reader = new FilesystemManifestReader({ rootFolder: './src', platform });\n * const editor = ManifestEditor.fromReader(reader);\n * editor.setVersion('2.0.0');\n * await editor.updateAllTaskVersions('2.0.0', 'major');\n *\n * const writer = await editor.toWriter();\n * await writer.writeToFilesystem();\n * await writer.close();\n *\n * // Use writer.getOverridesPath() with tfx --overrides-file\n * ```\n */\nexport class FilesystemManifestWriter {\n  private readonly editor: ManifestEditor;\n  private readonly platform: IPlatformAdapter;\n  private overridesPath: string | null = null;\n\n  private constructor(editor: ManifestEditor, platform: IPlatformAdapter) {\n    this.editor = editor;\n    this.platform = platform;\n  }\n\n  /**\n   * Create a writer from an editor\n   * @param editor The editor with modifications\n   * @returns FilesystemManifestWriter instance\n   */\n  static fromEditor(editor: ManifestEditor): FilesystemManifestWriter {\n    const reader = editor.getReader();\n\n    // Ensure reader is a FilesystemManifestReader\n    if (reader.constructor.name !== 'FilesystemManifestReader') {\n      throw new Error('FilesystemManifestWriter can only be used with FilesystemManifestReader');\n    }\n\n    // Get platform from reader (we need it for file operations)\n    const fsReader = reader as FilesystemManifestReader;\n    const platform = (fsReader as any).platform as IPlatformAdapter;\n\n    return new FilesystemManifestWriter(editor, platform);\n  }\n\n  /**\n   * Write modified manifests to the filesystem\n   *\n   * This updates task.json files directly and writes extension manifest changes.\n   * It also generates an overrides.json in the temp directory that can be passed\n   * to tfx with --overrides-file.\n   *\n   * @returns Promise that resolves when writing is complete\n   */\n  async writeToFilesystem(): Promise<void> {\n    const reader = this.editor.getReader() as FilesystemManifestReader;\n    const rootFolder = (reader as any).getRootFolder() as string;\n\n    const manifestMods = this.editor.getManifestModifications();\n    const taskManifestMods = this.editor.getTaskManifestModifications();\n    const fileMods = this.editor.getModifications();\n\n    this.platform.debug('Writing manifests to filesystem...');\n\n    // Step 1: Write task manifest modifications\n    if (taskManifestMods.size > 0) {\n      await this.writeTaskManifests(reader, rootFolder, taskManifestMods);\n    }\n\n    // Step 2: Write extension manifest modifications (if directly modifying source)\n    // Note: For package command, we typically use overrides.json instead\n    // But we support direct writes for other scenarios\n    if (Object.keys(manifestMods).length > 0) {\n      await this.writeExtensionManifest(reader, manifestMods);\n    }\n\n    // Step 3: Write any additional file modifications\n    for (const [filePath, mod] of fileMods) {\n      if (mod.type === 'modify' && mod.content) {\n        const absolutePath = path.isAbsolute(filePath) ? filePath : path.join(rootFolder, filePath);\n\n        this.platform.debug(`Writing file: ${absolutePath}`);\n        await writeFile(absolutePath, mod.content);\n      }\n    }\n\n    // Step 4: Generate overrides.json for extension manifest overrides\n    // This is used by tfx during packaging to override values without modifying source\n    await this.generateOverridesFile(manifestMods);\n\n    this.platform.info('Manifests written to filesystem successfully');\n  }\n\n  /**\n   * Write task manifest modifications to filesystem\n   */\n  private async writeTaskManifests(\n    reader: FilesystemManifestReader,\n    rootFolder: string,\n    taskManifestMods: Map<string, Partial<TaskManifest>>\n  ): Promise<void> {\n    const tasks = await reader.readTaskManifests();\n    const appliedTaskNames = new Set<string>();\n\n    // Get packagePath map to resolve actual source paths\n    const packagePathMap = (await (reader as any).buildPackagePathMap()) as Map<string, string>;\n\n    for (const { path: taskPath, manifest } of tasks) {\n      const mods = taskManifestMods.get(manifest.name);\n      if (mods) {\n        appliedTaskNames.add(manifest.name);\n        // Apply modifications\n        Object.assign(manifest, mods);\n\n        // Resolve actual source path using prefix matching (same logic as reader)\n        let actualPath = taskPath;\n        const normalizedTaskPath = taskPath.replace(/\\\\/g, '/');\n\n        // Try to find a matching packagePath prefix\n        for (const [pkgPath, sourcePath] of packagePathMap.entries()) {\n          const normalizedPkgPath = pkgPath.replace(/\\\\/g, '/');\n\n          // Check for exact match or prefix match (packagePath/subdir)\n          if (normalizedTaskPath === normalizedPkgPath) {\n            // Exact match: TaskName \u2192 sourcePath\n            actualPath = sourcePath;\n            break;\n          } else if (normalizedTaskPath.startsWith(normalizedPkgPath + '/')) {\n            // Prefix match: TaskName/v2 \u2192 sourcePath/v2\n            const remainder = normalizedTaskPath.substring(normalizedPkgPath.length + 1);\n            actualPath = path.join(sourcePath, remainder);\n            break;\n          }\n        }\n\n        this.platform.debug(\n          `Writing task manifest: taskPath='${taskPath}', actualPath='${actualPath}'`\n        );\n\n        // Resolve absolute path\n        const absoluteTaskPath = path.isAbsolute(actualPath)\n          ? actualPath\n          : path.join(rootFolder, actualPath);\n\n        const taskJsonPath = path.join(absoluteTaskPath, 'task.json');\n\n        this.platform.debug(`Writing to file: ${taskJsonPath}`);\n        const manifestJson = JSON.stringify(manifest, null, 2) + '\\n';\n        await writeFile(taskJsonPath, manifestJson, 'utf-8');\n      }\n    }\n\n    // Fallback: apply modifications for tasks not discoverable via contribution paths\n    for (const [taskName, mods] of taskManifestMods.entries()) {\n      if (appliedTaskNames.has(taskName)) {\n        continue;\n      }\n\n      const fallbackTaskDir = await this.findTaskDirectoryByName(rootFolder, taskName);\n      if (!fallbackTaskDir) {\n        this.platform.debug(`No task.json found for task '${taskName}' during fallback write`);\n        continue;\n      }\n\n      const taskJsonPath = path.join(fallbackTaskDir, 'task.json');\n      const content = await readFile(taskJsonPath, 'utf-8');\n      const manifest = JSON.parse(content) as TaskManifest;\n      Object.assign(manifest, mods);\n\n      this.platform.debug(`Fallback writing task manifest: ${taskJsonPath}`);\n      await writeFile(taskJsonPath, JSON.stringify(manifest, null, 2) + '\\n', 'utf-8');\n    }\n  }\n\n  /**\n   * Recursively find a task directory by task manifest name\n   */\n  private async findTaskDirectoryByName(\n    rootFolder: string,\n    taskName: string\n  ): Promise<string | null> {\n    const stack: string[] = [rootFolder];\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n      let entries;\n\n      try {\n        entries = await readdir(current, { withFileTypes: true });\n      } catch {\n        continue;\n      }\n\n      for (const entry of entries) {\n        const absolutePath = path.join(current, entry.name);\n\n        if (entry.isDirectory()) {\n          stack.push(absolutePath);\n          continue;\n        }\n\n        if (!entry.isFile() || entry.name !== 'task.json') {\n          continue;\n        }\n\n        try {\n          const content = await readFile(absolutePath, 'utf-8');\n          const manifest = JSON.parse(content) as TaskManifest;\n          if (manifest.name === taskName) {\n            return path.dirname(absolutePath);\n          }\n        } catch {\n          // ignore unreadable/invalid task manifests during search\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Write extension manifest modifications to filesystem\n   */\n  private async writeExtensionManifest(\n    reader: FilesystemManifestReader,\n    manifestMods: Partial<ExtensionManifest>\n  ): Promise<void> {\n    const manifest = await reader.readExtensionManifest();\n    Object.assign(manifest, manifestMods);\n\n    // Get manifest path from reader\n    const manifestPath = (reader as any).getManifestPath() as string;\n    if (!manifestPath) {\n      throw new Error('Extension manifest path not resolved');\n    }\n\n    this.platform.debug(`Writing extension manifest: ${manifestPath}`);\n    const manifestJson = JSON.stringify(manifest, null, 2) + '\\n';\n    await writeFile(manifestPath, manifestJson, 'utf-8');\n  }\n\n  /**\n   * Generate overrides.json file in temp directory\n   *\n   * This file can be passed to tfx with --overrides-file to override\n   * extension manifest values during packaging without modifying source files.\n   */\n  private async generateOverridesFile(manifestMods: Partial<ExtensionManifest>): Promise<void> {\n    if (Object.keys(manifestMods).length === 0) {\n      this.platform.debug('No manifest modifications, skipping overrides.json generation');\n      return;\n    }\n\n    // Create overrides object with only the fields that should be overridden\n    const overrides: any = {};\n\n    if (manifestMods.publisher) {\n      overrides.publisher = manifestMods.publisher;\n    }\n\n    if (manifestMods.id) {\n      overrides.id = manifestMods.id;\n    }\n\n    if (manifestMods.version) {\n      overrides.version = manifestMods.version;\n    }\n\n    if (manifestMods.name) {\n      overrides.name = manifestMods.name;\n    }\n\n    if (manifestMods.description) {\n      overrides.description = manifestMods.description;\n    }\n\n    if (manifestMods.galleryFlags) {\n      overrides.galleryFlags = manifestMods.galleryFlags;\n    }\n\n    // Write to temp directory\n    const tempDir = this.platform.getTempDir();\n    await mkdir(tempDir, { recursive: true });\n    this.overridesPath = path.join(tempDir, `overrides-${Date.now()}.json`);\n\n    this.platform.debug(`Writing overrides file: ${this.overridesPath}`);\n    const overridesJson = JSON.stringify(overrides, null, 2) + '\\n';\n    await writeFile(this.overridesPath, overridesJson, 'utf-8');\n\n    this.platform.info(`Generated overrides file: ${this.overridesPath}`);\n  }\n\n  /**\n   * Get the path to the generated overrides.json file\n   * This can be passed to tfx with --overrides-file\n   * @returns Path to overrides.json or null if not generated\n   */\n  getOverridesPath(): string | null {\n    return this.overridesPath;\n  }\n\n  /**\n   * Close and cleanup resources\n   */\n  async close(): Promise<void> {\n    // Could clean up overrides file here, but we leave it for tfx to use\n    // Temp directory will be cleaned up by the build agent\n  }\n}\n", "/**\n * Manifest Editor - Unified manifest editing for both VSIX and filesystem sources\n *\n * Provides chainable API for modifying extension and task manifests.\n * Tracks modifications without writing until toWriter() is called.\n * Works with any ManifestReader implementation (VSIX or filesystem).\n *\n * Centralizes all logic for calculating UUIDs, updating task versions, etc.\n */\n\nimport { v5 as uuidv5 } from 'uuid';\nimport type { ManifestReader, ExtensionManifest, TaskManifest } from './manifest-reader.js';\nimport { Buffer } from 'buffer';\n\n/**\n * Tracks a file modification\n */\ninterface FileModification {\n  type: 'add' | 'modify' | 'remove';\n  path: string;\n  content?: Buffer;\n}\n\n/**\n * Options for creating a ManifestEditor\n */\nexport interface ManifestEditorOptions {\n  reader: ManifestReader;\n}\n\n/**\n * Options for applying changes to manifests\n * Contains all possible modifications that can be made to an extension\n */\nexport interface ApplyManifestOptions {\n  // Extension manifest overrides\n  publisherId?: string;\n  extensionId?: string;\n  extensionVersion?: string;\n  extensionName?: string;\n  extensionVisibility?: 'public' | 'private' | 'public_preview' | 'private_preview';\n  extensionPricing?: 'free' | 'paid' | 'trial';\n\n  // Task updates\n  updateTasksVersion?: boolean;\n  updateTasksVersionType?: 'major' | 'minor' | 'patch';\n  updateTasksId?: boolean;\n}\n\n/**\n * ManifestEditor - Unified editor for extension and task manifests\n *\n * Works with any ManifestReader (VsixReader, FilesystemManifestReader, etc.)\n * Provides chainable API for modifications and centralizes all manifest\n * editing logic including UUID generation and task version calculations.\n *\n * Example usage with VSIX:\n * ```typescript\n * const reader = await VsixReader.open('input.vsix');\n * const editor = ManifestEditor.fromReader(reader);\n * await editor\n *   .setPublisher('new-publisher')\n *   .setVersion('2.0.0')\n *   .updateAllTaskVersions('2.0.0', 'major')\n *   .updateAllTaskIds();\n * const writer = await editor.toWriter();\n * await writer.writeToFile('output.vsix');\n * ```\n *\n * Example usage with filesystem:\n * ```typescript\n * const reader = new FilesystemManifestReader({ rootFolder: './src', platform });\n * const editor = ManifestEditor.fromReader(reader);\n * await editor\n *   .setVersion('1.5.0')\n *   .updateAllTaskVersions('1.5.0', 'minor');\n * const writer = await editor.toWriter();\n * await writer.writeToFilesystem('./dist');\n * ```\n */\nexport class ManifestEditor {\n  private readonly reader: ManifestReader;\n  private modifications: Map<string, FileModification> = new Map();\n  private manifestModifications: Partial<ExtensionManifest> = {};\n  private taskManifestModifications: Map<string, Partial<TaskManifest>> = new Map();\n\n  // Track original task IDs for updating extension manifest references\n  private taskIdUpdates: Map<string, { oldId: string; newId: string }> = new Map();\n\n  constructor(options: ManifestEditorOptions) {\n    this.reader = options.reader;\n  }\n\n  /**\n   * Create an editor from a reader\n   * @param reader The manifest reader (VSIX or filesystem)\n   * @returns ManifestEditor instance\n   */\n  static fromReader(reader: ManifestReader): ManifestEditor {\n    return new ManifestEditor({ reader });\n  }\n\n  /**\n   * Apply a set of options to the manifest\n   * This is the main entry point for batch modifications\n   * All conditional logic for applying changes is contained here\n   *\n   * @param options Options to apply\n   * @returns Promise<this> for async chaining\n   */\n  async applyOptions(options: ApplyManifestOptions): Promise<this> {\n    // Apply extension manifest overrides\n    if (options.publisherId) {\n      this.setPublisher(options.publisherId);\n    }\n\n    // Handle extension ID\n    if (options.extensionId) {\n      this.setExtensionId(options.extensionId);\n    }\n\n    if (options.extensionVersion) {\n      this.setVersion(options.extensionVersion);\n    }\n\n    if (options.extensionName) {\n      this.setName(options.extensionName);\n    }\n\n    if (options.extensionVisibility) {\n      this.setVisibility(options.extensionVisibility);\n    }\n\n    if (options.extensionPricing) {\n      this.setPricing(options.extensionPricing);\n    }\n\n    // Apply task updates\n    if (options.updateTasksVersion && options.extensionVersion) {\n      const versionType = options.updateTasksVersionType || 'major';\n      await this.updateAllTaskVersions(options.extensionVersion, versionType);\n    }\n\n    if (options.updateTasksId) {\n      await this.updateAllTaskIds();\n    }\n\n    return this;\n  }\n\n  /**\n   * Set the publisher ID\n   * @param publisher New publisher ID\n   * @returns This editor for chaining\n   */\n  setPublisher(publisher: string): this {\n    this.manifestModifications.publisher = publisher;\n    return this;\n  }\n\n  /**\n   * Set the extension ID\n   * @param id New extension ID\n   * @returns This editor for chaining\n   */\n  setExtensionId(id: string): this {\n    this.manifestModifications.id = id;\n    return this;\n  }\n\n  /**\n   * Set the extension version\n   * @param version New version (e.g., \"1.2.3\")\n   * @returns This editor for chaining\n   */\n  setVersion(version: string): this {\n    this.manifestModifications.version = version;\n    return this;\n  }\n\n  /**\n   * Set the extension name\n   * @param name New display name\n   * @returns This editor for chaining\n   */\n  setName(name: string): this {\n    this.manifestModifications.name = name;\n    return this;\n  }\n\n  /**\n   * Set the extension description\n   * @param description New description\n   * @returns This editor for chaining\n   */\n  setDescription(description: string): this {\n    this.manifestModifications.description = description;\n    return this;\n  }\n\n  /**\n   * Set extension visibility in gallery\n   * @param visibility 'public', 'private', 'public_preview', or 'private_preview'\n   * @returns This editor for chaining\n   */\n  setVisibility(visibility: 'public' | 'private' | 'public_preview' | 'private_preview'): this {\n    if (!this.manifestModifications.galleryFlags) {\n      this.manifestModifications.galleryFlags = [];\n    }\n    const flags = this.manifestModifications.galleryFlags;\n\n    // Remove existing visibility flags\n    const visibilityFlags = ['Public', 'Private', 'Preview'];\n    for (const flag of visibilityFlags) {\n      const index = flags.indexOf(flag);\n      if (index >= 0) {\n        flags.splice(index, 1);\n      }\n    }\n\n    // Add new flags based on visibility\n    if (visibility === 'public') {\n      flags.push('Public');\n    } else if (visibility === 'private') {\n      flags.push('Private');\n    } else if (visibility === 'public_preview') {\n      flags.push('Public', 'Preview');\n    } else if (visibility === 'private_preview') {\n      flags.push('Private', 'Preview');\n    }\n\n    return this;\n  }\n\n  /**\n   * Set extension pricing model\n   * @param pricing 'free', 'paid', or 'trial'\n   * @returns This editor for chaining\n   */\n  setPricing(pricing: 'free' | 'paid' | 'trial'): this {\n    if (!this.manifestModifications.galleryFlags) {\n      this.manifestModifications.galleryFlags = [];\n    }\n    const flags = this.manifestModifications.galleryFlags;\n\n    // Remove existing pricing flags\n    const pricingFlags = ['Free', 'Paid', 'Trial'];\n    for (const flag of pricingFlags) {\n      const index = flags.indexOf(flag);\n      if (index >= 0) {\n        flags.splice(index, 1);\n      }\n    }\n\n    // Add new flag\n    const flagMap = { free: 'Free', paid: 'Paid', trial: 'Trial' };\n    flags.push(flagMap[pricing]);\n\n    return this;\n  }\n\n  /**\n   * Update a specific task's version\n   * @param taskName Name of the task\n   * @param extensionVersion Extension version to apply (e.g., \"1.2.3\")\n   * @param versionType How to apply the version: 'major', 'minor', or 'patch'\n   * @returns This editor for chaining\n   */\n  updateTaskVersion(\n    taskName: string,\n    extensionVersion: string,\n    versionType: 'major' | 'minor' | 'patch' = 'major'\n  ): this {\n    const versionParts = extensionVersion.split('.');\n    if (versionParts.length > 3) {\n      // Warning: version has more than 3 parts\n      // Taking only first 3\n    }\n\n    const newVersion = {\n      major: parseInt(versionParts[0], 10) || 0,\n      minor: parseInt(versionParts[1], 10) || 0,\n      patch: parseInt(versionParts[2], 10) || 0,\n    };\n\n    if (!this.taskManifestModifications.has(taskName)) {\n      this.taskManifestModifications.set(taskName, {});\n    }\n\n    const taskMods = this.taskManifestModifications.get(taskName);\n\n    // Get existing version from modifications or we'll read it when applying\n    const existingVersion = taskMods.version || { Major: 0, Minor: 0, Patch: 0 };\n\n    // Apply version update based on type (cascading per v5 logic)\n    switch (versionType) {\n      case 'major':\n        taskMods.version = {\n          Major: newVersion.major,\n          Minor: newVersion.minor,\n          Patch: newVersion.patch,\n        };\n        break;\n      case 'minor':\n        taskMods.version = {\n          Major: existingVersion.Major,\n          Minor: newVersion.minor,\n          Patch: newVersion.patch,\n        };\n        break;\n      case 'patch':\n        taskMods.version = {\n          Major: existingVersion.Major,\n          Minor: existingVersion.Minor,\n          Patch: newVersion.patch,\n        };\n        break;\n    }\n\n    return this;\n  }\n\n  /**\n   * Update a specific task's ID (UUID) using v5 namespacing\n   * @param taskName Name of the task\n   * @param publisherId Publisher ID (for UUID generation)\n   * @param extensionId Extension ID (for UUID generation)\n   * @returns This editor for chaining\n   */\n  updateTaskId(taskName: string, publisherId: string, extensionId: string): this {\n    // Generate deterministic UUID v5 based on publisher, extension, and task name\n    // This matches v5 implementation exactly\n    const marketplaceNamespace = uuidv5('https://marketplace.visualstudio.com/vsts', uuidv5.URL);\n    const taskNamespace = `${publisherId}.${extensionId}.${taskName}`;\n    const newId = uuidv5(taskNamespace, marketplaceNamespace);\n\n    if (!this.taskManifestModifications.has(taskName)) {\n      this.taskManifestModifications.set(taskName, {});\n    }\n\n    const taskMods = this.taskManifestModifications.get(taskName);\n\n    // Store old ID for updating extension manifest references later\n    // We'll read the old ID when applying modifications\n    taskMods.id = newId;\n\n    return this;\n  }\n\n  /**\n   * Update all tasks' versions in the extension\n   * Reads all tasks from the reader and updates their versions\n   * @param extensionVersion Extension version to apply\n   * @param versionType How to apply the version: 'major', 'minor', or 'patch'\n   * @returns Promise<this> for async chaining\n   */\n  async updateAllTaskVersions(\n    extensionVersion: string,\n    versionType: 'major' | 'minor' | 'patch' = 'major'\n  ): Promise<this> {\n    const tasks = await this.reader.getTasksInfo();\n    const versionParts = extensionVersion.split('.');\n    const parsedVersion = {\n      major: parseInt(versionParts[0], 10) || 0,\n      minor: parseInt(versionParts[1], 10) || 0,\n      patch: parseInt(versionParts[2], 10) || 0,\n    };\n\n    for (const task of tasks) {\n      const existingParts = (task.version || '0.0.0').split('.');\n      const existingVersion = {\n        Major: parseInt(existingParts[0], 10) || 0,\n        Minor: parseInt(existingParts[1], 10) || 0,\n        Patch: parseInt(existingParts[2], 10) || 0,\n      };\n\n      if (!this.taskManifestModifications.has(task.name)) {\n        this.taskManifestModifications.set(task.name, {});\n      }\n\n      const taskMods = this.taskManifestModifications.get(task.name);\n\n      switch (versionType) {\n        case 'major':\n          taskMods.version = {\n            Major: parsedVersion.major,\n            Minor: parsedVersion.minor,\n            Patch: parsedVersion.patch,\n          };\n          break;\n        case 'minor':\n          taskMods.version = {\n            Major: existingVersion.Major,\n            Minor: parsedVersion.minor,\n            Patch: parsedVersion.patch,\n          };\n          break;\n        case 'patch':\n          taskMods.version = {\n            Major: existingVersion.Major,\n            Minor: existingVersion.Minor,\n            Patch: parsedVersion.patch,\n          };\n          break;\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Update all tasks' IDs in the extension using v5 namespacing\n   * Reads extension manifest for publisher/ID and all tasks from reader\n   * @returns Promise<this> for async chaining\n   */\n  async updateAllTaskIds(): Promise<this> {\n    const manifest = await this.reader.readExtensionManifest();\n    const publisherId = this.manifestModifications.publisher || manifest.publisher;\n    const extensionId = this.manifestModifications.id || manifest.id;\n\n    const tasks = await this.reader.getTasksInfo();\n\n    for (const task of tasks) {\n      this.updateTaskId(task.name, publisherId, extensionId);\n    }\n\n    return this;\n  }\n\n  /**\n   * Add or modify a file\n   * @param path Path to the file\n   * @param content File content\n   * @returns This editor for chaining\n   */\n  setFile(path: string, content: Buffer | string): this {\n    const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content, 'utf-8');\n    const normalizedPath = path.replace(/\\\\/g, '/');\n\n    this.modifications.set(normalizedPath, {\n      type: 'modify',\n      path: normalizedPath,\n      content: buffer,\n    });\n\n    return this;\n  }\n\n  /**\n   * Remove a file\n   * @param path Path to the file\n   * @returns This editor for chaining\n   */\n  removeFile(path: string): this {\n    const normalizedPath = path.replace(/\\\\/g, '/');\n\n    this.modifications.set(normalizedPath, {\n      type: 'remove',\n      path: normalizedPath,\n    });\n\n    return this;\n  }\n\n  /**\n   * Convert to a writer for output\n   * The writer type depends on the reader type\n   * @returns Promise<Writer> ready to write (VsixWriter or FilesystemManifestWriter)\n   */\n  async toWriter(): Promise<any> {\n    // Dynamically import based on reader type\n    const readerConstructorName = this.reader.constructor.name;\n\n    if (readerConstructorName === 'VsixReader') {\n      const { VsixWriter } = await import('./vsix-writer.js');\n      return VsixWriter.fromEditor(this);\n    } else if (readerConstructorName === 'FilesystemManifestReader') {\n      const { FilesystemManifestWriter } = await import('./filesystem-manifest-writer.js');\n      return FilesystemManifestWriter.fromEditor(this);\n    } else {\n      throw new Error(`Unsupported reader type: ${readerConstructorName}`);\n    }\n  }\n\n  /**\n   * Get the source reader\n   * @internal\n   */\n  getReader(): ManifestReader {\n    return this.reader;\n  }\n\n  /**\n   * Get all file modifications\n   * @internal\n   */\n  getModifications(): Map<string, FileModification> {\n    return this.modifications;\n  }\n\n  /**\n   * Get manifest modifications\n   * @internal\n   */\n  getManifestModifications(): Partial<ExtensionManifest> {\n    return this.manifestModifications;\n  }\n\n  /**\n   * Get task manifest modifications\n   * @internal\n   */\n  getTaskManifestModifications(): Map<string, Partial<TaskManifest>> {\n    return this.taskManifestModifications;\n  }\n\n  /**\n   * Get task ID updates (for updating extension manifest references)\n   * @internal\n   */\n  getTaskIdUpdates(): Map<string, { oldId: string; newId: string }> {\n    return this.taskIdUpdates;\n  }\n}\n", "/**\n * Filesystem Manifest Reader - Read manifests from filesystem\n *\n * Extends ManifestReader to provide filesystem-based reading of extension\n * and task manifests directly from source directories.\n */\n\nimport { readFile } from 'fs/promises';\nimport path from 'path';\nimport { ManifestReader, type ExtensionManifest, type TaskManifest } from './manifest-reader.js';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * FilesystemManifestReader - Read manifests from filesystem\n *\n * Reads extension and task manifests directly from a source directory.\n * Useful for package command where manifests haven't been packaged yet.\n *\n * Example usage:\n * ```typescript\n * const reader = new FilesystemManifestReader({\n *   rootFolder: '/path/to/extension',\n *   manifestGlobs: ['vss-extension.json'],\n *   platform\n * });\n * const manifest = await reader.readExtensionManifest();\n * await reader.close();\n * ```\n */\nexport class FilesystemManifestReader extends ManifestReader {\n  private readonly rootFolder: string;\n  private readonly manifestGlobs: string[];\n  private readonly platform: IPlatformAdapter;\n  private manifestPath: string | null = null;\n  private extensionManifest: ExtensionManifest | null = null;\n  // Map of packagePath (task name) to actual source path\n  private packagePathMap: Map<string, string> | null = null;\n\n  constructor(options: {\n    rootFolder: string;\n    manifestGlobs?: string[];\n    platform: IPlatformAdapter;\n  }) {\n    super();\n    this.rootFolder = options.rootFolder;\n    this.manifestGlobs = options.manifestGlobs || ['vss-extension.json'];\n    this.platform = options.platform;\n  }\n\n  /**\n   * Find and resolve the extension manifest file path\n   */\n  private async resolveManifestPath(): Promise<string> {\n    if (this.manifestPath) {\n      return this.manifestPath;\n    }\n\n    // Try to find manifest using globs\n    const matches = await this.platform.findMatch(this.rootFolder, this.manifestGlobs);\n\n    if (matches.length === 0) {\n      // Fallback: check for common manifest names\n      const commonNames = ['vss-extension.json', 'extension.vsomanifest'];\n      for (const name of commonNames) {\n        const candidate = path.join(this.rootFolder, name);\n        if (await this.platform.fileExists(candidate)) {\n          this.manifestPath = candidate;\n          return candidate;\n        }\n      }\n      throw new Error(\n        `Extension manifest not found in ${this.rootFolder}. ` +\n          `Tried patterns: ${this.manifestGlobs.join(', ')}`\n      );\n    }\n\n    if (matches.length > 1) {\n      this.platform.warning(\n        `Multiple manifest files found: ${matches.join(', ')}. Using first match.`\n      );\n    }\n\n    this.manifestPath = matches[0];\n    return this.manifestPath;\n  }\n\n  /**\n   * Read the extension manifest from filesystem\n   * @returns Parsed extension manifest\n   */\n  async readExtensionManifest(): Promise<ExtensionManifest> {\n    if (this.extensionManifest) {\n      return this.extensionManifest;\n    }\n\n    const manifestPath = await this.resolveManifestPath();\n    const content = await readFile(manifestPath, 'utf-8');\n    this.extensionManifest = JSON.parse(content);\n    return this.extensionManifest;\n  }\n\n  /**\n   * Build a map of packagePath to actual source path from files array\n   * This handles cases where task.json is in a different directory than the final package path\n   * @returns Map of packagePath to source path\n   */\n  private async buildPackagePathMap(): Promise<Map<string, string>> {\n    if (this.packagePathMap) {\n      return this.packagePathMap;\n    }\n\n    this.packagePathMap = new Map<string, string>();\n    const manifest = await this.readExtensionManifest();\n\n    // Check if files array exists with packagePath mappings\n    if (manifest.files) {\n      for (const file of manifest.files) {\n        // If packagePath is specified, map it to the source path\n        if (file.packagePath) {\n          this.packagePathMap.set(file.packagePath, file.path);\n          this.platform.debug(\n            `Mapped packagePath '${file.packagePath}' to source path '${file.path}'`\n          );\n        }\n      }\n    }\n\n    return this.packagePathMap;\n  }\n\n  /**\n   * Find task paths from the extension manifest\n   * @returns Array of task directory paths (relative to rootFolder)\n   */\n  async findTaskPaths(): Promise<string[]> {\n    const manifest = await this.readExtensionManifest();\n    const taskPaths: string[] = [];\n\n    // Look for task contributions\n    if (manifest.contributions) {\n      for (const contribution of manifest.contributions) {\n        if (contribution.type === 'ms.vss-distributed-task.task' && contribution.properties) {\n          const name = contribution.properties.name as string;\n          if (name) {\n            taskPaths.push(name);\n          }\n        }\n      }\n    }\n\n    // If no contributions found, look in files array\n    if (taskPaths.length === 0 && manifest.files) {\n      for (const file of manifest.files) {\n        const taskJsonPath = path.join(this.rootFolder, file.path, 'task.json');\n        if (await this.platform.fileExists(taskJsonPath)) {\n          taskPaths.push(file.path);\n        }\n      }\n    }\n\n    return taskPaths;\n  }\n\n  /**\n   * Read a task manifest from filesystem\n   * @param taskPath Path to the task directory (relative to rootFolder) or packagePath\n   * @returns Parsed task manifest\n   */\n  async readTaskManifest(taskPath: string): Promise<TaskManifest> {\n    // Build packagePath map to handle files with packagePath\n    const packagePathMap = await this.buildPackagePathMap();\n\n    // Check if taskPath starts with a packagePath prefix and replace it\n    let actualPath = taskPath;\n\n    // Normalize path separators for consistent matching\n    const normalizedTaskPath = taskPath.replace(/\\\\/g, '/');\n\n    // Try to find a matching packagePath prefix\n    for (const [pkgPath, sourcePath] of packagePathMap.entries()) {\n      const normalizedPkgPath = pkgPath.replace(/\\\\/g, '/');\n\n      // Check for exact match or prefix match (packagePath/subdir)\n      if (normalizedTaskPath === normalizedPkgPath) {\n        // Exact match: TaskName \u2192 sourcePath\n        actualPath = sourcePath;\n        break;\n      } else if (normalizedTaskPath.startsWith(normalizedPkgPath + '/')) {\n        // Prefix match: TaskName/v2 \u2192 sourcePath/v2\n        const remainder = normalizedTaskPath.substring(normalizedPkgPath.length + 1);\n        actualPath = path.join(sourcePath, remainder);\n        break;\n      }\n    }\n\n    this.platform.debug(\n      `Reading task manifest: taskPath='${taskPath}', actualPath='${actualPath}'`\n    );\n\n    // Resolve relative path from rootFolder\n    const absoluteTaskPath = path.isAbsolute(actualPath)\n      ? actualPath\n      : path.join(this.rootFolder, actualPath);\n\n    const taskJsonPath = path.join(absoluteTaskPath, 'task.json');\n\n    if (!(await this.platform.fileExists(taskJsonPath))) {\n      throw new Error(`Task manifest not found: ${taskJsonPath}`);\n    }\n\n    const content = await readFile(taskJsonPath, 'utf-8');\n    return JSON.parse(content);\n  }\n\n  /**\n   * Close and clean up resources\n   * No-op for filesystem reader as there are no persistent resources\n   */\n  async close(): Promise<void> {\n    // No resources to clean up\n    this.extensionManifest = null;\n    this.manifestPath = null;\n    this.packagePathMap = null;\n  }\n\n  /**\n   * Get the root folder path\n   */\n  getRootFolder(): string {\n    return this.rootFolder;\n  }\n\n  /**\n   * Get the resolved manifest path (if already resolved)\n   */\n  getManifestPath(): string | null {\n    return this.manifestPath;\n  }\n}\n", "module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n", "'use strict';\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n", "var concatMap = require('concat-map');\nvar balanced = require('balanced-match');\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,(?!,).*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n", "module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = (function () { try { return require('path') } catch (e) {}}()) || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = require('brace-expansion')\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  b = b || {}\n  var t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n  this.partial = !!options.partial\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nvar MAX_PATTERN_LENGTH = 1024 * 64\nvar assertValidPattern = function (pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar)\n      return GLOBSTAR\n    else\n      pattern = '*'\n  }\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      /* istanbul ignore next */\n      case '/': {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i)\n        try {\n          RegExp('[' + cs + ']')\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE)\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n          hasMagic = hasMagic || sp[1]\n          inClass = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '[': case '.': case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = function match (f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      hit = f === p\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n", "import * as core from '@actions/core';\nimport {\n  installExtension,\n  packageExtension,\n  publishExtension,\n  queryVersion,\n  shareExtension,\n  showExtension,\n  TaskResult,\n  TfxManager,\n  unpublishExtension,\n  unshareExtension,\n  validateAccountUrl,\n  validateAzureCliAvailable,\n  validateExtensionId,\n  validateNodeAvailable,\n  validateNpmAvailable,\n  validatePublisherId,\n  validateTfxAvailable,\n  validateVersion,\n  waitForInstallation,\n  waitForValidation,\n} from '@extension-tasks/core';\nimport { AuthType, getAuth } from './auth/index.js';\nimport { GitHubAdapter } from './github-adapter.js';\n\nasync function run(): Promise<void> {\n  try {\n    const platform = new GitHubAdapter();\n\n    // Validate node is available (always required)\n    await validateNodeAvailable(platform);\n\n    // Get the operation to perform\n    const operation = platform.getInput('operation', true);\n    if (!operation) {\n      throw new Error('Operation is required');\n    }\n\n    platform.debug(`Starting operation: ${operation}`);\n\n    // Validate common inputs early to fail fast\n    const publisherId = platform.getInput('publisher-id');\n    if (publisherId) {\n      validatePublisherId(publisherId);\n    }\n\n    const extensionId = platform.getInput('extension-id');\n    if (extensionId) {\n      validateExtensionId(extensionId);\n    }\n\n    const extensionVersion = platform.getInput('extension-version');\n    if (extensionVersion) {\n      validateVersion(extensionVersion);\n    }\n\n    // Create TfxManager\n    const tfxVersion = platform.getInput('tfx-version') || 'built-in';\n\n    // Validate binaries based on tfx version mode\n    if (tfxVersion === 'path') {\n      // User wants to use tfx from PATH\n      await validateTfxAvailable(platform);\n    } else if (tfxVersion !== 'built-in') {\n      // Version spec mode - need npm to download\n      await validateNpmAvailable(platform);\n    }\n\n    const tfxManager = new TfxManager({ tfxVersion: tfxVersion, platform });\n\n    // Get authentication if needed (not required for package)\n    let auth;\n    if (operation !== 'package') {\n      const authType = (platform.getInput('auth-type') || 'pat') as AuthType;\n\n      // For OIDC auth, validate Azure CLI is available\n      if (authType === 'oidc') {\n        await validateAzureCliAvailable(platform);\n      }\n\n      // Get authentication credentials with optional service/marketplace URLs\n      const token = platform.getInput('token');\n      const username = platform.getInput('username');\n      const password = platform.getInput('password');\n      const serviceUrl = platform.getInput('service-url');\n\n      auth = await getAuth(authType, platform, {\n        token,\n        username,\n        password,\n        serviceUrl,\n      });\n\n      // Secret masking is now handled inside auth providers\n      // But we keep this as defense in depth\n      if (auth.token) {\n        platform.setSecret(auth.token);\n      }\n      if (auth.password) {\n        platform.setSecret(auth.password);\n      }\n\n      // Validate service URL if present\n      if (auth.serviceUrl) {\n        validateAccountUrl(auth.serviceUrl);\n      }\n    }\n\n    // Validate account URLs for operations that need them\n    if (operation === 'install' || operation === 'wait-for-installation') {\n      const accounts = platform.getDelimitedInput('accounts', ';', false);\n      accounts.forEach((account) => {\n        if (account) {\n          validateAccountUrl(account);\n        }\n      });\n    }\n\n    // Route to appropriate command\n    switch (operation) {\n      case 'package':\n        await runPackage(platform, tfxManager);\n        break;\n\n      case 'publish':\n        await runPublish(platform, tfxManager, auth);\n        break;\n\n      case 'unpublish':\n        await runUnpublish(platform, tfxManager, auth);\n        break;\n\n      case 'share':\n        await runShare(platform, tfxManager, auth);\n        break;\n\n      case 'unshare':\n        await runUnshare(platform, tfxManager, auth);\n        break;\n\n      case 'install':\n        await runInstall(platform, tfxManager, auth);\n        break;\n\n      case 'show':\n        await runShow(platform, tfxManager, auth);\n        break;\n\n      case 'query-version':\n        await runQueryVersion(platform, tfxManager, auth);\n        break;\n\n      case 'wait-for-validation':\n        await runWaitForValidation(platform, tfxManager, auth);\n        break;\n\n      case 'wait-for-installation':\n        await runWaitForInstallation(platform, auth);\n        break;\n\n      default:\n        throw new Error(`Unknown operation: ${operation}`);\n    }\n\n    platform.info('\u2705 Operation completed successfully');\n    platform.setResult(TaskResult.Succeeded, `${operation} completed successfully`);\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    core.setFailed(message);\n  }\n}\n\nasync function runPackage(platform: GitHubAdapter, tfxManager: TfxManager): Promise<void> {\n  const options = {\n    rootFolder: platform.getInput('root-folder'),\n    manifestGlobs: platform.getDelimitedInput('manifest-globs', '\\n'),\n    publisherId: platform.getInput('publisher-id'),\n    extensionId: platform.getInput('extension-id'),\n    extensionVersion: platform.getInput('extension-version'),\n    extensionName: platform.getInput('extension-name'),\n    extensionVisibility: platform.getInput('extension-visibility') as any,\n    updateTasksVersion: platform.getBoolInput('update-tasks-version'),\n    updateTasksId: platform.getBoolInput('update-tasks-id'),\n    outputPath: platform.getInput('output-path'),\n    outputVariable: platform.getInput('output-variable'),\n    bypassValidation: platform.getBoolInput('bypass-validation'),\n    revVersion: platform.getBoolInput('rev-version'),\n  };\n\n  const result = await packageExtension(options, tfxManager, platform);\n\n  if (options.outputVariable && result.vsixPath) {\n    platform.setOutput(options.outputVariable, result.vsixPath);\n  }\n}\n\nasync function runPublish(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const publishSource = platform.getInput('publish-source', true) as 'manifest' | 'vsix';\n\n  const result = await publishExtension(\n    {\n      publishSource,\n      vsixFile: publishSource === 'vsix' ? platform.getInput('vsix-file', true) : undefined,\n      manifestGlobs:\n        publishSource === 'manifest'\n          ? platform.getDelimitedInput('manifest-globs', '\\n', true)\n          : undefined,\n      rootFolder: publishSource === 'manifest' ? platform.getInput('root-folder') : undefined,\n      publisherId: platform.getInput('publisher-id'),\n      extensionId: platform.getInput('extension-id'),\n      extensionVersion: platform.getInput('extension-version'),\n      extensionName: platform.getInput('extension-name'),\n      extensionVisibility: platform.getInput('extension-visibility') as any,\n      shareWith: platform.getDelimitedInput('share-with', '\\n'),\n      noWaitValidation: platform.getBoolInput('no-wait-validation'),\n      bypassValidation: platform.getBoolInput('bypass-validation'),\n      updateTasksVersion: platform.getBoolInput('update-tasks-version'),\n      updateTasksId: platform.getBoolInput('update-tasks-id'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  platform.debug(`Published: ${JSON.stringify(result)}`);\n}\n\nasync function runUnpublish(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  await unpublishExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n}\n\nasync function runShare(platform: GitHubAdapter, tfxManager: TfxManager, auth: any): Promise<void> {\n  await shareExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      shareWith: platform.getDelimitedInput('share-with', '\\n', true),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n}\n\nasync function runUnshare(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  await unshareExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      unshareWith: platform.getDelimitedInput('unshare-with', '\\n', true),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n}\n\nasync function runInstall(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const result = await installExtension(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      accounts: platform.getDelimitedInput('accounts', '\\n', true),\n      extensionVersion: platform.getInput('extension-version'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  if (!result.allSuccess) {\n    throw new Error(`Some accounts failed to install the extension`);\n  }\n}\n\nasync function runShow(platform: GitHubAdapter, tfxManager: TfxManager, auth: any): Promise<void> {\n  const options = {\n    publisherId: platform.getInput('publisher-id', true),\n    extensionId: platform.getInput('extension-id', true),\n    outputVariable: platform.getInput('output-variable'),\n  };\n\n  const result = await showExtension(options, auth, tfxManager, platform);\n\n  if (options.outputVariable && result.metadata) {\n    platform.setOutput(options.outputVariable, JSON.stringify(result.metadata));\n  }\n}\n\nasync function runQueryVersion(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const result = await queryVersion(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      versionAction:\n        (platform.getInput('version-action') as 'None' | 'Major' | 'Minor' | 'Patch') ?? 'None',\n      extensionVersionOverrideVariable: platform.getInput('extension-version-override'),\n      outputVariable: platform.getInput('output-variable'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  platform.setOutput('proposed-version', result.proposedVersion);\n  platform.setOutput('current-version', result.currentVersion);\n}\n\nasync function runWaitForValidation(\n  platform: GitHubAdapter,\n  tfxManager: TfxManager,\n  auth: any\n): Promise<void> {\n  const result = await waitForValidation(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      rootFolder: platform.getInput('root-folder'),\n      manifestGlobs: platform.getDelimitedInput('manifest-globs', '\\n'),\n      maxRetries: parseInt(platform.getInput('max-retries') || '10'),\n      minTimeout: parseInt(platform.getInput('min-timeout') || '1'),\n      maxTimeout: parseInt(platform.getInput('max-timeout') || '15'),\n    },\n    auth,\n    tfxManager,\n    platform\n  );\n\n  if (result.status !== 'success') {\n    throw new Error(`Validation failed with status: ${result.status}`);\n  }\n}\n\nasync function runWaitForInstallation(platform: GitHubAdapter, auth: any): Promise<void> {\n  const expectedTasksInput = platform.getInput('expected-tasks');\n  let expectedTasks;\n  if (expectedTasksInput) {\n    try {\n      expectedTasks = JSON.parse(expectedTasksInput);\n    } catch (error) {\n      throw new Error(`Failed to parse expected-tasks: ${error}`);\n    }\n  }\n\n  const result = await waitForInstallation(\n    {\n      publisherId: platform.getInput('publisher-id', true),\n      extensionId: platform.getInput('extension-id', true),\n      accounts: platform.getDelimitedInput('accounts', '\\n', true),\n      expectedTasks,\n      manifestPath: platform.getInput('manifest-path'),\n      vsixPath: platform.getInput('vsix-path'),\n      timeoutMinutes: parseInt(platform.getInput('timeout-minutes') || '10'),\n      pollingIntervalSeconds: parseInt(platform.getInput('polling-interval-seconds') || '30'),\n    },\n    auth,\n    platform\n  );\n\n  if (!result.success) {\n    throw new Error(`Verification failed - not all tasks are available`);\n  }\n}\n\n// Run the action\nvoid run();\n", "/**\n * Platform abstraction layer interface\n * This interface abstracts ALL platform-specific operations\n */\n\nexport enum TaskResult {\n  Succeeded = 0,\n  Failed = 1,\n  Warning = 2,\n}\n\nexport interface ExecOptions {\n  cwd?: string;\n  env?: Record<string, string>;\n  silent?: boolean;\n  ignoreReturnCode?: boolean;\n  outStream?: NodeJS.WritableStream;\n  errStream?: NodeJS.WritableStream;\n  failOnStdErr?: boolean;\n}\n\nexport interface ExecResult {\n  exitCode: number;\n  stdout: string;\n  stderr: string;\n}\n\n/**\n * Platform adapter interface\n * Implementations provide platform-specific functionality for Azure Pipelines or GitHub Actions\n */\nexport interface IPlatformAdapter {\n  // ===== Input =====\n  getInput(name: string, required?: boolean): string | undefined;\n  getBoolInput(name: string, required?: boolean): boolean;\n  getDelimitedInput(name: string, delimiter: string, required?: boolean): string[];\n\n  // ===== Output =====\n  setOutput(name: string, value: string): void;\n  setResult(result: TaskResult, message: string): void;\n  setVariable(name: string, value: string, isSecret?: boolean, isOutput?: boolean): void;\n  setSecret(value: string): void;\n\n  // ===== Logging =====\n  debug(message: string): void;\n  info(message: string): void;\n  warning(message: string): void;\n  error(message: string): void;\n\n  // ===== Execution =====\n  which(tool: string, check?: boolean): Promise<string>;\n  exec(tool: string, args: string[], options?: ExecOptions): Promise<number>;\n\n  // ===== Filesystem =====\n  findMatch(root: string, patterns: string[]): Promise<string[]>;\n  fileExists(path: string): Promise<boolean>;\n  readFile(path: string): Promise<string>;\n  writeFile(path: string, content: string): Promise<void>;\n  mkdirP(path: string): Promise<void>;\n  rmRF(path: string): Promise<void>;\n\n  // ===== Environment =====\n  getVariable(name: string): string | undefined;\n  getTempDir(): string;\n\n  // ===== Tool Management =====\n  cacheDir(sourceDir: string, tool: string, version: string): Promise<string>;\n  findCachedTool(tool: string, version: string): string | undefined;\n  downloadTool(url: string): Promise<string>;\n}\n", "/**\n * Fluent argument builder for constructing tfx CLI arguments\n */\nexport class ArgBuilder {\n  private args: string[] = [];\n\n  /**\n   * Add one or more arguments\n   */\n  arg(values: string | string[]): this {\n    if (Array.isArray(values)) {\n      this.args.push(...values);\n    } else {\n      this.args.push(values);\n    }\n    return this;\n  }\n\n  /**\n   * Add arguments if condition is truthy\n   */\n  argIf(condition: unknown, values: string | string[]): this {\n    if (condition) {\n      return this.arg(values);\n    }\n    return this;\n  }\n\n  /**\n   * Add a flag (e.g., '--json')\n   */\n  flag(name: string): this {\n    this.args.push(name);\n    return this;\n  }\n\n  /**\n   * Add a flag if condition is truthy\n   */\n  flagIf(condition: unknown, name: string): this {\n    if (condition) {\n      return this.flag(name);\n    }\n    return this;\n  }\n\n  /**\n   * Add an option with value (e.g., '--publisher', 'myPublisher')\n   */\n  option(name: string, value: string | undefined): this {\n    if (value !== undefined) {\n      this.args.push(name, value);\n    }\n    return this;\n  }\n\n  /**\n   * Add an option if condition is truthy\n   */\n  optionIf(condition: unknown, name: string, value: string | undefined): this {\n    if (condition && value !== undefined) {\n      return this.option(name, value);\n    }\n    return this;\n  }\n\n  /**\n   * Append raw command line string (split on spaces)\n   */\n  line(raw: string): this {\n    const parts = raw.split(/\\s+/).filter((s) => s.length > 0);\n    this.args.push(...parts);\n    return this;\n  }\n\n  /**\n   * Build and return the argument array\n   */\n  build(): string[] {\n    return [...this.args];\n  }\n}\n", "/**\n * JSON output stream parser for tfx CLI output\n * Parses mixed output from tfx --json --debug-log-stream stderr\n */\n\nimport { Writable } from 'stream';\n\n/**\n * Stream that separates tfx JSON output from debug messages\n * The tfx CLI with --json flag outputs JSON to stdout but also emits\n * debug messages and command echoes. This stream separates them.\n */\nexport class JsonOutputStream extends Writable {\n  /** Accumulated JSON string */\n  public jsonString = '';\n\n  /** Non-JSON messages (debug output, warnings, etc.) */\n  public messages: string[] = [];\n\n  /**\n   * @param lineWriter Function to write non-JSON lines (for logging)\n   */\n  constructor(private lineWriter: (message: string) => void) {\n    super();\n  }\n\n  /**\n   * Process a chunk of data from the stream\n   */\n  _write(\n    chunk: Buffer | string,\n    _encoding: string,\n    callback: (error?: Error | null) => void\n  ): void {\n    const chunkStr = chunk.toString();\n    const trimmed = chunkStr.trimStart();\n\n    // Azure Pipelines task-lib command output\n    if (chunkStr.startsWith('[command]')) {\n      this.writeOutput(chunkStr, this.lineWriter);\n    }\n    // If we haven't started collecting JSON yet and this doesn't look like JSON\n    else if (!this.jsonString && !this.looksLikeJsonStart(trimmed)) {\n      this.messages.push(chunkStr);\n      this.writeOutput(chunkStr, this.lineWriter);\n    }\n    // Accumulate JSON\n    else {\n      this.jsonString += chunkStr;\n      // Don't write JSON to output (will be parsed and processed separately)\n    }\n\n    callback();\n  }\n\n  /**\n   * Detect whether a chunk can be the start of a valid JSON value.\n   */\n  private looksLikeJsonStart(input: string): boolean {\n    if (!input) {\n      return false;\n    }\n\n    return /^(\\{|\\[|\"|-?\\d|true\\b|false\\b|null\\b)/.test(input);\n  }\n\n  /**\n   * Write output line by line (splits on newlines)\n   */\n  private writeOutput(messages: string, writer: (m: string) => void): void {\n    if (!messages) {\n      return;\n    }\n    // Split messages to invoke writer for each line\n    // This ensures proper line prefixing in logging systems\n    messages.split('\\n').forEach((line) => {\n      if (line) {\n        writer(line);\n      }\n    });\n  }\n\n  /**\n   * Parse the accumulated JSON string\n   * @returns Parsed JSON object or undefined if parsing fails\n   */\n  public parseJson<T = unknown>(): T | undefined {\n    if (!this.jsonString) {\n      return undefined;\n    }\n\n    try {\n      return JSON.parse(this.jsonString) as T;\n    } catch (error) {\n      // If JSON parsing fails, log the error and return undefined\n      this.lineWriter(`Failed to parse JSON output: ${error}`);\n      return undefined;\n    }\n  }\n}\n", "/**\n * Manifest utilities for reading, writing, and manipulating extension manifests\n */\n\nimport path from 'path';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * Resolve manifest file paths from root folder and glob patterns\n * @param rootFolder Root directory to search from\n * @param patterns Glob patterns to match (e.g., [\"vss-extension.json\", \"*.json\"])\n * @param platform Platform adapter for filesystem operations\n * @returns Array of resolved manifest file paths\n */\nexport async function resolveManifestPaths(\n  rootFolder: string,\n  patterns: string[],\n  platform: IPlatformAdapter\n): Promise<string[]> {\n  if (!patterns || patterns.length === 0) {\n    return [];\n  }\n\n  const matches = await platform.findMatch(rootFolder, patterns);\n  return matches;\n}\n\n/**\n * Read and parse a manifest file\n * @param manifestPath Path to manifest file\n * @param platform Platform adapter for filesystem operations\n * @returns Parsed manifest object\n */\nexport async function readManifest(\n  manifestPath: string,\n  platform: IPlatformAdapter\n): Promise<unknown> {\n  const content = await platform.readFile(manifestPath);\n  return JSON.parse(content);\n}\n\n/**\n * Write a manifest object to file\n * @param manifest Manifest object to serialize\n * @param manifestPath Path to write to\n * @param platform Platform adapter for filesystem operations\n */\nexport async function writeManifest(\n  manifest: unknown,\n  manifestPath: string,\n  platform: IPlatformAdapter\n): Promise<void> {\n  const content = JSON.stringify(manifest, null, 2);\n  await platform.writeFile(manifestPath, content);\n}\n\n/**\n * Resolve task manifest paths from extension manifest\n * Issue #188: Honor package path mappings when resolving task manifests\n *\n * @param extensionManifest Parsed extension manifest\n * @param extensionManifestPath Path to the extension manifest file\n * @param _platform Platform adapter for filesystem operations (reserved for future use)\n * @returns Array of task manifest file paths\n */\nexport function resolveTaskManifestPaths(\n  extensionManifest: any,\n  extensionManifestPath: string,\n  _platform: IPlatformAdapter\n): string[] {\n  void _platform;\n  // Get task contributions from manifest\n  const taskContributions = getTaskContributions(extensionManifest);\n\n  if (taskContributions.length === 0) {\n    return [];\n  }\n\n  const manifestDir = path.dirname(extensionManifestPath);\n  const taskPaths: string[] = [];\n\n  for (const contrib of taskContributions) {\n    const taskName = contrib.properties?.name;\n    if (!taskName) {\n      continue;\n    }\n\n    // Construct path to task.json\n    const taskManifestPath = path.join(manifestDir, taskName, 'task.json');\n    taskPaths.push(taskManifestPath);\n  }\n\n  return taskPaths;\n}\n\n/**\n * Get task contributions from extension manifest\n */\nfunction getTaskContributions(manifest: any): any[] {\n  if (!manifest.contributions) {\n    return [];\n  }\n\n  return manifest.contributions.filter(\n    (c: any) => c.type === 'ms.vss-distributed-task.task' && c.properties && c.properties.name\n  );\n}\n\n/**\n * Update contribution references in manifest when extension ID changes\n * Issue #172: Update internal contribution references when extension ID changes\n *\n * @param manifest Extension manifest to update\n * @param originalExtensionId Original extension ID\n * @param newExtensionId New extension ID\n * @returns Updated manifest\n */\nexport function updateContributionReferences(\n  manifest: any,\n  originalExtensionId: string,\n  newExtensionId: string\n): any {\n  if (!manifest || originalExtensionId === newExtensionId) {\n    return manifest;\n  }\n\n  const updated = JSON.parse(JSON.stringify(manifest)); // Deep clone\n\n  // Update contribution IDs\n  if (updated.contributions) {\n    updated.contributions = updated.contributions.map((contribution: any) => {\n      if (contribution.id && typeof contribution.id === 'string') {\n        // Replace extension ID in contribution ID\n        contribution.id = contribution.id.replace(\n          new RegExp(`^${escapeRegex(originalExtensionId)}\\\\.`),\n          `${newExtensionId}.`\n        );\n      }\n      return contribution;\n    });\n  }\n\n  // Update contribution targets in contribution points\n  if (updated.contributionTypes) {\n    updated.contributionTypes = updated.contributionTypes.map((type: any) => {\n      if (type.id && typeof type.id === 'string') {\n        type.id = type.id.replace(\n          new RegExp(`^${escapeRegex(originalExtensionId)}\\\\.`),\n          `${newExtensionId}.`\n        );\n      }\n      return type;\n    });\n  }\n\n  // Update targets in contributions that reference other contributions\n  if (updated.contributions) {\n    updated.contributions = updated.contributions.map((contribution: any) => {\n      if (contribution.targets && Array.isArray(contribution.targets)) {\n        contribution.targets = contribution.targets.map((target: string) => {\n          if (typeof target === 'string') {\n            return target.replace(\n              new RegExp(`^${escapeRegex(originalExtensionId)}\\\\.`),\n              `${newExtensionId}.`\n            );\n          }\n          return target;\n        });\n      }\n      return contribution;\n    });\n  }\n\n  return updated;\n}\n\n/**\n * Escape special regex characters\n */\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "/**\n * TfxManager - Manages tfx-cli installation, caching, and execution\n */\n\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { JsonOutputStream } from './json-output-stream.js';\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * Options for TfxManager\n */\nexport interface TfxManagerOptions {\n  /**\n   * Version of tfx to use:\n   * - \"built-in\": Use tfx-cli from core package dependencies\n   * - \"path\": Use tfx from system PATH\n   * - Version spec: Download and cache (e.g., \"0.17.0\", \"^0.17\", \"latest\")\n   */\n  tfxVersion: string;\n  /** Platform adapter for operations */\n  platform: IPlatformAdapter;\n}\n\n/**\n * Options for executing tfx\n */\nexport interface TfxExecOptions {\n  /** Working directory */\n  cwd?: string;\n  /** Additional environment variables */\n  env?: Record<string, string>;\n  /** Capture JSON output (adds --json and --debug-log-stream stderr flags) */\n  captureJson?: boolean;\n}\n\n/**\n * Result from tfx execution\n */\nexport interface TfxResult {\n  /** Exit code from tfx process */\n  exitCode: number;\n  /** Parsed JSON output (if captureJson was true and JSON was present) */\n  json?: unknown;\n  /** Standard output */\n  stdout: string;\n  /** Standard error */\n  stderr: string;\n}\n\n/**\n * Manages tfx-cli binary resolution, caching, and execution\n */\nexport class TfxManager {\n  private resolvedPath?: string;\n  private readonly tfxVersion: string;\n  private readonly platform: IPlatformAdapter;\n\n  constructor(options: TfxManagerOptions) {\n    this.tfxVersion = options.tfxVersion;\n    this.platform = options.platform;\n  }\n\n  /**\n   * Resolve tfx binary path using cache-first strategy\n   * @returns Path to tfx executable\n   */\n  async resolve(): Promise<string> {\n    // 1. In-memory cache (same process invocation)\n    if (this.resolvedPath) {\n      this.platform.debug(`Using cached tfx path: ${this.resolvedPath}`);\n      return this.resolvedPath;\n    }\n\n    // 2. Built-in mode - use tfx from core package dependencies\n    if (this.tfxVersion === 'built-in') {\n      this.resolvedPath = await this.resolveBuiltIn();\n      return this.resolvedPath;\n    }\n\n    // 3. Path mode - use tfx from system PATH (no download)\n    if (this.tfxVersion === 'path') {\n      this.resolvedPath = await this.resolveFromPath();\n      return this.resolvedPath;\n    }\n\n    // 4. Version spec - resolve to exact version first\n    const exactVersion = await this.resolveVersionSpec(this.tfxVersion);\n    this.platform.info(\n      `Resolved tfx-cli version spec '${this.tfxVersion}' to exact version '${exactVersion}'`\n    );\n\n    // 5. Check platform tool cache (cross-step reuse)\n    const cachedPath = this.platform.findCachedTool('tfx-cli', exactVersion);\n    if (cachedPath) {\n      this.platform.info(`Found cached tfx-cli@${exactVersion} at ${cachedPath}`);\n      this.resolvedPath = this.getTfxExecutable(cachedPath);\n      return this.resolvedPath;\n    }\n\n    // 6. Download and cache exact version\n    this.resolvedPath = await this.downloadAndCache(exactVersion);\n    return this.resolvedPath;\n  }\n\n  /**\n   * Resolve built-in tfx binary from core package dependencies\n   * Similar to tfxinstaller v5 behavior\n   *\n   * The tfx-cli package is a direct dependency of the core package.\n   * When bundled, tfx-cli is marked as external and will be in node_modules.\n   * We use 'which' to locate it, which will find it in node_modules/.bin/ or PATH.\n   */\n  private async resolveBuiltIn(): Promise<string> {\n    this.platform.info('Using built-in tfx-cli from core package dependencies');\n\n    const entrypoint = process.argv[1];\n    if (!entrypoint) {\n      throw new Error('Built-in tfx-cli resolution failed: process.argv[1] is not set.');\n    }\n\n    const entryDir = path.dirname(path.resolve(entrypoint));\n    const tfxExecutable = process.platform === 'win32' ? 'tfx.cmd' : 'tfx';\n    const candidateDirs = [entryDir];\n    const normalizedEntrypoint = path.resolve(entrypoint).replace(/\\\\/g, '/');\n\n    if (normalizedEntrypoint.includes('/node_modules/')) {\n      candidateDirs.push(process.cwd());\n    }\n\n    for (const candidateDir of candidateDirs) {\n      const builtInPath = path.join(candidateDir, 'node_modules', '.bin', tfxExecutable);\n\n      if (await this.pathExists(builtInPath)) {\n        this.platform.debug(`Resolved built-in tfx at: ${builtInPath}`);\n        return builtInPath;\n      }\n    }\n\n    throw new Error(\n      `Built-in tfx-cli not found at expected path: ${path.join(entryDir, 'node_modules', '.bin', tfxExecutable)}.`\n    );\n  }\n\n  private async pathExists(filePath: string): Promise<boolean> {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Resolve tfx from system PATH\n   * No download, uses whatever tfx is installed on the system\n   */\n  private async resolveFromPath(): Promise<string> {\n    this.platform.info('Using tfx-cli from system PATH');\n\n    // Find tfx on PATH\n    const tfxPath = await this.platform.which('tfx', true);\n\n    this.platform.debug(`Resolved tfx from PATH at: ${tfxPath}`);\n    return tfxPath;\n  }\n\n  /**\n   * Resolve a version spec to an exact version\n   * Uses npm to resolve version specs like \"^0.17\", \"latest\", etc.\n   * @param versionSpec - Version spec to resolve (e.g., \"^0.17\", \"latest\", \"0.17.0\")\n   * @returns Exact version string (e.g., \"0.17.3\")\n   */\n  private async resolveVersionSpec(versionSpec: string): Promise<string> {\n    this.platform.debug(`Resolving version spec: ${versionSpec}`);\n\n    try {\n      // Use npm view to get the exact version\n      const npmPath = await this.platform.which('npm', true);\n\n      // Create a temp buffer to capture output\n      let output = '';\n      const outStream: any = {\n        write: (data: string) => {\n          output += data;\n        },\n      };\n\n      const exitCode = await this.platform.exec(\n        npmPath,\n        ['view', `tfx-cli@${versionSpec}`, 'version', '--json'],\n        { outStream }\n      );\n\n      if (exitCode !== 0) {\n        throw new Error(`npm view failed with exit code ${exitCode}`);\n      }\n\n      // Parse the output\n      const trimmed = output.trim();\n      let exactVersion: string;\n\n      if (trimmed.startsWith('[')) {\n        // Multiple versions returned, take the last one (latest)\n        const versions = JSON.parse(trimmed) as string[];\n        exactVersion = versions[versions.length - 1];\n      } else if (trimmed.startsWith('\"')) {\n        // Single version as JSON string\n        exactVersion = JSON.parse(trimmed) as string;\n      } else {\n        // Plain version string\n        exactVersion = trimmed;\n      }\n\n      this.platform.debug(`Resolved '${versionSpec}' to exact version '${exactVersion}'`);\n      return exactVersion;\n    } catch (error) {\n      throw new Error(`Failed to resolve tfx-cli version spec '${versionSpec}': ${error}`);\n    }\n  }\n\n  /**\n   * Download tfx from npm and cache it\n   * Uses npm install to download tfx-cli and all its dependencies\n   * This matches the behavior of the previous tfxinstaller task\n   * @param exactVersion - Exact version to download (e.g., \"0.17.3\")\n   */\n  private async downloadAndCache(exactVersion: string): Promise<string> {\n    this.platform.info(`Installing tfx-cli@${exactVersion} from npm...`);\n\n    // Create temp directory for installation\n    const tempDir = this.platform.getTempDir();\n    const installDir = path.join(tempDir, `tfx-install-${Date.now()}`);\n    await fs.mkdir(installDir, { recursive: true });\n\n    try {\n      // Step 1: Run npm install to download tfx-cli and all dependencies\n      // This installs into node_modules/tfx-cli with full dependency tree\n      this.platform.debug(`Running npm install tfx-cli@${exactVersion} in ${installDir}`);\n      const npmPath = await this.platform.which('npm', true);\n      const exitCode = await this.platform.exec(\n        npmPath,\n        ['install', `tfx-cli@${exactVersion}`, '--production', '--no-save', '--no-package-lock'],\n        { cwd: installDir }\n      );\n\n      if (exitCode !== 0) {\n        throw new Error(`npm install failed with exit code ${exitCode}`);\n      }\n\n      // Step 2: Verify node_modules/tfx-cli exists\n      const tfxPackageDir = path.join(installDir, 'node_modules', 'tfx-cli');\n      try {\n        await fs.access(tfxPackageDir);\n      } catch {\n        throw new Error(`tfx-cli not found at ${tfxPackageDir} after npm install`);\n      }\n\n      this.platform.info(`Successfully installed tfx-cli@${exactVersion} with dependencies`);\n\n      // Step 3: Make tfx executable on Unix systems\n      await this.ensureExecutable(tfxPackageDir);\n\n      // Step 4: Cache the entire node_modules directory structure\n      // This preserves the full dependency tree for tfx to work correctly\n      this.platform.info(`Caching tfx-cli@${exactVersion}...`);\n      const nodeModulesDir = path.join(installDir, 'node_modules');\n      const cachedDir = await this.platform.cacheDir(nodeModulesDir, 'tfx-cli', exactVersion);\n      this.platform.info(`Cached tfx-cli@${exactVersion} to ${cachedDir}`);\n\n      // Step 5: Return path to tfx executable\n      // The tfx executable is in tfx-cli/bin/ within the cached node_modules\n      const binDir = path.join(cachedDir, 'tfx-cli', 'bin');\n      return this.getTfxExecutable(binDir);\n    } catch (error) {\n      // If install fails, fall back to PATH as last resort\n      this.platform.warning(\n        `Failed to install tfx-cli@${exactVersion}: ${error instanceof Error ? error.message : String(error)}`\n      );\n      this.platform.warning('Falling back to tfx from PATH');\n\n      try {\n        const tfxPath = await this.platform.which('tfx', true);\n        return tfxPath;\n      } catch {\n        throw new Error(\n          `Failed to install tfx-cli@${exactVersion} and no tfx found in PATH. ` +\n            `Original error: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    } finally {\n      // Clean up temp directory\n      try {\n        await this.platform.rmRF(installDir);\n        this.platform.debug(`Cleaned up temp directory: ${installDir}`);\n      } catch (cleanupError) {\n        this.platform.warning(\n          `Failed to clean up temp directory ${installDir}: ${cleanupError instanceof Error ? cleanupError.message : String(cleanupError)}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Ensure tfx binary is executable on Unix systems\n   * @param tfxPackageDir - Path to tfx-cli package directory\n   */\n  private async ensureExecutable(tfxPackageDir: string): Promise<void> {\n    // Only needed on Unix systems\n    if (process.platform === 'win32') {\n      this.platform.debug('Skipping chmod on Windows');\n      return;\n    }\n\n    try {\n      const tfxBin = path.join(tfxPackageDir, 'bin', 'tfx');\n      await fs.chmod(tfxBin, 0o755);\n      this.platform.debug(`Made tfx executable: ${tfxBin}`);\n    } catch (error) {\n      this.platform.warning(`Failed to chmod tfx: ${error}`);\n    }\n  }\n\n  /**\n   * Get tfx executable path from directory\n   * On Windows, uses tfx.cmd or tfx.ps1\n   * On Unix, uses tfx (made executable via chmod)\n   */\n  private getTfxExecutable(dir: string): string {\n    // On Windows, prefer .cmd wrapper, fallback to .ps1\n    const isWindows = process.platform === 'win32';\n    if (isWindows) {\n      const cmdPath = path.join(dir, 'tfx.cmd');\n      // Note: We return tfx.cmd even if it doesn't exist yet\n      // npm install will create it\n      return cmdPath;\n    }\n    // On Unix, use the tfx binary (will be made executable)\n    return path.join(dir, 'tfx');\n  }\n\n  /**\n   * Execute tfx with given arguments\n   * @param args Arguments to pass to tfx\n   * @param options Execution options\n   * @returns Result with exit code and output\n   */\n  async execute(args: string[], options?: TfxExecOptions): Promise<TfxResult> {\n    const tfxPath = await this.resolve();\n\n    // Add JSON output flags if requested\n    const finalArgs = [...args];\n    let jsonStream: JsonOutputStream | undefined;\n\n    if (options?.captureJson) {\n      // Add tfx flags for JSON output\n      if (!finalArgs.includes('--json')) {\n        finalArgs.push('--json');\n      }\n      if (!finalArgs.includes('--debug-log-stream')) {\n        finalArgs.push('--debug-log-stream', 'stderr');\n      }\n\n      // Create JSON output stream\n      jsonStream = new JsonOutputStream((msg) => this.platform.debug(msg));\n    }\n\n    // Build exec options\n    const execOptions = {\n      cwd: options?.cwd,\n      env: options?.env,\n      outStream: jsonStream,\n      errStream: undefined as NodeJS.WritableStream | undefined,\n    };\n\n    // Execute tfx\n    this.platform.info(`Executing: ${tfxPath} ${finalArgs.join(' ')}`);\n    const exitCode = await this.platform.exec(tfxPath, finalArgs, execOptions);\n\n    // Parse JSON if captured\n    let parsedJson: unknown | undefined;\n    if (jsonStream) {\n      parsedJson = jsonStream.parseJson();\n    }\n\n    return {\n      exitCode,\n      json: parsedJson,\n      stdout: jsonStream?.jsonString || '',\n      stderr: '',\n    };\n  }\n}\n", "// Platform abstraction layer\nexport * from './platform.js';\n\n// Authentication\nexport * from './auth.js';\n\n// Core utilities\nexport * from './arg-builder.js';\nexport * from './version-utils.js';\nexport * from './json-output-stream.js';\nexport * from './manifest-utils.js';\nexport * from './tfx-manager.js';\n\n// Manifest handling (unified architecture)\nexport * from './manifest-reader.js';\nexport * from './manifest-editor.js';\nexport * from './vsix-reader.js';\nexport * from './vsix-writer.js';\nexport * from './filesystem-manifest-reader.js';\nexport * from './filesystem-manifest-writer.js';\n\n// Validation\nexport * from './validation.js';\n\n// Commands\nexport * from './commands/index.js';\n", "/**\n * VSIX Reader - Read-only operations for VSIX files\n *\n * Extends ManifestReader to provide VSIX-specific reading from ZIP archives.\n * Completely separate from editing and writing concerns.\n *\n * Security: Protected against zip slip attacks with path validation.\n */\n\nimport yauzl from 'yauzl';\nimport { Buffer } from 'buffer';\nimport { normalize, isAbsolute } from 'path';\nimport { ManifestReader, type ExtensionManifest, type TaskManifest } from './manifest-reader.js';\n\n/**\n * Validate that a path from a ZIP file is safe and doesn't escape the extraction directory\n * Protects against zip slip vulnerabilities\n * @param filePath Path from ZIP entry\n * @throws Error if path is unsafe\n */\nfunction validateZipPath(filePath: string): void {\n  // Normalize the path to resolve any .. or . segments\n  const normalizedPath = normalize(filePath);\n\n  // Check for absolute paths (e.g., /etc/passwd or C:\\Windows\\System32)\n  if (isAbsolute(normalizedPath)) {\n    throw new Error(`Security: Absolute paths are not allowed in VSIX files: ${filePath}`);\n  }\n\n  // Check if the normalized path tries to escape upward (starts with ..)\n  if (normalizedPath.startsWith('..') || normalizedPath.includes(`${normalize('../')}`)) {\n    throw new Error(`Security: Path traversal detected in VSIX file: ${filePath}`);\n  }\n\n  // Check for suspicious patterns\n  const suspiciousPatterns = [\n    /\\.\\.[/\\\\]/, // Parent directory references\n    /^[/\\\\]/, // Root references\n    /[<>:\"|?*]/, // Windows invalid filename characters (except for paths)\n  ];\n\n  for (const pattern of suspiciousPatterns) {\n    if (pattern.test(filePath)) {\n      throw new Error(`Security: Suspicious pattern detected in path: ${filePath}`);\n    }\n  }\n\n  // Validate that the path doesn't contain null bytes (another attack vector)\n  if (filePath.includes('\\0')) {\n    throw new Error(`Security: Null byte detected in path: ${filePath}`);\n  }\n}\n\n/**\n * File entry in VSIX archive\n */\nexport interface VsixFile {\n  path: string;\n  size: number;\n  compressedSize: number;\n}\n\n/**\n * VsixReader - Read-only VSIX file operations extending ManifestReader\n *\n * Example usage:\n * ```typescript\n * const reader = await VsixReader.open('/path/to/extension.vsix');\n * const manifest = await reader.readExtensionManifest();\n * const tasks = await reader.readTaskManifests();\n * await reader.close();\n * ```\n *\n * Or chained:\n * ```typescript\n * const reader = await VsixReader.open('/path/to/extension.vsix');\n * const [manifest, tasks] = await Promise.all([\n *   reader.readExtensionManifest(),\n *   reader.readTaskManifests()\n * ]);\n * await reader.close();\n * ```\n */\nexport class VsixReader extends ManifestReader {\n  private zipFile: yauzl.ZipFile | null = null;\n  private readonly vsixPath: string;\n  private fileCache: Map<string, Buffer> = new Map();\n  private entriesCache: yauzl.Entry[] | null = null;\n\n  private constructor(vsixPath: string) {\n    super();\n    this.vsixPath = vsixPath;\n  }\n\n  /**\n   * Open a VSIX file for reading\n   * @param vsixPath Path to the VSIX file\n   * @returns VsixReader instance\n   */\n  static async open(vsixPath: string): Promise<VsixReader> {\n    const reader = new VsixReader(vsixPath);\n    await reader.openZip();\n    return reader;\n  }\n\n  /**\n   * Open the ZIP file\n   */\n  private async openZip(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      yauzl.open(\n        this.vsixPath,\n        {\n          lazyEntries: true,\n          strictFileNames: false,\n          validateEntrySizes: false,\n          autoClose: false, // Keep file open for multiple read operations\n        },\n        (err: Error | null, zipFile?: yauzl.ZipFile) => {\n          if (err) {\n            reject(new Error(`Failed to open VSIX file: ${err.message}`));\n            return;\n          }\n          this.zipFile = zipFile!;\n          resolve();\n        }\n      );\n    });\n  }\n\n  /**\n   * Read all entries from the ZIP file\n   * Validates all paths for security (zip slip protection)\n   */\n  private async readEntries(): Promise<yauzl.Entry[]> {\n    if (this.entriesCache) {\n      return this.entriesCache;\n    }\n\n    if (!this.zipFile) {\n      throw new Error('VSIX file is not open');\n    }\n\n    return new Promise((resolve, reject) => {\n      const entries: yauzl.Entry[] = [];\n\n      const onEntry = (entry: yauzl.Entry) => {\n        try {\n          // Validate path for security\n          validateZipPath(entry.fileName);\n          entries.push(entry);\n        } catch (err) {\n          // Security violation - reject the entire operation\n          this.zipFile.removeListener('entry', onEntry);\n          this.zipFile.removeListener('end', onEnd);\n          this.zipFile.removeListener('error', onError);\n          reject(err);\n          return;\n        }\n        this.zipFile.readEntry();\n      };\n\n      const onEnd = () => {\n        this.zipFile.removeListener('entry', onEntry);\n        this.zipFile.removeListener('end', onEnd);\n        this.zipFile.removeListener('error', onError);\n        this.entriesCache = entries;\n        resolve(entries);\n      };\n\n      const onError = (err: Error) => {\n        this.zipFile.removeListener('entry', onEntry);\n        this.zipFile.removeListener('end', onEnd);\n        this.zipFile.removeListener('error', onError);\n        reject(new Error(`Error reading VSIX entries: ${err.message}`));\n      };\n\n      this.zipFile.on('entry', onEntry);\n      this.zipFile.on('end', onEnd);\n      this.zipFile.on('error', onError);\n\n      this.zipFile.readEntry();\n    });\n  }\n\n  /**\n   * Read a specific file from the VSIX\n   * @param filePath Path to the file within the VSIX\n   * @returns File contents as Buffer\n   */\n  async readFile(filePath: string): Promise<Buffer> {\n    // Validate path for security (zip slip protection)\n    validateZipPath(filePath);\n\n    // Normalize path separators\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n\n    // Check cache\n    if (this.fileCache.has(normalizedPath)) {\n      return this.fileCache.get(normalizedPath);\n    }\n\n    if (!this.zipFile) {\n      throw new Error('VSIX file is not open');\n    }\n\n    const entries = await this.readEntries();\n    const entry = entries.find((e) => e.fileName === normalizedPath);\n\n    if (!entry) {\n      throw new Error(`File not found in VSIX: ${filePath}`);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.zipFile.openReadStream(entry, (err: Error | null, readStream?: any) => {\n        if (err || !readStream) {\n          reject(new Error(`Failed to read file ${filePath}: ${err?.message || 'No stream'}`));\n          return;\n        }\n\n        const chunks: Buffer[] = [];\n        readStream.on('data', (chunk: Buffer) => chunks.push(chunk));\n        readStream.on('end', () => {\n          const buffer = Buffer.concat(chunks);\n          this.fileCache.set(normalizedPath, buffer);\n          resolve(buffer);\n        });\n        readStream.on('error', (streamErr: Error) => {\n          reject(new Error(`Error reading file ${filePath}: ${streamErr.message}`));\n        });\n      });\n    });\n  }\n\n  /**\n   * Check if a file exists in the VSIX\n   * @param filePath Path to check\n   * @returns True if file exists\n   */\n  async fileExists(filePath: string): Promise<boolean> {\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\n    const entries = await this.readEntries();\n    return entries.some((e) => e.fileName === normalizedPath);\n  }\n\n  /**\n   * List all files in the VSIX\n   * @returns Array of file information\n   */\n  async listFiles(): Promise<VsixFile[]> {\n    const entries = await this.readEntries();\n    return entries\n      .filter((e) => !e.fileName.endsWith('/')) // Exclude directories\n      .map((e) => ({\n        path: e.fileName,\n        size: e.uncompressedSize,\n        compressedSize: e.compressedSize,\n      }));\n  }\n\n  /**\n   * Read the extension manifest (vss-extension.json or extension.vsixmanifest)\n   * @returns Parsed extension manifest\n   */\n  async readExtensionManifest(): Promise<ExtensionManifest> {\n    // Try vss-extension.json first (standard)\n    if (await this.fileExists('extension.vsomanifest')) {\n      const buffer = await this.readFile('extension.vsomanifest');\n      return JSON.parse(buffer.toString('utf-8'));\n    }\n\n    if (await this.fileExists('vss-extension.json')) {\n      const buffer = await this.readFile('vss-extension.json');\n      return JSON.parse(buffer.toString('utf-8'));\n    }\n\n    throw new Error(\n      'Extension manifest not found in VSIX (expected vss-extension.json or extension.vsomanifest)'\n    );\n  }\n\n  /**\n   * Find task directories from the extension manifest\n   * @returns Array of task directory paths\n   */\n  async findTaskPaths(): Promise<string[]> {\n    const manifest = await this.readExtensionManifest();\n    const taskPathsSet = new Set<string>();\n\n    // Look for task contributions\n    if (manifest.contributions) {\n      for (const contribution of manifest.contributions) {\n        if (contribution.type === 'ms.vss-distributed-task.task' && contribution.properties) {\n          const name = contribution.properties.name as string;\n          if (name) {\n            taskPathsSet.add(name);\n          }\n        }\n      }\n    }\n\n    // Look for files array (only if no contributions found)\n    if (taskPathsSet.size === 0 && manifest.files) {\n      const entries = await this.readEntries();\n      for (const file of manifest.files) {\n        // Task directories typically contain task.json\n        const taskJsonPath = `${file.path}/task.json`.replace(/\\\\/g, '/');\n        if (entries.some((e) => e.fileName === taskJsonPath)) {\n          taskPathsSet.add(file.path);\n        }\n      }\n    }\n\n    return Array.from(taskPathsSet);\n  }\n\n  /**\n   * Read a task manifest (task.json)\n   * @param taskPath Path to the task directory\n   * @returns Parsed task manifest\n   */\n  async readTaskManifest(taskPath: string): Promise<TaskManifest> {\n    const taskJsonPath = `${taskPath}/task.json`.replace(/\\\\/g, '/');\n    const buffer = await this.readFile(taskJsonPath);\n    return JSON.parse(buffer.toString('utf-8'));\n  }\n\n  /**\n   * Close the VSIX file and clean up resources\n   */\n  async close(): Promise<void> {\n    if (this.zipFile) {\n      this.zipFile.close();\n      this.zipFile = null;\n    }\n    this.fileCache.clear();\n    this.entriesCache = null;\n  }\n\n  /**\n   * Get the path to the VSIX file\n   */\n  getPath(): string {\n    return this.vsixPath;\n  }\n}\n\n// Re-export types from manifest-reader for backwards compatibility\nexport type {\n  ExtensionManifest,\n  TaskManifest,\n  ManifestMetadata,\n  TaskInfo,\n} from './manifest-reader.js';\n", "/**\n * Input validation functions for extension tasks\n */\n\nimport type { IPlatformAdapter } from './platform.js';\n\n/**\n * Validates an extension ID\n * @param id Extension ID to validate\n * @throws Error if invalid\n */\nexport function validateExtensionId(id: string): void {\n  if (!id || typeof id !== 'string') {\n    throw new Error('Extension ID is required and must be a string');\n  }\n\n  if (id.trim() !== id) {\n    throw new Error('Extension ID cannot have leading or trailing whitespace');\n  }\n\n  if (id.length === 0) {\n    throw new Error('Extension ID cannot be empty');\n  }\n\n  if (id.length > 200) {\n    throw new Error('Extension ID cannot exceed 200 characters');\n  }\n\n  // Azure DevOps extension IDs can contain letters, numbers, dots, underscores, and hyphens\n  const validPattern = /^[a-zA-Z0-9._-]+$/;\n  if (!validPattern.test(id)) {\n    throw new Error(\n      'Extension ID can only contain letters, numbers, dots (.), underscores (_), and hyphens (-)'\n    );\n  }\n}\n\n/**\n * Validates a publisher ID\n * @param id Publisher ID to validate\n * @throws Error if invalid\n */\nexport function validatePublisherId(id: string): void {\n  if (!id || typeof id !== 'string') {\n    throw new Error('Publisher ID is required and must be a string');\n  }\n\n  if (id.trim() !== id) {\n    throw new Error('Publisher ID cannot have leading or trailing whitespace');\n  }\n\n  if (id.length === 0) {\n    throw new Error('Publisher ID cannot be empty');\n  }\n\n  if (id.length > 200) {\n    throw new Error('Publisher ID cannot exceed 200 characters');\n  }\n\n  // Publisher IDs have same constraints as extension IDs\n  const validPattern = /^[a-zA-Z0-9._-]+$/;\n  if (!validPattern.test(id)) {\n    throw new Error(\n      'Publisher ID can only contain letters, numbers, dots (.), underscores (_), and hyphens (-)'\n    );\n  }\n}\n\n/**\n * Validates an Azure DevOps account URL\n * @param url Account URL to validate\n * @throws Error if invalid\n */\nexport function validateAccountUrl(url: string): void {\n  if (!url || typeof url !== 'string') {\n    throw new Error('Account URL is required and must be a string');\n  }\n\n  if (url.trim() !== url) {\n    throw new Error('Account URL cannot have leading or trailing whitespace');\n  }\n\n  if (url.length === 0) {\n    throw new Error('Account URL cannot be empty');\n  }\n\n  // Basic URL validation\n  let parsedUrl: URL;\n  try {\n    parsedUrl = new URL(url);\n  } catch {\n    throw new Error('Account URL must be a valid URL');\n  }\n\n  // Must use HTTPS\n  if (parsedUrl.protocol !== 'https:') {\n    throw new Error('Account URL must use HTTPS protocol');\n  }\n\n  // Check for Azure DevOps domains\n  const validDomains = ['dev.azure.com', 'visualstudio.com', 'azure.com'];\n\n  const hostname = parsedUrl.hostname.toLowerCase();\n  const isValidDomain = validDomains.some(\n    (domain) => hostname === domain || hostname.endsWith('.' + domain)\n  );\n\n  if (!isValidDomain) {\n    throw new Error(\n      'Account URL must be an Azure DevOps URL (dev.azure.com, *.visualstudio.com, or *.azure.com)'\n    );\n  }\n}\n\n/**\n * Validates a version string\n * @param version Version string to validate\n * @throws Error if invalid\n */\nexport function validateVersion(version: string): void {\n  if (!version || typeof version !== 'string') {\n    throw new Error('Version is required and must be a string');\n  }\n\n  if (version.trim() !== version) {\n    throw new Error('Version cannot have leading or trailing whitespace');\n  }\n\n  if (version.length === 0) {\n    throw new Error('Version cannot be empty');\n  }\n\n  // Semantic versioning pattern (simplified)\n  // Supports: 1.0.0, 1.0.0.0, 1.0, etc.\n  const semverPattern = /^\\d+(\\.\\d+){0,3}$/;\n\n  if (!semverPattern.test(version)) {\n    throw new Error('Version must follow semantic versioning (e.g., 1.0.0, 1.0.0.0)');\n  }\n\n  // Validate each part is within valid range\n  const parts = version.split('.');\n  for (const part of parts) {\n    const num = parseInt(part, 10);\n    if (num < 0 || num > 999999) {\n      throw new Error('Version numbers must be between 0 and 999999');\n    }\n  }\n}\n\n/**\n * Gets the version of a binary by executing it with --version\n * @param binary Binary name\n * @param platform Platform adapter for executing commands\n * @returns Version string or null if unable to determine\n */\nasync function getBinaryVersion(\n  binary: string,\n  platform: IPlatformAdapter\n): Promise<string | null> {\n  try {\n    // Different binaries use different flags for version info\n    const versionArgs: { [key: string]: string[] } = {\n      node: ['--version'],\n      npm: ['--version'],\n      az: ['--version'],\n      tfx: ['version', '--no-prompt', '--no-color'], // tfx version command with clean output\n    };\n\n    const args = versionArgs[binary] || ['--version'];\n\n    // Execute binary to check if it's available\n    const exitCode = await platform.exec(binary, args, {\n      silent: true,\n      ignoreReturnCode: true,\n    } as any);\n\n    // If exec succeeds, binary is available\n    if (exitCode === 0) {\n      return 'available';\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Validates that a required binary is available\n * @param binary Binary name to check (e.g., 'az', 'tfx', 'npm', 'node')\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if binary is not available\n */\nexport async function validateBinaryAvailable(\n  binary: string,\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  if (!binary || typeof binary !== 'string') {\n    throw new Error('Binary name is required and must be a string');\n  }\n\n  platform.debug(`Checking for required binary: ${binary}`);\n\n  try {\n    const binaryPath = await platform.which(binary, true);\n    platform.debug(`Found ${binary} at: ${binaryPath}`);\n\n    // Log version in debug mode\n    if (logVersion) {\n      const version = await getBinaryVersion(binary, platform);\n      if (version) {\n        platform.debug(`${binary} version: ${version}`);\n      } else {\n        platform.debug(`${binary} version: Unable to determine`);\n      }\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(\n      `Required binary '${binary}' is not available. ` +\n        `Please ensure ${binary} is installed and in your PATH. ` +\n        `Error: ${errorMessage}`\n    );\n  }\n}\n\n/**\n * Validates that Node.js is available and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if Node.js is not available\n */\nexport async function validateNodeAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('node', platform, logVersion);\n}\n\n/**\n * Validates that npm is available and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if npm is not available\n */\nexport async function validateNpmAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('npm', platform, logVersion);\n}\n\n/**\n * Validates that tfx is available (for path mode) and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if tfx is not available\n */\nexport async function validateTfxAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('tfx', platform, logVersion);\n}\n\n/**\n * Validates that Azure CLI is available (for OIDC authentication) and logs version in debug mode\n * @param platform Platform adapter for executing commands\n * @param logVersion If true, logs the version in debug mode (default: true)\n * @throws Error if Azure CLI is not available\n */\nexport async function validateAzureCliAvailable(\n  platform: IPlatformAdapter,\n  logVersion: boolean = true\n): Promise<void> {\n  await validateBinaryAvailable('az', platform, logVersion);\n}\n", "/**\n * Package command - Creates a .vsix file from extension manifest\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport { ArgBuilder } from '../arg-builder.js';\nimport { FilesystemManifestReader } from '../filesystem-manifest-reader.js';\nimport { ManifestEditor } from '../manifest-editor.js';\n\n/**\n * Options for package command\n */\nexport interface PackageOptions {\n  // Manifest source\n  rootFolder?: string;\n  manifestGlobs?: string[];\n  overridesFile?: string;\n\n  // Overrides\n  publisherId?: string;\n  extensionId?: string;\n  extensionName?: string;\n  extensionVersion?: string;\n  extensionVisibility?: 'private' | 'public';\n\n  // Task patching\n  updateTasksVersion?: boolean;\n  updateTasksVersionType?: 'major' | 'minor' | 'patch';\n  updateTasksId?: boolean;\n\n  // Output\n  outputPath?: string;\n  outputVariable?: string;\n\n  // Behavior\n  bypassValidation?: boolean;\n  revVersion?: boolean;\n}\n\n/**\n * Result from package command\n */\nexport interface PackageResult {\n  /** Path to created .vsix file */\n  vsixPath: string;\n  /** Extension ID from manifest */\n  extensionId: string;\n  /** Extension version */\n  extensionVersion: string;\n  /** Publisher ID from manifest */\n  publisherId: string;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Package an extension into a .vsix file\n * @param options Package options\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Package result with vsix path and metadata\n */\nexport async function packageExtension(\n  options: PackageOptions,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<PackageResult> {\n  platform.info('Packaging extension...');\n\n  // Build tfx arguments\n  const args = new ArgBuilder().arg(['extension', 'create']).flag('--json').flag('--no-color');\n\n  // Manifest arguments\n  if (options.rootFolder) {\n    args.option('--root', options.rootFolder);\n  }\n\n  if (options.manifestGlobs && options.manifestGlobs.length > 0) {\n    args.flag('--manifest-globs');\n    options.manifestGlobs.forEach((glob) => args.arg(glob));\n  }\n\n  if (options.overridesFile) {\n    args.option('--overrides-file', options.overridesFile);\n  }\n\n  // Overrides\n  if (options.publisherId) {\n    args.option('--publisher', options.publisherId);\n  }\n\n  const extensionId = options.extensionId;\n\n  if (extensionId) {\n    args.option('--extension-id', extensionId);\n  }\n\n  // Output path\n  if (options.outputPath) {\n    args.option('--output-path', options.outputPath);\n  }\n\n  // Flags\n  if (options.bypassValidation) {\n    args.flag('--bypass-validation');\n  }\n\n  if (options.revVersion) {\n    args.flag('--rev-version');\n  }\n\n  // Handle manifest updates using the unified architecture\n  let cleanupWriter: (() => Promise<void>) | null = null;\n\n  const shouldApplyManifestOptions =\n    options.updateTasksVersion ||\n    options.updateTasksId ||\n    options.extensionVersion ||\n    options.extensionName ||\n    options.extensionVisibility;\n\n  if (shouldApplyManifestOptions) {\n    platform.info('Updating task manifests before packaging...');\n\n    try {\n      // Create filesystem reader for the source directory\n      const rootFolder = options.rootFolder || '.';\n      const manifestGlobs = options.manifestGlobs || ['vss-extension.json'];\n\n      const reader = new FilesystemManifestReader({\n        rootFolder,\n        manifestGlobs,\n        platform,\n      });\n\n      // Create editor and apply all options at once\n      const editor = ManifestEditor.fromReader(reader);\n      await editor.applyOptions({\n        publisherId: options.publisherId,\n        extensionId: options.extensionId,\n        extensionVersion: options.extensionVersion,\n        extensionName: options.extensionName,\n        extensionVisibility: options.extensionVisibility,\n        updateTasksVersion: options.updateTasksVersion,\n        updateTasksVersionType: options.updateTasksVersionType,\n        updateTasksId: options.updateTasksId,\n      });\n\n      // Write modifications to filesystem\n      const writer = await editor.toWriter();\n      await writer.writeToFilesystem();\n\n      // Get overrides file path if generated\n      const overridesPath = writer.getOverridesPath();\n      if (overridesPath) {\n        platform.debug(`Using overrides file: ${overridesPath}`);\n        args.option('--overrides-file', overridesPath);\n      }\n\n      // Setup cleanup function\n      cleanupWriter = async () => {\n        await writer.close();\n        await reader.close();\n      };\n\n      platform.info('Task manifests updated successfully');\n    } catch (err) {\n      platform.error(`Failed to update task manifests: ${(err as Error).message}`);\n      throw err;\n    }\n  }\n\n  try {\n    // Execute tfx\n    const result = await tfx.execute(args.build(), { captureJson: true });\n\n    if (result.exitCode !== 0) {\n      platform.error(`tfx exited with code ${result.exitCode}`);\n      throw new Error(`tfx extension create failed with exit code ${result.exitCode}`);\n    }\n\n    // Parse JSON result\n    const json = result.json as any;\n    if (!json || !json.path) {\n      throw new Error('tfx did not return expected JSON output with path');\n    }\n\n    // Set output variable if specified\n    if (options.outputVariable) {\n      platform.setVariable(options.outputVariable, json.path, false, true);\n    }\n\n    // Always set Extension.OutputPath for compatibility\n    platform.setVariable('Extension.OutputPath', json.path, false, true);\n\n    platform.info(`Packaged extension: ${json.path}`);\n\n    return {\n      vsixPath: json.path,\n      extensionId: json.id || extensionId || '',\n      extensionVersion: json.version || options.extensionVersion || '',\n      publisherId: json.publisher || options.publisherId || '',\n      exitCode: result.exitCode,\n    };\n  } finally {\n    // Clean up writer resources if created\n    if (cleanupWriter) {\n      await cleanupWriter();\n    }\n  }\n}\n", "/**\n * Publish command - Publishes an extension to the marketplace\n */\n\nimport { ArgBuilder } from '../arg-builder.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ManifestEditor } from '../manifest-editor.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport { VsixReader } from '../vsix-reader.js';\n\n/**\n * Source for publishing\n */\nexport type PublishSource = 'manifest' | 'vsix';\n\n/**\n * Options for publish command\n */\nexport interface PublishOptions {\n  // Source\n  publishSource: PublishSource;\n\n  // Manifest source (when publishSource = 'manifest')\n  rootFolder?: string;\n  manifestGlobs?: string[];\n  overridesFile?: string;\n\n  // VSIX source (when publishSource = 'vsix')\n  vsixFile?: string;\n\n  // Overrides\n  publisherId?: string;\n  extensionId?: string;\n  extensionName?: string;\n  extensionVersion?: string;\n  extensionVisibility?: 'private' | 'public' | 'private_preview' | 'public_preview';\n\n  // Task patching\n  updateTasksVersion?: boolean;\n  updateTasksVersionType?: 'major' | 'minor' | 'patch';\n  updateTasksId?: boolean;\n\n  // Sharing\n  shareWith?: string[]; // Array of organization names to share with\n\n  // Behavior\n  noWaitValidation?: boolean;\n  bypassValidation?: boolean;\n  outputVariable?: string;\n}\n\n/**\n * Result from publish command\n */\nexport interface PublishResult {\n  /** Whether extension was published successfully */\n  published: boolean;\n  /** Path to the vsix file that was published */\n  vsixPath: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Extension version */\n  extensionVersion: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Helper function to execute tfx publish and parse results\n */\nasync function executeTfxPublish(\n  tfx: TfxManager,\n  args: ArgBuilder,\n  platform: IPlatformAdapter,\n  options: PublishOptions\n): Promise<PublishResult> {\n  // Sharing\n  if (options.shareWith && options.shareWith.length > 0) {\n    // Only share if extension is not public\n    const isPublic =\n      options.extensionVisibility === 'public' || options.extensionVisibility === 'public_preview';\n\n    if (isPublic) {\n      platform.warning('Ignoring shareWith - not available for public extensions');\n    } else {\n      args.flag('--share-with');\n      options.shareWith.forEach((org) => args.arg(org));\n    }\n  }\n\n  // Flags\n  if (options.noWaitValidation) {\n    args.flag('--no-wait-validation');\n  }\n\n  if (options.bypassValidation) {\n    args.flag('--bypass-validation');\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension publish failed with exit code ${result.exitCode}`);\n  }\n\n  // Parse JSON result\n  const json = result.json as any;\n  if (!json || !json.published) {\n    throw new Error('tfx did not return expected JSON output with published status');\n  }\n\n  // Determine vsix path\n  let vsixPath = '';\n  if (options.publishSource === 'manifest') {\n    vsixPath = json.packaged || '';\n  } else {\n    vsixPath = options.vsixFile || '';\n  }\n\n  // Set output variable if specified\n  if (options.outputVariable && vsixPath) {\n    platform.setVariable(options.outputVariable, vsixPath, false, true);\n  }\n\n  platform.info(`Published extension: ${json.id} v${json.version}`);\n\n  return {\n    published: json.published === true,\n    vsixPath,\n    extensionId: json.id || options.extensionId || '',\n    extensionVersion: json.version || options.extensionVersion || '',\n    publisherId: json.publisher || options.publisherId || '',\n    exitCode: result.exitCode,\n  };\n}\n\n/**\n * Publish an extension to the marketplace\n * @param options Publish options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Publish result\n */\nexport async function publishExtension(\n  options: PublishOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<PublishResult> {\n  platform.info('Publishing extension...');\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'publish'])\n    .flag('--json')\n    .flag('--no-color')\n    .flag('--debug-log-stream')\n    .arg('stderr');\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Source-specific arguments\n  if (options.publishSource === 'manifest') {\n    // Publishing from manifest files\n    if (options.rootFolder) {\n      args.option('--root', options.rootFolder);\n    }\n\n    if (options.manifestGlobs && options.manifestGlobs.length > 0) {\n      args.flag('--manifest-globs');\n      options.manifestGlobs.forEach((glob) => args.arg(glob));\n    }\n\n    if (options.overridesFile) {\n      args.option('--overrides-file', options.overridesFile);\n    }\n\n    // Overrides\n    if (options.publisherId) {\n      args.option('--publisher', options.publisherId);\n    }\n\n    const extensionId = options.extensionId;\n\n    if (extensionId) {\n      args.option('--extension-id', extensionId);\n    }\n\n    if (options.extensionName) {\n      args.option('--extension-name', options.extensionName);\n    }\n\n    if (options.extensionVersion) {\n      args.option('--extension-version', options.extensionVersion);\n    }\n\n    if (options.extensionVisibility) {\n      args.option('--extension-visibility', options.extensionVisibility);\n    }\n\n    // Handle task version and ID updates for manifest publishing\n    // This uses the same approach as package.ts\n    let cleanupWriter: (() => Promise<void>) | null = null;\n\n    if (options.updateTasksVersion || options.updateTasksId) {\n      platform.info('Updating task manifests before publishing...');\n\n      try {\n        // Import filesystem manifest modules\n        const { FilesystemManifestReader } = await import('../filesystem-manifest-reader.js');\n        const { ManifestEditor } = await import('../manifest-editor.js');\n\n        // Create filesystem reader for the source directory\n        const rootFolder = options.rootFolder || '.';\n        const manifestGlobs = options.manifestGlobs || ['vss-extension.json'];\n\n        const reader = new FilesystemManifestReader({\n          rootFolder,\n          manifestGlobs,\n          platform,\n        });\n\n        // Create editor and apply all options at once\n        const editor = ManifestEditor.fromReader(reader);\n        await editor.applyOptions({\n          publisherId: options.publisherId,\n          extensionId: options.extensionId,\n          extensionVersion: options.extensionVersion,\n          extensionName: options.extensionName,\n          extensionVisibility: options.extensionVisibility,\n          updateTasksVersion: options.updateTasksVersion,\n          updateTasksVersionType: options.updateTasksVersionType,\n          updateTasksId: options.updateTasksId,\n        });\n\n        // Write modifications to filesystem\n        const writer = await editor.toWriter();\n        await writer.writeToFilesystem();\n\n        // Get overrides file path if generated\n        const overridesPath = writer.getOverridesPath();\n        if (overridesPath) {\n          platform.debug(`Using overrides file: ${overridesPath}`);\n          args.option('--overrides-file', overridesPath);\n        }\n\n        // Setup cleanup function\n        cleanupWriter = async () => {\n          await writer.close();\n          await reader.close();\n        };\n\n        platform.info('Task manifests updated successfully');\n      } catch (err) {\n        platform.error(`Failed to update task manifests: ${(err as Error).message}`);\n        throw err;\n      }\n    }\n\n    // Execute tfx and handle cleanup\n    try {\n      return await executeTfxPublish(tfx, args, platform, options);\n    } finally {\n      if (cleanupWriter) {\n        await cleanupWriter();\n      }\n    }\n  } else {\n    // Publishing from VSIX file\n    if (!options.vsixFile) {\n      throw new Error('vsixFile is required when publishSource is \"vsix\"');\n    }\n\n    // Check if file exists\n    const fileExists = await platform.fileExists(options.vsixFile);\n    if (!fileExists) {\n      throw new Error(`VSIX file not found: ${options.vsixFile}`);\n    }\n\n    // Check if we need to modify the VSIX before publishing\n    const needsModification =\n      options.publisherId ||\n      options.extensionId ||\n      options.extensionVersion ||\n      options.extensionName ||\n      options.extensionVisibility ||\n      options.updateTasksVersion ||\n      options.updateTasksId;\n\n    if (needsModification) {\n      platform.info('Modifying VSIX before publishing...');\n\n      // Open the VSIX and create an editor using the unified architecture\n      const reader = await VsixReader.open(options.vsixFile);\n      const editor = ManifestEditor.fromReader(reader);\n\n      // Apply all options at once\n      await editor.applyOptions({\n        publisherId: options.publisherId,\n        extensionId: options.extensionId,\n        extensionVersion: options.extensionVersion,\n        extensionName: options.extensionName,\n        extensionVisibility: options.extensionVisibility,\n        updateTasksVersion: options.updateTasksVersion,\n        updateTasksVersionType: options.updateTasksVersionType,\n        updateTasksId: options.updateTasksId,\n      });\n\n      // Write modified VSIX to a temporary file\n      const writer = await editor.toWriter();\n      const tempDir = platform.getTempDir();\n      const tempVsixPath = `${tempDir}/temp-${Date.now()}.vsix`;\n\n      platform.debug(`Writing modified VSIX to: ${tempVsixPath}`);\n      await writer.writeToFile(tempVsixPath);\n      await writer.close();\n      await reader.close();\n\n      // Use the modified VSIX for publishing\n      args.option('--vsix', tempVsixPath);\n\n      platform.info('VSIX modifications applied successfully');\n    } else {\n      // No modifications needed - publish as-is\n      args.option('--vsix', options.vsixFile);\n    }\n  }\n\n  // Execute tfx using the helper function\n  return executeTfxPublish(tfx, args, platform, options);\n}\n", "/**\n * Unpublish command - Removes an extension from the marketplace\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for unpublish command\n */\nexport interface UnpublishOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n}\n\n/**\n * Result from unpublish command\n */\nexport interface UnpublishResult {\n  /** Whether extension was unpublished successfully */\n  success: boolean;\n  /** Extension ID that was unpublished */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Unpublish an extension from the marketplace\n * @param options Unpublish options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Unpublish result\n */\nexport async function unpublishExtension(\n  options: UnpublishOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<UnpublishResult> {\n  platform.info(`Unpublishing extension ${options.publisherId}.${options.extensionId}...`);\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'unpublish'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId);\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension unpublish failed with exit code ${result.exitCode}`);\n  }\n\n  platform.info(`Successfully unpublished extension: ${options.publisherId}.${extensionId}`);\n\n  return {\n    success: true,\n    extensionId,\n    publisherId: options.publisherId,\n    exitCode: result.exitCode,\n  };\n}\n", "/**\n * Share command - Shares an extension with organizations\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for share command\n */\nexport interface ShareOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Array of organization names to share with */\n  shareWith: string[];\n}\n\n/**\n * Result from share command\n */\nexport interface ShareResult {\n  /** Whether extension was shared successfully */\n  success: boolean;\n  /** Extension ID that was shared */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Organizations shared with */\n  sharedWith: string[];\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Share an extension with organizations\n * @param options Share options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Share result\n */\nexport async function shareExtension(\n  options: ShareOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<ShareResult> {\n  if (!options.shareWith || options.shareWith.length === 0) {\n    throw new Error('shareWith must contain at least one organization');\n  }\n\n  platform.info(\n    `Sharing extension ${options.publisherId}.${options.extensionId} with ${options.shareWith.length} organization(s)...`\n  );\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'share'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId)\n    .flag('--share-with');\n\n  // Add each organization\n  options.shareWith.forEach((org) => args.arg(org));\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension share failed with exit code ${result.exitCode}`);\n  }\n\n  platform.info(`Successfully shared extension with: ${options.shareWith.join(', ')}`);\n\n  return {\n    success: true,\n    extensionId,\n    publisherId: options.publisherId,\n    sharedWith: options.shareWith,\n    exitCode: result.exitCode,\n  };\n}\n", "/**\n * Unshare command - Unshares an extension from organizations\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for unshare command\n */\nexport interface UnshareOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Array of organization names to unshare from */\n  unshareWith: string[];\n}\n\n/**\n * Result from unshare command\n */\nexport interface UnshareResult {\n  /** Whether extension was unshared successfully */\n  success: boolean;\n  /** Extension ID that was unshared */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Organizations unshared from */\n  unsharedFrom: string[];\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Unshare an extension from organizations\n * @param options Unshare options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Unshare result\n */\nexport async function unshareExtension(\n  options: UnshareOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<UnshareResult> {\n  if (!options.unshareWith || options.unshareWith.length === 0) {\n    throw new Error('unshareWith must contain at least one organization');\n  }\n\n  platform.info(\n    `Unsharing extension ${options.publisherId}.${options.extensionId} from ${options.unshareWith.length} organization(s)...`\n  );\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'unshare'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId)\n    .flag('--unshare-with');\n\n  // Add each organization\n  options.unshareWith.forEach((org) => args.arg(org));\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension unshare failed with exit code ${result.exitCode}`);\n  }\n\n  platform.info(`Successfully unshared extension from: ${options.unshareWith.join(', ')}`);\n\n  return {\n    success: true,\n    extensionId,\n    publisherId: options.publisherId,\n    unsharedFrom: options.unshareWith,\n    exitCode: result.exitCode,\n  };\n}\n", "/**\n * Install command - Installs an extension to organization(s)\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for install command\n */\nexport interface InstallOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Target organization URLs to install to */\n  accounts: string[];\n  /** Extension version to install (optional) */\n  extensionVersion?: string;\n}\n\n/**\n * Result from install command for a single account\n */\nexport interface InstallAccountResult {\n  /** Account URL */\n  account: string;\n  /** Whether installation succeeded */\n  success: boolean;\n  /** Whether extension was already installed */\n  alreadyInstalled: boolean;\n  /** Error message if failed */\n  error?: string;\n}\n\n/**\n * Result from install command\n */\nexport interface InstallResult {\n  /** Extension ID that was installed */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Results per account */\n  accountResults: InstallAccountResult[];\n  /** Overall success (all accounts succeeded) */\n  allSuccess: boolean;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Install an extension to one or more organizations\n * @param options Install options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Install result\n */\nexport async function installExtension(\n  options: InstallOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<InstallResult> {\n  if (!options.accounts || options.accounts.length === 0) {\n    throw new Error('accounts must contain at least one organization URL');\n  }\n\n  platform.info(\n    `Installing extension ${options.publisherId}.${options.extensionId} to ${options.accounts.length} organization(s)...`\n  );\n\n  const extensionId = options.extensionId;\n\n  const accountResults: InstallAccountResult[] = [];\n  let overallExitCode = 0;\n\n  // Install to each account\n  for (const account of options.accounts) {\n    platform.info(`Installing to ${account}...`);\n\n    // Build tfx arguments for this account\n    const args = new ArgBuilder()\n      .arg(['extension', 'install'])\n      .flag('--json')\n      .flag('--no-color')\n      .option('--publisher', options.publisherId)\n      .option('--extension-id', extensionId)\n      .option('--service-url', account);\n\n    // Version if specified\n    if (options.extensionVersion) {\n      args.option('--extension-version', options.extensionVersion);\n    }\n\n    // Authentication (using marketplace auth, not account-specific)\n    args.option('--auth-type', auth.authType);\n\n    if (auth.authType === 'pat') {\n      args.option('--token', auth.token);\n      platform.setSecret(auth.token);\n    } else if (auth.authType === 'basic') {\n      args.option('--username', auth.username);\n      args.option('--password', auth.password);\n      platform.setSecret(auth.password);\n    }\n\n    try {\n      // Execute tfx\n      const result = await tfx.execute(args.build(), { captureJson: true });\n\n      if (result.exitCode === 0) {\n        accountResults.push({\n          account,\n          success: true,\n          alreadyInstalled: false,\n        });\n        platform.info(`\u2713 Successfully installed to ${account}`);\n      } else {\n        // Check if error is \"already installed\" (TF1590010)\n        const stderr = result.stderr || '';\n        const alreadyInstalled = stderr.includes('TF1590010');\n\n        if (alreadyInstalled) {\n          accountResults.push({\n            account,\n            success: true,\n            alreadyInstalled: true,\n          });\n          platform.warning(`Extension already installed in ${account} - continuing`);\n        } else {\n          accountResults.push({\n            account,\n            success: false,\n            alreadyInstalled: false,\n            error: `Exit code ${result.exitCode}`,\n          });\n          platform.error(`\u2717 Failed to install to ${account}: exit code ${result.exitCode}`);\n          overallExitCode = result.exitCode;\n        }\n      }\n    } catch (err) {\n      accountResults.push({\n        account,\n        success: false,\n        alreadyInstalled: false,\n        error: String(err),\n      });\n      platform.error(`\u2717 Failed to install to ${account}: ${err}`);\n      overallExitCode = 1;\n    }\n  }\n\n  const allSuccess = accountResults.every((r) => r.success);\n  const successCount = accountResults.filter((r) => r.success).length;\n\n  platform.info(`Installation complete: ${successCount}/${options.accounts.length} succeeded`);\n\n  return {\n    extensionId,\n    publisherId: options.publisherId,\n    accountResults,\n    allSuccess,\n    exitCode: overallExitCode,\n  };\n}\n", "/**\n * Show command - Displays extension metadata from marketplace\n */\n\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { ArgBuilder } from '../arg-builder.js';\n\n/**\n * Options for show command\n */\nexport interface ShowOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Output variable name to store extension data (optional) */\n  outputVariable?: string;\n}\n\n/**\n * Extension metadata from marketplace\n */\nexport interface ExtensionMetadata {\n  /** Extension ID */\n  id: string;\n  /** Publisher ID */\n  publisher: string;\n  /** Extension version */\n  version: string;\n  /** Display name */\n  name?: string;\n  /** Description */\n  description?: string;\n  /** Categories */\n  categories?: string[];\n  /** Tags */\n  tags?: string[];\n  /** Any other metadata from tfx */\n  [key: string]: any;\n}\n\n/**\n * Result from show command\n */\nexport interface ShowResult {\n  /** Extension metadata */\n  metadata: ExtensionMetadata;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Show extension metadata from marketplace\n * @param options Show options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns Show result with extension metadata\n */\nexport async function showExtension(\n  options: ShowOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<ShowResult> {\n  platform.info(`Querying extension ${options.publisherId}.${options.extensionId}...`);\n\n  const extensionId = options.extensionId;\n\n  // Build tfx arguments\n  const args = new ArgBuilder()\n    .arg(['extension', 'show'])\n    .flag('--json')\n    .flag('--no-color')\n    .option('--publisher', options.publisherId)\n    .option('--extension-id', extensionId);\n\n  // Authentication\n  args.option('--service-url', auth.serviceUrl);\n\n  if (auth.authType === 'pat') {\n    args.option('--auth-type', 'pat');\n    args.option('--token', auth.token);\n    platform.setSecret(auth.token);\n  } else if (auth.authType === 'basic') {\n    args.option('--auth-type', 'basic');\n    args.option('--username', auth.username);\n    args.option('--password', auth.password);\n    platform.setSecret(auth.password);\n  }\n\n  // Execute tfx\n  const result = await tfx.execute(args.build(), { captureJson: true });\n\n  if (result.exitCode !== 0) {\n    platform.error(`tfx exited with code ${result.exitCode}`);\n    throw new Error(`tfx extension show failed with exit code ${result.exitCode}`);\n  }\n\n  // Parse JSON result\n  const json = result.json as any;\n  if (!json) {\n    throw new Error('tfx did not return expected JSON output');\n  }\n\n  const metadata: ExtensionMetadata = {\n    id: json.extensionId || json.id || extensionId,\n    publisher: json.publisher || options.publisherId,\n    version: json.version || json.versions?.[0]?.version || '',\n    name: json.extensionName || json.displayName || json.name,\n    description: json.shortDescription || json.description,\n    categories: json.categories,\n    tags: json.tags,\n    ...json, // Include all other fields\n  };\n\n  // Set output variable if specified\n  if (options.outputVariable) {\n    platform.setVariable(options.outputVariable, JSON.stringify(metadata), false, true);\n  }\n\n  platform.info(`Extension: ${metadata.name || metadata.id} v${metadata.version}`);\n  if (metadata.description) {\n    platform.info(`Description: ${metadata.description}`);\n  }\n\n  return {\n    metadata,\n    exitCode: result.exitCode,\n  };\n}\n", "import type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { showExtension } from './show.js';\n\nexport type VersionAction = 'None' | 'Major' | 'Minor' | 'Patch';\n\nexport interface QueryVersionOptions {\n  publisherId: string;\n  extensionId: string;\n  versionAction?: VersionAction;\n  extensionVersionOverrideVariable?: string;\n  outputVariable?: string;\n}\n\nexport interface QueryVersionResult {\n  currentVersion: string;\n  proposedVersion: string;\n  version: string;\n  source: 'override' | 'marketplace';\n}\n\nfunction applyVersionAction(version: string, versionAction: VersionAction): string {\n  if (versionAction === 'None') {\n    return version;\n  }\n\n  const versionParts = version.split('.').map((part) => Number.parseInt(part, 10));\n  if (\n    versionParts.length !== 3 ||\n    Number.isNaN(versionParts[0]) ||\n    Number.isNaN(versionParts[1]) ||\n    Number.isNaN(versionParts[2])\n  ) {\n    throw new Error(`Version '${version}' is not a valid semantic version (major.minor.patch)`);\n  }\n\n  switch (versionAction) {\n    case 'Major':\n      return `${versionParts[0] + 1}.0.0`;\n    case 'Minor':\n      return `${versionParts[0]}.${versionParts[1] + 1}.0`;\n    case 'Patch':\n      return `${versionParts[0]}.${versionParts[1]}.${versionParts[2] + 1}`;\n    default:\n      return version;\n  }\n}\n\nexport async function queryVersion(\n  options: QueryVersionOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<QueryVersionResult> {\n  const versionAction = options.versionAction ?? 'None';\n\n  if (options.extensionVersionOverrideVariable) {\n    platform.debug(\n      `Override variable '${options.extensionVersionOverrideVariable}' specified, checking for value.`\n    );\n    const overrideVersion = platform.getVariable(options.extensionVersionOverrideVariable);\n    if (overrideVersion) {\n      platform.info(\n        `Ignoring marketplace version and using supplied override: ${overrideVersion}.`\n      );\n      platform.setVariable('Extension.Version', overrideVersion, false, false);\n      platform.setVariable('Extension.Version', overrideVersion, false, true);\n      if (options.outputVariable) {\n        platform.setVariable(options.outputVariable, overrideVersion, false, true);\n      }\n      return {\n        currentVersion: overrideVersion,\n        proposedVersion: overrideVersion,\n        version: overrideVersion,\n        source: 'override',\n      };\n    }\n  }\n\n  const showResult = await showExtension(\n    {\n      publisherId: options.publisherId,\n      extensionId: options.extensionId,\n    },\n    auth,\n    tfx,\n    platform\n  );\n\n  const marketplaceVersion = showResult.metadata.version;\n  if (!marketplaceVersion) {\n    throw new Error('Could not determine extension version from marketplace response');\n  }\n\n  platform.info(`Latest version   : ${marketplaceVersion}.`);\n  platform.info(`Requested action : ${versionAction}.`);\n\n  const updatedVersion = applyVersionAction(marketplaceVersion, versionAction);\n  if (updatedVersion !== marketplaceVersion) {\n    platform.info(`Updated to       : ${updatedVersion}.`);\n  }\n\n  platform.setVariable('Extension.Version', updatedVersion, false, false);\n  platform.setVariable('Extension.Version', updatedVersion, false, true);\n  if (options.outputVariable) {\n    platform.setVariable(options.outputVariable, updatedVersion, false, true);\n  }\n\n  return {\n    currentVersion: marketplaceVersion,\n    proposedVersion: updatedVersion,\n    version: updatedVersion,\n    source: 'marketplace',\n  };\n}\n", "/**\n * WaitForValidation command - Validates extension against marketplace with retry\n */\n\nimport { ArgBuilder } from '../arg-builder.js';\nimport type { AuthCredentials } from '../auth.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport type { TfxManager } from '../tfx-manager.js';\n\n/**\n * Validation status from marketplace\n */\nexport type ValidationStatus = 'pending' | 'success' | 'failed' | 'error';\n\n/**\n * Options for waitForValidation command\n */\nexport interface WaitForValidationOptions {\n  /** Publisher ID */\n  publisherId: string;\n  /** Extension ID */\n  extensionId: string;\n  /** Root folder for manifest (if validating from manifest) */\n  rootFolder?: string;\n  /** Manifest globs (if validating from manifest) */\n  manifestGlobs?: string[];\n  /** Max retries for pending validation (default: 10) */\n  maxRetries?: number;\n  /** Min timeout between retries in minutes (default: 1) */\n  minTimeout?: number;\n  /** Max timeout between retries in minutes (default: 15) */\n  maxTimeout?: number;\n}\n\n/**\n * Result from waitForValidation command\n */\nexport interface WaitForValidationResult {\n  /** Validation status */\n  status: ValidationStatus;\n  /** Whether extension is valid */\n  isValid: boolean;\n  /** Extension ID */\n  extensionId: string;\n  /** Publisher ID */\n  publisherId: string;\n  /** Number of attempts made */\n  attempts: number;\n  /** Exit code from tfx */\n  exitCode: number;\n}\n\n/**\n * Validate extension against marketplace\n * Retries if validation is pending\n * @param options WaitForValidation options\n * @param auth Authentication credentials\n * @param tfx TfxManager instance\n * @param platform Platform adapter\n * @returns WaitForValidation result\n */\nexport async function waitForValidation(\n  options: WaitForValidationOptions,\n  auth: AuthCredentials,\n  tfx: TfxManager,\n  platform: IPlatformAdapter\n): Promise<WaitForValidationResult> {\n  platform.info(`Validating extension ${options.publisherId}.${options.extensionId}...`);\n\n  const extensionId = options.extensionId;\n\n  // Retry configuration\n  const maxRetries = options.maxRetries ?? 10;\n  const minTimeoutMs = (options.minTimeout ?? 1) * 60 * 1000;\n  const maxTimeoutMs = (options.maxTimeout ?? 15) * 60 * 1000;\n\n  let attempts = 0;\n  let lastStatus: ValidationStatus = 'pending';\n  let lastExitCode = 0;\n\n  while (attempts < maxRetries) {\n    attempts++;\n    platform.info(`Validation attempt ${attempts}/${maxRetries}...`);\n\n    // Build tfx arguments\n    const args = new ArgBuilder()\n      .arg(['extension', 'isvalid'])\n      .flag('--json')\n      .flag('--no-color')\n      .option('--publisher', options.publisherId)\n      .option('--extension-id', extensionId);\n\n    // Manifest arguments if provided\n    if (options.rootFolder) {\n      args.option('--root', options.rootFolder);\n    }\n\n    if (options.manifestGlobs && options.manifestGlobs.length > 0) {\n      args.flag('--manifest-globs');\n      options.manifestGlobs.forEach((glob) => args.arg(glob));\n    }\n\n    // Authentication\n    args.option('--service-url', auth.serviceUrl);\n\n    if (auth.authType === 'pat') {\n      args.option('--auth-type', 'pat');\n      args.option('--token', auth.token);\n      platform.setSecret(auth.token);\n    } else if (auth.authType === 'basic') {\n      args.option('--auth-type', 'basic');\n      args.option('--username', auth.username);\n      args.option('--password', auth.password);\n      platform.setSecret(auth.password);\n    }\n\n    try {\n      // Execute tfx (allow non-zero exit codes for pending/failed status)\n      const result = await tfx.execute(args.build(), { captureJson: true });\n      lastExitCode = result.exitCode;\n\n      // Parse JSON result\n      const json = result.json as any;\n      if (json && json.status) {\n        lastStatus = json.status as ValidationStatus;\n\n        switch (lastStatus) {\n          case 'success':\n            platform.info('\u2713 Extension validation succeeded');\n            return {\n              status: lastStatus,\n              isValid: true,\n              extensionId,\n              publisherId: options.publisherId,\n              attempts,\n              exitCode: result.exitCode,\n            };\n\n          case 'pending':\n            platform.info('\u23F3 Validation pending, retrying...');\n            // Wait before retry with exponential backoff\n            if (attempts < maxRetries) {\n              const waitTime = Math.min(minTimeoutMs * Math.pow(2, attempts - 1), maxTimeoutMs);\n              platform.debug(`Waiting ${waitTime / 1000}s before retry...`);\n              await sleep(waitTime);\n            }\n            break;\n\n          case 'failed':\n          case 'error':\n            platform.error(`\u2717 Extension validation failed: ${lastStatus}`);\n            return {\n              status: lastStatus,\n              isValid: false,\n              extensionId,\n              publisherId: options.publisherId,\n              attempts,\n              exitCode: result.exitCode,\n            };\n\n          default:\n            platform.warning(`Unknown validation status: ${lastStatus}`);\n            break;\n        }\n      } else {\n        platform.warning('No status in validation response');\n      }\n    } catch (err) {\n      platform.error(`Validation attempt ${attempts} failed: ${err}`);\n      if (attempts >= maxRetries) {\n        throw err;\n      }\n      // Wait before retry\n      await sleep(minTimeoutMs);\n    }\n  }\n\n  // Max retries reached\n  platform.error(\n    `\u2717 Extension validation timed out after ${attempts} attempts (status: ${lastStatus})`\n  );\n  return {\n    status: lastStatus,\n    isValid: false,\n    extensionId,\n    publisherId: options.publisherId,\n    attempts,\n    exitCode: lastExitCode,\n  };\n}\n\n/**\n * Sleep for specified milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "import { WebApi, getPersonalAccessTokenHandler } from 'azure-devops-node-api';\nimport type { ITaskAgentApi } from 'azure-devops-node-api/TaskAgentApi.js';\nimport type { TaskDefinition } from 'azure-devops-node-api/interfaces/TaskAgentInterfaces.js';\nimport type { AuthCredentials } from '../auth.js';\nimport { readManifest, resolveTaskManifestPaths } from '../manifest-utils.js';\nimport type { IPlatformAdapter } from '../platform.js';\nimport { VsixReader } from '../vsix-reader.js';\n\nexport interface ExpectedTask {\n  name: string;\n  versions: string[]; // Expected versions (major.minor.patch)\n}\n\nexport interface WaitForInstallationOptions {\n  publisherId: string;\n  extensionId: string;\n  accounts: string[]; // Target org URLs\n  expectedTasks?: ExpectedTask[]; // Tasks with expected versions\n  manifestPath?: string; // Path to extension manifest (vss-extension.json) to read task versions\n  vsixPath?: string; // Path to VSIX file to read task versions from\n  timeoutMinutes?: number; // Default: 10\n  pollingIntervalSeconds?: number; // Default: 30\n}\n\nexport interface InstalledTask {\n  name: string;\n  id: string;\n  version: string;\n  friendlyName: string;\n  matchesExpected: boolean; // True if this version is one of the expected versions\n}\n\nexport interface WaitForInstallationResult {\n  success: boolean;\n  accountResults: {\n    accountUrl: string;\n    available: boolean;\n    installedTasks: InstalledTask[];\n    missingTasks: string[]; // Task names that are completely missing\n    missingVersions: string[]; // Task/version combinations that are missing (e.g., \"TaskName@1.0.0\")\n    error?: string;\n  }[];\n  allTasksAvailable: boolean;\n}\n\nfunction validateWaitForInstallationServiceUrl(serviceUrl: string | undefined): void {\n  if (!serviceUrl) {\n    throw new Error(\n      'wait-for-installation requires service-url to be set to an Azure DevOps organization/server endpoint (not marketplace)'\n    );\n  }\n\n  let parsedUrl: URL;\n  try {\n    parsedUrl = new URL(serviceUrl);\n  } catch {\n    throw new Error(\n      'wait-for-installation requires service-url to be a valid HTTPS Azure DevOps organization/server URL'\n    );\n  }\n\n  const hostname = parsedUrl.hostname.toLowerCase();\n  if (hostname === 'marketplace.visualstudio.com') {\n    throw new Error(\n      'wait-for-installation cannot use the default marketplace endpoint. Set service-url to https://dev.azure.com/<organization>'\n    );\n  }\n\n  if (parsedUrl.protocol !== 'https:') {\n    throw new Error(\n      'wait-for-installation requires service-url to be a valid HTTPS Azure DevOps organization/server URL'\n    );\n  }\n}\n\n/**\n * Resolve expected tasks from various sources\n */\nasync function resolveExpectedTasks(\n  options: WaitForInstallationOptions,\n  platform: IPlatformAdapter\n): Promise<ExpectedTask[]> {\n  // If expectedTasks is provided directly, use it\n  if (options.expectedTasks && options.expectedTasks.length > 0) {\n    platform.debug(`Using ${options.expectedTasks.length} expected tasks from options`);\n    return options.expectedTasks;\n  }\n\n  // If manifestPath is provided, read task versions from manifest\n  if (options.manifestPath) {\n    try {\n      platform.debug(`Reading task versions from manifest: ${options.manifestPath}`);\n      const manifest = await readManifest(options.manifestPath, platform);\n      const taskPaths = resolveTaskManifestPaths(manifest, options.manifestPath, platform);\n\n      const tasks: ExpectedTask[] = [];\n      for (const taskPath of taskPaths) {\n        try {\n          const taskManifest = (await readManifest(taskPath, platform)) as any;\n          if (taskManifest.name && taskManifest.version) {\n            const version = `${taskManifest.version.Major}.${taskManifest.version.Minor}.${taskManifest.version.Patch}`;\n            tasks.push({\n              name: taskManifest.name as string,\n              versions: [version],\n            });\n            platform.debug(`Found task ${taskManifest.name} v${version}`);\n          }\n        } catch (error) {\n          platform.warning(\n            `Failed to read task manifest ${taskPath}: ${error instanceof Error ? error.message : String(error)}`\n          );\n        }\n      }\n\n      if (tasks.length > 0) {\n        platform.debug(`Resolved ${tasks.length} tasks from manifest`);\n        return tasks;\n      }\n    } catch (error) {\n      platform.warning(\n        `Failed to read manifest ${options.manifestPath}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // If vsixPath is provided, read task versions from VSIX\n  if (options.vsixPath) {\n    try {\n      platform.debug(`Reading task versions from VSIX: ${options.vsixPath}`);\n      const reader = await VsixReader.open(options.vsixPath);\n\n      try {\n        const tasksInfo = await reader.getTasksInfo();\n        const tasks: ExpectedTask[] = tasksInfo.map((task) => ({\n          name: task.name,\n          versions: [task.version],\n        }));\n\n        platform.debug(`Resolved ${tasks.length} tasks from VSIX`);\n        return tasks;\n      } finally {\n        await reader.close();\n      }\n    } catch (error) {\n      platform.warning(\n        `Failed to read VSIX ${options.vsixPath}: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // No expected tasks specified\n  return [];\n}\n\n/**\n * Verify that an extension's tasks are installed and available in Azure DevOps organizations.\n * Uses Azure DevOps REST API to poll for task availability.\n */\nexport async function waitForInstallation(\n  options: WaitForInstallationOptions,\n  auth: AuthCredentials,\n  platform: IPlatformAdapter\n): Promise<WaitForInstallationResult> {\n  validateWaitForInstallationServiceUrl(auth.serviceUrl);\n\n  const fullExtensionId = options.extensionId;\n\n  const timeoutMs = (options.timeoutMinutes ?? 10) * 60_000;\n  const pollingIntervalMs = (options.pollingIntervalSeconds ?? 30) * 1000;\n\n  platform.debug(\n    `Verifying installation of ${options.publisherId}.${fullExtensionId} in ${options.accounts.length} account(s)`\n  );\n\n  // Resolve expected tasks with versions\n  const expectedTasks = await resolveExpectedTasks(options, platform);\n\n  const accountResults: WaitForInstallationResult['accountResults'] = [];\n\n  for (const accountUrl of options.accounts) {\n    platform.debug(`Checking account: ${accountUrl}`);\n    platform.info(\n      `Polling for task availability (timeout: ${options.timeoutMinutes ?? 10} minutes, interval: ${options.pollingIntervalSeconds ?? 30} seconds)`\n    );\n\n    try {\n      // Create Azure DevOps API connection\n      if (!auth.token) {\n        throw new Error('PAT token is required for waitForInstallation command');\n      }\n\n      const handler = getPersonalAccessTokenHandler(auth.token);\n      const connection = new WebApi(accountUrl, handler);\n      const taskAgentApi: ITaskAgentApi = await connection.getTaskAgentApi();\n\n      // Poll until tasks appear or timeout\n      const deadline = Date.now() + timeoutMs;\n      let lastError: Error | undefined;\n      let found = false;\n      let finalInstalledTasks: InstalledTask[] = [];\n      let finalMissingTasks: string[] = [];\n      let finalMissingVersions: string[] = [];\n      let pollCount = 0;\n\n      while (Date.now() < deadline && !found) {\n        pollCount++;\n        const remainingMs = deadline - Date.now();\n        const remainingMinutes = Math.ceil(remainingMs / 60_000);\n\n        platform.debug(`Poll attempt ${pollCount} (${remainingMinutes} minute(s) remaining)`);\n\n        try {\n          const taskDefinitions: TaskDefinition[] = await taskAgentApi.getTaskDefinitions();\n\n          // Find tasks matching the extension\n          const installedTasks: InstalledTask[] = [];\n          const missingTasks: string[] = [];\n          const missingVersions: string[] = [];\n\n          // If we have expected tasks, check for them specifically\n          if (expectedTasks.length > 0) {\n            for (const expectedTask of expectedTasks) {\n              // Find all installed versions of this task\n              const installedTaskVersions = taskDefinitions.filter(\n                (t) =>\n                  t.name?.toLowerCase() === expectedTask.name.toLowerCase() && t.id && t.version\n              );\n\n              if (installedTaskVersions.length === 0) {\n                // Task name not found at all\n                missingTasks.push(expectedTask.name);\n                // Also track specific versions that are missing\n                for (const ver of expectedTask.versions) {\n                  missingVersions.push(`${expectedTask.name}@${ver}`);\n                }\n                continue;\n              }\n\n              // Check each installed version of this task\n              for (const installedTask of installedTaskVersions) {\n                const installedVersion = `${installedTask.version.major}.${installedTask.version.minor}.${installedTask.version.patch}`;\n\n                // Check if this version matches any expected version\n                const matchesExpected = expectedTask.versions.includes(installedVersion);\n\n                installedTasks.push({\n                  name: installedTask.name,\n                  id: installedTask.id,\n                  version: installedVersion,\n                  friendlyName: installedTask.friendlyName || installedTask.name,\n                  matchesExpected,\n                });\n              }\n\n              // Check if all required versions are present\n              const installedVersionStrings = installedTaskVersions.map(\n                (t) => `${t.version.major}.${t.version.minor}.${t.version.patch}`\n              );\n\n              for (const expectedVer of expectedTask.versions) {\n                if (!installedVersionStrings.includes(expectedVer)) {\n                  missingVersions.push(`${expectedTask.name}@${expectedVer}`);\n                  platform.debug(`Missing version ${expectedVer} for task ${expectedTask.name}`);\n                }\n              }\n            }\n\n            // Success if all tasks found and all required versions present\n            if (missingTasks.length === 0 && missingVersions.length === 0) {\n              found = true;\n              finalInstalledTasks = installedTasks;\n              finalMissingTasks = missingTasks;\n              finalMissingVersions = missingVersions;\n\n              // Count unique task names and total expected versions\n              const uniqueTasks = new Set(expectedTasks.map((t) => t.name));\n              const totalExpectedVersions = expectedTasks.reduce((sum, t) => {\n                return sum + t.versions.length;\n              }, 0);\n\n              platform.info(\n                `\u2713 All ${uniqueTasks.size} expected task(s) with ${totalExpectedVersions} version(s) found in ${accountUrl}`\n              );\n            } else if (missingTasks.length > 0) {\n              platform.debug(`Missing ${missingTasks.length} task(s): ${missingTasks.join(', ')}`);\n            } else if (missingVersions.length > 0) {\n              platform.debug(\n                `Missing ${missingVersions.length} version(s): ${missingVersions.join(', ')}`\n              );\n            }\n          } else {\n            // No expected tasks - collect all tasks\n            for (const task of taskDefinitions) {\n              if (task.name && task.id && task.version) {\n                installedTasks.push({\n                  name: task.name,\n                  id: task.id,\n                  version: `${task.version.major}.${task.version.minor}.${task.version.patch}`,\n                  friendlyName: task.friendlyName || task.name,\n                  matchesExpected: true, // No expectations, so all match\n                });\n              }\n            }\n\n            if (installedTasks.length > 0) {\n              found = true;\n              finalInstalledTasks = installedTasks;\n              finalMissingTasks = missingTasks;\n              finalMissingVersions = missingVersions;\n              platform.info(\n                `\u2713 Found ${installedTasks.length} task(s) from extension in ${accountUrl}`\n              );\n            }\n          }\n\n          if (!found && Date.now() < deadline) {\n            // Wait before next poll\n            platform.debug(`Waiting ${pollingIntervalMs / 1000}s before next poll...`);\n            await new Promise((resolve) => setTimeout(resolve, pollingIntervalMs));\n          }\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n          platform.debug(`Error polling for tasks: ${lastError.message}. Retrying...`);\n\n          if (Date.now() < deadline) {\n            await new Promise((resolve) => setTimeout(resolve, pollingIntervalMs));\n          }\n        }\n      }\n\n      if (found) {\n        accountResults.push({\n          accountUrl,\n          available: true,\n          installedTasks: finalInstalledTasks,\n          missingTasks: finalMissingTasks,\n          missingVersions: finalMissingVersions,\n        });\n      } else {\n        const errorMsg = lastError\n          ? `Timeout waiting for tasks. Last error: ${lastError.message}`\n          : `Timeout waiting for tasks after ${options.timeoutMinutes ?? 10} minutes`;\n\n        platform.warning(errorMsg);\n\n        // Calculate all missing versions for expected tasks\n        const allMissingVersions: string[] = [];\n        for (const task of expectedTasks) {\n          for (const ver of task.versions) {\n            allMissingVersions.push(`${task.name}@${ver}`);\n          }\n        }\n\n        accountResults.push({\n          accountUrl,\n          available: false,\n          installedTasks: [],\n          missingTasks: expectedTasks.map((t) => t.name),\n          missingVersions: allMissingVersions,\n          error: errorMsg,\n        });\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      platform.error(`Failed to verify installation in ${accountUrl}: ${errorMsg}`);\n\n      // Calculate all missing versions for expected tasks\n      const allMissingVersions: string[] = [];\n      for (const task of expectedTasks) {\n        for (const ver of task.versions) {\n          allMissingVersions.push(`${task.name}@${ver}`);\n        }\n      }\n\n      accountResults.push({\n        accountUrl,\n        available: false,\n        installedTasks: [],\n        missingTasks: expectedTasks.map((t) => t.name),\n        missingVersions: allMissingVersions,\n        error: errorMsg,\n      });\n    }\n  }\n\n  const allTasksAvailable = accountResults.every(\n    (r) => r.available && r.missingVersions.length === 0\n  );\n\n  // Log summary\n  if (allTasksAvailable) {\n    platform.info(\n      `\u2705 All tasks verified successfully across ${options.accounts.length} account(s)`\n    );\n  } else {\n    const failedAccounts = accountResults.filter((r) => !r.available);\n    const missingVersionAccounts = accountResults.filter(\n      (r) => r.available && r.missingVersions.length > 0\n    );\n\n    if (failedAccounts.length > 0) {\n      platform.warning(`\u274C Failed to verify tasks in ${failedAccounts.length} account(s)`);\n    }\n    if (missingVersionAccounts.length > 0) {\n      platform.warning(`\u26A0\uFE0F Missing versions found in ${missingVersionAccounts.length} account(s)`);\n    }\n  }\n\n  return {\n    success: allTasksAvailable,\n    accountResults,\n    allTasksAvailable,\n  };\n}\n", "import { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\n\n/**\n * Get basic authentication from GitHub Actions inputs\n */\nexport async function getBasicAuth(\n  username: string,\n  password: string,\n  serviceUrl: string | undefined,\n  platform: IPlatformAdapter\n): Promise<AuthCredentials> {\n  if (!username) {\n    throw new Error('Username is required for basic authentication');\n  }\n\n  if (password === undefined || password === null) {\n    throw new Error('Password is required for basic authentication');\n  }\n\n  // Mask the password immediately to prevent exposure in logs\n  // Note: username is typically not sensitive, but password definitely is\n  // We mask even empty passwords for consistency\n  platform.setSecret(password);\n\n  // Use provided service URL or default to marketplace\n  const finalServiceUrl = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  return {\n    authType: 'basic',\n    serviceUrl: finalServiceUrl,\n    username,\n    password,\n  };\n}\n", "import * as core from '@actions/core';\nimport * as exec from '@actions/exec';\nimport { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\n\n/**\n * Get Azure AD token via Azure CLI for marketplace authentication\n *\n * This approach requires the azure/login action to be run first with OIDC federation.\n * The azure/login action handles:\n * 1. GitHub OIDC \u2192 Azure AD federation\n * 2. Azure CLI authentication\n *\n * Then this function retrieves an Azure AD access token using the Azure CLI.\n * This token is accepted by the Visual Studio Marketplace.\n *\n * This mirrors the Azure Pipelines approach where Azure RM service connections\n * provide Azure AD tokens for marketplace operations.\n *\n * Requirements:\n * 1. Run azure/login action first:\n *    ```yaml\n *    - uses: azure/login@v2\n *      with:\n *        client-id: ${{ secrets.AZURE_CLIENT_ID }}\n *        tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n *        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n *    ```\n *\n * 2. Azure App Registration with:\n *    - Federated credentials for GitHub Actions\n *    - Appropriate permissions (if needed for marketplace)\n *\n * See: https://jessehouwing.net/authenticate-connect-mggraph-using-oidc-in-github-actions/\n *\n * @param resource - The Azure resource to get token for (defaults to marketplace)\n * @param platform - Platform adapter for secret masking\n */\nexport async function getOidcAuth(\n  serviceUrl: string | undefined,\n  platform: IPlatformAdapter\n): Promise<AuthCredentials> {\n  // Determine the resource URL to request token for\n  // If custom service URL is provided, use it as the token resource\n  const tokenResource = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  // Use the provided service URL or default to marketplace URL\n  const finalServiceUrl = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  core.info('Getting Azure AD token via Azure CLI (requires azure/login action)...');\n\n  try {\n    // Execute Azure CLI to get access token\n    let output = '';\n    let errorOutput = '';\n\n    const exitCode = await exec.exec(\n      'az',\n      ['account', 'get-access-token', '--resource', tokenResource, '--output', 'json'],\n      {\n        silent: true,\n        listeners: {\n          stdout: (data: Buffer) => {\n            output += data.toString();\n          },\n          stderr: (data: Buffer) => {\n            errorOutput += data.toString();\n          },\n        },\n      }\n    );\n\n    if (exitCode !== 0) {\n      throw new Error(`Azure CLI exited with code ${exitCode}: ${errorOutput}`);\n    }\n\n    // Parse JSON output\n    const result = JSON.parse(output);\n    const token = result.accessToken;\n\n    if (!token) {\n      throw new Error('No accessToken in Azure CLI response');\n    }\n\n    // Mask the token immediately using both the core API and platform adapter\n    // This provides defense in depth\n    core.setSecret(token);\n    platform.setSecret(token);\n\n    core.info('Successfully obtained Azure AD token via Azure CLI');\n\n    return {\n      authType: 'pat', // Use 'pat' type as the token format is similar\n      serviceUrl: finalServiceUrl,\n      token: token,\n    };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    throw new Error(\n      `Failed to get Azure AD token via Azure CLI: ${message}\\n\\n` +\n        'Make sure you have run the azure/login action before this action:\\n' +\n        '  - uses: azure/login@v2\\n' +\n        '    with:\\n' +\n        '      client-id: ${{ secrets.AZURE_CLIENT_ID }}\\n' +\n        '      tenant-id: ${{ secrets.AZURE_TENANT_ID }}\\n' +\n        '      subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\\n\\n' +\n        'See: https://jessehouwing.net/authenticate-connect-mggraph-using-oidc-in-github-actions/'\n    );\n  }\n}\n", "import { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\n\n/**\n * Get PAT authentication from GitHub Actions input\n */\nexport async function getPatAuth(\n  token: string,\n  serviceUrl: string | undefined,\n  platform: IPlatformAdapter\n): Promise<AuthCredentials> {\n  if (!token) {\n    throw new Error('PAT token is required');\n  }\n\n  // Mask the secret immediately to prevent exposure in logs\n  platform.setSecret(token);\n\n  // Use provided service URL or default to marketplace\n  const finalServiceUrl = serviceUrl || 'https://marketplace.visualstudio.com';\n\n  return {\n    authType: 'pat',\n    serviceUrl: finalServiceUrl,\n    token,\n  };\n}\n", "import { AuthCredentials, IPlatformAdapter } from '@extension-tasks/core';\nimport { getBasicAuth } from './basic-auth.js';\nimport { getOidcAuth } from './oidc-auth.js';\nimport { getPatAuth } from './pat-auth.js';\n\nexport type AuthType = 'pat' | 'basic' | 'oidc';\n\nexport interface AuthOptions {\n  token?: string;\n  username?: string;\n  password?: string;\n  serviceUrl?: string;\n}\n\n/**\n * Get authentication credentials based on auth type\n */\nexport async function getAuth(\n  authType: AuthType,\n  platform: IPlatformAdapter,\n  options: AuthOptions\n): Promise<AuthCredentials> {\n  const finalServiceUrl = options.serviceUrl;\n\n  switch (authType) {\n    case 'pat':\n      if (!options.token) {\n        throw new Error('Token is required for PAT authentication');\n      }\n      return getPatAuth(options.token, finalServiceUrl, platform);\n\n    case 'basic':\n      if (!options.username || !options.password) {\n        throw new Error('Username and password are required for basic authentication');\n      }\n      return getBasicAuth(options.username, options.password, finalServiceUrl, platform);\n\n    case 'oidc':\n      return getOidcAuth(finalServiceUrl, platform);\n\n    default:\n      throw new Error(`Unsupported auth type: ${authType}`);\n  }\n}\n\nexport { getBasicAuth, getOidcAuth, getPatAuth };\n", "import * as core from '@actions/core';\nimport * as exec from '@actions/exec';\nimport * as glob from '@actions/glob';\nimport * as io from '@actions/io';\nimport * as tc from '@actions/tool-cache';\nimport { ExecOptions, IPlatformAdapter, TaskResult } from '@extension-tasks/core';\nimport { promises as fs } from 'fs';\nimport * as os from 'os';\nimport path from 'path';\n\n/**\n * GitHub Actions platform adapter\n * Implements IPlatformAdapter using @actions/* packages\n */\nexport class GitHubAdapter implements IPlatformAdapter {\n  // ===== Input =====\n\n  getInput(name: string, required?: boolean): string | undefined {\n    const value = core.getInput(name, { required: required || false });\n    return value || undefined;\n  }\n\n  getBoolInput(name: string, required?: boolean): boolean {\n    const value = core.getInput(name, { required: required || false });\n    if (!value) {\n      return false;\n    }\n\n    return core.getBooleanInput(name, { required: required || false });\n  }\n\n  getDelimitedInput(name: string, delimiter: string, required?: boolean): string[] {\n    const value = core.getInput(name, { required: required || false });\n    if (!value) return [];\n    return value\n      .split(delimiter)\n      .map((v) => v.trim())\n      .filter((v) => v);\n  }\n\n  // ===== Output =====\n\n  setOutput(name: string, value: string): void {\n    core.setOutput(name, value);\n  }\n\n  setResult(result: TaskResult, message: string): void {\n    if (result === TaskResult.Succeeded) {\n      core.info(`\u2705 ${message}`);\n    } else if (result === TaskResult.Failed) {\n      core.setFailed(message);\n    } else {\n      core.warning(message);\n    }\n  }\n\n  setVariable(name: string, value: string, isSecret?: boolean, isOutput?: boolean): void {\n    if (isSecret) {\n      core.setSecret(value);\n    }\n    if (isOutput) {\n      core.setOutput(name, value);\n    } else {\n      core.exportVariable(name, value);\n    }\n  }\n\n  setSecret(value: string): void {\n    core.setSecret(value);\n  }\n\n  // ===== Logging =====\n\n  debug(message: string): void {\n    core.debug(message);\n  }\n\n  info(message: string): void {\n    core.info(message);\n  }\n\n  warning(message: string): void {\n    core.warning(message);\n  }\n\n  error(message: string): void {\n    core.error(message);\n  }\n\n  // ===== Execution =====\n\n  async which(tool: string, check?: boolean): Promise<string> {\n    const result = await io.which(tool, check);\n    return result;\n  }\n\n  async exec(tool: string, args: string[], options?: ExecOptions): Promise<number> {\n    let stderr = '';\n    const toolCommand = tool.includes(' ') ? `\"${tool}\"` : tool;\n\n    const listeners = {\n      stdout: (data: Buffer) => {\n        const str = data.toString();\n        if (options?.outStream) {\n          options.outStream.write(str);\n        }\n      },\n      stderr: (data: Buffer) => {\n        const str = data.toString();\n        stderr += str;\n        if (options?.errStream) {\n          options.errStream.write(str);\n        }\n      },\n    };\n\n    const exitCode = await exec.exec(toolCommand, args, {\n      cwd: options?.cwd,\n      env: options?.env,\n      silent: options?.silent,\n      ignoreReturnCode: options?.ignoreReturnCode,\n      listeners,\n    });\n\n    if (options?.failOnStdErr && stderr) {\n      throw new Error(`Command failed with stderr: ${stderr}`);\n    }\n\n    return exitCode;\n  }\n\n  // ===== Filesystem =====\n\n  async findMatch(root: string, patterns: string[]): Promise<string[]> {\n    const normalizedPatterns = patterns\n      .map((pattern) => pattern.trim())\n      .filter((pattern) => pattern.length > 0)\n      .map((pattern) => {\n        const isExclude = pattern.startsWith('!');\n        const value = isExclude ? pattern.slice(1) : pattern;\n        const rootedPattern = path.isAbsolute(value) ? value : path.join(root, value);\n        const normalized = rootedPattern.replace(/\\\\/g, '/');\n        return isExclude ? `!${normalized}` : normalized;\n      });\n\n    if (normalizedPatterns.length === 0) {\n      return [];\n    }\n\n    const globber = await glob.create(normalizedPatterns.join('\\n'));\n    const matches = await globber.glob();\n\n    return Array.from(new Set(matches.map((match) => path.resolve(match))));\n  }\n\n  async fileExists(filePath: string): Promise<boolean> {\n    try {\n      await fs.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async readFile(filePath: string): Promise<string> {\n    return fs.readFile(filePath, 'utf-8');\n  }\n\n  async writeFile(filePath: string, content: string): Promise<void> {\n    await fs.writeFile(filePath, content, 'utf-8');\n  }\n\n  async mkdirP(dirPath: string): Promise<void> {\n    await io.mkdirP(dirPath);\n  }\n\n  async rmRF(dirPath: string): Promise<void> {\n    await io.rmRF(dirPath);\n  }\n\n  // ===== Environment =====\n\n  getVariable(name: string): string | undefined {\n    return process.env[name];\n  }\n\n  getTempDir(): string {\n    return process.env.RUNNER_TEMP || os.tmpdir();\n  }\n\n  // ===== Tool Management =====\n\n  async cacheDir(sourceDir: string, tool: string, version: string): Promise<string> {\n    return tc.cacheDir(sourceDir, tool, version);\n  }\n\n  findCachedTool(tool: string, version: string): string | undefined {\n    const found = tc.find(tool, version);\n    return found || undefined;\n  }\n\n  async downloadTool(url: string): Promise<string> {\n    return tc.downloadTool(url);\n  }\n}\n", null, null, null, null, null, null, null, null, null, null],
  "mappings": "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",
  "names": ["path", "URL", "URL", "Buffer", "path", "path", "Buffer", "path", "VsixWriter", "FilesystemManifestWriter", "readFile", "path", "minimatch", "Minimatch", "path", "filter", "makeRe", "braceExpand", "debug", "set", "parse", "match", "core", "TaskResult", "error", "path", "path", "error", "Buffer", "validateZipPath", "error", "FilesystemManifestReader", "ManifestEditor", "error", "error", "core", "exec", "core", "fs", "core", "path", "path", "dirname", "MatchKind", "IS_WINDOWS", "dirname", "path", "assert", "path", "assert", "IS_WINDOWS", "dirname", "basename", "minimatch", "IS_WINDOWS", "homedir", "assert", "dirname", "path", "IS_WINDOWS", "match", "partialMatch", "core", "fs", "os", "path", "match", "error"]
}
